{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"dj-stripe - Django + Stripe Made Easy Stripe Models for Django. Introduction dj-stripe implements all of the Stripe models, for Django. Set up your webhook endpoint and start receiving model updates. You will then have a copy of all the Stripe models available in Django models, as soon as they are updated! The full documentation is available on Read the Docs . Features Stripe Core Stripe Billing Stripe Cards (JS v2) and Sources (JS v3) Payment Methods and Payment Intents (SCA support) Support for multiple accounts and API keys Stripe Connect (partial support) Tested with Stripe API 2020-08-27 (see API versions ) Requirements Django >=3.2 Python >=3.8 PostgreSQL engine (recommended) >=9.6 MySQL engine: MariaDB >=10.2 or MySQL >=5.7 SQLite: Not recommended in production. Version >=3.26 required. Installation See installation instructions. Changelog See release notes on Read the Docs . Funding and Support You can now become a sponsor to dj-stripe with GitHub Sponsors . We've been bringing dj-stripe to the world for over 7 years and are excited to be able to start dedicating some real resources to the project. Your sponsorship helps us keep a team of maintainers actively working to improve dj-stripe and ensure it stays up-to-date with the latest Stripe changes. If you use dj-stripe commercially, we would encourage you to invest in its continued development by signing up for a paid plan . Corporate sponsors receive priority support and development time . All contributions through GitHub sponsors flow into our Open Collective , which holds our funds and keeps an open ledger on how donations are spent. Our Gold sponsors Similar libraries dj-paypal ( PayPal ) dj-paddle ( Paddle )","title":"Home"},{"location":"#dj-stripe-django-stripe-made-easy","text":"Stripe Models for Django.","title":"dj-stripe - Django + Stripe Made Easy"},{"location":"#introduction","text":"dj-stripe implements all of the Stripe models, for Django. Set up your webhook endpoint and start receiving model updates. You will then have a copy of all the Stripe models available in Django models, as soon as they are updated! The full documentation is available on Read the Docs .","title":"Introduction"},{"location":"#features","text":"Stripe Core Stripe Billing Stripe Cards (JS v2) and Sources (JS v3) Payment Methods and Payment Intents (SCA support) Support for multiple accounts and API keys Stripe Connect (partial support) Tested with Stripe API 2020-08-27 (see API versions )","title":"Features"},{"location":"#requirements","text":"Django >=3.2 Python >=3.8 PostgreSQL engine (recommended) >=9.6 MySQL engine: MariaDB >=10.2 or MySQL >=5.7 SQLite: Not recommended in production. Version >=3.26 required.","title":"Requirements"},{"location":"#installation","text":"See installation instructions.","title":"Installation"},{"location":"#changelog","text":"See release notes on Read the Docs .","title":"Changelog"},{"location":"#funding-and-support","text":"You can now become a sponsor to dj-stripe with GitHub Sponsors . We've been bringing dj-stripe to the world for over 7 years and are excited to be able to start dedicating some real resources to the project. Your sponsorship helps us keep a team of maintainers actively working to improve dj-stripe and ensure it stays up-to-date with the latest Stripe changes. If you use dj-stripe commercially, we would encourage you to invest in its continued development by signing up for a paid plan . Corporate sponsors receive priority support and development time . All contributions through GitHub sponsors flow into our Open Collective , which holds our funds and keeps an open ledger on how donations are spent.","title":"Funding and Support"},{"location":"#our-gold-sponsors","text":"","title":"Our Gold sponsors"},{"location":"#similar-libraries","text":"dj-paypal ( PayPal ) dj-paddle ( Paddle )","title":"Similar libraries"},{"location":"CONTRIBUTING/","text":"Contributing Contributions are welcome, and they are greatly appreciated! Every little bit helps, and credit will always be given. You can contribute in many ways: Types of Contributions Report Bugs Report bugs at https://github.com/dj-stripe/dj-stripe/issues . If you are reporting a bug, please include: The version of python and Django you're running Detailed steps to reproduce the bug. Fix Bugs Look through the GitHub issues for bugs. Anything tagged with \"bug\" is open to whoever wants to implement it. Implement Features Look through the GitHub issues for features. Anything tagged with \"feature\" is open to whoever wants to implement it. Write Documentation dj-stripe could always use more documentation, whether as part of the official dj-stripe docs, in docstrings, or even on the web in blog posts, articles, and such. To see the project's documentation live, run the following command: mkdocs serve The documentation site will then be served on http://127.0.0.1:8000 . In case of any installation error In case you get the error that some plugin is not installed, please run: poetry install --with docs If you wish to just generate the documentation, you can replace serve with build , and the docs will be generated into the site/ folder. Submit Feedback The best way to send feedback is to file an issue at https://github.com/dj-stripe/dj-stripe/issues . If you are proposing a feature: Explain in detail how it would work. Keep the scope as narrow as possible, to make it easier to implement. Remember that this is a volunteer-driven project, and that contributions are welcome :) Contributor Discussion For questions regarding contributions to dj-stripe, another avenue is our Discord channel at https://discord.gg/UJY8fcc . Get Started! Ready to contribute? Here's how to set up local development. Fork dj-stripe on Github . Clone your fork locally: $ git clone git@github.com:your_name_here/dj-stripe.git Set up pre-commit : $ git init # A git repo is required to install pre-commit $ pre-commit install Set up your test database. If you're running tests using PostgreSQL: $ createdb djstripe or if you want to test vs sqlite (for convenience) or MySQL, they can be selected by setting this environment variable: $ export DJSTRIPE_TEST_DB_VENDOR = sqlite # or: export DJSTRIPE_TEST_DB_VENDOR=mysql For postgres and mysql, the database host,port,username and password can be set with environment variables, see tests/settings.py Install Poetry if you do not have it already. You can set up a virtual environment with: $ poetry install You can then, at any time, open a shell into that environment with: $ poetry shell When you're done making changes, check that your changes pass the tests. A quick test run can be done as follows: $ DJSTRIPE_TEST_DB_VENDOR = sqlite poetry run pytest --reuse-db You should also check that the tests pass with other python and Django versions with tox. pytest will output both command line and html coverage statistics and will warn you if your changes caused code coverage to drop.: $ pip install tox $ tox If your changes altered the models you may need to generate Django migrations: $ DJSTRIPE_TEST_DB_VENDOR = sqlite poetry run ./manage.py makemigrations Commit your changes and push your branch to GitHub: $ git add . $ git commit -m \"Your detailed description of your changes.\" $ git push Submit a pull request through the GitHub website. Congratulations, you're now a dj-stripe contributor! Have some \u2665 from us. Preferred Django Model Field Types When mapping from Stripe API field types to Django model fields, we try to follow Django best practises where practical. The following types should be preferred for fields that map to the Stripe API (which is almost all fields in our models). Strings Stripe API string fields have a default maximum length of 5,000 characters . In some cases a maximum length ( maxLength ) is specified in the Stripe OpenAPI schema . We follow Django's recommendation and avoid using null on string fields (which means we store \"\" for string fields that are null in stripe). Note that is enforced in the sync logic in StripeModel._stripe_object_to_record . For long string fields (eg above 255 characters) we prefer TextField over Charfield . Therefore the default type for string fields that don't have a maxLength specified in the Stripe OpenAPI schema should usually be: str_field = TextField(max_length=5000, default=\", blank=True, help_text=\"...\") Enumerations Fields that have a defined set of values can be implemented using StripeEnumField . Hash (dictionaries) Use the JSONField in djstripe.fields . Currency amounts Stripe handles all currency amounts as integer cents, we currently have a mixture of fields as integer cents and decimal (eg dollar, euro etc) values, but we are aiming to standardise on cents (see https://github.com/dj-stripe/dj-stripe/issues/955 ). All new currency amount fields should use StripeQuantumCurrencyAmountField . Dates and Datetimes The Stripe API uses an integer timestamp (seconds since the Unix epoch) for dates and datetimes. We store this as a datetime field, using StripeDateTimeField . Django Migration Policy Migrations are considered a breaking change, so it's not usually not acceptable to add a migration to a stable branch, it will be a new MAJOR.MINOR.0 release. A workaround to this in the case that the Stripe API data isn't compatible with out model (eg Stripe is sending null to a non-null field) is to implement the _manipulate_stripe_object_hook classmethod on the model. Avoid new migrations with non-schema changes If a code change produces a migration that doesn't alter the database schema (eg changing help_text ) then instead of adding a new migration you can edit the most recent migration that affects the field in question. e.g.: https://github.com/dj-stripe/dj-stripe/commit/e2762c38918a90f00c42ecf21187a920bd3a2087 Pull Request Guidelines Before you submit a pull request, check that it meets these guidelines: The pull request should include tests. The pull request must not drop code coverage below the current level. If the pull request adds functionality, the docs should be updated. Put your new functionality into a function with a docstring. If the pull request makes changes to a model, include Django migrations. The pull request should work for Python 3.6+. Check Github Actions and make sure that the tests pass for all supported Python versions. Code formatting: Make sure to install pre-commit to automatically run it on staged files or run manually with pre-commit run --all-files at the dj-stripe root to keep a consistent style.","title":"Contributing"},{"location":"CONTRIBUTING/#contributing","text":"Contributions are welcome, and they are greatly appreciated! Every little bit helps, and credit will always be given. You can contribute in many ways:","title":"Contributing"},{"location":"CONTRIBUTING/#types-of-contributions","text":"","title":"Types of Contributions"},{"location":"CONTRIBUTING/#report-bugs","text":"Report bugs at https://github.com/dj-stripe/dj-stripe/issues . If you are reporting a bug, please include: The version of python and Django you're running Detailed steps to reproduce the bug.","title":"Report Bugs"},{"location":"CONTRIBUTING/#fix-bugs","text":"Look through the GitHub issues for bugs. Anything tagged with \"bug\" is open to whoever wants to implement it.","title":"Fix Bugs"},{"location":"CONTRIBUTING/#implement-features","text":"Look through the GitHub issues for features. Anything tagged with \"feature\" is open to whoever wants to implement it.","title":"Implement Features"},{"location":"CONTRIBUTING/#write-documentation","text":"dj-stripe could always use more documentation, whether as part of the official dj-stripe docs, in docstrings, or even on the web in blog posts, articles, and such. To see the project's documentation live, run the following command: mkdocs serve The documentation site will then be served on http://127.0.0.1:8000 . In case of any installation error In case you get the error that some plugin is not installed, please run: poetry install --with docs If you wish to just generate the documentation, you can replace serve with build , and the docs will be generated into the site/ folder.","title":"Write Documentation"},{"location":"CONTRIBUTING/#submit-feedback","text":"The best way to send feedback is to file an issue at https://github.com/dj-stripe/dj-stripe/issues . If you are proposing a feature: Explain in detail how it would work. Keep the scope as narrow as possible, to make it easier to implement. Remember that this is a volunteer-driven project, and that contributions are welcome :)","title":"Submit Feedback"},{"location":"CONTRIBUTING/#contributor-discussion","text":"For questions regarding contributions to dj-stripe, another avenue is our Discord channel at https://discord.gg/UJY8fcc .","title":"Contributor Discussion"},{"location":"CONTRIBUTING/#get-started","text":"Ready to contribute? Here's how to set up local development. Fork dj-stripe on Github . Clone your fork locally: $ git clone git@github.com:your_name_here/dj-stripe.git Set up pre-commit : $ git init # A git repo is required to install pre-commit $ pre-commit install Set up your test database. If you're running tests using PostgreSQL: $ createdb djstripe or if you want to test vs sqlite (for convenience) or MySQL, they can be selected by setting this environment variable: $ export DJSTRIPE_TEST_DB_VENDOR = sqlite # or: export DJSTRIPE_TEST_DB_VENDOR=mysql For postgres and mysql, the database host,port,username and password can be set with environment variables, see tests/settings.py Install Poetry if you do not have it already. You can set up a virtual environment with: $ poetry install You can then, at any time, open a shell into that environment with: $ poetry shell When you're done making changes, check that your changes pass the tests. A quick test run can be done as follows: $ DJSTRIPE_TEST_DB_VENDOR = sqlite poetry run pytest --reuse-db You should also check that the tests pass with other python and Django versions with tox. pytest will output both command line and html coverage statistics and will warn you if your changes caused code coverage to drop.: $ pip install tox $ tox If your changes altered the models you may need to generate Django migrations: $ DJSTRIPE_TEST_DB_VENDOR = sqlite poetry run ./manage.py makemigrations Commit your changes and push your branch to GitHub: $ git add . $ git commit -m \"Your detailed description of your changes.\" $ git push Submit a pull request through the GitHub website. Congratulations, you're now a dj-stripe contributor! Have some \u2665 from us.","title":"Get Started!"},{"location":"CONTRIBUTING/#preferred-django-model-field-types","text":"When mapping from Stripe API field types to Django model fields, we try to follow Django best practises where practical. The following types should be preferred for fields that map to the Stripe API (which is almost all fields in our models).","title":"Preferred Django Model Field Types"},{"location":"CONTRIBUTING/#strings","text":"Stripe API string fields have a default maximum length of 5,000 characters . In some cases a maximum length ( maxLength ) is specified in the Stripe OpenAPI schema . We follow Django's recommendation and avoid using null on string fields (which means we store \"\" for string fields that are null in stripe). Note that is enforced in the sync logic in StripeModel._stripe_object_to_record . For long string fields (eg above 255 characters) we prefer TextField over Charfield . Therefore the default type for string fields that don't have a maxLength specified in the Stripe OpenAPI schema should usually be: str_field = TextField(max_length=5000, default=\", blank=True, help_text=\"...\")","title":"Strings"},{"location":"CONTRIBUTING/#enumerations","text":"Fields that have a defined set of values can be implemented using StripeEnumField .","title":"Enumerations"},{"location":"CONTRIBUTING/#hash-dictionaries","text":"Use the JSONField in djstripe.fields .","title":"Hash (dictionaries)"},{"location":"CONTRIBUTING/#currency-amounts","text":"Stripe handles all currency amounts as integer cents, we currently have a mixture of fields as integer cents and decimal (eg dollar, euro etc) values, but we are aiming to standardise on cents (see https://github.com/dj-stripe/dj-stripe/issues/955 ). All new currency amount fields should use StripeQuantumCurrencyAmountField .","title":"Currency amounts"},{"location":"CONTRIBUTING/#dates-and-datetimes","text":"The Stripe API uses an integer timestamp (seconds since the Unix epoch) for dates and datetimes. We store this as a datetime field, using StripeDateTimeField .","title":"Dates and Datetimes"},{"location":"CONTRIBUTING/#django-migration-policy","text":"Migrations are considered a breaking change, so it's not usually not acceptable to add a migration to a stable branch, it will be a new MAJOR.MINOR.0 release. A workaround to this in the case that the Stripe API data isn't compatible with out model (eg Stripe is sending null to a non-null field) is to implement the _manipulate_stripe_object_hook classmethod on the model.","title":"Django Migration Policy"},{"location":"CONTRIBUTING/#avoid-new-migrations-with-non-schema-changes","text":"If a code change produces a migration that doesn't alter the database schema (eg changing help_text ) then instead of adding a new migration you can edit the most recent migration that affects the field in question. e.g.: https://github.com/dj-stripe/dj-stripe/commit/e2762c38918a90f00c42ecf21187a920bd3a2087","title":"Avoid new migrations with non-schema changes"},{"location":"CONTRIBUTING/#pull-request-guidelines","text":"Before you submit a pull request, check that it meets these guidelines: The pull request should include tests. The pull request must not drop code coverage below the current level. If the pull request adds functionality, the docs should be updated. Put your new functionality into a function with a docstring. If the pull request makes changes to a model, include Django migrations. The pull request should work for Python 3.6+. Check Github Actions and make sure that the tests pass for all supported Python versions. Code formatting: Make sure to install pre-commit to automatically run it on staged files or run manually with pre-commit run --all-files at the dj-stripe root to keep a consistent style.","title":"Pull Request Guidelines"},{"location":"api_keys/","text":"Managing Stripe API keys Stripe API keys are stored in the database, and editable from the Django admin. Important Note By default, keys are visible by anyone who has access to the dj-stripe administration. Adding new API keys You may add new API keys via the Dj-Stripe \"API key\" administration. The only required value is the key's \"secret\" value itself. Example: Once saved, Dj-Stripe will automatically detect whether the key is a public, restricted or secret key, and whether it's for live or test mode. If it's a secret key, the matching Account object will automatically be fetched as well and the key will be associated with it, so that it can be used to communicate with the Stripe API when dealing with objects belonging to that Account. Updating the API keys When expiring or rolling new secret keys, you should create the new API key in Stripe, then add it from the Django administration. Whenever you are ready, you may delete the old key. (It is safe to keep it around, as long as it hasn't expired. Keeping expired keys in the database may result in errors during usage). FAQ Why store them in the database? As we work on supporting multiple Stripe accounts per instance, it is vital for dj-stripe to have a mechanism to store more than one Stripe API key. It also became obvious that we may want proper programmatic access to create and delete keys. Furthermore, API keys are a legitimate upstream Stripe object, and it is not unlikely the API may allow access to listing other API keys in the future, in which case we will want to move them to the database anyway. Isn't that insecure? Please do keep your billing database encrypted. There's a copy of all your customers' billing data on it! You may also instead create a read-only restricted key with all-read permissions for dj-stripe. There is no added risk there, given that dj-stripe holds a copy of all your data regardless. I'm using environment variables. Do I need to change anything? Not at this time. The settings STRIPE_LIVE_SECRET_KEY and STRIPE_TEST_SECRET_KEY can still be used. Their values will however be automatically saved to the database at the earliest opportunity. What about public keys? Setting STRIPE_LIVE_PUBLIC_KEY and STRIPE_TEST_PUBLIC_KEY will be deprecated in 2.5.0. You do not risk anything by leaving them in your settings: They are not used by Dj-Stripe outside of the Dj-Stripe mixins, which are now themselves deprecated. So you can safely leave them in your settings, or you can move them to the database as well (Keys beginning in pk_test_ and pk_live_ will be detected as publishable keys).","title":"Managing Stripe API Keys"},{"location":"api_keys/#managing-stripe-api-keys","text":"Stripe API keys are stored in the database, and editable from the Django admin. Important Note By default, keys are visible by anyone who has access to the dj-stripe administration.","title":"Managing Stripe API keys"},{"location":"api_keys/#adding-new-api-keys","text":"You may add new API keys via the Dj-Stripe \"API key\" administration. The only required value is the key's \"secret\" value itself. Example: Once saved, Dj-Stripe will automatically detect whether the key is a public, restricted or secret key, and whether it's for live or test mode. If it's a secret key, the matching Account object will automatically be fetched as well and the key will be associated with it, so that it can be used to communicate with the Stripe API when dealing with objects belonging to that Account.","title":"Adding new API keys"},{"location":"api_keys/#updating-the-api-keys","text":"When expiring or rolling new secret keys, you should create the new API key in Stripe, then add it from the Django administration. Whenever you are ready, you may delete the old key. (It is safe to keep it around, as long as it hasn't expired. Keeping expired keys in the database may result in errors during usage).","title":"Updating the API keys"},{"location":"api_keys/#faq","text":"","title":"FAQ"},{"location":"api_keys/#why-store-them-in-the-database","text":"As we work on supporting multiple Stripe accounts per instance, it is vital for dj-stripe to have a mechanism to store more than one Stripe API key. It also became obvious that we may want proper programmatic access to create and delete keys. Furthermore, API keys are a legitimate upstream Stripe object, and it is not unlikely the API may allow access to listing other API keys in the future, in which case we will want to move them to the database anyway.","title":"Why store them in the database?"},{"location":"api_keys/#isnt-that-insecure","text":"Please do keep your billing database encrypted. There's a copy of all your customers' billing data on it! You may also instead create a read-only restricted key with all-read permissions for dj-stripe. There is no added risk there, given that dj-stripe holds a copy of all your data regardless.","title":"Isn't that insecure?"},{"location":"api_keys/#im-using-environment-variables-do-i-need-to-change-anything","text":"Not at this time. The settings STRIPE_LIVE_SECRET_KEY and STRIPE_TEST_SECRET_KEY can still be used. Their values will however be automatically saved to the database at the earliest opportunity.","title":"I'm using environment variables. Do I need to change anything?"},{"location":"api_keys/#what-about-public-keys","text":"Setting STRIPE_LIVE_PUBLIC_KEY and STRIPE_TEST_PUBLIC_KEY will be deprecated in 2.5.0. You do not risk anything by leaving them in your settings: They are not used by Dj-Stripe outside of the Dj-Stripe mixins, which are now themselves deprecated. So you can safely leave them in your settings, or you can move them to the database as well (Keys beginning in pk_test_ and pk_live_ will be detected as publishable keys).","title":"What about public keys?"},{"location":"api_versions/","text":"A note on Stripe API versions A point that can cause confusion to new users of dj-stripe is that there are several different Stripe API versions in play at once. Your Stripe account's API version This is the version used by Stripe when sending webhook data to you and the default version used by the Stripe API. You can find this on your Stripe dashboard labelled \" default \". New Stripe accounts are always on the latest version. Read more about it on stripe.com/docs/api/versioning . Stripe's current latest API version You can find this on your Stripe dashboard labelled \" latest \" or in Stripe's API documentation See stripe.com/docs/upgrades on how to upgrade your Stripe API version. Stripe will only allow upgrades to the latest version. Dj-stripe API version This is the Stripe API version used by dj-stripe in all communication with Stripe, including when processing webhooks (though webhook data is sent to you by Stripe with your API version, we re-fetch the data with dj-stripe's API version), this is because the API schema needs to match dj-stripe's Django model schema. It is defined by STRIPE_API_VERSION with a default of DEFAULT_STRIPE_API_VERSION . You mustn't change this as it ensures that dj-stripe receives data in the format it expects. Note dj-stripe will always use STRIPE_API_VERSION in its requests regardless of what stripe.api_version is set to. Dj-stripe Latest Tested Version This is the most recent Stripe account API version used by the maintainers during testing, more recent versions account versions are probably fine though.","title":"A note on Stripe API Versions"},{"location":"api_versions/#a-note-on-stripe-api-versions","text":"A point that can cause confusion to new users of dj-stripe is that there are several different Stripe API versions in play at once.","title":"A note on Stripe API versions"},{"location":"api_versions/#your-stripe-accounts-api-version","text":"This is the version used by Stripe when sending webhook data to you and the default version used by the Stripe API. You can find this on your Stripe dashboard labelled \" default \". New Stripe accounts are always on the latest version. Read more about it on stripe.com/docs/api/versioning .","title":"Your Stripe account's API version"},{"location":"api_versions/#stripes-current-latest-api-version","text":"You can find this on your Stripe dashboard labelled \" latest \" or in Stripe's API documentation See stripe.com/docs/upgrades on how to upgrade your Stripe API version. Stripe will only allow upgrades to the latest version.","title":"Stripe's current latest API version"},{"location":"api_versions/#dj-stripe-api-version","text":"This is the Stripe API version used by dj-stripe in all communication with Stripe, including when processing webhooks (though webhook data is sent to you by Stripe with your API version, we re-fetch the data with dj-stripe's API version), this is because the API schema needs to match dj-stripe's Django model schema. It is defined by STRIPE_API_VERSION with a default of DEFAULT_STRIPE_API_VERSION . You mustn't change this as it ensures that dj-stripe receives data in the format it expects. Note dj-stripe will always use STRIPE_API_VERSION in its requests regardless of what stripe.api_version is set to.","title":"Dj-stripe API version"},{"location":"api_versions/#dj-stripe-latest-tested-version","text":"This is the most recent Stripe account API version used by the maintainers during testing, more recent versions account versions are probably fine though.","title":"Dj-stripe Latest Tested Version"},{"location":"installation/","text":"Installation Get the distribution Install dj-stripe with pip: pip install dj-stripe Or with Poetry (recommended): poetry add dj-stripe Configuration Add djstripe to your INSTALLED_APPS : INSTALLED_APPS =( ... \"djstripe\" , ... ) Add to urls.py: path ( \"stripe/\" , include ( \"djstripe.urls\" , namespace = \"djstripe\" )) , Tell Stripe about the webhook (Stripe webhook docs can be found here ) using the full URL of your endpoint from the urls.py step above (e.g. https://example.com/stripe/webhook ). Add your Stripe keys and set the operating mode: STRIPE_LIVE_SECRET_KEY = os.environ.get ( \"STRIPE_LIVE_SECRET_KEY\" , \"<your secret key>\" ) STRIPE_TEST_SECRET_KEY = os.environ.get ( \"STRIPE_TEST_SECRET_KEY\" , \"<your secret key>\" ) STRIPE_LIVE_MODE = False # Change to True in production DJSTRIPE_WEBHOOK_SECRET = \"whsec_xxx\" # Get it from the section in the Stripe dashboard where you added the webhook endpoint DJSTRIPE_FOREIGN_KEY_TO_FIELD = \"id\" Note djstripe expects STRIPE_LIVE_MODE to be a Boolean Type. In case you use Bash env vars or equivalent to inject its value, make sure to convert it to a Boolean type. We highly recommended the library django-environ Sync data from Stripe: Note djstripe expects APIKeys of all Stripe Accounts you'd like to sync data for to already be in the DB. They can be Added from Django Admin. Run the commands: python manage.py migrate python manage.py djstripe_sync_models See here for notes about usage of the Stripe Elements frontend JS library. Running Tests Assuming the tests are run against PostgreSQL: createdb djstripe pip install tox tox","title":"Installation"},{"location":"installation/#installation","text":"","title":"Installation"},{"location":"installation/#get-the-distribution","text":"Install dj-stripe with pip: pip install dj-stripe Or with Poetry (recommended): poetry add dj-stripe","title":"Get the distribution"},{"location":"installation/#configuration","text":"Add djstripe to your INSTALLED_APPS : INSTALLED_APPS =( ... \"djstripe\" , ... ) Add to urls.py: path ( \"stripe/\" , include ( \"djstripe.urls\" , namespace = \"djstripe\" )) , Tell Stripe about the webhook (Stripe webhook docs can be found here ) using the full URL of your endpoint from the urls.py step above (e.g. https://example.com/stripe/webhook ). Add your Stripe keys and set the operating mode: STRIPE_LIVE_SECRET_KEY = os.environ.get ( \"STRIPE_LIVE_SECRET_KEY\" , \"<your secret key>\" ) STRIPE_TEST_SECRET_KEY = os.environ.get ( \"STRIPE_TEST_SECRET_KEY\" , \"<your secret key>\" ) STRIPE_LIVE_MODE = False # Change to True in production DJSTRIPE_WEBHOOK_SECRET = \"whsec_xxx\" # Get it from the section in the Stripe dashboard where you added the webhook endpoint DJSTRIPE_FOREIGN_KEY_TO_FIELD = \"id\" Note djstripe expects STRIPE_LIVE_MODE to be a Boolean Type. In case you use Bash env vars or equivalent to inject its value, make sure to convert it to a Boolean type. We highly recommended the library django-environ Sync data from Stripe: Note djstripe expects APIKeys of all Stripe Accounts you'd like to sync data for to already be in the DB. They can be Added from Django Admin. Run the commands: python manage.py migrate python manage.py djstripe_sync_models See here for notes about usage of the Stripe Elements frontend JS library.","title":"Configuration"},{"location":"installation/#running-tests","text":"Assuming the tests are run against PostgreSQL: createdb djstripe pip install tox tox","title":"Running Tests"},{"location":"stripe_elements_js/","text":"Integrating Stripe Elements (JS SDK) Tip TLDR: If you haven't yet migrated to PaymentIntents, prefer stripe.createSource() over stripe.createToken() for better compatibility with PaymentMethods. Attention A point that can cause confusion when integrating Stripe on the web is that there are multiple generations of frontend JS APIs that use Stripe Elements with stripe js v3. In descending order of preference these are: Payment Intents (SCA compliant) The newest and preferred way of handling payments, which supports SCA compliance (3D secure etc). Charges using stripe.createSource() This creates Source objects within Stripe, and can be used for various different methods of payment (including, but not limited to cards), but isn't SCA compliant. The Card Elements Quickstart JS example can be used, except use stripe.createSource instead of stripe.createToken and the result.source instead of result.token . Checkout a working example of this Charges using stripe.createToken() This predates stripe.createSource , and creates legacy Card objects within Stripe, which have some compatibility issues with Payment Methods. If you're using stripe.createToken , see if you can upgrade to stripe.createSource or ideally to Payment Intents . Tip Checkout Card Elements Quickstart JS","title":"Integrating Stripe Elements"},{"location":"stripe_elements_js/#integrating-stripe-elements-js-sdk","text":"Tip TLDR: If you haven't yet migrated to PaymentIntents, prefer stripe.createSource() over stripe.createToken() for better compatibility with PaymentMethods. Attention A point that can cause confusion when integrating Stripe on the web is that there are multiple generations of frontend JS APIs that use Stripe Elements with stripe js v3.","title":"Integrating Stripe Elements (JS SDK)"},{"location":"stripe_elements_js/#in-descending-order-of-preference-these-are","text":"","title":"In descending order of preference these are:"},{"location":"stripe_elements_js/#payment-intents-sca-compliant","text":"The newest and preferred way of handling payments, which supports SCA compliance (3D secure etc).","title":"Payment Intents (SCA compliant)"},{"location":"stripe_elements_js/#charges-using-stripecreatesource","text":"This creates Source objects within Stripe, and can be used for various different methods of payment (including, but not limited to cards), but isn't SCA compliant. The Card Elements Quickstart JS example can be used, except use stripe.createSource instead of stripe.createToken and the result.source instead of result.token . Checkout a working example of this","title":"Charges using stripe.createSource()"},{"location":"stripe_elements_js/#charges-using-stripecreatetoken","text":"This predates stripe.createSource , and creates legacy Card objects within Stripe, which have some compatibility issues with Payment Methods. If you're using stripe.createToken , see if you can upgrade to stripe.createSource or ideally to Payment Intents . Tip Checkout Card Elements Quickstart JS","title":"Charges using stripe.createToken()"},{"location":"history/0_x/","text":"dj-stripe 0.x release notes 0.8.0 (2015-12-30) better plan ordering documentation (Thanks @cjrh) added a confirmation page when choosing a subscription (Thanks @chrissmejia, @areski) setup.py reverse dependency fix (#258/#268) (Thanks @ticosax) Dropped official support for Django 1.7 (no code changes were made) Python 3.5 support, Django 1.9.1 support Migration improvements (Thanks @michi88) Fixed \"Invoice matching query does not exist\" bug (#263) (Thanks @mthornhill) Fixed duplicate content in account view (Thanks @areski) 0.7.0 (2015-09-22) dj-stripe now responds to the invoice.created event (Thanks @wahuneke) dj-stripe now cancels subscriptions and purges customers during sync if they were deleted from the stripe dashboard (Thanks @unformatt) dj-stripe now checks for an active stripe subscription in the update_plan_quantity call (Thanks @ctrengove) Event processing is now handled by \"event handlers\" - functions outside of models that respond to various event types and subtypes. Documentation on how to tie into the event handler system coming soon. (Thanks @wahuneke) Experimental Python 3.5 support Support for Django 1.6 and lower is now officially gone. Much, much more! 0.6.0 (2015-07-12) Support for Django 1.6 and lower is now deprecated. Improved test harness now tests coverage and pep8 SubscribeFormView and ChangePlanView no longer populate self.error with form errors InvoiceItems.plan can now be null (as it is with individual charges), resolving #140 (Thanks @awechsler and @MichelleGlauser for help troubleshooting) Email templates are now packaged during distribution. sync_plans now takes an optional api_key 100% test coverage Stripe ID is now returned as part of each model's str method (Thanks @areski) Customer model now stores card expiration month and year (Thanks @jpadilla) Ability to extend subscriptions (Thanks @TigerDX) Support for plan heirarchies (Thanks @chrissmejia) Rest API endpoints for Subscriptions [contrib] (Thanks @philippeluickx) Admin interface search by email funtionality is removed (#221) (Thanks @jpadilla) 0.5.0 (2015-05-25) Began deprecation of support for Django 1.6 and lower. Added formal support for Django 1.8. Removed the StripeSubscriptionSignupForm Removed djstripe.safe_settings . Settings are now all located in djstripe.settings DJSTRIPE_TRIAL_PERIOD_FOR_SUBSCRIBER_CALLBACK can no longer be a module string The sync_subscriber argument has been renamed from subscriber_model to subscriber Moved available currencies to the DJSTRIPE_CURRENCIES setting (Thanks @martinhill) Allow passing of extra parameters to stripe Charge API (Thanks @mthornhill) Support for all available arguments when syncing plans (Thanks @jamesbrobb) charge.refund() now returns the refunded charge object (Thanks @mthornhill) Charge model now has captured field and a capture method (Thanks @mthornhill) Subscription deleted webhook bugfix South migrations are now up to date (Thanks @Tyrdall) 0.4.0 (2015-04-05) Formal Python 3.3+/Django 1.7 Support (including migrations) Removed Python 2.6 from Travis CI build. (Thanks @audreyr) Dropped Django 1.4 support. (Thanks @audreyr) Deprecated the djstripe.forms.StripeSubscriptionSignupForm . Making this form work easily with both dj-stripe and django-allauth required too much abstraction. It will be removed in the 0.5.0 release. Add the ability to add invoice items for a customer (Thanks @kavdev) Add the ability to use a custom customer model (Thanks @kavdev) Added setting to disable Invoice receipt emails (Thanks Chris Halpert) Enable proration when customer upgrades plan, and pass proration policy and cancellation at period end for upgrades in settings. (Thanks Yasmine Charif) Removed the redundant context processor. (Thanks @kavdev) Fixed create a token call in change_card.html (Thanks @dollydagr) Fix charge.dispute.closed typo. (Thanks @ipmb) Fix contributing docs formatting. (Thanks @audreyr) Fix subscription canceled_at_period_end field sync on plan upgrade (Thanks @nigma) Remove \"account\" bug in Middleware (Thanks @sromero84) Fix correct plan selection on subscription in subscribe_form template. (Thanks Yasmine Charif) Fix subscription status in account, _subscription_status, and cancel_subscription templates. (Thanks Yasmine Charif) Now using user.get_username() instead of user.username , to support custom User models. (Thanks @shvechikov) Update remaining DOM Ids for Bootstrap 3. (Thanks Yasmine Charif) Update publish command in setup.py. (Thanks @pydanny) Explicitly specify tox's virtual environment names. (Thanks @audreyr) Manually call django.setup() to populate apps registry. (Thanks @audreyr) 0.3.5 (2014-05-01) Fixed djstripe_init_customers management command so it works with custom user models. 0.3.4 (2014-05-01) Clarify documentation for redirects on app_name. If settings.DEBUG is True, then django-debug-toolbar is exempt from redirect to subscription form. Use collections.OrderedDict to ensure that plans are listed in order of price. Add ordereddict library to support Python 2.6 users. Switch from __unicode__ to __str__ methods on models to better support Python 3. Add python_2_unicode_compatible decorator to Models. Check for PY3 so the unicode(self.user) in models.Customer doesn't blow up in Python 3. 0.3.3 (2014-04-24) Increased the extendability of the views by removing as many hard-coded URLs as possible and replacing them with success_url and other attributes/methods. Added single unit purchasing to the cookbook 0.3.2 (2014-01-16) Made Yasmine Charif a core committer Take into account trial days in a subscription plan (Thanks Yasmine Charif) Correct invoice period end value (Thanks Yasmine Charif) Make plan cancellation and plan change consistently not prorating (Thanks Yasmine Charif) Fix circular import when ACCOUNT_SIGNUP_FORM_CLASS is defined (Thanks Dustin Farris) Add send e-mail receipt action in charges admin panel (Thanks Buddy Lindsay) Add created field to all ModelAdmins to help with internal auditing (Thanks Kulbir Singh) 0.3.1 (2013-11-14) Cancellation fix (Thanks Yasmine Charif) Add setup.cfg for wheel generation (Thanks Charlie Denton) 0.3.0 (2013-11-12) Fully tested against Django 1.6, 1.5, and 1.4 Fix boolean default issue in models (from now on they are all default to False ). Replace duplicated code with djstripe.utils.user_has_active_subscription . 0.2.9 (2013-09-06) Cancellation added to views. Support for kwargs on charge and invoice fetching. def charge() now supports send_receipt flag, default to True. Fixed templates to work with Bootstrap 3.0.0 column design. 0.2.8 (2013-09-02) Improved usage documentation. Corrected order of fields in StripeSubscriptionSignupForm. Corrected transaction history template layout. Updated models to take into account when settings.USE_TZ is disabled. 0.2.7 (2013-08-24) Add handy rest_framework permission class. Fixing attribution for django-stripe-payments. Add new status to Invoice model. 0.2.6 (2013-08-20) Changed name of division tag to djdiv. Added safe_setting.py module to handle edge cases when working with custom user models. Added cookbook page in the documentation. 0.2.5 (2013-08-18) Fixed bug in initial checkout You can't purchase the same plan that you currently have. 0.2.4 (2013-08-18) Recursive package finding. 0.2.3 (2013-08-16) Fix packaging so all submodules are loaded 0.2.2 (2013-08-15) Added Registration + Subscription form 0.2.1 (2013-08-12) Fixed a bug on CurrentSubscription tests Improved usage documentation Added to migration from other tools documentation 0.2.0 (2013-08-12) Cancellation of plans now works. Upgrades and downgrades of plans now work. Changing of cards now works. Added breadcrumbs to improve navigation. Improved installation instructions. Consolidation of test instructions. Minor improvement to django-stripe-payments documentation Added coverage.py to test process. Added south migrations. Fixed the subscription_payment_required function-based view decorator. Removed unnecessary django-crispy-forms 0.1.7 (2013-08-08) Middleware excepts all of the djstripe namespaced URLs. This way people can pay. 0.1.6 (2013-08-08) Fixed a couple template paths Fixed the manifest so we include html, images. 0.1.5 (2013-08-08) Fixed the manifest so we include html, css, js, images. 0.1.4 (2013-08-08) Change PaymentRequiredMixin to SubscriptionPaymentRequiredMixin Add subscription_payment_required function-based view decorator Added SubscriptionPaymentRedirectMiddleware Much nicer accounts view display Much improved subscription form display Payment plans can have decimals Payment plans can have custom images 0.1.3 (2013-08-7) Added account view Added Customer.get_or_create method Added djstripe_sync_customers management command sync file for all code that keeps things in sync with stripe Use client-side JavaScript to get history data asynchronously More user friendly action views 0.1.2 (2013-08-6) Admin working Better publish statement Fix dependencies 0.1.1 (2013-08-6) Ported internals from django-stripe-payments Began writing the views Travis-CI All tests passing on Python 2.7 and 3.3 All tests passing on Django 1.4 and 1.5 Began model cleanup Better form Provide better response from management commands 0.1.0 (2013-08-5) First release on PyPI.","title":"dj-stripe 0.x release notes"},{"location":"history/0_x/#dj-stripe-0x-release-notes","text":"","title":"dj-stripe 0.x release notes"},{"location":"history/0_x/#080-2015-12-30","text":"better plan ordering documentation (Thanks @cjrh) added a confirmation page when choosing a subscription (Thanks @chrissmejia, @areski) setup.py reverse dependency fix (#258/#268) (Thanks @ticosax) Dropped official support for Django 1.7 (no code changes were made) Python 3.5 support, Django 1.9.1 support Migration improvements (Thanks @michi88) Fixed \"Invoice matching query does not exist\" bug (#263) (Thanks @mthornhill) Fixed duplicate content in account view (Thanks @areski)","title":"0.8.0 (2015-12-30)"},{"location":"history/0_x/#070-2015-09-22","text":"dj-stripe now responds to the invoice.created event (Thanks @wahuneke) dj-stripe now cancels subscriptions and purges customers during sync if they were deleted from the stripe dashboard (Thanks @unformatt) dj-stripe now checks for an active stripe subscription in the update_plan_quantity call (Thanks @ctrengove) Event processing is now handled by \"event handlers\" - functions outside of models that respond to various event types and subtypes. Documentation on how to tie into the event handler system coming soon. (Thanks @wahuneke) Experimental Python 3.5 support Support for Django 1.6 and lower is now officially gone. Much, much more!","title":"0.7.0 (2015-09-22)"},{"location":"history/0_x/#060-2015-07-12","text":"Support for Django 1.6 and lower is now deprecated. Improved test harness now tests coverage and pep8 SubscribeFormView and ChangePlanView no longer populate self.error with form errors InvoiceItems.plan can now be null (as it is with individual charges), resolving #140 (Thanks @awechsler and @MichelleGlauser for help troubleshooting) Email templates are now packaged during distribution. sync_plans now takes an optional api_key 100% test coverage Stripe ID is now returned as part of each model's str method (Thanks @areski) Customer model now stores card expiration month and year (Thanks @jpadilla) Ability to extend subscriptions (Thanks @TigerDX) Support for plan heirarchies (Thanks @chrissmejia) Rest API endpoints for Subscriptions [contrib] (Thanks @philippeluickx) Admin interface search by email funtionality is removed (#221) (Thanks @jpadilla)","title":"0.6.0 (2015-07-12)"},{"location":"history/0_x/#050-2015-05-25","text":"Began deprecation of support for Django 1.6 and lower. Added formal support for Django 1.8. Removed the StripeSubscriptionSignupForm Removed djstripe.safe_settings . Settings are now all located in djstripe.settings DJSTRIPE_TRIAL_PERIOD_FOR_SUBSCRIBER_CALLBACK can no longer be a module string The sync_subscriber argument has been renamed from subscriber_model to subscriber Moved available currencies to the DJSTRIPE_CURRENCIES setting (Thanks @martinhill) Allow passing of extra parameters to stripe Charge API (Thanks @mthornhill) Support for all available arguments when syncing plans (Thanks @jamesbrobb) charge.refund() now returns the refunded charge object (Thanks @mthornhill) Charge model now has captured field and a capture method (Thanks @mthornhill) Subscription deleted webhook bugfix South migrations are now up to date (Thanks @Tyrdall)","title":"0.5.0 (2015-05-25)"},{"location":"history/0_x/#040-2015-04-05","text":"Formal Python 3.3+/Django 1.7 Support (including migrations) Removed Python 2.6 from Travis CI build. (Thanks @audreyr) Dropped Django 1.4 support. (Thanks @audreyr) Deprecated the djstripe.forms.StripeSubscriptionSignupForm . Making this form work easily with both dj-stripe and django-allauth required too much abstraction. It will be removed in the 0.5.0 release. Add the ability to add invoice items for a customer (Thanks @kavdev) Add the ability to use a custom customer model (Thanks @kavdev) Added setting to disable Invoice receipt emails (Thanks Chris Halpert) Enable proration when customer upgrades plan, and pass proration policy and cancellation at period end for upgrades in settings. (Thanks Yasmine Charif) Removed the redundant context processor. (Thanks @kavdev) Fixed create a token call in change_card.html (Thanks @dollydagr) Fix charge.dispute.closed typo. (Thanks @ipmb) Fix contributing docs formatting. (Thanks @audreyr) Fix subscription canceled_at_period_end field sync on plan upgrade (Thanks @nigma) Remove \"account\" bug in Middleware (Thanks @sromero84) Fix correct plan selection on subscription in subscribe_form template. (Thanks Yasmine Charif) Fix subscription status in account, _subscription_status, and cancel_subscription templates. (Thanks Yasmine Charif) Now using user.get_username() instead of user.username , to support custom User models. (Thanks @shvechikov) Update remaining DOM Ids for Bootstrap 3. (Thanks Yasmine Charif) Update publish command in setup.py. (Thanks @pydanny) Explicitly specify tox's virtual environment names. (Thanks @audreyr) Manually call django.setup() to populate apps registry. (Thanks @audreyr)","title":"0.4.0 (2015-04-05)"},{"location":"history/0_x/#035-2014-05-01","text":"Fixed djstripe_init_customers management command so it works with custom user models.","title":"0.3.5 (2014-05-01)"},{"location":"history/0_x/#034-2014-05-01","text":"Clarify documentation for redirects on app_name. If settings.DEBUG is True, then django-debug-toolbar is exempt from redirect to subscription form. Use collections.OrderedDict to ensure that plans are listed in order of price. Add ordereddict library to support Python 2.6 users. Switch from __unicode__ to __str__ methods on models to better support Python 3. Add python_2_unicode_compatible decorator to Models. Check for PY3 so the unicode(self.user) in models.Customer doesn't blow up in Python 3.","title":"0.3.4 (2014-05-01)"},{"location":"history/0_x/#033-2014-04-24","text":"Increased the extendability of the views by removing as many hard-coded URLs as possible and replacing them with success_url and other attributes/methods. Added single unit purchasing to the cookbook","title":"0.3.3 (2014-04-24)"},{"location":"history/0_x/#032-2014-01-16","text":"Made Yasmine Charif a core committer Take into account trial days in a subscription plan (Thanks Yasmine Charif) Correct invoice period end value (Thanks Yasmine Charif) Make plan cancellation and plan change consistently not prorating (Thanks Yasmine Charif) Fix circular import when ACCOUNT_SIGNUP_FORM_CLASS is defined (Thanks Dustin Farris) Add send e-mail receipt action in charges admin panel (Thanks Buddy Lindsay) Add created field to all ModelAdmins to help with internal auditing (Thanks Kulbir Singh)","title":"0.3.2 (2014-01-16)"},{"location":"history/0_x/#031-2013-11-14","text":"Cancellation fix (Thanks Yasmine Charif) Add setup.cfg for wheel generation (Thanks Charlie Denton)","title":"0.3.1 (2013-11-14)"},{"location":"history/0_x/#030-2013-11-12","text":"Fully tested against Django 1.6, 1.5, and 1.4 Fix boolean default issue in models (from now on they are all default to False ). Replace duplicated code with djstripe.utils.user_has_active_subscription .","title":"0.3.0 (2013-11-12)"},{"location":"history/0_x/#029-2013-09-06","text":"Cancellation added to views. Support for kwargs on charge and invoice fetching. def charge() now supports send_receipt flag, default to True. Fixed templates to work with Bootstrap 3.0.0 column design.","title":"0.2.9 (2013-09-06)"},{"location":"history/0_x/#028-2013-09-02","text":"Improved usage documentation. Corrected order of fields in StripeSubscriptionSignupForm. Corrected transaction history template layout. Updated models to take into account when settings.USE_TZ is disabled.","title":"0.2.8 (2013-09-02)"},{"location":"history/0_x/#027-2013-08-24","text":"Add handy rest_framework permission class. Fixing attribution for django-stripe-payments. Add new status to Invoice model.","title":"0.2.7 (2013-08-24)"},{"location":"history/0_x/#026-2013-08-20","text":"Changed name of division tag to djdiv. Added safe_setting.py module to handle edge cases when working with custom user models. Added cookbook page in the documentation.","title":"0.2.6 (2013-08-20)"},{"location":"history/0_x/#025-2013-08-18","text":"Fixed bug in initial checkout You can't purchase the same plan that you currently have.","title":"0.2.5 (2013-08-18)"},{"location":"history/0_x/#024-2013-08-18","text":"Recursive package finding.","title":"0.2.4 (2013-08-18)"},{"location":"history/0_x/#023-2013-08-16","text":"Fix packaging so all submodules are loaded","title":"0.2.3 (2013-08-16)"},{"location":"history/0_x/#022-2013-08-15","text":"Added Registration + Subscription form","title":"0.2.2 (2013-08-15)"},{"location":"history/0_x/#021-2013-08-12","text":"Fixed a bug on CurrentSubscription tests Improved usage documentation Added to migration from other tools documentation","title":"0.2.1 (2013-08-12)"},{"location":"history/0_x/#020-2013-08-12","text":"Cancellation of plans now works. Upgrades and downgrades of plans now work. Changing of cards now works. Added breadcrumbs to improve navigation. Improved installation instructions. Consolidation of test instructions. Minor improvement to django-stripe-payments documentation Added coverage.py to test process. Added south migrations. Fixed the subscription_payment_required function-based view decorator. Removed unnecessary django-crispy-forms","title":"0.2.0 (2013-08-12)"},{"location":"history/0_x/#017-2013-08-08","text":"Middleware excepts all of the djstripe namespaced URLs. This way people can pay.","title":"0.1.7 (2013-08-08)"},{"location":"history/0_x/#016-2013-08-08","text":"Fixed a couple template paths Fixed the manifest so we include html, images.","title":"0.1.6 (2013-08-08)"},{"location":"history/0_x/#015-2013-08-08","text":"Fixed the manifest so we include html, css, js, images.","title":"0.1.5 (2013-08-08)"},{"location":"history/0_x/#014-2013-08-08","text":"Change PaymentRequiredMixin to SubscriptionPaymentRequiredMixin Add subscription_payment_required function-based view decorator Added SubscriptionPaymentRedirectMiddleware Much nicer accounts view display Much improved subscription form display Payment plans can have decimals Payment plans can have custom images","title":"0.1.4 (2013-08-08)"},{"location":"history/0_x/#013-2013-08-7","text":"Added account view Added Customer.get_or_create method Added djstripe_sync_customers management command sync file for all code that keeps things in sync with stripe Use client-side JavaScript to get history data asynchronously More user friendly action views","title":"0.1.3 (2013-08-7)"},{"location":"history/0_x/#012-2013-08-6","text":"Admin working Better publish statement Fix dependencies","title":"0.1.2 (2013-08-6)"},{"location":"history/0_x/#011-2013-08-6","text":"Ported internals from django-stripe-payments Began writing the views Travis-CI All tests passing on Python 2.7 and 3.3 All tests passing on Django 1.4 and 1.5 Began model cleanup Better form Provide better response from management commands","title":"0.1.1 (2013-08-6)"},{"location":"history/0_x/#010-2013-08-5","text":"First release on PyPI.","title":"0.1.0 (2013-08-5)"},{"location":"history/1_x/","text":"dj-stripe 1.x release notes 1.2.4 (2019-02-27) This is a bugfix-only version: Allow billing_cycle_anchor argument when creating a subscription (#814) Fixup plan amount null with tier plans (#781) Update Cancel subscription view tests to match backport in f64af57 Implement Invoice._manipulate_stripe_object_hook for compatability with API 2018-11-08 (#771) Fix product webhook for type=\"good\" (#724) Add trial_from_plan, trial_period_days args to Customer.subscribe() (#709) 1.2.3 (2018-10-13) This is a bugfix-only version: Updated Subscription.cancel() for compatibility with Stripe 2018-08-23 (#723) 1.2.2 (2018-08-11) This is a bugfix-only version: Fixed an error with request.urlconf in some setups (#562) Always save text-type fields as empty strings in db instead of null (#713) Fix support for DJSTRIPE_SUBSCRIBER_MODEL_MIGRATION_DEPENDENCY (#707) Fix reactivate() with Stripe API 2018-02-28 and above 1.2.1 (2018-07-18) This is a bugfix-only version: Fixed various Python 2.7 compatibility issues Fixed issues with max_length of receipt_number Fixed various fields incorrectly marked as required Handle product webhook calls Fix compatibility with stripe-python 2.0.0 1.2.0 (2018-06-11) The dj-stripe 1.2.0 release resets all migrations. Do not upgrade to 1.2.0 directly from 1.0.1 or below. You must upgrade to 1.1.0 first. Please read the 1.1.0 release notes below for more information. 1.1.0 (2018-06-11) In dj-stripe 1.1.0, we made a lot of changes to models in order to bring the dj-stripe model state much closer to the upstream API objects. If you are a current user of dj-stripe, you will most likely have to make changes in order to upgrade. Please read the full changelog below. If you are having trouble upgrading, you may ask for help by filing an issue on GitHub . Migration reset The next version of dj-stripe, 1.2.0 , will reset all the migrations to 0001_initial . Migrations are currently in an unmaintainable state. What this means is you will not be able to upgrade directly to dj-stripe 1.2.0. You must go through 1.1.0 first, run ``manage.py migrate djstripe``, then upgrade to 1.2.0. Python 2.7 end-of-life dj-stripe 1.1.0 drops support for Django 1.10 and adds support for Django 2.0. Django 1.11+ and Python 2.7+ or 3.4+ are required. Support for Python versions older than 3.5, and Django versions older than 2.0, will be dropped in dj-stripe 2.0.0. Backwards-incompatible changes and deprecations Removal of polymorphic models The model architecture of dj-stripe has been simplified. Polymorphic models have been dropped and the old base StripeCustomer, StripeCharge, StripeInvoice, etc models have all been merged into the top-level Customer, Charge, Invoice, etc models. Importing those legacy models from djstripe.stripe_objects will yield the new ones. This is deprecated and support for this will be dropped in dj-stripe 2.0.0. Full support for Stripe Sources (Support for v3 stripe.js) Stripe sources ( src_XXXX ) are objects that can arbitrarily reference any of the payment method types that Stripe supports. However, the legacy Card object (with object IDs like card_XXXX or cc_XXXX ) is not a Source object, and cannot be turned into a Source object at this time. In order to support both Card and Source objects in ForeignKeys, a new model PaymentMethod has been devised (renamed to DjstripePaymentMethod in 2.0). That model can resolve into a Card, a Source, or a BankAccount object. The ``default_source`` attribute on ``Customer`` now refers to a ``PaymentMethod`` object . You will need to call .resolve() on it to get the Card or Source in question. References to Customer.sources expecting a queryset of Card objects should be updated to Customer.legacy_cards . The legacy StripeSource name refers to the Card model. This will be removed in dj-stripe 2.0.0. Update your references to either Card or Source . enums.SourceType has been renamed to enums.LegacySourceType . enums.SourceType now refers to the actual Stripe Source types enum. Core fields renamed The numeric id field has been renamed to djstripe_id . This avoids a clash with the upstream stripe id. Accessing .id is deprecated and **will reference the upstream stripe_id in dj-stripe 2.0.0 1.0.0 (2017-08-12) It's finally here! We've made significant changes to the codebase and are now compliant with stripe API version 2017-06-05 . I want to give a huge thanks to all of our contributors for their help in making this happen, especially Bill Huneke (@wahuneke) for his impressive design work and @jleclanche for really pushing this release along. I also want to welcome onboard two more maintainers, @jleclanche and @lskillen. They've stepped up and have graciously dedicated their resources to making dj-stripe such an amazing package. Almost all methods now mimic the parameters of those same methods in the stripe API. Note that some methods do not have some parameters implemented. This is intentional. That being said, expect all method signatures to be different than those in previous versions of dj-stripe. Finally, please note that there is still a bit of work ahead of us. Not everything in the Stripe API is currently supported by dj-stripe -- we're working on it. That said, v1.0.0 has been thoroughly tested and is verified stable in production applications. A few things to get excited for Multiple subscription support (finally) Multiple sources support (currently limited to Cards) Idempotency support (See #455, #460 for discussion -- big thanks to @jleclanche) Full model documentation Objects that come through webhooks are now tied to the API version set in dj-stripe. No more errors if dj-stripe falls behind the newest stripe API version. Any create/update action on an object automatically syncs the object. Concurrent LIVE and TEST mode support (Thanks to @jleclanche). Note that you'll run into issues if livemode isn't set on your existing customer objects. All choices are now enum-based (Thanks @jleclanche, See #520). Access them from the new djstripe.enums module. The ability to check against model property based choices will be deprecated in 1.1 Support for the Coupon model, and coupons on Customer objects. Support for the Payout/Transfer split from api version 2017-04-06 . What still needs to be done (in v1.1.0) Documentation . Our original documentation was not very helpful, but it covered the important bits. It will be very out of date after this update and will need to be rewritten. If you feel like helping, we could use all the help we can get to get this pushed out asap. Master sync re-write . This sounds scary, but really isn't. The current management methods run sync methods on Customer that aren't very helpful and are due for removal. My plan is to write something that first updates local data (via api_retrieve and sync_from_stripe_data ) and then pulls all objects from Stripe and populates the local database with any records that don't already exist there. You might be wondering, \"Why are they releasing this if there are only a few things left?\" Well, that thinking turned this into a two year release... Trust me, this is a good thing. Significant changes (mostly backwards-incompatible) Idempotency . #460 introduces idempotency keys and implements idempotency for Customer.get_or_create() . Idempotency will be enabled for all calls that need it. Improved Admin Interface . This is almost complete. See #451 and #452. Drop non-trivial endpoint views . We're dropping everything except the webhook endpoint and the subscription cancel endpoint. See #428. Drop support for sending receipts . Stripe now handles this for you. See #478. Drop support for plans as settings , including custom plan hierarchy (if you want this, write something custom) and the dynamic trial callback. We've decided to gut having plans as settings. Stripe should be your source of truth; create your plans there and sync them down manually. If you need to create plans locally for testing, etc., simply use the ORM to create Plan models. The sync rewrite will make this drop less annoying. Orphan Customer Sync . We will now sync Customer objects from Stripe even if they aren't linked to local subscriber objects. You can link up subscribers to those Customers manually. Concurrent Live and Test Mode . dj-stripe now supports test-mode and live-mode Customer objects concurrently. As a result, the User.customer One-to-One reverse-relationship is now the User.djstripe_customers RelatedManager. (Thanks @jleclanche) #440. You'll run into some dj-stripe check issues if you don't update your KEY settings accordingly. Check our GitHub issue tracker for help on this. SETTINGS The PLAN_CHOICES , PLAN_LIST , and PAYMENT_PLANS objects are removed. Use Plan.objects.all() instead. The plan_from_stripe_id function is removed. Use Plan.objects.get(stripe_id=) SYNCING sync_plans no longer takes an api_key sync methods no longer take a cu parameter All sync methods are now private. We're in the process of building a better syncing mechanism. UTILITIES dj-stripe decorators now take a plan argument. If you're passing in a custom test function to subscriber_passes_pay_test , be sure to account for this new argument. MIXINS The context provided by dj-stripe's mixins has changed. PaymentsContextMixin now provides STRIPE_PUBLIC_KEY and plans (changed to Plan.objects.all() ). SubscriptionMixin now provides customer and is_plans_plural . We've removed the SubscriptionPaymentRequiredMixin. Use @method_decorator(\"dispatch\", subscription_payment_required ) instead. MIDDLEWARE dj-stripe middleware doesn't support multiple subscriptions. SIGNALS Local custom signals are deprecated in favor of Stripe webhooks: cancelled -> WEBHOOK_SIGNALS[\"customer.subscription.deleted\"] card_changed -> WEBHOOK_SIGNALS[\"customer.source.updated\"] subscription_made -> WEBHOOK_SIGNALS[\"customer.subscription.created\"] WEBHOOK EVENTS The Event Handlers designed by @wahuneke are the new way to handle events that come through webhooks. Definitely take a look at event_handlers.py and webhooks.py . EXCEPTIONS SubscriptionUpdateFailure and SubscriptionCancellationFailure exceptions are removed. There should no longer be a case where they would have been useful. Catch native stripe errors in their place instead. MODELS CHARGE Charge.charge_created -> Charge.stripe_timestamp Charge.card_last_4 and Charge.card_kind are removed. Use Charge.source.last4 and Charge.source.brand (if the source is a Card) Charge.invoice is no longer a foreign key to the Invoice model. Invoice now has a OneToOne relationship with Charge . ( Charge.invoice will still work, but will no longer be represented in the database). CUSTOMER dj-stripe now supports test mode and live mode Customer objects concurrently (See #440). As a result, the <subscriber_model>.customer OneToOne reverse relationship is no longer a thing. You should now instead add a customer property to your subscriber model that checks whether you're in live or test mode (see djstripe.settings.STRIPE_LIVE_MODE as an example) and grabs the customer from <subscriber_model>.djstripe_customers with a simple livemode= filter. Customer no longer has a current_subscription property. We've added a subscription property that should suit your needs. With the advent of multiple subscriptions, the behavior of Customer.subscribe() has changed. Before, calling subscribe() when a customer was already subscribed to a plan would switch the customer to the new plan with an option to prorate. Now calling subscribe() simply subscribes that customer to a new plan in addition to it's current subsription. Use Subscription.update() to change a subscription's plan instead. Customer.cancel_subscription() is removed. Use Subscription.cancel() instead. The Customer.update_plan_quantity() method is removed. Use Subscription.update() instead. CustomerManager is now SubscriptionManager and works on the Subscription model instead of the Customer model. Customer.has_valid_card() is now Customer.has_valid_source() . Customer.update_card() now takes an id. If the id is not supplied, the default source is updated. Customer.stripe_customer property is removed. Use Customer.api_retrieve() instead. The at_period_end parameter of Customer.cancel_subscription() now actually follows the DJSTRIPE_PRORATION_POLICY setting. Customer.card_fingerprint , Customer.card_last_4 , Customer.card_kind , Customer.card_exp_month , Customer.card_exp_year are all removed. Check Customer.default_source (if it's a Card) or one of the sources in Customer.sources (again, if it's a Card) instead. The invoice_id parameter of Customer.add_invoice_item is now named invoice and can be either an Invoice object or the stripe_id of an Invoice. EVENT Event.kind -> Event.type Removed Event.validated_message . Just check if the event is valid no need to double check (we do that for you) TRANSFER Removed Transfer.update_status() Removed Transfer.event TransferChargeFee is removed. It hasn't been used in a while due to a broken API version. Use Transfer.fee_details instead. Any fields that were in Transfer.summary no longer exist and are therefore deprecated (unused but not removed from the database). Because of this, TransferManager now only aggregates total_sum INVOICE Invoice.attempts -> Invoice.attempt_count InvoiceItems are no longer created when Invoices are synced. You must now sync InvoiceItems directly. INVOICEITEM Removed InvoiceItem.line_type PLAN Plan no longer has a stripe_plan property. Use api_retrieve() instead. Plan.currency no longer uses choices. Use the get_supported_currency_choices() utility and create your own custom choices list instead. Plan interval choices are now in Plan.INTERVAL_TYPE_CHOICES SUBSCRIPTION Subscription.is_period_current() now checks for a current trial end if the current period has ended. This change means subscriptions extended with Subscription.extend() will now be seen as valid. MIGRATIONS We'll sync your current records with Stripe in a migration. It will take a while, but it's the only way we can ensure data integrity. There were some fields for which we needed to temporarily add placeholder defaults, so just make sure you have a customer with ID 1 and a plan with ID 1 and you shouldn't run into any issues (create dummy values for these if need be and delete them after the migration). BIG HUGE NOTE - DON'T OVERLOOK THIS Warning Subscription and InvoiceItem migration is not possible because old records don't have Stripe IDs (so we can't sync them). Our approach is to delete all local subscription and invoiceitem objects and re-sync them from Stripe. We 100% recommend you create a backup of your database before performing this upgrade. Other changes Postgres users now have access to the DJSTRIPE_USE_NATIVE_JSONFIELD setting. (Thanks @jleclanche) #517, #523 Charge receipts now take DJSTRIPE_SEND_INVOICE_RECEIPT_EMAILS into account (Thanks @r0fls) Clarified/modified installation documentation (Thanks @pydanny) Corrected and revised ANONYMOUS_USER_ERROR_MSG (Thanks @pydanny) Added fnmatching to SubscriptionPaymentMiddleware (Thanks @pydanny) SubscriptionPaymentMiddleware.process_request() functionality broken up into multiple methods, making local customizations easier (Thanks @pydanny) Fully qualified events are now supported by event handlers as strings e.g. 'customer.subscription.deleted' (Thanks @lskillen) #316 runtests now accepts positional arguments for declaring which tests to run (Thanks @lskillen) #317 It is now possible to reprocess events in both code and the admin interface (Thanks @lskillen) #318 The confirm page now checks that a valid card exists. (Thanks @scream4ik) #325 Added support for viewing upcoming invoices (Thanks @lskillen) #320 Event handler improvements and bugfixes (Thanks @lskillen) #321 API list() method bugfixes (Thanks @lskillen) #322 Added support for a custom webhook event handler (Thanks @lskillen) #323 Django REST Framework contrib package improvements (Thanks @aleccool213) #334 Added tax_percent to CreateSubscriptionSerializer (Thanks @aleccool213) #349 Fixed incorrectly assigned application_fee in Charge calls (Thanks @kronok) #382 Fixed bug caused by API change (Thanks @jessamynsmith) #353 Added inline documentation to pretty much everything and enforced docsytle via flake8 (Thanks @aleccool213) Fixed outdated method call in template (Thanks @kandoio) #391 Customer is correctly purged when subscriber is deleted, regardless of how the deletion happened (Thanks @lskillen) #396 Test webhooks are now properly captured and logged. No more bounced requests to Stripe! (Thanks @jameshiew) #408 CancelSubscriptionView redirect is now more flexible (Thanks @jleclanche) #418 Customer.sync_cards() (Thanks @jleclanche) #438 Many stability fixes, bugfixes, and code cleanup (Thanks @jleclanche) Support syncing canceled subscriptions (Thanks @jleclanche) #443 Improved admin interface (Thanks @jleclanche with @jameshiew) #451 Support concurrent TEST + LIVE API keys (Fix webhook event processing for both modes) (Thanks @jleclanche) #461 Added Stripe Dashboard link to admin change panel (Thanks @jleclanche) #465 Implemented Plan.amount_in_cents (Thanks @jleclanche) #466 Implemented Subscription.reactivate() (Thanks @jleclanche) #470 Added Plan.human_readable_price (Thanks @jleclanche) #498 (Re)attach the Subscriber when we find it's id attached to a customer on Customer sync (Thanks @jleclanche) #500 Made API version configurable (with dj-stripe recommended default) (Thanks @lskillen) #504","title":"dj-stripe 1.x release notes"},{"location":"history/1_x/#dj-stripe-1x-release-notes","text":"","title":"dj-stripe 1.x release notes"},{"location":"history/1_x/#124-2019-02-27","text":"This is a bugfix-only version: Allow billing_cycle_anchor argument when creating a subscription (#814) Fixup plan amount null with tier plans (#781) Update Cancel subscription view tests to match backport in f64af57 Implement Invoice._manipulate_stripe_object_hook for compatability with API 2018-11-08 (#771) Fix product webhook for type=\"good\" (#724) Add trial_from_plan, trial_period_days args to Customer.subscribe() (#709)","title":"1.2.4 (2019-02-27)"},{"location":"history/1_x/#123-2018-10-13","text":"This is a bugfix-only version: Updated Subscription.cancel() for compatibility with Stripe 2018-08-23 (#723)","title":"1.2.3 (2018-10-13)"},{"location":"history/1_x/#122-2018-08-11","text":"This is a bugfix-only version: Fixed an error with request.urlconf in some setups (#562) Always save text-type fields as empty strings in db instead of null (#713) Fix support for DJSTRIPE_SUBSCRIBER_MODEL_MIGRATION_DEPENDENCY (#707) Fix reactivate() with Stripe API 2018-02-28 and above","title":"1.2.2 (2018-08-11)"},{"location":"history/1_x/#121-2018-07-18","text":"This is a bugfix-only version: Fixed various Python 2.7 compatibility issues Fixed issues with max_length of receipt_number Fixed various fields incorrectly marked as required Handle product webhook calls Fix compatibility with stripe-python 2.0.0","title":"1.2.1 (2018-07-18)"},{"location":"history/1_x/#120-2018-06-11","text":"The dj-stripe 1.2.0 release resets all migrations. Do not upgrade to 1.2.0 directly from 1.0.1 or below. You must upgrade to 1.1.0 first. Please read the 1.1.0 release notes below for more information.","title":"1.2.0 (2018-06-11)"},{"location":"history/1_x/#110-2018-06-11","text":"In dj-stripe 1.1.0, we made a lot of changes to models in order to bring the dj-stripe model state much closer to the upstream API objects. If you are a current user of dj-stripe, you will most likely have to make changes in order to upgrade. Please read the full changelog below. If you are having trouble upgrading, you may ask for help by filing an issue on GitHub .","title":"1.1.0 (2018-06-11)"},{"location":"history/1_x/#migration-reset","text":"The next version of dj-stripe, 1.2.0 , will reset all the migrations to 0001_initial . Migrations are currently in an unmaintainable state. What this means is you will not be able to upgrade directly to dj-stripe 1.2.0. You must go through 1.1.0 first, run ``manage.py migrate djstripe``, then upgrade to 1.2.0.","title":"Migration reset"},{"location":"history/1_x/#python-27-end-of-life","text":"dj-stripe 1.1.0 drops support for Django 1.10 and adds support for Django 2.0. Django 1.11+ and Python 2.7+ or 3.4+ are required. Support for Python versions older than 3.5, and Django versions older than 2.0, will be dropped in dj-stripe 2.0.0.","title":"Python 2.7 end-of-life"},{"location":"history/1_x/#backwards-incompatible-changes-and-deprecations","text":"","title":"Backwards-incompatible changes and deprecations"},{"location":"history/1_x/#removal-of-polymorphic-models","text":"The model architecture of dj-stripe has been simplified. Polymorphic models have been dropped and the old base StripeCustomer, StripeCharge, StripeInvoice, etc models have all been merged into the top-level Customer, Charge, Invoice, etc models. Importing those legacy models from djstripe.stripe_objects will yield the new ones. This is deprecated and support for this will be dropped in dj-stripe 2.0.0.","title":"Removal of polymorphic models"},{"location":"history/1_x/#full-support-for-stripe-sources-support-for-v3-stripejs","text":"Stripe sources ( src_XXXX ) are objects that can arbitrarily reference any of the payment method types that Stripe supports. However, the legacy Card object (with object IDs like card_XXXX or cc_XXXX ) is not a Source object, and cannot be turned into a Source object at this time. In order to support both Card and Source objects in ForeignKeys, a new model PaymentMethod has been devised (renamed to DjstripePaymentMethod in 2.0). That model can resolve into a Card, a Source, or a BankAccount object. The ``default_source`` attribute on ``Customer`` now refers to a ``PaymentMethod`` object . You will need to call .resolve() on it to get the Card or Source in question. References to Customer.sources expecting a queryset of Card objects should be updated to Customer.legacy_cards . The legacy StripeSource name refers to the Card model. This will be removed in dj-stripe 2.0.0. Update your references to either Card or Source . enums.SourceType has been renamed to enums.LegacySourceType . enums.SourceType now refers to the actual Stripe Source types enum.","title":"Full support for Stripe Sources (Support for v3 stripe.js)"},{"location":"history/1_x/#core-fields-renamed","text":"The numeric id field has been renamed to djstripe_id . This avoids a clash with the upstream stripe id. Accessing .id is deprecated and **will reference the upstream stripe_id in dj-stripe 2.0.0","title":"Core fields renamed"},{"location":"history/1_x/#100-2017-08-12","text":"It's finally here! We've made significant changes to the codebase and are now compliant with stripe API version 2017-06-05 . I want to give a huge thanks to all of our contributors for their help in making this happen, especially Bill Huneke (@wahuneke) for his impressive design work and @jleclanche for really pushing this release along. I also want to welcome onboard two more maintainers, @jleclanche and @lskillen. They've stepped up and have graciously dedicated their resources to making dj-stripe such an amazing package. Almost all methods now mimic the parameters of those same methods in the stripe API. Note that some methods do not have some parameters implemented. This is intentional. That being said, expect all method signatures to be different than those in previous versions of dj-stripe. Finally, please note that there is still a bit of work ahead of us. Not everything in the Stripe API is currently supported by dj-stripe -- we're working on it. That said, v1.0.0 has been thoroughly tested and is verified stable in production applications.","title":"1.0.0 (2017-08-12)"},{"location":"history/1_x/#a-few-things-to-get-excited-for","text":"Multiple subscription support (finally) Multiple sources support (currently limited to Cards) Idempotency support (See #455, #460 for discussion -- big thanks to @jleclanche) Full model documentation Objects that come through webhooks are now tied to the API version set in dj-stripe. No more errors if dj-stripe falls behind the newest stripe API version. Any create/update action on an object automatically syncs the object. Concurrent LIVE and TEST mode support (Thanks to @jleclanche). Note that you'll run into issues if livemode isn't set on your existing customer objects. All choices are now enum-based (Thanks @jleclanche, See #520). Access them from the new djstripe.enums module. The ability to check against model property based choices will be deprecated in 1.1 Support for the Coupon model, and coupons on Customer objects. Support for the Payout/Transfer split from api version 2017-04-06 .","title":"A few things to get excited for"},{"location":"history/1_x/#what-still-needs-to-be-done-in-v110","text":"Documentation . Our original documentation was not very helpful, but it covered the important bits. It will be very out of date after this update and will need to be rewritten. If you feel like helping, we could use all the help we can get to get this pushed out asap. Master sync re-write . This sounds scary, but really isn't. The current management methods run sync methods on Customer that aren't very helpful and are due for removal. My plan is to write something that first updates local data (via api_retrieve and sync_from_stripe_data ) and then pulls all objects from Stripe and populates the local database with any records that don't already exist there. You might be wondering, \"Why are they releasing this if there are only a few things left?\" Well, that thinking turned this into a two year release... Trust me, this is a good thing.","title":"What still needs to be done (in v1.1.0)"},{"location":"history/1_x/#significant-changes-mostly-backwards-incompatible","text":"Idempotency . #460 introduces idempotency keys and implements idempotency for Customer.get_or_create() . Idempotency will be enabled for all calls that need it. Improved Admin Interface . This is almost complete. See #451 and #452. Drop non-trivial endpoint views . We're dropping everything except the webhook endpoint and the subscription cancel endpoint. See #428. Drop support for sending receipts . Stripe now handles this for you. See #478. Drop support for plans as settings , including custom plan hierarchy (if you want this, write something custom) and the dynamic trial callback. We've decided to gut having plans as settings. Stripe should be your source of truth; create your plans there and sync them down manually. If you need to create plans locally for testing, etc., simply use the ORM to create Plan models. The sync rewrite will make this drop less annoying. Orphan Customer Sync . We will now sync Customer objects from Stripe even if they aren't linked to local subscriber objects. You can link up subscribers to those Customers manually. Concurrent Live and Test Mode . dj-stripe now supports test-mode and live-mode Customer objects concurrently. As a result, the User.customer One-to-One reverse-relationship is now the User.djstripe_customers RelatedManager. (Thanks @jleclanche) #440. You'll run into some dj-stripe check issues if you don't update your KEY settings accordingly. Check our GitHub issue tracker for help on this.","title":"Significant changes (mostly backwards-incompatible)"},{"location":"history/1_x/#settings","text":"The PLAN_CHOICES , PLAN_LIST , and PAYMENT_PLANS objects are removed. Use Plan.objects.all() instead. The plan_from_stripe_id function is removed. Use Plan.objects.get(stripe_id=)","title":"SETTINGS"},{"location":"history/1_x/#syncing","text":"sync_plans no longer takes an api_key sync methods no longer take a cu parameter All sync methods are now private. We're in the process of building a better syncing mechanism.","title":"SYNCING"},{"location":"history/1_x/#utilities","text":"dj-stripe decorators now take a plan argument. If you're passing in a custom test function to subscriber_passes_pay_test , be sure to account for this new argument.","title":"UTILITIES"},{"location":"history/1_x/#mixins","text":"The context provided by dj-stripe's mixins has changed. PaymentsContextMixin now provides STRIPE_PUBLIC_KEY and plans (changed to Plan.objects.all() ). SubscriptionMixin now provides customer and is_plans_plural . We've removed the SubscriptionPaymentRequiredMixin. Use @method_decorator(\"dispatch\", subscription_payment_required ) instead.","title":"MIXINS"},{"location":"history/1_x/#middleware","text":"dj-stripe middleware doesn't support multiple subscriptions.","title":"MIDDLEWARE"},{"location":"history/1_x/#signals","text":"Local custom signals are deprecated in favor of Stripe webhooks: cancelled -> WEBHOOK_SIGNALS[\"customer.subscription.deleted\"] card_changed -> WEBHOOK_SIGNALS[\"customer.source.updated\"] subscription_made -> WEBHOOK_SIGNALS[\"customer.subscription.created\"]","title":"SIGNALS"},{"location":"history/1_x/#webhook-events","text":"The Event Handlers designed by @wahuneke are the new way to handle events that come through webhooks. Definitely take a look at event_handlers.py and webhooks.py .","title":"WEBHOOK EVENTS"},{"location":"history/1_x/#exceptions","text":"SubscriptionUpdateFailure and SubscriptionCancellationFailure exceptions are removed. There should no longer be a case where they would have been useful. Catch native stripe errors in their place instead.","title":"EXCEPTIONS"},{"location":"history/1_x/#models","text":"CHARGE Charge.charge_created -> Charge.stripe_timestamp Charge.card_last_4 and Charge.card_kind are removed. Use Charge.source.last4 and Charge.source.brand (if the source is a Card) Charge.invoice is no longer a foreign key to the Invoice model. Invoice now has a OneToOne relationship with Charge . ( Charge.invoice will still work, but will no longer be represented in the database). CUSTOMER dj-stripe now supports test mode and live mode Customer objects concurrently (See #440). As a result, the <subscriber_model>.customer OneToOne reverse relationship is no longer a thing. You should now instead add a customer property to your subscriber model that checks whether you're in live or test mode (see djstripe.settings.STRIPE_LIVE_MODE as an example) and grabs the customer from <subscriber_model>.djstripe_customers with a simple livemode= filter. Customer no longer has a current_subscription property. We've added a subscription property that should suit your needs. With the advent of multiple subscriptions, the behavior of Customer.subscribe() has changed. Before, calling subscribe() when a customer was already subscribed to a plan would switch the customer to the new plan with an option to prorate. Now calling subscribe() simply subscribes that customer to a new plan in addition to it's current subsription. Use Subscription.update() to change a subscription's plan instead. Customer.cancel_subscription() is removed. Use Subscription.cancel() instead. The Customer.update_plan_quantity() method is removed. Use Subscription.update() instead. CustomerManager is now SubscriptionManager and works on the Subscription model instead of the Customer model. Customer.has_valid_card() is now Customer.has_valid_source() . Customer.update_card() now takes an id. If the id is not supplied, the default source is updated. Customer.stripe_customer property is removed. Use Customer.api_retrieve() instead. The at_period_end parameter of Customer.cancel_subscription() now actually follows the DJSTRIPE_PRORATION_POLICY setting. Customer.card_fingerprint , Customer.card_last_4 , Customer.card_kind , Customer.card_exp_month , Customer.card_exp_year are all removed. Check Customer.default_source (if it's a Card) or one of the sources in Customer.sources (again, if it's a Card) instead. The invoice_id parameter of Customer.add_invoice_item is now named invoice and can be either an Invoice object or the stripe_id of an Invoice. EVENT Event.kind -> Event.type Removed Event.validated_message . Just check if the event is valid no need to double check (we do that for you) TRANSFER Removed Transfer.update_status() Removed Transfer.event TransferChargeFee is removed. It hasn't been used in a while due to a broken API version. Use Transfer.fee_details instead. Any fields that were in Transfer.summary no longer exist and are therefore deprecated (unused but not removed from the database). Because of this, TransferManager now only aggregates total_sum INVOICE Invoice.attempts -> Invoice.attempt_count InvoiceItems are no longer created when Invoices are synced. You must now sync InvoiceItems directly. INVOICEITEM Removed InvoiceItem.line_type PLAN Plan no longer has a stripe_plan property. Use api_retrieve() instead. Plan.currency no longer uses choices. Use the get_supported_currency_choices() utility and create your own custom choices list instead. Plan interval choices are now in Plan.INTERVAL_TYPE_CHOICES SUBSCRIPTION Subscription.is_period_current() now checks for a current trial end if the current period has ended. This change means subscriptions extended with Subscription.extend() will now be seen as valid.","title":"MODELS"},{"location":"history/1_x/#migrations","text":"We'll sync your current records with Stripe in a migration. It will take a while, but it's the only way we can ensure data integrity. There were some fields for which we needed to temporarily add placeholder defaults, so just make sure you have a customer with ID 1 and a plan with ID 1 and you shouldn't run into any issues (create dummy values for these if need be and delete them after the migration).","title":"MIGRATIONS"},{"location":"history/1_x/#big-huge-note-dont-overlook-this","text":"Warning Subscription and InvoiceItem migration is not possible because old records don't have Stripe IDs (so we can't sync them). Our approach is to delete all local subscription and invoiceitem objects and re-sync them from Stripe. We 100% recommend you create a backup of your database before performing this upgrade.","title":"BIG HUGE NOTE - DON'T OVERLOOK THIS"},{"location":"history/1_x/#other-changes","text":"Postgres users now have access to the DJSTRIPE_USE_NATIVE_JSONFIELD setting. (Thanks @jleclanche) #517, #523 Charge receipts now take DJSTRIPE_SEND_INVOICE_RECEIPT_EMAILS into account (Thanks @r0fls) Clarified/modified installation documentation (Thanks @pydanny) Corrected and revised ANONYMOUS_USER_ERROR_MSG (Thanks @pydanny) Added fnmatching to SubscriptionPaymentMiddleware (Thanks @pydanny) SubscriptionPaymentMiddleware.process_request() functionality broken up into multiple methods, making local customizations easier (Thanks @pydanny) Fully qualified events are now supported by event handlers as strings e.g. 'customer.subscription.deleted' (Thanks @lskillen) #316 runtests now accepts positional arguments for declaring which tests to run (Thanks @lskillen) #317 It is now possible to reprocess events in both code and the admin interface (Thanks @lskillen) #318 The confirm page now checks that a valid card exists. (Thanks @scream4ik) #325 Added support for viewing upcoming invoices (Thanks @lskillen) #320 Event handler improvements and bugfixes (Thanks @lskillen) #321 API list() method bugfixes (Thanks @lskillen) #322 Added support for a custom webhook event handler (Thanks @lskillen) #323 Django REST Framework contrib package improvements (Thanks @aleccool213) #334 Added tax_percent to CreateSubscriptionSerializer (Thanks @aleccool213) #349 Fixed incorrectly assigned application_fee in Charge calls (Thanks @kronok) #382 Fixed bug caused by API change (Thanks @jessamynsmith) #353 Added inline documentation to pretty much everything and enforced docsytle via flake8 (Thanks @aleccool213) Fixed outdated method call in template (Thanks @kandoio) #391 Customer is correctly purged when subscriber is deleted, regardless of how the deletion happened (Thanks @lskillen) #396 Test webhooks are now properly captured and logged. No more bounced requests to Stripe! (Thanks @jameshiew) #408 CancelSubscriptionView redirect is now more flexible (Thanks @jleclanche) #418 Customer.sync_cards() (Thanks @jleclanche) #438 Many stability fixes, bugfixes, and code cleanup (Thanks @jleclanche) Support syncing canceled subscriptions (Thanks @jleclanche) #443 Improved admin interface (Thanks @jleclanche with @jameshiew) #451 Support concurrent TEST + LIVE API keys (Fix webhook event processing for both modes) (Thanks @jleclanche) #461 Added Stripe Dashboard link to admin change panel (Thanks @jleclanche) #465 Implemented Plan.amount_in_cents (Thanks @jleclanche) #466 Implemented Subscription.reactivate() (Thanks @jleclanche) #470 Added Plan.human_readable_price (Thanks @jleclanche) #498 (Re)attach the Subscriber when we find it's id attached to a customer on Customer sync (Thanks @jleclanche) #500 Made API version configurable (with dj-stripe recommended default) (Thanks @lskillen) #504","title":"Other changes"},{"location":"history/2_4_0/","text":"dj-stripe 2.4.0 release notes (2020-11-19) Attention To upgrade to 2.4.0 from older versions of dj-stripe, scroll down to the Upgrade Guide . Introducing sponsorships and our first sponsor We're excited to introduce our Sponsorship tiers . Individuals may back dj-stripe to assist with development. Larger backers may choose one the paid support plans available to receive support on top of ensuring the long-term viability of the project! And this release was made possible by none other than\u2026 Stripe ! Our very first Gold sponsor. Their financial backing has allowed us to pour a lot of work that could not have otherwise happened. Release notes Support for Django 3.1 and Python 3.8. Minimum stripe-python version is now 2.48.0. Default Stripe API version is now 2020-08-27 . First-class support for the Price model, replacing Plans. Support multi-item subscriptions. Support for API keys in the database (see Managing Stripe API keys ). Support for syncing objects for multiple, different Stripe accounts. Use Django 3.1 native JSONField when available. The field djstripe_owner_account has been added to all Stripe models, and is automatically populated with the Account that owns the API key used to retrieve it. Support for subscription schedules (#899). Add support for Reporting categories and TaxIds Update many models to match latest version of the Stripe API. Fixed Account.get_default_account() for Restricted API Keys. Allow passing arbitrary arguments (any valid SDK argument) to the following methods: Customer.charge() Customer.subscribe() , Charge.capture() Subscription.update() New management command: djstripe_update_invoiceitem_ids . This command migrates InvoiceItems using Stripe's old IDs to the new ones. Hundreds of other bugfixes. New feature: in-database Stripe API keys Stripe API keys are now stored in the database, and are now editable in the admin. Warning By default, all keys are visible by anyone who has access to the dj-stripe administration. Why? As we work on supporting multiple Stripe accounts per instance, it is vital for dj-stripe to have a mechanism to store more than one Stripe API key. It also became obvious that we may want proper programmatic access to create and delete keys. Furthermore, API keys are a legitimate upstream Stripe object, and it is not unlikely the API may allow access to listing other API keys in the future, in which case we will want to move them to the database anyway. In the next release, we are planning to make WebhookEndpoints (and thus webhook secrets) manageable via the database as well. Do I need to change anything? Not at this time. The settings STRIPE_LIVE_SECRET_KEY and STRIPE_TEST_SECRET_KEY can still be used. Their values will however be automatically saved to the database at the earliest opportunity. What about public keys? Setting STRIPE_LIVE_PUBLIC_KEY and STRIPE_TEST_PUBLIC_KEY will be deprecated next release. You do not risk anything by leaving them in your settings: They are not used by Dj-Stripe outside of the Dj-Stripe mixins, which are now themselves deprecated. So you can safely leave them in your settings, or you can move them to the database as well (Keys beginning in pk_test_ and pk_live_ will be detected as publishable keys). Deprecated features Nobody likes features being removed. However, the last few releases we have had to remove features that were not core to what dj-stripe does, or simply poorly-maintained. To keep up with the trend, we are making three major deprecations this release: Creating Plans from the Django Admin is no longer supported The Plan model was special cased in various places, including being the only one which supported being created from the Django administration. This is no longer supported. We have plans to allow creating arbitrary Stripe objects from the Django Admin, but until it can be done consistently, we have decided to remove the feature for Plans (which are deprecated by Stripe anyway). The only object type you should be dealing with from the admin is the new APIKey model. Along with this, we are also deprecating the djstripe_sync_plans_from_stripe management command. You can instead use the djstripe_sync_models management command, which supports arbitrary models. Deprecating the REST API We are dropping all support for the REST API and will be fully removing it in 2.5.0. We're doing this because we wish to keep such an API separate from dj-stripe. Work has already started on a new project, and we will be sharing more details about it soon. If you're interested in helping out, please reach out on Github ! Deprecating djstripe.middleware.SubscriptionPaymentMiddleware Large parts of dj-stripe, including this middleware, were designed before Stripe's major revamps of the old Plan model into Prices, Products, and multi-plan subscriptions. The functionality offered by the middleware is no longer adequate, and building on top of it would not be particularly robust. We may bring similar functionality back in the future, but the middleware as it is is going away (as well as the undocumented djstripe.utils.subscriber_has_active_subscription utility function). If you want to keep the functionality for your project, you may wish to copy the latest version of the middleware . Deprecating djstripe.mixins This is being deprecated for similar reasons as the SubscriptionPaymentMiddleware. However, the mixins module was undocumented and never officially supported. Other deprecations The account field on Charge has been renamed to on_behalf_of , to be consistent with Stripe's upstream model. Note that this field is separate from djstripe_owner_account , which is set by dj-stripe itself to match the account of the API key used. Account.get_connected_account_from_token() is deprecated in favour of Account.get_or_retrieve_for_api_key() , which supports more than just Connect accounts. Customer.has_active_subscription() is deprecated in favour of Customer.is_subscribed_to() . Note that the former takes a plan as argument, whereas the latter takes a product as argument. The tax_percent attribute of Invoice is no longer populated and will be removed in 2.5.0. You may want to use Invoice.default_tax_rates instead, which uses the new TaxId functionality. Customer.business_vat_id is being deprecated in favour of using TaxId models directly. Breaking changes Rename PlanBillingScheme to BillingScheme. Remove Plan.update_name() and these previously-deprecated fields: Customer.business_vat_id Subscription.start Subscription.billing Upgrade Guide Before you upgrade to dj-stripe 2.4.0, we recommend upgrading to dj-stripe 2.3.0. Upgrading one major release at a time minimizes the risk of issues arising. Upgrading directly to 2.4.0 from dj-stripe versions older than 2.2.0 is unsupported. To upgrade dj-stripe, run pip install --upgrade dj-stripe==2.4.0 . Once installed, you can run manage.py migrate djstripe to migrate the database models. Attention If you are doing multiple major dj-stripe upgrades in a row, remember to run the migrate command after every upgrade. Skipping this step WILL cause errors. Note Migrating the database models may take a long time on databases with large amounts of customers. Settings changes A new mandatory setting DJSTRIPE_FOREIGN_KEY_TO_FIELD has been added. If you are upgrading from an older version, you need to set it to \"djstripe_id\" . Setting it to \"id\" will make dj-stripe use the Stripe IDs as foreign keys. Although this is recommended for new installations, there is currently no migration available for going from \"djstripe_id\" to \"id\" . For more information on this setting, see Settings .","title":"dj-stripe 2.4 release notes"},{"location":"history/2_4_0/#dj-stripe-240-release-notes-2020-11-19","text":"Attention To upgrade to 2.4.0 from older versions of dj-stripe, scroll down to the Upgrade Guide .","title":"dj-stripe 2.4.0 release notes (2020-11-19)"},{"location":"history/2_4_0/#introducing-sponsorships-and-our-first-sponsor","text":"We're excited to introduce our Sponsorship tiers . Individuals may back dj-stripe to assist with development. Larger backers may choose one the paid support plans available to receive support on top of ensuring the long-term viability of the project! And this release was made possible by none other than\u2026 Stripe ! Our very first Gold sponsor. Their financial backing has allowed us to pour a lot of work that could not have otherwise happened.","title":"Introducing sponsorships and our first sponsor"},{"location":"history/2_4_0/#release-notes","text":"Support for Django 3.1 and Python 3.8. Minimum stripe-python version is now 2.48.0. Default Stripe API version is now 2020-08-27 . First-class support for the Price model, replacing Plans. Support multi-item subscriptions. Support for API keys in the database (see Managing Stripe API keys ). Support for syncing objects for multiple, different Stripe accounts. Use Django 3.1 native JSONField when available. The field djstripe_owner_account has been added to all Stripe models, and is automatically populated with the Account that owns the API key used to retrieve it. Support for subscription schedules (#899). Add support for Reporting categories and TaxIds Update many models to match latest version of the Stripe API. Fixed Account.get_default_account() for Restricted API Keys. Allow passing arbitrary arguments (any valid SDK argument) to the following methods: Customer.charge() Customer.subscribe() , Charge.capture() Subscription.update() New management command: djstripe_update_invoiceitem_ids . This command migrates InvoiceItems using Stripe's old IDs to the new ones. Hundreds of other bugfixes.","title":"Release notes"},{"location":"history/2_4_0/#new-feature-in-database-stripe-api-keys","text":"Stripe API keys are now stored in the database, and are now editable in the admin. Warning By default, all keys are visible by anyone who has access to the dj-stripe administration.","title":"New feature: in-database Stripe API keys"},{"location":"history/2_4_0/#why","text":"As we work on supporting multiple Stripe accounts per instance, it is vital for dj-stripe to have a mechanism to store more than one Stripe API key. It also became obvious that we may want proper programmatic access to create and delete keys. Furthermore, API keys are a legitimate upstream Stripe object, and it is not unlikely the API may allow access to listing other API keys in the future, in which case we will want to move them to the database anyway. In the next release, we are planning to make WebhookEndpoints (and thus webhook secrets) manageable via the database as well.","title":"Why?"},{"location":"history/2_4_0/#do-i-need-to-change-anything","text":"Not at this time. The settings STRIPE_LIVE_SECRET_KEY and STRIPE_TEST_SECRET_KEY can still be used. Their values will however be automatically saved to the database at the earliest opportunity.","title":"Do I need to change anything?"},{"location":"history/2_4_0/#what-about-public-keys","text":"Setting STRIPE_LIVE_PUBLIC_KEY and STRIPE_TEST_PUBLIC_KEY will be deprecated next release. You do not risk anything by leaving them in your settings: They are not used by Dj-Stripe outside of the Dj-Stripe mixins, which are now themselves deprecated. So you can safely leave them in your settings, or you can move them to the database as well (Keys beginning in pk_test_ and pk_live_ will be detected as publishable keys).","title":"What about public keys?"},{"location":"history/2_4_0/#deprecated-features","text":"Nobody likes features being removed. However, the last few releases we have had to remove features that were not core to what dj-stripe does, or simply poorly-maintained. To keep up with the trend, we are making three major deprecations this release:","title":"Deprecated features"},{"location":"history/2_4_0/#creating-plans-from-the-django-admin-is-no-longer-supported","text":"The Plan model was special cased in various places, including being the only one which supported being created from the Django administration. This is no longer supported. We have plans to allow creating arbitrary Stripe objects from the Django Admin, but until it can be done consistently, we have decided to remove the feature for Plans (which are deprecated by Stripe anyway). The only object type you should be dealing with from the admin is the new APIKey model. Along with this, we are also deprecating the djstripe_sync_plans_from_stripe management command. You can instead use the djstripe_sync_models management command, which supports arbitrary models.","title":"Creating Plans from the Django Admin is no longer supported"},{"location":"history/2_4_0/#deprecating-the-rest-api","text":"We are dropping all support for the REST API and will be fully removing it in 2.5.0. We're doing this because we wish to keep such an API separate from dj-stripe. Work has already started on a new project, and we will be sharing more details about it soon. If you're interested in helping out, please reach out on Github !","title":"Deprecating the REST API"},{"location":"history/2_4_0/#deprecating-djstripemiddlewaresubscriptionpaymentmiddleware","text":"Large parts of dj-stripe, including this middleware, were designed before Stripe's major revamps of the old Plan model into Prices, Products, and multi-plan subscriptions. The functionality offered by the middleware is no longer adequate, and building on top of it would not be particularly robust. We may bring similar functionality back in the future, but the middleware as it is is going away (as well as the undocumented djstripe.utils.subscriber_has_active_subscription utility function). If you want to keep the functionality for your project, you may wish to copy the latest version of the middleware .","title":"Deprecating djstripe.middleware.SubscriptionPaymentMiddleware"},{"location":"history/2_4_0/#deprecating-djstripemixins","text":"This is being deprecated for similar reasons as the SubscriptionPaymentMiddleware. However, the mixins module was undocumented and never officially supported.","title":"Deprecating djstripe.mixins"},{"location":"history/2_4_0/#other-deprecations","text":"The account field on Charge has been renamed to on_behalf_of , to be consistent with Stripe's upstream model. Note that this field is separate from djstripe_owner_account , which is set by dj-stripe itself to match the account of the API key used. Account.get_connected_account_from_token() is deprecated in favour of Account.get_or_retrieve_for_api_key() , which supports more than just Connect accounts. Customer.has_active_subscription() is deprecated in favour of Customer.is_subscribed_to() . Note that the former takes a plan as argument, whereas the latter takes a product as argument. The tax_percent attribute of Invoice is no longer populated and will be removed in 2.5.0. You may want to use Invoice.default_tax_rates instead, which uses the new TaxId functionality. Customer.business_vat_id is being deprecated in favour of using TaxId models directly.","title":"Other deprecations"},{"location":"history/2_4_0/#breaking-changes","text":"Rename PlanBillingScheme to BillingScheme. Remove Plan.update_name() and these previously-deprecated fields: Customer.business_vat_id Subscription.start Subscription.billing","title":"Breaking changes"},{"location":"history/2_4_0/#upgrade-guide","text":"Before you upgrade to dj-stripe 2.4.0, we recommend upgrading to dj-stripe 2.3.0. Upgrading one major release at a time minimizes the risk of issues arising. Upgrading directly to 2.4.0 from dj-stripe versions older than 2.2.0 is unsupported. To upgrade dj-stripe, run pip install --upgrade dj-stripe==2.4.0 . Once installed, you can run manage.py migrate djstripe to migrate the database models. Attention If you are doing multiple major dj-stripe upgrades in a row, remember to run the migrate command after every upgrade. Skipping this step WILL cause errors. Note Migrating the database models may take a long time on databases with large amounts of customers.","title":"Upgrade Guide"},{"location":"history/2_4_0/#settings-changes","text":"A new mandatory setting DJSTRIPE_FOREIGN_KEY_TO_FIELD has been added. If you are upgrading from an older version, you need to set it to \"djstripe_id\" . Setting it to \"id\" will make dj-stripe use the Stripe IDs as foreign keys. Although this is recommended for new installations, there is currently no migration available for going from \"djstripe_id\" to \"id\" . For more information on this setting, see Settings .","title":"Settings changes"},{"location":"history/2_4_x/","text":"dj-stripe 2.4.4 release notes (2021-05-22) Fix syncing of tax IDs in management commands Set default_auto_field in migrations to prevent creation of extra migrations Misc test and documentation fixes dj-stripe 2.4.3 release notes (2021-02-08) Fix webhook error when processing events that contain a reference to a deleted payment method (such as a refund on a payment whose card has been detached or removed) Fix a couple of regressions in djstripe_sync_models management command. dj-stripe 2.4.2 release notes (2021-01-24) Release notes Fix error in Customer.add_card() due to Stripe's sources deprecation. (#1293) Fix Subscription.update() usage of the deprecated Stripe prorate argument. dj-stripe now explicitly uses proration_behavior , setting it to \"none\" when prorate is False , and \"create_prorations\" when prorate is True . dj-stripe 2.4.1 release notes (2020-11-29) Release notes Upgrade default Stripe API version to 2020-08-27 . Although we documented doing so in 2.4.0, it was not correctly set as such. This has been fixed for consistency. The Price model was incorrectly released with an amount_in_cents property, matching that of the Plan model. However, Price amounts are already in cent. The property has been removed, use unit_amount instead. Fix Price.human_readable_price calculation Fix non-blank nullable Charge fields Fix Price.tiers not being synced correctly with djstripe_sync_models (#1284) Fix sync model recursion loop (see #1288)","title":"dj-stripe 2.4.1 release notes"},{"location":"history/2_4_x/#dj-stripe-244-release-notes-2021-05-22","text":"Fix syncing of tax IDs in management commands Set default_auto_field in migrations to prevent creation of extra migrations Misc test and documentation fixes","title":"dj-stripe 2.4.4 release notes (2021-05-22)"},{"location":"history/2_4_x/#dj-stripe-243-release-notes-2021-02-08","text":"Fix webhook error when processing events that contain a reference to a deleted payment method (such as a refund on a payment whose card has been detached or removed) Fix a couple of regressions in djstripe_sync_models management command.","title":"dj-stripe 2.4.3 release notes (2021-02-08)"},{"location":"history/2_4_x/#dj-stripe-242-release-notes-2021-01-24","text":"","title":"dj-stripe 2.4.2 release notes (2021-01-24)"},{"location":"history/2_4_x/#release-notes","text":"Fix error in Customer.add_card() due to Stripe's sources deprecation. (#1293) Fix Subscription.update() usage of the deprecated Stripe prorate argument. dj-stripe now explicitly uses proration_behavior , setting it to \"none\" when prorate is False , and \"create_prorations\" when prorate is True .","title":"Release notes"},{"location":"history/2_4_x/#dj-stripe-241-release-notes-2020-11-29","text":"","title":"dj-stripe 2.4.1 release notes (2020-11-29)"},{"location":"history/2_4_x/#release-notes_1","text":"Upgrade default Stripe API version to 2020-08-27 . Although we documented doing so in 2.4.0, it was not correctly set as such. This has been fixed for consistency. The Price model was incorrectly released with an amount_in_cents property, matching that of the Plan model. However, Price amounts are already in cent. The property has been removed, use unit_amount instead. Fix Price.human_readable_price calculation Fix non-blank nullable Charge fields Fix Price.tiers not being synced correctly with djstripe_sync_models (#1284) Fix sync model recursion loop (see #1288)","title":"Release notes"},{"location":"history/2_5_0/","text":"dj-stripe 2.5.0 (2021-06-06) Attention It is not possible to upgrade to dj-stripe 2.5.0 from versions older than 2.2.2. To upgrade from an older version, first upgrade to dj-stripe 2.2.2 . Release notes Minimum Python version is now 3.6.2. Support for Python 3.9 and Django 3.2. In keeping with upstream's cycle, Django 3.0 is no longer officially supported. (Note that it will still work, because Django 2.2 LTS is still supported.) SQLite versions older than 3.26 are no longer supported. New models: FileLink, Mandate Cards and Bank Accounts are now visible in the admin interface. Lots of model sync fixes since 2.4.0. Deprecated features The FileUpload model has been renamed File , for consistency with Stripe's SDK. Although the old name is still supported, it will eventually be removed. Deprecate charge_immediately argument to Customer.subscribe() . It did not behave as expected on recent versions of Stripe. If you were using it set to charge_immediately=False , you can instead pass collection_method=\"send_invoice\" , which will send the Customer the invoice to manually pay, instead. Breaking changes When calling Customer.delete() in prior versions of dj-stripe, the Customer object would be deleted in the upstream API and the Customer object would be retained but with a date_purged attribute. This was the only model behaving this way, and it is no longer the case. If you wish to purge a customer like before, you may call Customer.purge() instead, though that method may be removed in future versions as well. Remove deprecated DRF integration ( djstripe.contrib.rest_framework ) Remove deprecated djstripe.decorators module Remove deprecated djstripe.middleware module Remove deprecated fields Account.business_vat_id and Subscription.tax_percent Remove deprecated method Account.get_connected_account_from_token() . Use Account.get_or_retrieve_for_api_key() instead. Remove deprecated Charge.account property. Use Charge.on_behalf_of instead. Remove deprecated Customer.has_active_subscription() method. Use Customer.is_subscribed_to(product) instead. FileUploadPurpose enum has been renamed FilePurpose . FileUploadType enum has been renamed FileType .","title":"dj-stripe 2.5 release notes"},{"location":"history/2_5_0/#dj-stripe-250-2021-06-06","text":"Attention It is not possible to upgrade to dj-stripe 2.5.0 from versions older than 2.2.2. To upgrade from an older version, first upgrade to dj-stripe 2.2.2 .","title":"dj-stripe 2.5.0 (2021-06-06)"},{"location":"history/2_5_0/#release-notes","text":"Minimum Python version is now 3.6.2. Support for Python 3.9 and Django 3.2. In keeping with upstream's cycle, Django 3.0 is no longer officially supported. (Note that it will still work, because Django 2.2 LTS is still supported.) SQLite versions older than 3.26 are no longer supported. New models: FileLink, Mandate Cards and Bank Accounts are now visible in the admin interface. Lots of model sync fixes since 2.4.0.","title":"Release notes"},{"location":"history/2_5_0/#deprecated-features","text":"The FileUpload model has been renamed File , for consistency with Stripe's SDK. Although the old name is still supported, it will eventually be removed. Deprecate charge_immediately argument to Customer.subscribe() . It did not behave as expected on recent versions of Stripe. If you were using it set to charge_immediately=False , you can instead pass collection_method=\"send_invoice\" , which will send the Customer the invoice to manually pay, instead.","title":"Deprecated features"},{"location":"history/2_5_0/#breaking-changes","text":"When calling Customer.delete() in prior versions of dj-stripe, the Customer object would be deleted in the upstream API and the Customer object would be retained but with a date_purged attribute. This was the only model behaving this way, and it is no longer the case. If you wish to purge a customer like before, you may call Customer.purge() instead, though that method may be removed in future versions as well. Remove deprecated DRF integration ( djstripe.contrib.rest_framework ) Remove deprecated djstripe.decorators module Remove deprecated djstripe.middleware module Remove deprecated fields Account.business_vat_id and Subscription.tax_percent Remove deprecated method Account.get_connected_account_from_token() . Use Account.get_or_retrieve_for_api_key() instead. Remove deprecated Charge.account property. Use Charge.on_behalf_of instead. Remove deprecated Customer.has_active_subscription() method. Use Customer.is_subscribed_to(product) instead. FileUploadPurpose enum has been renamed FilePurpose . FileUploadType enum has been renamed FileType .","title":"Breaking changes"},{"location":"history/2_5_x/","text":"dj-stripe 2.5.1 (2021-07-02) Release notes Fixed migration issue for new setups using custom DJSTRIPE_CUSTOMER_MODEL . Display correct JSON for JSONFields in the Django admin. Fix manual syncing of SubscriptionItem .","title":"dj-stripe 2.5.1 (2021-07-02)"},{"location":"history/2_5_x/#dj-stripe-251-2021-07-02","text":"","title":"dj-stripe 2.5.1 (2021-07-02)"},{"location":"history/2_5_x/#release-notes","text":"Fixed migration issue for new setups using custom DJSTRIPE_CUSTOMER_MODEL . Display correct JSON for JSONFields in the Django admin. Fix manual syncing of SubscriptionItem .","title":"Release notes"},{"location":"history/2_6_0/","text":"dj-stripe 2.6.0 (2022-01-15) Attention It is not possible to upgrade to dj-stripe 2.6.0 from versions older than 2.3.0. To upgrade from an older version, first upgrade to dj-stripe 2.3.0 . Release highlights Support for Python 3.10 and Django 4.0. New models: Mandate, Payout, UsageRecordSummary, WebhookEndpoint (unused) Significant improvements and fixes to Stripe Connect features. Storing Stripe API keys by adding them to the Admin is now supported. This allows for use of multiple Stripe API keys (multiple Stripe accounts). Support for syncing Connect accounts via djstripe_sync_models . Deprecated features The use of the old jsonfield -based JSONField is deprecated and support for it will be dropped in dj-stripe 2.8.0. django.models.JSONField is available since Django 3.1.0. To switch to the newer JSONFields, set DJSTRIPE_USE_NATIVE_JSONFIELD to True . Set it to False to remain on the jsonfield -powered text-based fields. A manual migration is necessary to convert existing databases from text to json. The DJSTRIPE_PRORATION_POLICY setting is deprecated and will be ignored in 2.8. Specify proration_policy in the Subscription.update() method explicitly instead. Customer.can_charge() is now deprecated. This was a very misleading method which resulted in incorrect behaviour when Customers had multiple payment methods. It will be removed in dj-stripe 2.8.0. You can use Customer.payment_methods.all() instead. For similar reasons, Customer.has_valid_source() is deprecated and will be removed in dj-stripe 2.8.0. You can use Customer.sources.all() instead. Breaking changes Python 3.6 is no longer supported. The new minimum version of Python is 3.7.12. Django 2.2 and 3.1 are no longer supported. DJSTRIPE_USE_NATIVE_JSONFIELD now defaults to True . If you previously had it set to False , or did not have it set, you may want to explicitly set it to False in order to support a pre-existing database. A migration path will later be provided for this use case. The undocumented get_stripe_api_version() helper function has been removed. Settings for dj-stripe are now in djstripe.settings.djstripe_settings (as opposed to top-level in djstripe.settings ) Customer.subscribe() method no longer accepts positional arguments, only keywords. charge_immediately support in Customer.subscribe() has been removed (deprecated in 2.4). Set collection_method instead. The at_period_end argument to Subscription.cancel() now defaults to False , instead of the value of DJSTRIPE_PRORATION_POLICY . Other changes The Stripe Account that triggered an Event is now available on the field WebhookEventTrigger.stripe_trigger_account . Fixed recursive fetch/update loop errors in djstripe_sync_models . Migrations have been optimized and should be faster. dj-stripe now checks the apparent validity of API keys used and will raise InvalidStripeAPIKey if the API key looks completely incorrect. Customers can now be subscribed to multiple prices and/or plans by passing the items argument to Customer.subscribe() . Checkout Session metadata can be used to create/link a Stripe Customer to the Customer instance specified by the djstripe_settings.SUBSCRIBER_CUSTOMER_KEY .","title":"dj-stripe 2.6 release notes"},{"location":"history/2_6_0/#dj-stripe-260-2022-01-15","text":"Attention It is not possible to upgrade to dj-stripe 2.6.0 from versions older than 2.3.0. To upgrade from an older version, first upgrade to dj-stripe 2.3.0 .","title":"dj-stripe 2.6.0 (2022-01-15)"},{"location":"history/2_6_0/#release-highlights","text":"Support for Python 3.10 and Django 4.0. New models: Mandate, Payout, UsageRecordSummary, WebhookEndpoint (unused) Significant improvements and fixes to Stripe Connect features. Storing Stripe API keys by adding them to the Admin is now supported. This allows for use of multiple Stripe API keys (multiple Stripe accounts). Support for syncing Connect accounts via djstripe_sync_models .","title":"Release highlights"},{"location":"history/2_6_0/#deprecated-features","text":"The use of the old jsonfield -based JSONField is deprecated and support for it will be dropped in dj-stripe 2.8.0. django.models.JSONField is available since Django 3.1.0. To switch to the newer JSONFields, set DJSTRIPE_USE_NATIVE_JSONFIELD to True . Set it to False to remain on the jsonfield -powered text-based fields. A manual migration is necessary to convert existing databases from text to json. The DJSTRIPE_PRORATION_POLICY setting is deprecated and will be ignored in 2.8. Specify proration_policy in the Subscription.update() method explicitly instead. Customer.can_charge() is now deprecated. This was a very misleading method which resulted in incorrect behaviour when Customers had multiple payment methods. It will be removed in dj-stripe 2.8.0. You can use Customer.payment_methods.all() instead. For similar reasons, Customer.has_valid_source() is deprecated and will be removed in dj-stripe 2.8.0. You can use Customer.sources.all() instead.","title":"Deprecated features"},{"location":"history/2_6_0/#breaking-changes","text":"Python 3.6 is no longer supported. The new minimum version of Python is 3.7.12. Django 2.2 and 3.1 are no longer supported. DJSTRIPE_USE_NATIVE_JSONFIELD now defaults to True . If you previously had it set to False , or did not have it set, you may want to explicitly set it to False in order to support a pre-existing database. A migration path will later be provided for this use case. The undocumented get_stripe_api_version() helper function has been removed. Settings for dj-stripe are now in djstripe.settings.djstripe_settings (as opposed to top-level in djstripe.settings ) Customer.subscribe() method no longer accepts positional arguments, only keywords. charge_immediately support in Customer.subscribe() has been removed (deprecated in 2.4). Set collection_method instead. The at_period_end argument to Subscription.cancel() now defaults to False , instead of the value of DJSTRIPE_PRORATION_POLICY .","title":"Breaking changes"},{"location":"history/2_6_0/#other-changes","text":"The Stripe Account that triggered an Event is now available on the field WebhookEventTrigger.stripe_trigger_account . Fixed recursive fetch/update loop errors in djstripe_sync_models . Migrations have been optimized and should be faster. dj-stripe now checks the apparent validity of API keys used and will raise InvalidStripeAPIKey if the API key looks completely incorrect. Customers can now be subscribed to multiple prices and/or plans by passing the items argument to Customer.subscribe() . Checkout Session metadata can be used to create/link a Stripe Customer to the Customer instance specified by the djstripe_settings.SUBSCRIBER_CUSTOMER_KEY .","title":"Other changes"},{"location":"history/2_6_x/","text":"dj-stripe 2.6.2 (2022-07-02) This is a maintenance release to remove the generation of an unnecessary migration when running dj-stripe on Django 4.0. This release does not guarantee Django 4.0 compatibility. Run at your own risk. Release notes Update migrations to be compatible with Django 4.0 dj-stripe 2.6.1 (2022-02-07) Release notes Fix issue saving a new WebhookEndpoint from the admin Fix potential IntegrityError when syncing models","title":"dj-stripe 2.6.2 (2022-07-02)"},{"location":"history/2_6_x/#dj-stripe-262-2022-07-02","text":"This is a maintenance release to remove the generation of an unnecessary migration when running dj-stripe on Django 4.0. This release does not guarantee Django 4.0 compatibility. Run at your own risk.","title":"dj-stripe 2.6.2 (2022-07-02)"},{"location":"history/2_6_x/#release-notes","text":"Update migrations to be compatible with Django 4.0","title":"Release notes"},{"location":"history/2_6_x/#dj-stripe-261-2022-02-07","text":"","title":"dj-stripe 2.6.1 (2022-02-07)"},{"location":"history/2_6_x/#release-notes_1","text":"Fix issue saving a new WebhookEndpoint from the admin Fix potential IntegrityError when syncing models","title":"Release notes"},{"location":"history/2_7_0/","text":"dj-stripe 2.7.0 (2022-10-17) Attention It is not possible to upgrade to dj-stripe 2.7.0 from versions older than 2.4.0. To upgrade from an older version, first upgrade to dj-stripe 2.4.0. This release focuses on Webhook Endpoints. For more information on the reasoning behind the changes, please see the discussion on Github: https://github.com/dj-stripe/dj-stripe/discussions/1437 Release highlights Webhook Endpoints are now configured via the Django administration. Multiple Webhook Endpoints are now supported. Webhook Endpoints now have a unique, non-guessable URL. Deprecated features The DJSTRIPE_WEBHOOK_URL setting is deprecated. It will be removed in dj-stripe 2.9. It was added to give a way of \"hiding\" the webhook endpoint URL, but that is no longer necessary with the new webhook endpoint system. Breaking changes Remove the deprecated middleware djstripe.middleware.SubscriptionPaymentMiddleware Remove support for the deprecated DJSTRIPE_SUBSCRIPTION_REDIRECT setting Remove support for the DJSTRIPE_SUBSCRIPTION_REQUIRED_EXCEPTION_URLS setting Other changes Many Stripe Connect related fixes (Special thanks to Dominik Bartenstein of Zemtu) Allow passing stripe kwargs in Subscription.cancel() Various admin improvements Add support for managing subscription schedules from the admin","title":"dj-stripe 2.7 release notes"},{"location":"history/2_7_0/#dj-stripe-270-2022-10-17","text":"Attention It is not possible to upgrade to dj-stripe 2.7.0 from versions older than 2.4.0. To upgrade from an older version, first upgrade to dj-stripe 2.4.0. This release focuses on Webhook Endpoints. For more information on the reasoning behind the changes, please see the discussion on Github: https://github.com/dj-stripe/dj-stripe/discussions/1437","title":"dj-stripe 2.7.0 (2022-10-17)"},{"location":"history/2_7_0/#release-highlights","text":"Webhook Endpoints are now configured via the Django administration. Multiple Webhook Endpoints are now supported. Webhook Endpoints now have a unique, non-guessable URL.","title":"Release highlights"},{"location":"history/2_7_0/#deprecated-features","text":"The DJSTRIPE_WEBHOOK_URL setting is deprecated. It will be removed in dj-stripe 2.9. It was added to give a way of \"hiding\" the webhook endpoint URL, but that is no longer necessary with the new webhook endpoint system.","title":"Deprecated features"},{"location":"history/2_7_0/#breaking-changes","text":"Remove the deprecated middleware djstripe.middleware.SubscriptionPaymentMiddleware Remove support for the deprecated DJSTRIPE_SUBSCRIPTION_REDIRECT setting Remove support for the DJSTRIPE_SUBSCRIPTION_REQUIRED_EXCEPTION_URLS setting","title":"Breaking changes"},{"location":"history/2_7_0/#other-changes","text":"Many Stripe Connect related fixes (Special thanks to Dominik Bartenstein of Zemtu) Allow passing stripe kwargs in Subscription.cancel() Various admin improvements Add support for managing subscription schedules from the admin","title":"Other changes"},{"location":"history/2_7_x/","text":"dj-stripe 2.7.3 (2022-11-26) Due to Stripe dropping support for the Order model, we have had to restrict the Stripe SDK to versions below 5.0.0. This release thus fixes the following error: AttributeError: module 'stripe' has no attribute 'Order' More info: https://github.com/dj-stripe/dj-stripe/issues/1842 If you are on an older version of dj-stripe and cannot upgrade, you may simply install an older version of the Stripe SDK, for example with pip install stripe<5.0.0 . dj-stripe 2.7.2 (2022-10-21) Release notes Fix installing with Poetry on Django 4.0 and higher dj-stripe 2.7.1 (2022-10-20) Release notes Remove an enum value generating an extra migration Allow Django 4.1 as a dependency (Note: Running dj-stripe 2.7.x with Django 4.1 is untested)","title":"dj-stripe 2.7.3 (2022-11-26)"},{"location":"history/2_7_x/#dj-stripe-273-2022-11-26","text":"Due to Stripe dropping support for the Order model, we have had to restrict the Stripe SDK to versions below 5.0.0. This release thus fixes the following error: AttributeError: module 'stripe' has no attribute 'Order' More info: https://github.com/dj-stripe/dj-stripe/issues/1842 If you are on an older version of dj-stripe and cannot upgrade, you may simply install an older version of the Stripe SDK, for example with pip install stripe<5.0.0 .","title":"dj-stripe 2.7.3 (2022-11-26)"},{"location":"history/2_7_x/#dj-stripe-272-2022-10-21","text":"","title":"dj-stripe 2.7.2 (2022-10-21)"},{"location":"history/2_7_x/#release-notes","text":"Fix installing with Poetry on Django 4.0 and higher","title":"Release notes"},{"location":"history/2_7_x/#dj-stripe-271-2022-10-20","text":"","title":"dj-stripe 2.7.1 (2022-10-20)"},{"location":"history/2_7_x/#release-notes_1","text":"Remove an enum value generating an extra migration Allow Django 4.1 as a dependency (Note: Running dj-stripe 2.7.x with Django 4.1 is untested)","title":"Release notes"},{"location":"history/2_8_0/","text":"dj-stripe 2.8.0 (202X-XX-XX) Attention It is not possible to upgrade to dj-stripe 2.8.0 from versions older than 2.5.0. To upgrade from an older version, first upgrade to dj-stripe 2.5.0. Release highlights Python 3.11 is now supported. Django 4.1 is now supported. Python 3.7 is no longer supported. Python 3.8 or higher is required. Added LineItem model. Added Discount model. New webhook signals are available: djstripe.signals.webhook_pre_validate(instance, api_key) : Fired before webhook validation djstripe.signals.webhook_post_validate(instance, api_key, valid) : Fired after validation (even unsuccessful validations) djstripe.signals.webhook_pre_process(instance, api_key) : Fired before webhook processing. Not fired if the validation failed. djstripe.signals.webhook_post_process(instance, api_key) : Fired after webhook successful processing. djstripe.signals.webhook_processing_error now also takes instance and api_key arguments stripe.api_version is no longer manipulated by dj-stripe. Resolved ambiguity between LineItem and InvoiceItem models. It was incorrectly assumed that the lines List object on Invoice and UpcomingInvoice models only return InvoiceItem objects. Moreover LineItem objects can also be of type subscription if the user adds a Subscription to their Invoice as a lineitem. Deprecated features DJSTRIPE_WEBHOOK_EVENT_CALLBACK is deprecated in favour of the new webhook signals. Breaking changes Remove legacy JSONField support. This drops support for installations with the DJSTRIPE_USE_NATIVE_JSONFIELD setting set to False . NOTE: No migration path is available yet. https://github.com/dj-stripe/dj-stripe/issues/1820 Remove djstripe_sync_plans_from_stripe command (deprecated in 2.4.0). Use djstripe_sync_models price instead. Remove Customer.can_charge() , Customer.has_valid_source() () Remove DJSTRIPE_PRORATION_POLICY setting (deprecated in 2.6.0) Remove deprecated prorate argument to Subscription.update() (Use Stripe's proration_behavior argument instead) Remove undocumented set_stripe_api_version() helper function and context manager stripe_temporary_api_version() . The API version is now set on each request individually. Updated Charge.refund(...) helper function to correctly create the desired refund. Note that the created Refund object is now returned as opposed to the Charge object. Other changes Updated check_stripe_api_key django system check to not be a blocker for new dj-stripe users by raising Info warnings on the console. If the Stripe keys were not defined in the settings file, the Critical warning was preventing users to add them directly from the admin as mentioned in the docs. This was creating a chicken-egg situation where one could only add keys in the admin before they were defined in settings. check_stripe_api_key will raise appropriate warnings on the console directing users to add keys directly from the django admin. Swapped Critical Error to Info for _check_webhook_endpoint_validation check to allow the users to use the django admin. LineItem instances can also get synced using the djstripe_sync_models management command. Added missing line_items model field to Checkout Sessions. Added missing setup_intent model field to Checkout Sessions. Added missing shipping_address_collection model field to Checkout Sessions. Added missing shipping_cost model field to Checkout Sessions. Added missing shipping_details model field to Checkout Sessions. Added missing shipping_options model field to Checkout Sessions. Added missing amount_total model field to Checkout Sessions. Added missing amount_subtotal model field to Checkout Sessions. Added missing url model field to Checkout Sessions. Added missing total_details model field to Checkout Sessions. Added missing currency model field to Checkout Sessions. Added missing payment_status model field to Checkout Sessions. Added missing status model field to Checkout Sessions. Added support for running tests using the actual Stripe API. It will take a while to replace all existing tests with the actual API. By default tests will run using mocks, but -m stripe_api can be added to use the actual API.","title":"dj-stripe 2.8.0 (202X-XX-XX)"},{"location":"history/2_8_0/#dj-stripe-280-202x-xx-xx","text":"Attention It is not possible to upgrade to dj-stripe 2.8.0 from versions older than 2.5.0. To upgrade from an older version, first upgrade to dj-stripe 2.5.0.","title":"dj-stripe 2.8.0 (202X-XX-XX)"},{"location":"history/2_8_0/#release-highlights","text":"Python 3.11 is now supported. Django 4.1 is now supported. Python 3.7 is no longer supported. Python 3.8 or higher is required. Added LineItem model. Added Discount model. New webhook signals are available: djstripe.signals.webhook_pre_validate(instance, api_key) : Fired before webhook validation djstripe.signals.webhook_post_validate(instance, api_key, valid) : Fired after validation (even unsuccessful validations) djstripe.signals.webhook_pre_process(instance, api_key) : Fired before webhook processing. Not fired if the validation failed. djstripe.signals.webhook_post_process(instance, api_key) : Fired after webhook successful processing. djstripe.signals.webhook_processing_error now also takes instance and api_key arguments stripe.api_version is no longer manipulated by dj-stripe. Resolved ambiguity between LineItem and InvoiceItem models. It was incorrectly assumed that the lines List object on Invoice and UpcomingInvoice models only return InvoiceItem objects. Moreover LineItem objects can also be of type subscription if the user adds a Subscription to their Invoice as a lineitem.","title":"Release highlights"},{"location":"history/2_8_0/#deprecated-features","text":"DJSTRIPE_WEBHOOK_EVENT_CALLBACK is deprecated in favour of the new webhook signals.","title":"Deprecated features"},{"location":"history/2_8_0/#breaking-changes","text":"Remove legacy JSONField support. This drops support for installations with the DJSTRIPE_USE_NATIVE_JSONFIELD setting set to False . NOTE: No migration path is available yet. https://github.com/dj-stripe/dj-stripe/issues/1820 Remove djstripe_sync_plans_from_stripe command (deprecated in 2.4.0). Use djstripe_sync_models price instead. Remove Customer.can_charge() , Customer.has_valid_source() () Remove DJSTRIPE_PRORATION_POLICY setting (deprecated in 2.6.0) Remove deprecated prorate argument to Subscription.update() (Use Stripe's proration_behavior argument instead) Remove undocumented set_stripe_api_version() helper function and context manager stripe_temporary_api_version() . The API version is now set on each request individually. Updated Charge.refund(...) helper function to correctly create the desired refund. Note that the created Refund object is now returned as opposed to the Charge object.","title":"Breaking changes"},{"location":"history/2_8_0/#other-changes","text":"Updated check_stripe_api_key django system check to not be a blocker for new dj-stripe users by raising Info warnings on the console. If the Stripe keys were not defined in the settings file, the Critical warning was preventing users to add them directly from the admin as mentioned in the docs. This was creating a chicken-egg situation where one could only add keys in the admin before they were defined in settings. check_stripe_api_key will raise appropriate warnings on the console directing users to add keys directly from the django admin. Swapped Critical Error to Info for _check_webhook_endpoint_validation check to allow the users to use the django admin. LineItem instances can also get synced using the djstripe_sync_models management command. Added missing line_items model field to Checkout Sessions. Added missing setup_intent model field to Checkout Sessions. Added missing shipping_address_collection model field to Checkout Sessions. Added missing shipping_cost model field to Checkout Sessions. Added missing shipping_details model field to Checkout Sessions. Added missing shipping_options model field to Checkout Sessions. Added missing amount_total model field to Checkout Sessions. Added missing amount_subtotal model field to Checkout Sessions. Added missing url model field to Checkout Sessions. Added missing total_details model field to Checkout Sessions. Added missing currency model field to Checkout Sessions. Added missing payment_status model field to Checkout Sessions. Added missing status model field to Checkout Sessions. Added support for running tests using the actual Stripe API. It will take a while to replace all existing tests with the actual API. By default tests will run using mocks, but -m stripe_api can be added to use the actual API.","title":"Other changes"},{"location":"history/2_x/","text":"dj-stripe 2.0 ~ 2.3 release notes 2.3.0 (2020-04-19) The minimum version of Django is now 2.1, and Python 3.6. Changed JSONField dependency back to jsonfield from jsonfield2 (see Warning about safe uninstall of jsonfield2 on upgrade ). Fixed handling of TaxRate events (#1094). Fixed pagination issue in Invoice.sync_from_stripe_data (#1052). Fixed pagination issues in Subscription & Charge .sync_from_stripe_data (#1054). Tidyup _stripe_object_set_total_tax_amounts unique handling (#1139). Dropped previously-deprecated Invoice fields (see https://stripe.com/docs/upgrades#2018-11-08 ): .closed .forgiven .billing (renamed to .collection_method ) Dropped previously-deprecated enums.InvoiceStatus (#1020). Deprecated the following fields - will be removed in 2.4 (#1087): Subscription.billing (use .collection_method instead) Subscription.start (use .start_date instead) Subscription.tax_percent (use .default_tax_rates instead) Added Invoice.status and enums.InvoiceStatus (#1020). Added new Invoice fields (#1020, #1087): .discount .default_source .status Added new Subscription fields (#1087): .default_payment_method .default_source .next_pending_invoice_item_invoice .pending_invoice_item_interval .pending_update .start_date Warning about safe uninstall of jsonfield2 on upgrade Both jsonfield and jsonfield2 use the same import path, so if upgrading from dj-stripe\\~=2.2.0 in an existing virtualenv, be sure to uninstall jsonfield2 first. eg: # ensure jsonfield is uninstalled before we install jsonfield2 pip uninstall jsonfield2 -y && pip install \"dj-stripe>=2.3.0dev\" Otherwise, pip uninstall jsonfield2 will remove jsonfield's jsonfield module from site-packages , which would cause errors like ImportError: cannot import name 'JSONField' from 'jsonfield' (unknown location) If you have hit this ImportError already after upgrading, running this should resolve it: # remove both jsonfield packages before reinstall to fix ImportError: pip uninstall jsonfield jsonfield2 -y && pip install \"dj-stripe>=2.3.0\" Note that this is only necessary if upgrading from dj-stripe 2.2.x, which temporarily depended on jsonfield2. This process is not necessary if upgrading from an earlier version of dj-stripe. 2.2.2 (2020-01-20) This is a bugfix-only version: Fixed handling of TaxRate events (#1094). 2.2.1 (2020-01-14) This is a bugfix-only version: Fixed bad package build. 2.2.0 (2020-01-13) Changed JSONField dependency package from jsonfield to jsonfield2 , for Django 3 compatibility (see Warning about safe uninstall of jsonfield on upgrade ). Note that Django 2.1 requires jsonfield<3.1. Added support for Django 3.0 (requires jsonfield2>=3.0.3). Added support for python 3.8. Refactored UpcomingInvoice , so it's no longer a subclass of Invoice (to allow Invoice to use ManyToManyFields ). Dropped previously-deprecated Account fields (see https://stripe.com/docs/upgrades#2019-02-19 ): .business_name .business_primary_color .business_url (changed to a property) .debit_negative_balances .decline_charge_on .display_name .legal_entity .payout_schedule .payout_statement_descriptor .statement_descriptor .support_email .support_phone .support_url .timezone .verification Dropped previously-deprecated Account.business_logo property (renamed to .branding_icon ) Dropped previously-deprecated Customer.account_balance property (renamed to .balance ) Dropped previously-deprecated properties Invoice.application_fee , Invoice.date Dropped previously-deprecated enum PaymentMethodType (use DjstripePaymentMethodType instead) Renamed Invoice.billing to .collection_method (added deprecated property for the old name). Updated Invoice model to add missing fields. Added TaxRate model, and Invoice.default_tax_rates , InvoiceItem.tax_rates , Invoice.total_tax_amounts , Subscription.default_tax_rates , SubscriptionItem.tax_rates (#1027). Change urls.py to use the new style urls. Update forward relation fields in the admin to be raw id fields. Updated StripeQuantumCurrencyAmountField and StripeDecimalCurrencyAmountField to support Stripe Large Charges (#1045). Update event handling so customer.subscription.deleted updates subscriptions to status=\"canceled\" instead of deleting it from our database, to match Stripe's behaviour (#599). Added missing Refund.reason value, increases field width (#1075). Fixed Refund.status definition, reduces field width (#1076). Deprecated non-standard Invoice.status (renamed to Invoice.legacy_status ) to make way for the Stripe field (preparation for #1020). Warning about safe uninstall of jsonfield on upgrade Both jsonfield and jsonfield2 use the same import path, so if upgrading to dj-stripe>=2.2 in an existing virtualenv, be sure to uninstall jsonfield first. eg: # ensure jsonfield is uninstalled before we install jsonfield2 pip uninstall jsonfield -y && pip install \"dj-stripe>=2.2.0\" Otherwise, pip uninstall jsonfield will remove jsonfield2's jsonfield module from site-packages , which would cause errors like ImportError: cannot import name 'JSONField' from 'jsonfield' (unknown location) If you have hit this ImportError already after upgrading, running this should resolve it: # remove both jsonfield packages before reinstall to fix ImportError: pip uninstall jsonfield jsonfield2 -y && pip install \"dj-stripe>=2.2.0\" Note on usage of Stripe Elements JS See Integrating Stripe Elements for notes about usage of the Stripe Elements frontend JS library. In summary: If you haven't yet migrated to PaymentIntents, prefer stripe.createSource() to stripe.createToken() . 2.1.1 (2019-10-01) This is a bugfix-only release: Updated webhook signals list (#1000). Fixed issue syncing PaymentIntent with destination charge (#960). Fixed Customer.subscription and .valid_subscriptions() to ignore status=incomplete_expired (#1006). Fixed error on paymentmethod.detached event with card_xxx payment methods (#967). Added PaymentMethod.detach() (#943). Updated help_text on all currency fields to make it clear if they're holding integer cents ( StripeQuantumCurrencyAmountField ) or decimal dollar (or euro, pound etc) ( StripeDecimalCurrencyAmountField ) (#999) Documented our preferred Django model field types (#986) Upcoming migration of currency fields (storage as cents instead of dollars) Please be aware that we're looking at standardising our currency storage fields as integer quanta (cents) instead of Decimal (dollar) values, to match stripe. This is intended to be part of the 3.0 release, since it will involve some breaking changes. See #955 for details and discussion. 2.1.0 (2019-09-12) Dropped Django 2.0 support The Python stripe library minimum version is now 2.32.0 , also 2.36.0 is excluded due to a regression (#991). Dropped previously-deprecated Charge.fee_details property. Dropped previously-deprecated Transfer.fee_details property. Dropped previously-deprecated field_name parameter to sync_from_stripe_data Dropped previously-deprecated alias StripeObject of StripeModel Dropped previously-deprecated alias PaymentMethod of DjstripePaymentMethod Dropped previously-deprecated properties Charge.source_type and Charge.source_stripe_id enums.PaymentMethodType has been deprecated, use enums.DjstripePaymentMethodType Made SubscriptionItem.quantity nullable as per Plans with usage_type=\"metered\" (follow-up to #865) Added manage commands djstripe_sync_models and djstripe_process_events (#727, #89) Fixed issue with re-creating a customer after Customer.purge() (#916) Fixed sync of Customer Bank Accounts (#829) Fixed Subscription.is_status_temporarily_current() (#852) New models Payment Intent Setup Intent Payment Method Session Added fields to Customer model: address , invoice_prefix , invoice_settings , phone , preferred_locales , tax_exempt Changes from API 2018-11-08: Added Invoice.auto_advance , deprecated Invoice.closed and Invoice.forgiven , see https://stripe.com/docs/billing/migration/invoice-states#upgrade-checklist Changes from API 2019-02-19: Major changes to Account fields, see https://stripe.com/docs/upgrades#2019-02-19 , updated Account fields to match API 2019-02-19: Added Account.business_profile , .business_type , .company , .individual , .requirements , .settings Deprecated the existing fields, to be removed in 2.2 Special handling of the icon and logo fields: > - Renamed Account.business_logo to Account.branding_icon > (note that in Stripe's API Account.business_logo was renamed > to Account.settings.branding_icon , and > Account.business_logo_large (which we didn't have a field > for) was renamed to Account.settings.branding_logo ) > - Added deprecated property for Account.business_logo > - Added Account.branding_logo as a ForeignKey > - Populate Account.branding_icon and .branding_logo from the > new Account.settings.branding.icon and .logo Changes from API 2019-03-14: Renamed Invoice.application_fee to Invoice.application_fee_amount (added deprecated property for the old name) Removed Invoice.date , in place of Invoice.created (added deprecated property for the old name) Added Invoice.status_transitions Renamed Customer.account_balance to Customer.balance (added deprecated property for the old name) Renamed Customer.payment_methods to Customer.customer_payment_methods Added new SubscriptionStatus.incomplete and SubscriptionStatus.incomplete_expired statuses (#974) Added new BalanceTransactionType values (#983) Squashed dev migrations As per our migration policy , unreleased migrations on the master branch have been squashed. If you have been using the 2.1.0dev branch from master, you'll need to run the squashed migrations migrations before upgrading to >=2.1.0. The simplest way to do this is to pip install dj-stripe==2.1.0rc0 and migrate, alternatively check out the 2.1.0rc0 git tag. 2.0.5 (2019-09-12) This is a bugfix-only version: Avoid stripe==2.36.0 due to regression (#991) 2.0.4 (2019-09-09) This is a bugfix-only version: Fixed irreversible migration (#909) 2.0.3 (2019-06-11) This is a bugfix-only version: In _get_or_create_from_stripe_object , wrap create _create_from_stripe_object in transaction, fixes TransactionManagementError on race condition in webhook processing (#877, #903). 2.0.2 (2019-06-09) This is a bugfix-only version: Don't save event objects if the webhook processing fails (#832). Fixed IntegrityError when REMOTE_ADDR is an empty string. Deprecated field_name parameter to sync_from_stripe_data 2.0.1 (2019-04-29) This is a bugfix-only version: Fixed an error on invoiceitem.updated (#848). Handle test webhook properly in recent versions of Stripe API (#779). At some point 2018 Stripe silently changed the ID used for test events and evt_00000000000000 is not used anymore. Fixed OperationalError seen in migration 0003 on postgres (#850). Fixed issue with migration 0003 not being unapplied correctly (#882). Fixed missing SubscriptionItem.quantity on metered Plans (#865). Fixed Plan.create() (#870). 2.0.0 (2019-03-01) The Python stripe library minimum version is now 2.3.0 . PaymentMethod has been renamed to DjstripePaymentMethod (#841). An alias remains but will be removed in the next version. Dropped support for Django<2.0, Python<3.4. Dropped previously-deprecated stripe_objects module. Dropped previously-deprecated stripe_timestamp field. Dropped previously-deprecated Charge.receipt_number field. Dropped previously-deprecated StripeSource alias for Card Dropped previously-deprecated SubscriptionView , CancelSubscriptionView and CancelSubscriptionForm . Removed the default value from DJSTRIPE_SUBSCRIPTION_REDIRECT . All stripe_id fields have been renamed id . Charge.source_type has been deprecated. Use Charge.source.type . Charge.source_stripe_id has been deprecated. Use Charge.source.id . All deprecated Transfer fields (Stripe API 2017-04-06 and older), have been dropped. This includes date , destination_type ( type ), failure_code , failure_message , statement_descriptor and status . Fixed IntegrityError when REMOTE_ADDR is missing (#640). New models: ApplicationFee ApplicationFeeRefund BalanceTransaction CountrySpec ScheduledQuery SubscriptionItem TransferReversal UsageRecord The fee and fee_details attributes of both the Charge and Transfer objects are no longer stored in the database. Instead, they access their respective new balance_transaction foreign key. Note that fee_details has been deprecated on both models. The fraudulent attribute on Charge is now a property that checks the fraud_details field. Object key validity is now always enforced (#503). Customer.sources no longer refers to a Card queryset, but to a Source queryset. In order to correctly transition, you should change all your references to customer.sources to customer.legacy_cards instead. The legacy_cards attribute already exists in 1.2.0. Customer.sources_v3 is now named Customer.sources . A new property Customer.payment_methods is now available, which allows you to iterate over all of a customer's payment methods (sources then cards). Card.customer is now nullable and cards are no longer deleted when their corresponding customer is deleted (#654). Webhook signature verification is now available and is preferred. Set the DJSTRIPE_WEBHOOK_SECRET setting to your secret to start using it. StripeObject has been renamed StripeModel . An alias remains but will be removed in the next version. The metadata key used in the Customer object can now be configured by changing the DJSTRIPE_SUBSCRIBER_CUSTOMER_KEY setting. Setting this to None or an empty string now also disables the behaviour altogether. Text-type fields in dj-stripe will no longer ever be None. Instead, any falsy text field will return an empty string. Switched test runner to pytest-django StripeModel.sync_from_stripe_data() will now automatically retrieve related objects and populate foreign keys (#681) Added Coupon.name Added Transfer.balance_transaction Exceptions in webhooks are now re-raised as well as saved in the database (#833)","title":"dj-stripe 2.0 ~ 2.3 release notes"},{"location":"history/2_x/#dj-stripe-20-23-release-notes","text":"","title":"dj-stripe 2.0 ~ 2.3 release notes"},{"location":"history/2_x/#230-2020-04-19","text":"The minimum version of Django is now 2.1, and Python 3.6. Changed JSONField dependency back to jsonfield from jsonfield2 (see Warning about safe uninstall of jsonfield2 on upgrade ). Fixed handling of TaxRate events (#1094). Fixed pagination issue in Invoice.sync_from_stripe_data (#1052). Fixed pagination issues in Subscription & Charge .sync_from_stripe_data (#1054). Tidyup _stripe_object_set_total_tax_amounts unique handling (#1139). Dropped previously-deprecated Invoice fields (see https://stripe.com/docs/upgrades#2018-11-08 ): .closed .forgiven .billing (renamed to .collection_method ) Dropped previously-deprecated enums.InvoiceStatus (#1020). Deprecated the following fields - will be removed in 2.4 (#1087): Subscription.billing (use .collection_method instead) Subscription.start (use .start_date instead) Subscription.tax_percent (use .default_tax_rates instead) Added Invoice.status and enums.InvoiceStatus (#1020). Added new Invoice fields (#1020, #1087): .discount .default_source .status Added new Subscription fields (#1087): .default_payment_method .default_source .next_pending_invoice_item_invoice .pending_invoice_item_interval .pending_update .start_date","title":"2.3.0 (2020-04-19)"},{"location":"history/2_x/#warning-about-safe-uninstall-of-jsonfield2-on-upgrade","text":"Both jsonfield and jsonfield2 use the same import path, so if upgrading from dj-stripe\\~=2.2.0 in an existing virtualenv, be sure to uninstall jsonfield2 first. eg: # ensure jsonfield is uninstalled before we install jsonfield2 pip uninstall jsonfield2 -y && pip install \"dj-stripe>=2.3.0dev\" Otherwise, pip uninstall jsonfield2 will remove jsonfield's jsonfield module from site-packages , which would cause errors like ImportError: cannot import name 'JSONField' from 'jsonfield' (unknown location) If you have hit this ImportError already after upgrading, running this should resolve it: # remove both jsonfield packages before reinstall to fix ImportError: pip uninstall jsonfield jsonfield2 -y && pip install \"dj-stripe>=2.3.0\" Note that this is only necessary if upgrading from dj-stripe 2.2.x, which temporarily depended on jsonfield2. This process is not necessary if upgrading from an earlier version of dj-stripe.","title":"Warning about safe uninstall of jsonfield2 on upgrade"},{"location":"history/2_x/#222-2020-01-20","text":"This is a bugfix-only version: Fixed handling of TaxRate events (#1094).","title":"2.2.2 (2020-01-20)"},{"location":"history/2_x/#221-2020-01-14","text":"This is a bugfix-only version: Fixed bad package build.","title":"2.2.1 (2020-01-14)"},{"location":"history/2_x/#220-2020-01-13","text":"Changed JSONField dependency package from jsonfield to jsonfield2 , for Django 3 compatibility (see Warning about safe uninstall of jsonfield on upgrade ). Note that Django 2.1 requires jsonfield<3.1. Added support for Django 3.0 (requires jsonfield2>=3.0.3). Added support for python 3.8. Refactored UpcomingInvoice , so it's no longer a subclass of Invoice (to allow Invoice to use ManyToManyFields ). Dropped previously-deprecated Account fields (see https://stripe.com/docs/upgrades#2019-02-19 ): .business_name .business_primary_color .business_url (changed to a property) .debit_negative_balances .decline_charge_on .display_name .legal_entity .payout_schedule .payout_statement_descriptor .statement_descriptor .support_email .support_phone .support_url .timezone .verification Dropped previously-deprecated Account.business_logo property (renamed to .branding_icon ) Dropped previously-deprecated Customer.account_balance property (renamed to .balance ) Dropped previously-deprecated properties Invoice.application_fee , Invoice.date Dropped previously-deprecated enum PaymentMethodType (use DjstripePaymentMethodType instead) Renamed Invoice.billing to .collection_method (added deprecated property for the old name). Updated Invoice model to add missing fields. Added TaxRate model, and Invoice.default_tax_rates , InvoiceItem.tax_rates , Invoice.total_tax_amounts , Subscription.default_tax_rates , SubscriptionItem.tax_rates (#1027). Change urls.py to use the new style urls. Update forward relation fields in the admin to be raw id fields. Updated StripeQuantumCurrencyAmountField and StripeDecimalCurrencyAmountField to support Stripe Large Charges (#1045). Update event handling so customer.subscription.deleted updates subscriptions to status=\"canceled\" instead of deleting it from our database, to match Stripe's behaviour (#599). Added missing Refund.reason value, increases field width (#1075). Fixed Refund.status definition, reduces field width (#1076). Deprecated non-standard Invoice.status (renamed to Invoice.legacy_status ) to make way for the Stripe field (preparation for #1020).","title":"2.2.0 (2020-01-13)"},{"location":"history/2_x/#warning-about-safe-uninstall-of-jsonfield-on-upgrade","text":"Both jsonfield and jsonfield2 use the same import path, so if upgrading to dj-stripe>=2.2 in an existing virtualenv, be sure to uninstall jsonfield first. eg: # ensure jsonfield is uninstalled before we install jsonfield2 pip uninstall jsonfield -y && pip install \"dj-stripe>=2.2.0\" Otherwise, pip uninstall jsonfield will remove jsonfield2's jsonfield module from site-packages , which would cause errors like ImportError: cannot import name 'JSONField' from 'jsonfield' (unknown location) If you have hit this ImportError already after upgrading, running this should resolve it: # remove both jsonfield packages before reinstall to fix ImportError: pip uninstall jsonfield jsonfield2 -y && pip install \"dj-stripe>=2.2.0\"","title":"Warning about safe uninstall of jsonfield on upgrade"},{"location":"history/2_x/#note-on-usage-of-stripe-elements-js","text":"See Integrating Stripe Elements for notes about usage of the Stripe Elements frontend JS library. In summary: If you haven't yet migrated to PaymentIntents, prefer stripe.createSource() to stripe.createToken() .","title":"Note on usage of Stripe Elements JS"},{"location":"history/2_x/#211-2019-10-01","text":"This is a bugfix-only release: Updated webhook signals list (#1000). Fixed issue syncing PaymentIntent with destination charge (#960). Fixed Customer.subscription and .valid_subscriptions() to ignore status=incomplete_expired (#1006). Fixed error on paymentmethod.detached event with card_xxx payment methods (#967). Added PaymentMethod.detach() (#943). Updated help_text on all currency fields to make it clear if they're holding integer cents ( StripeQuantumCurrencyAmountField ) or decimal dollar (or euro, pound etc) ( StripeDecimalCurrencyAmountField ) (#999) Documented our preferred Django model field types (#986)","title":"2.1.1 (2019-10-01)"},{"location":"history/2_x/#upcoming-migration-of-currency-fields-storage-as-cents-instead-of-dollars","text":"Please be aware that we're looking at standardising our currency storage fields as integer quanta (cents) instead of Decimal (dollar) values, to match stripe. This is intended to be part of the 3.0 release, since it will involve some breaking changes. See #955 for details and discussion.","title":"Upcoming migration of currency fields (storage as cents instead of dollars)"},{"location":"history/2_x/#210-2019-09-12","text":"Dropped Django 2.0 support The Python stripe library minimum version is now 2.32.0 , also 2.36.0 is excluded due to a regression (#991). Dropped previously-deprecated Charge.fee_details property. Dropped previously-deprecated Transfer.fee_details property. Dropped previously-deprecated field_name parameter to sync_from_stripe_data Dropped previously-deprecated alias StripeObject of StripeModel Dropped previously-deprecated alias PaymentMethod of DjstripePaymentMethod Dropped previously-deprecated properties Charge.source_type and Charge.source_stripe_id enums.PaymentMethodType has been deprecated, use enums.DjstripePaymentMethodType Made SubscriptionItem.quantity nullable as per Plans with usage_type=\"metered\" (follow-up to #865) Added manage commands djstripe_sync_models and djstripe_process_events (#727, #89) Fixed issue with re-creating a customer after Customer.purge() (#916) Fixed sync of Customer Bank Accounts (#829) Fixed Subscription.is_status_temporarily_current() (#852) New models Payment Intent Setup Intent Payment Method Session Added fields to Customer model: address , invoice_prefix , invoice_settings , phone , preferred_locales , tax_exempt Changes from API 2018-11-08: Added Invoice.auto_advance , deprecated Invoice.closed and Invoice.forgiven , see https://stripe.com/docs/billing/migration/invoice-states#upgrade-checklist Changes from API 2019-02-19: Major changes to Account fields, see https://stripe.com/docs/upgrades#2019-02-19 , updated Account fields to match API 2019-02-19: Added Account.business_profile , .business_type , .company , .individual , .requirements , .settings Deprecated the existing fields, to be removed in 2.2 Special handling of the icon and logo fields: > - Renamed Account.business_logo to Account.branding_icon > (note that in Stripe's API Account.business_logo was renamed > to Account.settings.branding_icon , and > Account.business_logo_large (which we didn't have a field > for) was renamed to Account.settings.branding_logo ) > - Added deprecated property for Account.business_logo > - Added Account.branding_logo as a ForeignKey > - Populate Account.branding_icon and .branding_logo from the > new Account.settings.branding.icon and .logo Changes from API 2019-03-14: Renamed Invoice.application_fee to Invoice.application_fee_amount (added deprecated property for the old name) Removed Invoice.date , in place of Invoice.created (added deprecated property for the old name) Added Invoice.status_transitions Renamed Customer.account_balance to Customer.balance (added deprecated property for the old name) Renamed Customer.payment_methods to Customer.customer_payment_methods Added new SubscriptionStatus.incomplete and SubscriptionStatus.incomplete_expired statuses (#974) Added new BalanceTransactionType values (#983)","title":"2.1.0 (2019-09-12)"},{"location":"history/2_x/#squashed-dev-migrations","text":"As per our migration policy , unreleased migrations on the master branch have been squashed. If you have been using the 2.1.0dev branch from master, you'll need to run the squashed migrations migrations before upgrading to >=2.1.0. The simplest way to do this is to pip install dj-stripe==2.1.0rc0 and migrate, alternatively check out the 2.1.0rc0 git tag.","title":"Squashed dev migrations"},{"location":"history/2_x/#205-2019-09-12","text":"This is a bugfix-only version: Avoid stripe==2.36.0 due to regression (#991)","title":"2.0.5 (2019-09-12)"},{"location":"history/2_x/#204-2019-09-09","text":"This is a bugfix-only version: Fixed irreversible migration (#909)","title":"2.0.4 (2019-09-09)"},{"location":"history/2_x/#203-2019-06-11","text":"This is a bugfix-only version: In _get_or_create_from_stripe_object , wrap create _create_from_stripe_object in transaction, fixes TransactionManagementError on race condition in webhook processing (#877, #903).","title":"2.0.3 (2019-06-11)"},{"location":"history/2_x/#202-2019-06-09","text":"This is a bugfix-only version: Don't save event objects if the webhook processing fails (#832). Fixed IntegrityError when REMOTE_ADDR is an empty string. Deprecated field_name parameter to sync_from_stripe_data","title":"2.0.2 (2019-06-09)"},{"location":"history/2_x/#201-2019-04-29","text":"This is a bugfix-only version: Fixed an error on invoiceitem.updated (#848). Handle test webhook properly in recent versions of Stripe API (#779). At some point 2018 Stripe silently changed the ID used for test events and evt_00000000000000 is not used anymore. Fixed OperationalError seen in migration 0003 on postgres (#850). Fixed issue with migration 0003 not being unapplied correctly (#882). Fixed missing SubscriptionItem.quantity on metered Plans (#865). Fixed Plan.create() (#870).","title":"2.0.1 (2019-04-29)"},{"location":"history/2_x/#200-2019-03-01","text":"The Python stripe library minimum version is now 2.3.0 . PaymentMethod has been renamed to DjstripePaymentMethod (#841). An alias remains but will be removed in the next version. Dropped support for Django<2.0, Python<3.4. Dropped previously-deprecated stripe_objects module. Dropped previously-deprecated stripe_timestamp field. Dropped previously-deprecated Charge.receipt_number field. Dropped previously-deprecated StripeSource alias for Card Dropped previously-deprecated SubscriptionView , CancelSubscriptionView and CancelSubscriptionForm . Removed the default value from DJSTRIPE_SUBSCRIPTION_REDIRECT . All stripe_id fields have been renamed id . Charge.source_type has been deprecated. Use Charge.source.type . Charge.source_stripe_id has been deprecated. Use Charge.source.id . All deprecated Transfer fields (Stripe API 2017-04-06 and older), have been dropped. This includes date , destination_type ( type ), failure_code , failure_message , statement_descriptor and status . Fixed IntegrityError when REMOTE_ADDR is missing (#640). New models: ApplicationFee ApplicationFeeRefund BalanceTransaction CountrySpec ScheduledQuery SubscriptionItem TransferReversal UsageRecord The fee and fee_details attributes of both the Charge and Transfer objects are no longer stored in the database. Instead, they access their respective new balance_transaction foreign key. Note that fee_details has been deprecated on both models. The fraudulent attribute on Charge is now a property that checks the fraud_details field. Object key validity is now always enforced (#503). Customer.sources no longer refers to a Card queryset, but to a Source queryset. In order to correctly transition, you should change all your references to customer.sources to customer.legacy_cards instead. The legacy_cards attribute already exists in 1.2.0. Customer.sources_v3 is now named Customer.sources . A new property Customer.payment_methods is now available, which allows you to iterate over all of a customer's payment methods (sources then cards). Card.customer is now nullable and cards are no longer deleted when their corresponding customer is deleted (#654). Webhook signature verification is now available and is preferred. Set the DJSTRIPE_WEBHOOK_SECRET setting to your secret to start using it. StripeObject has been renamed StripeModel . An alias remains but will be removed in the next version. The metadata key used in the Customer object can now be configured by changing the DJSTRIPE_SUBSCRIBER_CUSTOMER_KEY setting. Setting this to None or an empty string now also disables the behaviour altogether. Text-type fields in dj-stripe will no longer ever be None. Instead, any falsy text field will return an empty string. Switched test runner to pytest-django StripeModel.sync_from_stripe_data() will now automatically retrieve related objects and populate foreign keys (#681) Added Coupon.name Added Transfer.balance_transaction Exceptions in webhooks are now re-raised as well as saved in the database (#833)","title":"2.0.0 (2019-03-01)"},{"location":"project/authors/","text":"Credits Core contributors Alexander Kavanaugh (Co-maintainer) Jerome Leclanche (Co-maintainer) Arnav Choudhury Former core contributors John Carter Pablo Castellano Daniel Greenfeld Lee Skillen Contributors dj-stripe is brought to you by many more open source contributors. See the complete list on Github .","title":"Credits"},{"location":"project/authors/#credits","text":"","title":"Credits"},{"location":"project/authors/#core-contributors","text":"Alexander Kavanaugh (Co-maintainer) Jerome Leclanche (Co-maintainer) Arnav Choudhury","title":"Core contributors"},{"location":"project/authors/#former-core-contributors","text":"John Carter Pablo Castellano Daniel Greenfeld Lee Skillen","title":"Former core contributors"},{"location":"project/authors/#contributors","text":"dj-stripe is brought to you by many more open source contributors. See the complete list on Github .","title":"Contributors"},{"location":"project/contributing/","text":"Contributing Contributions are welcome, and they are greatly appreciated! Every little bit helps, and credit will always be given. You can contribute in many ways: Types of Contributions Report Bugs Report bugs at https://github.com/dj-stripe/dj-stripe/issues . If you are reporting a bug, please include: The version of python and Django you're running Detailed steps to reproduce the bug. Fix Bugs Look through the GitHub issues for bugs. Anything tagged with \"bug\" is open to whoever wants to implement it. Implement Features Look through the GitHub issues for features. Anything tagged with \"feature\" is open to whoever wants to implement it. Write Documentation dj-stripe could always use more documentation, whether as part of the official dj-stripe docs, in docstrings, or even on the web in blog posts, articles, and such. To see the project's documentation live, run the following command: mkdocs serve The documentation site will then be served on http://127.0.0.1:8000 . In case of any installation error In case you get the error that some plugin is not installed, please run: poetry install --with docs If you wish to just generate the documentation, you can replace serve with build , and the docs will be generated into the site/ folder. Submit Feedback The best way to send feedback is to file an issue at https://github.com/dj-stripe/dj-stripe/issues . If you are proposing a feature: Explain in detail how it would work. Keep the scope as narrow as possible, to make it easier to implement. Remember that this is a volunteer-driven project, and that contributions are welcome :) Contributor Discussion For questions regarding contributions to dj-stripe, another avenue is our Discord channel at https://discord.gg/UJY8fcc . Get Started! Ready to contribute? Here's how to set up local development. Fork dj-stripe on Github . Clone your fork locally: $ git clone git@github.com:your_name_here/dj-stripe.git Set up pre-commit : $ git init # A git repo is required to install pre-commit $ pre-commit install Set up your test database. If you're running tests using PostgreSQL: $ createdb djstripe or if you want to test vs sqlite (for convenience) or MySQL, they can be selected by setting this environment variable: $ export DJSTRIPE_TEST_DB_VENDOR = sqlite # or: export DJSTRIPE_TEST_DB_VENDOR=mysql For postgres and mysql, the database host,port,username and password can be set with environment variables, see tests/settings.py Install Poetry if you do not have it already. You can set up a virtual environment with: $ poetry install You can then, at any time, open a shell into that environment with: $ poetry shell When you're done making changes, check that your changes pass the tests. A quick test run can be done as follows: $ DJSTRIPE_TEST_DB_VENDOR = sqlite poetry run pytest --reuse-db You should also check that the tests pass with other python and Django versions with tox. pytest will output both command line and html coverage statistics and will warn you if your changes caused code coverage to drop.: $ pip install tox $ tox If your changes altered the models you may need to generate Django migrations: $ DJSTRIPE_TEST_DB_VENDOR = sqlite poetry run ./manage.py makemigrations Commit your changes and push your branch to GitHub: $ git add . $ git commit -m \"Your detailed description of your changes.\" $ git push Submit a pull request through the GitHub website. Congratulations, you're now a dj-stripe contributor! Have some \u2665 from us. Preferred Django Model Field Types When mapping from Stripe API field types to Django model fields, we try to follow Django best practises where practical. The following types should be preferred for fields that map to the Stripe API (which is almost all fields in our models). Strings Stripe API string fields have a default maximum length of 5,000 characters . In some cases a maximum length ( maxLength ) is specified in the Stripe OpenAPI schema . We follow Django's recommendation and avoid using null on string fields (which means we store \"\" for string fields that are null in stripe). Note that is enforced in the sync logic in StripeModel._stripe_object_to_record . For long string fields (eg above 255 characters) we prefer TextField over Charfield . Therefore the default type for string fields that don't have a maxLength specified in the Stripe OpenAPI schema should usually be: str_field = TextField(max_length=5000, default=\", blank=True, help_text=\"...\") Enumerations Fields that have a defined set of values can be implemented using StripeEnumField . Hash (dictionaries) Use the JSONField in djstripe.fields . Currency amounts Stripe handles all currency amounts as integer cents, we currently have a mixture of fields as integer cents and decimal (eg dollar, euro etc) values, but we are aiming to standardise on cents (see https://github.com/dj-stripe/dj-stripe/issues/955 ). All new currency amount fields should use StripeQuantumCurrencyAmountField . Dates and Datetimes The Stripe API uses an integer timestamp (seconds since the Unix epoch) for dates and datetimes. We store this as a datetime field, using StripeDateTimeField . Django Migration Policy Migrations are considered a breaking change, so it's not usually not acceptable to add a migration to a stable branch, it will be a new MAJOR.MINOR.0 release. A workaround to this in the case that the Stripe API data isn't compatible with out model (eg Stripe is sending null to a non-null field) is to implement the _manipulate_stripe_object_hook classmethod on the model. Avoid new migrations with non-schema changes If a code change produces a migration that doesn't alter the database schema (eg changing help_text ) then instead of adding a new migration you can edit the most recent migration that affects the field in question. e.g.: https://github.com/dj-stripe/dj-stripe/commit/e2762c38918a90f00c42ecf21187a920bd3a2087 Pull Request Guidelines Before you submit a pull request, check that it meets these guidelines: The pull request should include tests. The pull request must not drop code coverage below the current level. If the pull request adds functionality, the docs should be updated. Put your new functionality into a function with a docstring. If the pull request makes changes to a model, include Django migrations. The pull request should work for Python 3.6+. Check Github Actions and make sure that the tests pass for all supported Python versions. Code formatting: Make sure to install pre-commit to automatically run it on staged files or run manually with pre-commit run --all-files at the dj-stripe root to keep a consistent style.","title":"Contributing"},{"location":"project/contributing/#contributing","text":"Contributions are welcome, and they are greatly appreciated! Every little bit helps, and credit will always be given. You can contribute in many ways:","title":"Contributing"},{"location":"project/contributing/#types-of-contributions","text":"","title":"Types of Contributions"},{"location":"project/contributing/#report-bugs","text":"Report bugs at https://github.com/dj-stripe/dj-stripe/issues . If you are reporting a bug, please include: The version of python and Django you're running Detailed steps to reproduce the bug.","title":"Report Bugs"},{"location":"project/contributing/#fix-bugs","text":"Look through the GitHub issues for bugs. Anything tagged with \"bug\" is open to whoever wants to implement it.","title":"Fix Bugs"},{"location":"project/contributing/#implement-features","text":"Look through the GitHub issues for features. Anything tagged with \"feature\" is open to whoever wants to implement it.","title":"Implement Features"},{"location":"project/contributing/#write-documentation","text":"dj-stripe could always use more documentation, whether as part of the official dj-stripe docs, in docstrings, or even on the web in blog posts, articles, and such. To see the project's documentation live, run the following command: mkdocs serve The documentation site will then be served on http://127.0.0.1:8000 . In case of any installation error In case you get the error that some plugin is not installed, please run: poetry install --with docs If you wish to just generate the documentation, you can replace serve with build , and the docs will be generated into the site/ folder.","title":"Write Documentation"},{"location":"project/contributing/#submit-feedback","text":"The best way to send feedback is to file an issue at https://github.com/dj-stripe/dj-stripe/issues . If you are proposing a feature: Explain in detail how it would work. Keep the scope as narrow as possible, to make it easier to implement. Remember that this is a volunteer-driven project, and that contributions are welcome :)","title":"Submit Feedback"},{"location":"project/contributing/#contributor-discussion","text":"For questions regarding contributions to dj-stripe, another avenue is our Discord channel at https://discord.gg/UJY8fcc .","title":"Contributor Discussion"},{"location":"project/contributing/#get-started","text":"Ready to contribute? Here's how to set up local development. Fork dj-stripe on Github . Clone your fork locally: $ git clone git@github.com:your_name_here/dj-stripe.git Set up pre-commit : $ git init # A git repo is required to install pre-commit $ pre-commit install Set up your test database. If you're running tests using PostgreSQL: $ createdb djstripe or if you want to test vs sqlite (for convenience) or MySQL, they can be selected by setting this environment variable: $ export DJSTRIPE_TEST_DB_VENDOR = sqlite # or: export DJSTRIPE_TEST_DB_VENDOR=mysql For postgres and mysql, the database host,port,username and password can be set with environment variables, see tests/settings.py Install Poetry if you do not have it already. You can set up a virtual environment with: $ poetry install You can then, at any time, open a shell into that environment with: $ poetry shell When you're done making changes, check that your changes pass the tests. A quick test run can be done as follows: $ DJSTRIPE_TEST_DB_VENDOR = sqlite poetry run pytest --reuse-db You should also check that the tests pass with other python and Django versions with tox. pytest will output both command line and html coverage statistics and will warn you if your changes caused code coverage to drop.: $ pip install tox $ tox If your changes altered the models you may need to generate Django migrations: $ DJSTRIPE_TEST_DB_VENDOR = sqlite poetry run ./manage.py makemigrations Commit your changes and push your branch to GitHub: $ git add . $ git commit -m \"Your detailed description of your changes.\" $ git push Submit a pull request through the GitHub website. Congratulations, you're now a dj-stripe contributor! Have some \u2665 from us.","title":"Get Started!"},{"location":"project/contributing/#preferred-django-model-field-types","text":"When mapping from Stripe API field types to Django model fields, we try to follow Django best practises where practical. The following types should be preferred for fields that map to the Stripe API (which is almost all fields in our models).","title":"Preferred Django Model Field Types"},{"location":"project/contributing/#strings","text":"Stripe API string fields have a default maximum length of 5,000 characters . In some cases a maximum length ( maxLength ) is specified in the Stripe OpenAPI schema . We follow Django's recommendation and avoid using null on string fields (which means we store \"\" for string fields that are null in stripe). Note that is enforced in the sync logic in StripeModel._stripe_object_to_record . For long string fields (eg above 255 characters) we prefer TextField over Charfield . Therefore the default type for string fields that don't have a maxLength specified in the Stripe OpenAPI schema should usually be: str_field = TextField(max_length=5000, default=\", blank=True, help_text=\"...\")","title":"Strings"},{"location":"project/contributing/#enumerations","text":"Fields that have a defined set of values can be implemented using StripeEnumField .","title":"Enumerations"},{"location":"project/contributing/#hash-dictionaries","text":"Use the JSONField in djstripe.fields .","title":"Hash (dictionaries)"},{"location":"project/contributing/#currency-amounts","text":"Stripe handles all currency amounts as integer cents, we currently have a mixture of fields as integer cents and decimal (eg dollar, euro etc) values, but we are aiming to standardise on cents (see https://github.com/dj-stripe/dj-stripe/issues/955 ). All new currency amount fields should use StripeQuantumCurrencyAmountField .","title":"Currency amounts"},{"location":"project/contributing/#dates-and-datetimes","text":"The Stripe API uses an integer timestamp (seconds since the Unix epoch) for dates and datetimes. We store this as a datetime field, using StripeDateTimeField .","title":"Dates and Datetimes"},{"location":"project/contributing/#django-migration-policy","text":"Migrations are considered a breaking change, so it's not usually not acceptable to add a migration to a stable branch, it will be a new MAJOR.MINOR.0 release. A workaround to this in the case that the Stripe API data isn't compatible with out model (eg Stripe is sending null to a non-null field) is to implement the _manipulate_stripe_object_hook classmethod on the model.","title":"Django Migration Policy"},{"location":"project/contributing/#avoid-new-migrations-with-non-schema-changes","text":"If a code change produces a migration that doesn't alter the database schema (eg changing help_text ) then instead of adding a new migration you can edit the most recent migration that affects the field in question. e.g.: https://github.com/dj-stripe/dj-stripe/commit/e2762c38918a90f00c42ecf21187a920bd3a2087","title":"Avoid new migrations with non-schema changes"},{"location":"project/contributing/#pull-request-guidelines","text":"Before you submit a pull request, check that it meets these guidelines: The pull request should include tests. The pull request must not drop code coverage below the current level. If the pull request adds functionality, the docs should be updated. Put your new functionality into a function with a docstring. If the pull request makes changes to a model, include Django migrations. The pull request should work for Python 3.6+. Check Github Actions and make sure that the tests pass for all supported Python versions. Code formatting: Make sure to install pre-commit to automatically run it on staged files or run manually with pre-commit run --all-files at the dj-stripe root to keep a consistent style.","title":"Pull Request Guidelines"},{"location":"project/release_process/","text":"Release Process Note Before MAJOR or MINOR releases: Review deprecation notes (eg search for \"deprecated\") and remove deprecated features as appropriate Squash migrations (ONLY on unreleased migrations) - see below Squash migrations If there's more than one unreleased migration on master consider squashing them with squashmigrations , immediately before tagging the new release: Create a new squashed migration with ./manage.py squashmigrations (only squash migrations that have never been in a tagged release) Commit the squashed migration on master with a commit message like \"Squash x.y.0dev migrations\" (this will allow users who running master to safely upgrade, see note below about rc package) Then transition the squashed migration to a normal migration as per Django: Delete all the migration files it replaces Update all migrations that depend on the deleted migrations to depend on the squashed migration instead Remove the replaces attribute in the Migration class of the squashed migration (this is how Django tells that it is a squashed migration) Commit these changes to master with a message like \"Transition squashed migration to normal migration\" Then do the normal release process - bump version as another commit and tag the release See https://docs.djangoproject.com/en/dev/topics/migrations/#migration-squashing Tag + package squashed migrations as rc package (optional) As a convenience to users who are running master, an rc version can be created to package the squashed migration. To do this, immediately after the \"Squash x.y.0dev migrations\" commit, follow the steps below but with a x.y.0rc0 version to tag and package a rc version. Users who have been using the x.y.0dev code from master can then run the squashed migrations migrations before upgrading to >=x.y.0. The simplest way to do this is to pip install dj-stripe==x.y.0rc0 and migrate, or alternatively check out the x.y.0rc0 git tag and migrate. Prepare changes for the release commit Choose your version number (using https://semver.org/ ) if there's a new migration, it should be a MAJOR.0.0 or MAJOR.MINOR.0 version. Review and update HISTORY.md Add a section for this release version Set date on this release version Check that summary of feature/fixes is since the last release is up to date Update package version number in setup.cfg Review and update supported API version in README.md (this is the most recent Stripe account version tested against, not DEFAULT_STRIPE_API_VERSION ) git add to stage these changes Create signed release commit tag Note Before doing this you should have a GPG key set up on github If you don't have a GPG key already, one method is via https://keybase.io/ , and then add it to your github profile. Create a release tag with the above staged changes (where $VERSION is the version number to be released: $ git commit -m \"Release $VERSION \" $ git tag -fsm \"Release $VERSION \" $VERSION This can be expressed as a bash function as follows: git_release() { git commit -m \"Release $1\" && git tag -fsm \"Release $1\" $1; } Push the commit and tag: $ git push --follow-tags Update/create stable branch Push these changes to the appropriate stable/MAJOR.MINOR version branch (eg stable/2.0 ) if they're not already - note that this will trigger the readthedocs build Release on pypi See https://packaging.python.org/tutorials/packaging-projects/#generating-distribution-archives","title":"Release Process"},{"location":"project/release_process/#release-process","text":"Note Before MAJOR or MINOR releases: Review deprecation notes (eg search for \"deprecated\") and remove deprecated features as appropriate Squash migrations (ONLY on unreleased migrations) - see below","title":"Release Process"},{"location":"project/release_process/#squash-migrations","text":"If there's more than one unreleased migration on master consider squashing them with squashmigrations , immediately before tagging the new release: Create a new squashed migration with ./manage.py squashmigrations (only squash migrations that have never been in a tagged release) Commit the squashed migration on master with a commit message like \"Squash x.y.0dev migrations\" (this will allow users who running master to safely upgrade, see note below about rc package) Then transition the squashed migration to a normal migration as per Django: Delete all the migration files it replaces Update all migrations that depend on the deleted migrations to depend on the squashed migration instead Remove the replaces attribute in the Migration class of the squashed migration (this is how Django tells that it is a squashed migration) Commit these changes to master with a message like \"Transition squashed migration to normal migration\" Then do the normal release process - bump version as another commit and tag the release See https://docs.djangoproject.com/en/dev/topics/migrations/#migration-squashing","title":"Squash migrations"},{"location":"project/release_process/#tag-package-squashed-migrations-as-rc-package-optional","text":"As a convenience to users who are running master, an rc version can be created to package the squashed migration. To do this, immediately after the \"Squash x.y.0dev migrations\" commit, follow the steps below but with a x.y.0rc0 version to tag and package a rc version. Users who have been using the x.y.0dev code from master can then run the squashed migrations migrations before upgrading to >=x.y.0. The simplest way to do this is to pip install dj-stripe==x.y.0rc0 and migrate, or alternatively check out the x.y.0rc0 git tag and migrate.","title":"Tag + package squashed migrations as rc package (optional)"},{"location":"project/release_process/#prepare-changes-for-the-release-commit","text":"Choose your version number (using https://semver.org/ ) if there's a new migration, it should be a MAJOR.0.0 or MAJOR.MINOR.0 version. Review and update HISTORY.md Add a section for this release version Set date on this release version Check that summary of feature/fixes is since the last release is up to date Update package version number in setup.cfg Review and update supported API version in README.md (this is the most recent Stripe account version tested against, not DEFAULT_STRIPE_API_VERSION ) git add to stage these changes","title":"Prepare changes for the release commit"},{"location":"project/release_process/#create-signed-release-commit-tag","text":"Note Before doing this you should have a GPG key set up on github If you don't have a GPG key already, one method is via https://keybase.io/ , and then add it to your github profile. Create a release tag with the above staged changes (where $VERSION is the version number to be released: $ git commit -m \"Release $VERSION \" $ git tag -fsm \"Release $VERSION \" $VERSION This can be expressed as a bash function as follows: git_release() { git commit -m \"Release $1\" && git tag -fsm \"Release $1\" $1; } Push the commit and tag: $ git push --follow-tags","title":"Create signed release commit tag"},{"location":"project/release_process/#updatecreate-stable-branch","text":"Push these changes to the appropriate stable/MAJOR.MINOR version branch (eg stable/2.0 ) if they're not already - note that this will trigger the readthedocs build","title":"Update/create stable branch"},{"location":"project/release_process/#release-on-pypi","text":"See https://packaging.python.org/tutorials/packaging-projects/#generating-distribution-archives","title":"Release on pypi"},{"location":"project/sponsors/","text":"Sponsors Gold Sponsors This project is sponsored by none other than Stripe , since August 2020. We're thankful for their contribution, which has allowed us to greatly improve the project, increase QA and testing, and push forward with the dj-stripe 2.4.0 release. Silver Sponsors We do not currently have any Silver sponsors. Want to be the first?","title":"Sponsors"},{"location":"project/sponsors/#sponsors","text":"","title":"Sponsors"},{"location":"project/sponsors/#gold-sponsors","text":"This project is sponsored by none other than Stripe , since August 2020. We're thankful for their contribution, which has allowed us to greatly improve the project, increase QA and testing, and push forward with the dj-stripe 2.4.0 release.","title":"Gold Sponsors"},{"location":"project/sponsors/#silver-sponsors","text":"We do not currently have any Silver sponsors. Want to be the first?","title":"Silver Sponsors"},{"location":"project/support/","text":"Support Support plans dj-stripe offers paid support plans via Github Sponsors: https://github.com/sponsors/dj-stripe All issues and feature requests raised by corporate sponsors will be prioritized. Gold Sponsors also get a dedicated developer point of contact, to help with any questions, issues, or general inquiries relating to dj-stripe. Bug reports and feature requests Please report any issues you come across on the Github issue tracker . Do not hesitate to leave feedback and suggestions there as well. You may also ask usage questions on the issue tracker.","title":"Support"},{"location":"project/support/#support","text":"","title":"Support"},{"location":"project/support/#support-plans","text":"dj-stripe offers paid support plans via Github Sponsors: https://github.com/sponsors/dj-stripe All issues and feature requests raised by corporate sponsors will be prioritized. Gold Sponsors also get a dedicated developer point of contact, to help with any questions, issues, or general inquiries relating to dj-stripe.","title":"Support plans"},{"location":"project/support/#bug-reports-and-feature-requests","text":"Please report any issues you come across on the Github issue tracker . Do not hesitate to leave feedback and suggestions there as well. You may also ask usage questions on the issue tracker.","title":"Bug reports and feature requests"},{"location":"project/test_fixtures/","text":"Test Fixtures dj-stripe's unit tests rely on fixtures to represent Stripe API and webhook data. Rationale These fixtures are partly hand-coded and partly generated by creating objects in Stripe and then retrieved via the API. Each approach has pros and cons: Hand-coding the fixtures allows them to be crafted specifically for a test case. They can also be terse, and nested objects can be done by reference to avoid duplication. But maintaining or upgrading them is a painstaking manual process. Generating the fixtures via Stripe gives the big advantage that Stripe schema changes are automatically represented in the fixtures, which should allow us to upgrade dj-stripe's schema to match Stripe much more easily. This would be done by updating dj-stripe's targeted API version ( DEFAULT_STRIPE_API_VERSION ), regenerating the fixtures, and updating the model to match the fixture changes. The down side is it's tricky to regenerate fixture files without introducing big changes (eg to object ids) - the script does this by mapping a dummy id to various objects. Regenerating the test fixtures To regenerate the test fixtures (e.g. to populate the fixtures with new API fields from Stripe), do the following: (one time only) Create a new Stripe account called \"dj-stripe scratch\", with country set to United States. (we use US so the currency matches the existing fixtures matches, in the future it would be good to test for other countries). If you already had this account ready and want to start again from scratch, you can delete all of the test data via the button in Settings > Data https://dashboard.stripe.com/account/data Activate a virtualenv with the dj-stripe project (see Getting Started) Set the dj-stripe secret key environment variable to the secret key for this account ( export STRIPE_SECRET_KEY=sk_test_... ) Run the manage command to create the test objects in your stripe account if they don't already exist, and regenerate the local fixture files from them: $ ./manage.py regenerate_test_fixtures The command tries to avoid inconsequential changes to the fixtures (e.g the created timestamp) by restoring a whitelist of values from the existing fixtures. This functionality can be disabled by passing --update-sideeffect-fields .","title":"Test Fixtures"},{"location":"project/test_fixtures/#test-fixtures","text":"dj-stripe's unit tests rely on fixtures to represent Stripe API and webhook data.","title":"Test Fixtures"},{"location":"project/test_fixtures/#rationale","text":"These fixtures are partly hand-coded and partly generated by creating objects in Stripe and then retrieved via the API. Each approach has pros and cons: Hand-coding the fixtures allows them to be crafted specifically for a test case. They can also be terse, and nested objects can be done by reference to avoid duplication. But maintaining or upgrading them is a painstaking manual process. Generating the fixtures via Stripe gives the big advantage that Stripe schema changes are automatically represented in the fixtures, which should allow us to upgrade dj-stripe's schema to match Stripe much more easily. This would be done by updating dj-stripe's targeted API version ( DEFAULT_STRIPE_API_VERSION ), regenerating the fixtures, and updating the model to match the fixture changes. The down side is it's tricky to regenerate fixture files without introducing big changes (eg to object ids) - the script does this by mapping a dummy id to various objects.","title":"Rationale"},{"location":"project/test_fixtures/#regenerating-the-test-fixtures","text":"To regenerate the test fixtures (e.g. to populate the fixtures with new API fields from Stripe), do the following: (one time only) Create a new Stripe account called \"dj-stripe scratch\", with country set to United States. (we use US so the currency matches the existing fixtures matches, in the future it would be good to test for other countries). If you already had this account ready and want to start again from scratch, you can delete all of the test data via the button in Settings > Data https://dashboard.stripe.com/account/data Activate a virtualenv with the dj-stripe project (see Getting Started) Set the dj-stripe secret key environment variable to the secret key for this account ( export STRIPE_SECRET_KEY=sk_test_... ) Run the manage command to create the test objects in your stripe account if they don't already exist, and regenerate the local fixture files from them: $ ./manage.py regenerate_test_fixtures The command tries to avoid inconsequential changes to the fixtures (e.g the created timestamp) by restoring a whitelist of values from the existing fixtures. This functionality can be disabled by passing --update-sideeffect-fields .","title":"Regenerating the test fixtures"},{"location":"reference/enums/","text":"Enumerations Attributes djstripe . enums . PlanTiersMode = PriceTiersMode module-attribute djstripe . enums . PlanUsageType = PriceUsageType module-attribute Classes djstripe.enums.APIKeyType Bases: Enum API Key Types (internal model only) Source code in djstripe/enums.py 58 59 60 61 62 63 64 65 class APIKeyType ( Enum ): \"\"\" API Key Types (internal model only) \"\"\" publishable = _ ( \"Publishable key\" ) secret = _ ( \"Secret key\" ) restricted = _ ( \"Restricted key\" ) Attributes djstripe . enums . APIKeyType . publishable = _ ( 'Publishable key' ) class-attribute djstripe . enums . APIKeyType . restricted = _ ( 'Restricted key' ) class-attribute djstripe . enums . APIKeyType . secret = _ ( 'Secret key' ) class-attribute djstripe.enums.AccountType Bases: Enum Source code in djstripe/enums.py 168 169 170 171 class AccountType ( Enum ): standard = _ ( \"Standard\" ) express = _ ( \"Express\" ) custom = _ ( \"Custom\" ) Attributes djstripe . enums . AccountType . custom = _ ( 'Custom' ) class-attribute djstripe . enums . AccountType . express = _ ( 'Express' ) class-attribute djstripe . enums . AccountType . standard = _ ( 'Standard' ) class-attribute djstripe.enums.ApiErrorCode Bases: Enum Charge failure error codes. https://stripe.com/docs/error-codes Source code in djstripe/enums.py 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 class ApiErrorCode ( Enum ): \"\"\" Charge failure error codes. https://stripe.com/docs/error-codes \"\"\" account_already_exists = _ ( \"Account already exists\" ) account_country_invalid_address = _ ( \"Account country invalid address\" ) account_invalid = _ ( \"Account invalid\" ) account_number_invalid = _ ( \"Account number invalid\" ) alipay_upgrade_required = _ ( \"Alipay upgrade required\" ) amount_too_large = _ ( \"Amount too large\" ) amount_too_small = _ ( \"Amount too small\" ) api_key_expired = _ ( \"Api key expired\" ) balance_insufficient = _ ( \"Balance insufficient\" ) bank_account_exists = _ ( \"Bank account exists\" ) bank_account_unusable = _ ( \"Bank account unusable\" ) bank_account_unverified = _ ( \"Bank account unverified\" ) bitcoin_upgrade_required = _ ( \"Bitcoin upgrade required\" ) card_declined = _ ( \"Card was declined\" ) charge_already_captured = _ ( \"Charge already captured\" ) charge_already_refunded = _ ( \"Charge already refunded\" ) charge_disputed = _ ( \"Charge disputed\" ) charge_exceeds_source_limit = _ ( \"Charge exceeds source limit\" ) charge_expired_for_capture = _ ( \"Charge expired for capture\" ) country_unsupported = _ ( \"Country unsupported\" ) coupon_expired = _ ( \"Coupon expired\" ) customer_max_subscriptions = _ ( \"Customer max subscriptions\" ) email_invalid = _ ( \"Email invalid\" ) expired_card = _ ( \"Expired card\" ) idempotency_key_in_use = _ ( \"Idempotency key in use\" ) incorrect_address = _ ( \"Incorrect address\" ) incorrect_cvc = _ ( \"Incorrect security code\" ) incorrect_number = _ ( \"Incorrect number\" ) incorrect_zip = _ ( \"ZIP code failed validation\" ) instant_payouts_unsupported = _ ( \"Instant payouts unsupported\" ) invalid_card_type = _ ( \"Invalid card type\" ) invalid_charge_amount = _ ( \"Invalid charge amount\" ) invalid_cvc = _ ( \"Invalid security code\" ) invalid_expiry_month = _ ( \"Invalid expiration month\" ) invalid_expiry_year = _ ( \"Invalid expiration year\" ) invalid_number = _ ( \"Invalid number\" ) invalid_source_usage = _ ( \"Invalid source usage\" ) invoice_no_customer_line_items = _ ( \"Invoice no customer line items\" ) invoice_no_subscription_line_items = _ ( \"Invoice no subscription line items\" ) invoice_not_editable = _ ( \"Invoice not editable\" ) invoice_upcoming_none = _ ( \"Invoice upcoming none\" ) livemode_mismatch = _ ( \"Livemode mismatch\" ) missing = _ ( \"No card being charged\" ) not_allowed_on_standard_account = _ ( \"Not allowed on standard account\" ) order_creation_failed = _ ( \"Order creation failed\" ) order_required_settings = _ ( \"Order required settings\" ) order_status_invalid = _ ( \"Order status invalid\" ) order_upstream_timeout = _ ( \"Order upstream timeout\" ) out_of_inventory = _ ( \"Out of inventory\" ) parameter_invalid_empty = _ ( \"Parameter invalid empty\" ) parameter_invalid_integer = _ ( \"Parameter invalid integer\" ) parameter_invalid_string_blank = _ ( \"Parameter invalid string blank\" ) parameter_invalid_string_empty = _ ( \"Parameter invalid string empty\" ) parameter_missing = _ ( \"Parameter missing\" ) parameter_unknown = _ ( \"Parameter unknown\" ) parameters_exclusive = _ ( \"Parameters exclusive\" ) payment_intent_authentication_failure = _ ( \"Payment intent authentication failure\" ) payment_intent_incompatible_payment_method = _ ( \"Payment intent incompatible payment method\" ) payment_intent_invalid_parameter = _ ( \"Payment intent invalid parameter\" ) payment_intent_payment_attempt_failed = _ ( \"Payment intent payment attempt failed\" ) payment_intent_unexpected_state = _ ( \"Payment intent unexpected state\" ) payment_method_unactivated = _ ( \"Payment method unactivated\" ) payment_method_unexpected_state = _ ( \"Payment method unexpected state\" ) payouts_not_allowed = _ ( \"Payouts not allowed\" ) platform_api_key_expired = _ ( \"Platform api key expired\" ) postal_code_invalid = _ ( \"Postal code invalid\" ) processing_error = _ ( \"Processing error\" ) product_inactive = _ ( \"Product inactive\" ) rate_limit = _ ( \"Rate limit\" ) resource_already_exists = _ ( \"Resource already exists\" ) resource_missing = _ ( \"Resource missing\" ) routing_number_invalid = _ ( \"Routing number invalid\" ) secret_key_required = _ ( \"Secret key required\" ) sepa_unsupported_account = _ ( \"SEPA unsupported account\" ) shipping_calculation_failed = _ ( \"Shipping calculation failed\" ) sku_inactive = _ ( \"SKU inactive\" ) state_unsupported = _ ( \"State unsupported\" ) tax_id_invalid = _ ( \"Tax id invalid\" ) taxes_calculation_failed = _ ( \"Taxes calculation failed\" ) testmode_charges_only = _ ( \"Testmode charges only\" ) tls_version_unsupported = _ ( \"TLS version unsupported\" ) token_already_used = _ ( \"Token already used\" ) token_in_use = _ ( \"Token in use\" ) transfers_not_allowed = _ ( \"Transfers not allowed\" ) upstream_order_creation_failed = _ ( \"Upstream order creation failed\" ) url_invalid = _ ( \"URL invalid\" ) # deprecated invalid_swipe_data = _ ( \"Invalid swipe data\" ) Attributes djstripe . enums . ApiErrorCode . account_already_exists = _ ( 'Account already exists' ) class-attribute djstripe . enums . ApiErrorCode . account_country_invalid_address = _ ( 'Account country invalid address' ) class-attribute djstripe . enums . ApiErrorCode . account_invalid = _ ( 'Account invalid' ) class-attribute djstripe . enums . ApiErrorCode . account_number_invalid = _ ( 'Account number invalid' ) class-attribute djstripe . enums . ApiErrorCode . alipay_upgrade_required = _ ( 'Alipay upgrade required' ) class-attribute djstripe . enums . ApiErrorCode . amount_too_large = _ ( 'Amount too large' ) class-attribute djstripe . enums . ApiErrorCode . amount_too_small = _ ( 'Amount too small' ) class-attribute djstripe . enums . ApiErrorCode . api_key_expired = _ ( 'Api key expired' ) class-attribute djstripe . enums . ApiErrorCode . balance_insufficient = _ ( 'Balance insufficient' ) class-attribute djstripe . enums . ApiErrorCode . bank_account_exists = _ ( 'Bank account exists' ) class-attribute djstripe . enums . ApiErrorCode . bank_account_unusable = _ ( 'Bank account unusable' ) class-attribute djstripe . enums . ApiErrorCode . bank_account_unverified = _ ( 'Bank account unverified' ) class-attribute djstripe . enums . ApiErrorCode . bitcoin_upgrade_required = _ ( 'Bitcoin upgrade required' ) class-attribute djstripe . enums . ApiErrorCode . card_declined = _ ( 'Card was declined' ) class-attribute djstripe . enums . ApiErrorCode . charge_already_captured = _ ( 'Charge already captured' ) class-attribute djstripe . enums . ApiErrorCode . charge_already_refunded = _ ( 'Charge already refunded' ) class-attribute djstripe . enums . ApiErrorCode . charge_disputed = _ ( 'Charge disputed' ) class-attribute djstripe . enums . ApiErrorCode . charge_exceeds_source_limit = _ ( 'Charge exceeds source limit' ) class-attribute djstripe . enums . ApiErrorCode . charge_expired_for_capture = _ ( 'Charge expired for capture' ) class-attribute djstripe . enums . ApiErrorCode . country_unsupported = _ ( 'Country unsupported' ) class-attribute djstripe . enums . ApiErrorCode . coupon_expired = _ ( 'Coupon expired' ) class-attribute djstripe . enums . ApiErrorCode . customer_max_subscriptions = _ ( 'Customer max subscriptions' ) class-attribute djstripe . enums . ApiErrorCode . email_invalid = _ ( 'Email invalid' ) class-attribute djstripe . enums . ApiErrorCode . expired_card = _ ( 'Expired card' ) class-attribute djstripe . enums . ApiErrorCode . idempotency_key_in_use = _ ( 'Idempotency key in use' ) class-attribute djstripe . enums . ApiErrorCode . incorrect_address = _ ( 'Incorrect address' ) class-attribute djstripe . enums . ApiErrorCode . incorrect_cvc = _ ( 'Incorrect security code' ) class-attribute djstripe . enums . ApiErrorCode . incorrect_number = _ ( 'Incorrect number' ) class-attribute djstripe . enums . ApiErrorCode . incorrect_zip = _ ( 'ZIP code failed validation' ) class-attribute djstripe . enums . ApiErrorCode . instant_payouts_unsupported = _ ( 'Instant payouts unsupported' ) class-attribute djstripe . enums . ApiErrorCode . invalid_card_type = _ ( 'Invalid card type' ) class-attribute djstripe . enums . ApiErrorCode . invalid_charge_amount = _ ( 'Invalid charge amount' ) class-attribute djstripe . enums . ApiErrorCode . invalid_cvc = _ ( 'Invalid security code' ) class-attribute djstripe . enums . ApiErrorCode . invalid_expiry_month = _ ( 'Invalid expiration month' ) class-attribute djstripe . enums . ApiErrorCode . invalid_expiry_year = _ ( 'Invalid expiration year' ) class-attribute djstripe . enums . ApiErrorCode . invalid_number = _ ( 'Invalid number' ) class-attribute djstripe . enums . ApiErrorCode . invalid_source_usage = _ ( 'Invalid source usage' ) class-attribute djstripe . enums . ApiErrorCode . invalid_swipe_data = _ ( 'Invalid swipe data' ) class-attribute djstripe . enums . ApiErrorCode . invoice_no_customer_line_items = _ ( 'Invoice no customer line items' ) class-attribute djstripe . enums . ApiErrorCode . invoice_no_subscription_line_items = _ ( 'Invoice no subscription line items' ) class-attribute djstripe . enums . ApiErrorCode . invoice_not_editable = _ ( 'Invoice not editable' ) class-attribute djstripe . enums . ApiErrorCode . invoice_upcoming_none = _ ( 'Invoice upcoming none' ) class-attribute djstripe . enums . ApiErrorCode . livemode_mismatch = _ ( 'Livemode mismatch' ) class-attribute djstripe . enums . ApiErrorCode . missing = _ ( 'No card being charged' ) class-attribute djstripe . enums . ApiErrorCode . not_allowed_on_standard_account = _ ( 'Not allowed on standard account' ) class-attribute djstripe . enums . ApiErrorCode . order_creation_failed = _ ( 'Order creation failed' ) class-attribute djstripe . enums . ApiErrorCode . order_required_settings = _ ( 'Order required settings' ) class-attribute djstripe . enums . ApiErrorCode . order_status_invalid = _ ( 'Order status invalid' ) class-attribute djstripe . enums . ApiErrorCode . order_upstream_timeout = _ ( 'Order upstream timeout' ) class-attribute djstripe . enums . ApiErrorCode . out_of_inventory = _ ( 'Out of inventory' ) class-attribute djstripe . enums . ApiErrorCode . parameter_invalid_empty = _ ( 'Parameter invalid empty' ) class-attribute djstripe . enums . ApiErrorCode . parameter_invalid_integer = _ ( 'Parameter invalid integer' ) class-attribute djstripe . enums . ApiErrorCode . parameter_invalid_string_blank = _ ( 'Parameter invalid string blank' ) class-attribute djstripe . enums . ApiErrorCode . parameter_invalid_string_empty = _ ( 'Parameter invalid string empty' ) class-attribute djstripe . enums . ApiErrorCode . parameter_missing = _ ( 'Parameter missing' ) class-attribute djstripe . enums . ApiErrorCode . parameter_unknown = _ ( 'Parameter unknown' ) class-attribute djstripe . enums . ApiErrorCode . parameters_exclusive = _ ( 'Parameters exclusive' ) class-attribute djstripe . enums . ApiErrorCode . payment_intent_authentication_failure = _ ( 'Payment intent authentication failure' ) class-attribute djstripe . enums . ApiErrorCode . payment_intent_incompatible_payment_method = _ ( 'Payment intent incompatible payment method' ) class-attribute djstripe . enums . ApiErrorCode . payment_intent_invalid_parameter = _ ( 'Payment intent invalid parameter' ) class-attribute djstripe . enums . ApiErrorCode . payment_intent_payment_attempt_failed = _ ( 'Payment intent payment attempt failed' ) class-attribute djstripe . enums . ApiErrorCode . payment_intent_unexpected_state = _ ( 'Payment intent unexpected state' ) class-attribute djstripe . enums . ApiErrorCode . payment_method_unactivated = _ ( 'Payment method unactivated' ) class-attribute djstripe . enums . ApiErrorCode . payment_method_unexpected_state = _ ( 'Payment method unexpected state' ) class-attribute djstripe . enums . ApiErrorCode . payouts_not_allowed = _ ( 'Payouts not allowed' ) class-attribute djstripe . enums . ApiErrorCode . platform_api_key_expired = _ ( 'Platform api key expired' ) class-attribute djstripe . enums . ApiErrorCode . postal_code_invalid = _ ( 'Postal code invalid' ) class-attribute djstripe . enums . ApiErrorCode . processing_error = _ ( 'Processing error' ) class-attribute djstripe . enums . ApiErrorCode . product_inactive = _ ( 'Product inactive' ) class-attribute djstripe . enums . ApiErrorCode . rate_limit = _ ( 'Rate limit' ) class-attribute djstripe . enums . ApiErrorCode . resource_already_exists = _ ( 'Resource already exists' ) class-attribute djstripe . enums . ApiErrorCode . resource_missing = _ ( 'Resource missing' ) class-attribute djstripe . enums . ApiErrorCode . routing_number_invalid = _ ( 'Routing number invalid' ) class-attribute djstripe . enums . ApiErrorCode . secret_key_required = _ ( 'Secret key required' ) class-attribute djstripe . enums . ApiErrorCode . sepa_unsupported_account = _ ( 'SEPA unsupported account' ) class-attribute djstripe . enums . ApiErrorCode . shipping_calculation_failed = _ ( 'Shipping calculation failed' ) class-attribute djstripe . enums . ApiErrorCode . sku_inactive = _ ( 'SKU inactive' ) class-attribute djstripe . enums . ApiErrorCode . state_unsupported = _ ( 'State unsupported' ) class-attribute djstripe . enums . ApiErrorCode . tax_id_invalid = _ ( 'Tax id invalid' ) class-attribute djstripe . enums . ApiErrorCode . taxes_calculation_failed = _ ( 'Taxes calculation failed' ) class-attribute djstripe . enums . ApiErrorCode . testmode_charges_only = _ ( 'Testmode charges only' ) class-attribute djstripe . enums . ApiErrorCode . tls_version_unsupported = _ ( 'TLS version unsupported' ) class-attribute djstripe . enums . ApiErrorCode . token_already_used = _ ( 'Token already used' ) class-attribute djstripe . enums . ApiErrorCode . token_in_use = _ ( 'Token in use' ) class-attribute djstripe . enums . ApiErrorCode . transfers_not_allowed = _ ( 'Transfers not allowed' ) class-attribute djstripe . enums . ApiErrorCode . upstream_order_creation_failed = _ ( 'Upstream order creation failed' ) class-attribute djstripe . enums . ApiErrorCode . url_invalid = _ ( 'URL invalid' ) class-attribute djstripe.enums.BalanceTransactionReportingCategory Bases: Enum https://stripe.com/docs/reports/reporting-categories Source code in djstripe/enums.py 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 class BalanceTransactionReportingCategory ( Enum ): \"\"\" https://stripe.com/docs/reports/reporting-categories \"\"\" advance = _ ( \"Advance\" ) advance_funding = _ ( \"Advance funding\" ) anticipation_repayment = _ ( \"Anticipation loan repayment (BR)\" ) charge = _ ( \"Charge\" ) charge_failure = _ ( \"Charge failure\" ) connect_collection_transfer = _ ( \"Stripe Connect collection transfer\" ) connect_reserved_funds = _ ( \"Stripe Connect reserved funds\" ) dispute = _ ( \"Dispute\" ) dispute_reversal = _ ( \"Dispute reversal\" ) fee = _ ( \"Stripe fee\" ) issuing_authorization_hold = _ ( \"Issuing authorization hold\" ) issuing_authorization_release = _ ( \"Issuing authorization release\" ) issuing_dispute = _ ( \"Issuing dispute\" ) issuing_transaction = _ ( \"Issuing transaction\" ) other_adjustment = _ ( \"Other adjustment\" ) partial_capture_reversal = _ ( \"Partial capture reversal\" ) payout = _ ( \"Payout\" ) payout_reversal = _ ( \"Payout reversal\" ) platform_earning = _ ( \"Stripe Connect platform earning\" ) platform_earning_refund = _ ( \"Stripe Connect platform earning refund\" ) refund = _ ( \"Refund\" ) refund_failure = _ ( \"Refund failure\" ) risk_reserved_funds = _ ( \"Risk-reserved funds\" ) tax = _ ( \"Tax\" ) topup = _ ( \"Top-up\" ) topup_reversal = _ ( \"Top-up reversal\" ) transfer = _ ( \"Stripe Connect transfer\" ) transfer_reversal = _ ( \"Stripe Connect transfer reversal\" ) Attributes djstripe . enums . BalanceTransactionReportingCategory . advance = _ ( 'Advance' ) class-attribute djstripe . enums . BalanceTransactionReportingCategory . advance_funding = _ ( 'Advance funding' ) class-attribute djstripe . enums . BalanceTransactionReportingCategory . anticipation_repayment = _ ( 'Anticipation loan repayment (BR)' ) class-attribute djstripe . enums . BalanceTransactionReportingCategory . charge = _ ( 'Charge' ) class-attribute djstripe . enums . BalanceTransactionReportingCategory . charge_failure = _ ( 'Charge failure' ) class-attribute djstripe . enums . BalanceTransactionReportingCategory . connect_collection_transfer = _ ( 'Stripe Connect collection transfer' ) class-attribute djstripe . enums . BalanceTransactionReportingCategory . connect_reserved_funds = _ ( 'Stripe Connect reserved funds' ) class-attribute djstripe . enums . BalanceTransactionReportingCategory . dispute = _ ( 'Dispute' ) class-attribute djstripe . enums . BalanceTransactionReportingCategory . dispute_reversal = _ ( 'Dispute reversal' ) class-attribute djstripe . enums . BalanceTransactionReportingCategory . fee = _ ( 'Stripe fee' ) class-attribute djstripe . enums . BalanceTransactionReportingCategory . issuing_authorization_hold = _ ( 'Issuing authorization hold' ) class-attribute djstripe . enums . BalanceTransactionReportingCategory . issuing_authorization_release = _ ( 'Issuing authorization release' ) class-attribute djstripe . enums . BalanceTransactionReportingCategory . issuing_dispute = _ ( 'Issuing dispute' ) class-attribute djstripe . enums . BalanceTransactionReportingCategory . issuing_transaction = _ ( 'Issuing transaction' ) class-attribute djstripe . enums . BalanceTransactionReportingCategory . other_adjustment = _ ( 'Other adjustment' ) class-attribute djstripe . enums . BalanceTransactionReportingCategory . partial_capture_reversal = _ ( 'Partial capture reversal' ) class-attribute djstripe . enums . BalanceTransactionReportingCategory . payout = _ ( 'Payout' ) class-attribute djstripe . enums . BalanceTransactionReportingCategory . payout_reversal = _ ( 'Payout reversal' ) class-attribute djstripe . enums . BalanceTransactionReportingCategory . platform_earning = _ ( 'Stripe Connect platform earning' ) class-attribute djstripe . enums . BalanceTransactionReportingCategory . platform_earning_refund = _ ( 'Stripe Connect platform earning refund' ) class-attribute djstripe . enums . BalanceTransactionReportingCategory . refund = _ ( 'Refund' ) class-attribute djstripe . enums . BalanceTransactionReportingCategory . refund_failure = _ ( 'Refund failure' ) class-attribute djstripe . enums . BalanceTransactionReportingCategory . risk_reserved_funds = _ ( 'Risk-reserved funds' ) class-attribute djstripe . enums . BalanceTransactionReportingCategory . tax = _ ( 'Tax' ) class-attribute djstripe . enums . BalanceTransactionReportingCategory . topup = _ ( 'Top-up' ) class-attribute djstripe . enums . BalanceTransactionReportingCategory . topup_reversal = _ ( 'Top-up reversal' ) class-attribute djstripe . enums . BalanceTransactionReportingCategory . transfer = _ ( 'Stripe Connect transfer' ) class-attribute djstripe . enums . BalanceTransactionReportingCategory . transfer_reversal = _ ( 'Stripe Connect transfer reversal' ) class-attribute djstripe.enums.BalanceTransactionStatus Bases: Enum Source code in djstripe/enums.py 209 210 211 class BalanceTransactionStatus ( Enum ): available = _ ( \"Available\" ) pending = _ ( \"Pending\" ) Attributes djstripe . enums . BalanceTransactionStatus . available = _ ( 'Available' ) class-attribute djstripe . enums . BalanceTransactionStatus . pending = _ ( 'Pending' ) class-attribute djstripe.enums.BalanceTransactionType Bases: Enum Source code in djstripe/enums.py 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 class BalanceTransactionType ( Enum ): # https://stripe.com/docs/reports/balance-transaction-types adjustment = _ ( \"Adjustment\" ) advance = _ ( \"Advance\" ) advance_funding = _ ( \"Advance funding\" ) anticipation_repayment = _ ( \"Anticipation loan repayment\" ) application_fee = _ ( \"Application fee\" ) application_fee_refund = _ ( \"Application fee refund\" ) balance_transfer_inbound = _ ( \"Balance transfer (inbound)\" ) balance_transfer_outbound = _ ( \"Balance transfer (outbound)\" ) charge = _ ( \"Charge\" ) connect_collection_transfer = _ ( \"Connect collection transfer\" ) contribution = _ ( \"Charitable contribution\" ) issuing_authorization_hold = _ ( \"Issuing authorization hold\" ) issuing_authorization_release = _ ( \"Issuing authorization release\" ) issuing_dispute = _ ( \"Issuing dispute\" ) issuing_transaction = _ ( \"Issuing transaction\" ) network_cost = _ ( \"Network cost\" ) payment = _ ( \"Payment\" ) payment_failure_refund = _ ( \"Payment failure refund\" ) payment_refund = _ ( \"Payment refund\" ) payout = _ ( \"Payout\" ) payout_cancel = _ ( \"Payout cancellation\" ) payout_failure = _ ( \"Payout failure\" ) refund = _ ( \"Refund\" ) refund_failure = _ ( \"Refund failure\" ) reserve_transaction = _ ( \"Reserve transaction\" ) reserved_funds = _ ( \"Reserved funds\" ) stripe_fee = _ ( \"Stripe fee\" ) stripe_fx_fee = _ ( \"Stripe currency conversion fee\" ) tax_fee = _ ( \"Tax fee\" ) topup = _ ( \"Topup\" ) topup_reversal = _ ( \"Topup reversal\" ) transfer = _ ( \"Transfer\" ) transfer_cancel = _ ( \"Transfer cancel\" ) transfer_failure = _ ( \"Transfer failure\" ) transfer_refund = _ ( \"Transfer refund\" ) validation = _ ( \"Validation\" ) Attributes djstripe . enums . BalanceTransactionType . adjustment = _ ( 'Adjustment' ) class-attribute djstripe . enums . BalanceTransactionType . advance = _ ( 'Advance' ) class-attribute djstripe . enums . BalanceTransactionType . advance_funding = _ ( 'Advance funding' ) class-attribute djstripe . enums . BalanceTransactionType . anticipation_repayment = _ ( 'Anticipation loan repayment' ) class-attribute djstripe . enums . BalanceTransactionType . application_fee = _ ( 'Application fee' ) class-attribute djstripe . enums . BalanceTransactionType . application_fee_refund = _ ( 'Application fee refund' ) class-attribute djstripe . enums . BalanceTransactionType . balance_transfer_inbound = _ ( 'Balance transfer (inbound)' ) class-attribute djstripe . enums . BalanceTransactionType . balance_transfer_outbound = _ ( 'Balance transfer (outbound)' ) class-attribute djstripe . enums . BalanceTransactionType . charge = _ ( 'Charge' ) class-attribute djstripe . enums . BalanceTransactionType . connect_collection_transfer = _ ( 'Connect collection transfer' ) class-attribute djstripe . enums . BalanceTransactionType . contribution = _ ( 'Charitable contribution' ) class-attribute djstripe . enums . BalanceTransactionType . issuing_authorization_hold = _ ( 'Issuing authorization hold' ) class-attribute djstripe . enums . BalanceTransactionType . issuing_authorization_release = _ ( 'Issuing authorization release' ) class-attribute djstripe . enums . BalanceTransactionType . issuing_dispute = _ ( 'Issuing dispute' ) class-attribute djstripe . enums . BalanceTransactionType . issuing_transaction = _ ( 'Issuing transaction' ) class-attribute djstripe . enums . BalanceTransactionType . network_cost = _ ( 'Network cost' ) class-attribute djstripe . enums . BalanceTransactionType . payment = _ ( 'Payment' ) class-attribute djstripe . enums . BalanceTransactionType . payment_failure_refund = _ ( 'Payment failure refund' ) class-attribute djstripe . enums . BalanceTransactionType . payment_refund = _ ( 'Payment refund' ) class-attribute djstripe . enums . BalanceTransactionType . payout = _ ( 'Payout' ) class-attribute djstripe . enums . BalanceTransactionType . payout_cancel = _ ( 'Payout cancellation' ) class-attribute djstripe . enums . BalanceTransactionType . payout_failure = _ ( 'Payout failure' ) class-attribute djstripe . enums . BalanceTransactionType . refund = _ ( 'Refund' ) class-attribute djstripe . enums . BalanceTransactionType . refund_failure = _ ( 'Refund failure' ) class-attribute djstripe . enums . BalanceTransactionType . reserve_transaction = _ ( 'Reserve transaction' ) class-attribute djstripe . enums . BalanceTransactionType . reserved_funds = _ ( 'Reserved funds' ) class-attribute djstripe . enums . BalanceTransactionType . stripe_fee = _ ( 'Stripe fee' ) class-attribute djstripe . enums . BalanceTransactionType . stripe_fx_fee = _ ( 'Stripe currency conversion fee' ) class-attribute djstripe . enums . BalanceTransactionType . tax_fee = _ ( 'Tax fee' ) class-attribute djstripe . enums . BalanceTransactionType . topup = _ ( 'Topup' ) class-attribute djstripe . enums . BalanceTransactionType . topup_reversal = _ ( 'Topup reversal' ) class-attribute djstripe . enums . BalanceTransactionType . transfer = _ ( 'Transfer' ) class-attribute djstripe . enums . BalanceTransactionType . transfer_cancel = _ ( 'Transfer cancel' ) class-attribute djstripe . enums . BalanceTransactionType . transfer_failure = _ ( 'Transfer failure' ) class-attribute djstripe . enums . BalanceTransactionType . transfer_refund = _ ( 'Transfer refund' ) class-attribute djstripe . enums . BalanceTransactionType . validation = _ ( 'Validation' ) class-attribute djstripe.enums.BankAccountHolderType Bases: Enum Source code in djstripe/enums.py 254 255 256 class BankAccountHolderType ( Enum ): individual = _ ( \"Individual\" ) company = _ ( \"Company\" ) Attributes djstripe . enums . BankAccountHolderType . company = _ ( 'Company' ) class-attribute djstripe . enums . BankAccountHolderType . individual = _ ( 'Individual' ) class-attribute djstripe.enums.BankAccountStatus Bases: Enum Source code in djstripe/enums.py 259 260 261 262 263 264 class BankAccountStatus ( Enum ): new = _ ( \"New\" ) validated = _ ( \"Validated\" ) verified = _ ( \"Verified\" ) verification_failed = _ ( \"Verification failed\" ) errored = _ ( \"Errored\" ) Attributes djstripe . enums . BankAccountStatus . errored = _ ( 'Errored' ) class-attribute djstripe . enums . BankAccountStatus . new = _ ( 'New' ) class-attribute djstripe . enums . BankAccountStatus . validated = _ ( 'Validated' ) class-attribute djstripe . enums . BankAccountStatus . verification_failed = _ ( 'Verification failed' ) class-attribute djstripe . enums . BankAccountStatus . verified = _ ( 'Verified' ) class-attribute djstripe.enums.BillingScheme Bases: Enum Source code in djstripe/enums.py 267 268 269 class BillingScheme ( Enum ): per_unit = _ ( \"Per-unit\" ) tiered = _ ( \"Tiered\" ) Attributes djstripe . enums . BillingScheme . per_unit = _ ( 'Per-unit' ) class-attribute djstripe . enums . BillingScheme . tiered = _ ( 'Tiered' ) class-attribute djstripe.enums.BusinessType Bases: Enum Source code in djstripe/enums.py 272 273 274 275 276 class BusinessType ( Enum ): individual = _ ( \"Individual\" ) company = _ ( \"Company\" ) non_profit = _ ( \"Non Profit\" ) government_entity = _ ( \"Government Entity\" ) Attributes djstripe . enums . BusinessType . company = _ ( 'Company' ) class-attribute djstripe . enums . BusinessType . government_entity = _ ( 'Government Entity' ) class-attribute djstripe . enums . BusinessType . individual = _ ( 'Individual' ) class-attribute djstripe . enums . BusinessType . non_profit = _ ( 'Non Profit' ) class-attribute djstripe.enums.CaptureMethod Bases: Enum Source code in djstripe/enums.py 279 280 281 class CaptureMethod ( Enum ): automatic = _ ( \"Automatic\" ) manual = _ ( \"Manual\" ) Attributes djstripe . enums . CaptureMethod . automatic = _ ( 'Automatic' ) class-attribute djstripe . enums . CaptureMethod . manual = _ ( 'Manual' ) class-attribute djstripe.enums.CardBrand Bases: Enum Source code in djstripe/enums.py 291 292 293 294 295 296 297 298 299 class CardBrand ( Enum ): AmericanExpress = ( _ ( \"American Express\" ), \"American Express\" ) DinersClub = ( _ ( \"Diners Club\" ), \"Diners Club\" ) Discover = _ ( \"Discover\" ) JCB = _ ( \"JCB\" ) MasterCard = _ ( \"MasterCard\" ) UnionPay = _ ( \"UnionPay\" ) Visa = _ ( \"Visa\" ) Unknown = _ ( \"Unknown\" ) Attributes djstripe . enums . CardBrand . AmericanExpress = ( _ ( 'American Express' ), 'American Express' ) class-attribute djstripe . enums . CardBrand . DinersClub = ( _ ( 'Diners Club' ), 'Diners Club' ) class-attribute djstripe . enums . CardBrand . Discover = _ ( 'Discover' ) class-attribute djstripe . enums . CardBrand . JCB = _ ( 'JCB' ) class-attribute djstripe . enums . CardBrand . MasterCard = _ ( 'MasterCard' ) class-attribute djstripe . enums . CardBrand . UnionPay = _ ( 'UnionPay' ) class-attribute djstripe . enums . CardBrand . Unknown = _ ( 'Unknown' ) class-attribute djstripe . enums . CardBrand . Visa = _ ( 'Visa' ) class-attribute djstripe.enums.CardCheckResult Bases: Enum Source code in djstripe/enums.py 284 285 286 287 288 class CardCheckResult ( Enum ): pass_ = ( _ ( \"Pass\" ), \"pass\" ) fail = _ ( \"Fail\" ) unavailable = _ ( \"Unavailable\" ) unchecked = _ ( \"Unchecked\" ) Attributes djstripe . enums . CardCheckResult . fail = _ ( 'Fail' ) class-attribute djstripe . enums . CardCheckResult . pass_ = ( _ ( 'Pass' ), 'pass' ) class-attribute djstripe . enums . CardCheckResult . unavailable = _ ( 'Unavailable' ) class-attribute djstripe . enums . CardCheckResult . unchecked = _ ( 'Unchecked' ) class-attribute djstripe.enums.CardFundingType Bases: Enum Source code in djstripe/enums.py 302 303 304 305 306 class CardFundingType ( Enum ): credit = _ ( \"Credit\" ) debit = _ ( \"Debit\" ) prepaid = _ ( \"Prepaid\" ) unknown = _ ( \"Unknown\" ) Attributes djstripe . enums . CardFundingType . credit = _ ( 'Credit' ) class-attribute djstripe . enums . CardFundingType . debit = _ ( 'Debit' ) class-attribute djstripe . enums . CardFundingType . prepaid = _ ( 'Prepaid' ) class-attribute djstripe . enums . CardFundingType . unknown = _ ( 'Unknown' ) class-attribute djstripe.enums.CardTokenizationMethod Bases: Enum Source code in djstripe/enums.py 309 310 311 class CardTokenizationMethod ( Enum ): apple_pay = _ ( \"Apple Pay\" ) android_pay = _ ( \"Android Pay\" ) Attributes djstripe . enums . CardTokenizationMethod . android_pay = _ ( 'Android Pay' ) class-attribute djstripe . enums . CardTokenizationMethod . apple_pay = _ ( 'Apple Pay' ) class-attribute djstripe.enums.ChargeStatus Bases: Enum Source code in djstripe/enums.py 314 315 316 317 class ChargeStatus ( Enum ): succeeded = _ ( \"Succeeded\" ) pending = _ ( \"Pending\" ) failed = _ ( \"Failed\" ) Attributes djstripe . enums . ChargeStatus . failed = _ ( 'Failed' ) class-attribute djstripe . enums . ChargeStatus . pending = _ ( 'Pending' ) class-attribute djstripe . enums . ChargeStatus . succeeded = _ ( 'Succeeded' ) class-attribute djstripe.enums.ConfirmationMethod Bases: Enum Source code in djstripe/enums.py 332 333 334 class ConfirmationMethod ( Enum ): automatic = _ ( \"Automatic\" ) manual = _ ( \"Manual\" ) Attributes djstripe . enums . ConfirmationMethod . automatic = _ ( 'Automatic' ) class-attribute djstripe . enums . ConfirmationMethod . manual = _ ( 'Manual' ) class-attribute djstripe.enums.CouponDuration Bases: Enum Source code in djstripe/enums.py 337 338 339 340 class CouponDuration ( Enum ): once = _ ( \"Once\" ) repeating = _ ( \"Multi-month\" ) forever = _ ( \"Forever\" ) Attributes djstripe . enums . CouponDuration . forever = _ ( 'Forever' ) class-attribute djstripe . enums . CouponDuration . once = _ ( 'Once' ) class-attribute djstripe . enums . CouponDuration . repeating = _ ( 'Multi-month' ) class-attribute djstripe.enums.CustomerTaxExempt Bases: Enum Source code in djstripe/enums.py 343 344 345 346 class CustomerTaxExempt ( Enum ): none = _ ( \"None\" ) exempt = _ ( \"Exempt\" ) reverse = _ ( \"Reverse\" ) Attributes djstripe . enums . CustomerTaxExempt . exempt = _ ( 'Exempt' ) class-attribute djstripe . enums . CustomerTaxExempt . none = _ ( 'None' ) class-attribute djstripe . enums . CustomerTaxExempt . reverse = _ ( 'Reverse' ) class-attribute djstripe.enums.DisputeReason Bases: Enum Source code in djstripe/enums.py 349 350 351 352 353 354 355 356 357 358 359 360 361 362 class DisputeReason ( Enum ): duplicate = _ ( \"Duplicate\" ) fraudulent = _ ( \"Fraudulent\" ) subscription_canceled = _ ( \"Subscription canceled\" ) product_unacceptable = _ ( \"Product unacceptable\" ) product_not_received = _ ( \"Product not received\" ) unrecognized = _ ( \"Unrecognized\" ) credit_not_processed = _ ( \"Credit not processed\" ) general = _ ( \"General\" ) incorrect_account_details = _ ( \"Incorrect account details\" ) insufficient_funds = _ ( \"Insufficient funds\" ) bank_cannot_process = _ ( \"Bank cannot process\" ) debit_not_authorized = _ ( \"Debit not authorized\" ) customer_initiated = _ ( \"Customer-initiated\" ) Attributes djstripe . enums . DisputeReason . bank_cannot_process = _ ( 'Bank cannot process' ) class-attribute djstripe . enums . DisputeReason . credit_not_processed = _ ( 'Credit not processed' ) class-attribute djstripe . enums . DisputeReason . customer_initiated = _ ( 'Customer-initiated' ) class-attribute djstripe . enums . DisputeReason . debit_not_authorized = _ ( 'Debit not authorized' ) class-attribute djstripe . enums . DisputeReason . duplicate = _ ( 'Duplicate' ) class-attribute djstripe . enums . DisputeReason . fraudulent = _ ( 'Fraudulent' ) class-attribute djstripe . enums . DisputeReason . general = _ ( 'General' ) class-attribute djstripe . enums . DisputeReason . incorrect_account_details = _ ( 'Incorrect account details' ) class-attribute djstripe . enums . DisputeReason . insufficient_funds = _ ( 'Insufficient funds' ) class-attribute djstripe . enums . DisputeReason . product_not_received = _ ( 'Product not received' ) class-attribute djstripe . enums . DisputeReason . product_unacceptable = _ ( 'Product unacceptable' ) class-attribute djstripe . enums . DisputeReason . subscription_canceled = _ ( 'Subscription canceled' ) class-attribute djstripe . enums . DisputeReason . unrecognized = _ ( 'Unrecognized' ) class-attribute djstripe.enums.DisputeStatus Bases: Enum Source code in djstripe/enums.py 365 366 367 368 369 370 371 372 373 class DisputeStatus ( Enum ): warning_needs_response = _ ( \"Warning needs response\" ) warning_under_review = _ ( \"Warning under review\" ) warning_closed = _ ( \"Warning closed\" ) needs_response = _ ( \"Needs response\" ) under_review = _ ( \"Under review\" ) charge_refunded = _ ( \"Charge refunded\" ) won = _ ( \"Won\" ) lost = _ ( \"Lost\" ) Attributes djstripe . enums . DisputeStatus . charge_refunded = _ ( 'Charge refunded' ) class-attribute djstripe . enums . DisputeStatus . lost = _ ( 'Lost' ) class-attribute djstripe . enums . DisputeStatus . needs_response = _ ( 'Needs response' ) class-attribute djstripe . enums . DisputeStatus . under_review = _ ( 'Under review' ) class-attribute djstripe . enums . DisputeStatus . warning_closed = _ ( 'Warning closed' ) class-attribute djstripe . enums . DisputeStatus . warning_needs_response = _ ( 'Warning needs response' ) class-attribute djstripe . enums . DisputeStatus . warning_under_review = _ ( 'Warning under review' ) class-attribute djstripe . enums . DisputeStatus . won = _ ( 'Won' ) class-attribute djstripe.enums.DjstripePaymentMethodType Bases: Enum A djstripe-specific enum for the DjStripePaymentMethod model. Source code in djstripe/enums.py 862 863 864 865 866 867 868 869 870 class DjstripePaymentMethodType ( Enum ): \"\"\" A djstripe-specific enum for the DjStripePaymentMethod model. \"\"\" alipay_account = _ ( \"Alipay account\" ) card = _ ( \"Card\" ) bank_account = _ ( \"Bank account\" ) source = _ ( \"Source\" ) Attributes djstripe . enums . DjstripePaymentMethodType . alipay_account = _ ( 'Alipay account' ) class-attribute djstripe . enums . DjstripePaymentMethodType . bank_account = _ ( 'Bank account' ) class-attribute djstripe . enums . DjstripePaymentMethodType . card = _ ( 'Card' ) class-attribute djstripe . enums . DjstripePaymentMethodType . source = _ ( 'Source' ) class-attribute djstripe.enums.Enum Source code in djstripe/enums.py 54 55 class Enum ( metaclass = EnumMetaClass ): pass djstripe.enums.EnumMetaClass Bases: type Source code in djstripe/enums.py 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 class EnumMetaClass ( type ): def __init__ ( cls , name , bases , classdict ): def _human_enum_values ( enum ): return cls . __choices__ [ enum ] # add a class attribute cls . humanize = _human_enum_values @classmethod def __prepare__ ( cls , name , bases ): return OrderedDict () def __new__ ( cls , name , bases , classdict ): members = [] keys = {} choices = OrderedDict () for key , value in classdict . items (): if key . startswith ( \"__\" ): continue members . append ( key ) if isinstance ( value , tuple ): value , alias = value keys [ alias ] = key else : alias = None keys [ alias or key ] = key choices [ alias or key ] = value for k , v in keys . items (): classdict [ v ] = k classdict [ \"__choices__\" ] = choices classdict [ \"__members__\" ] = members # Note: Differences between Python 2.x and Python 3.x force us to # explicitly use unicode here, and to explicitly sort the list. In # Python 2.x, class members are unordered and so the ordering will # vary on different systems based on internal hashing. Without this # Django will continually require new no-op migrations. classdict [ \"choices\" ] = tuple ( ( str ( k ), str ( v )) for k , v in sorted ( choices . items (), key = operator . itemgetter ( 0 )) ) return type . __new__ ( cls , name , bases , classdict ) Functions djstripe . enums . EnumMetaClass . __init__ ( name , bases , classdict ) Source code in djstripe/enums.py 8 9 10 11 12 13 def __init__ ( cls , name , bases , classdict ): def _human_enum_values ( enum ): return cls . __choices__ [ enum ] # add a class attribute cls . humanize = _human_enum_values djstripe . enums . EnumMetaClass . __new__ ( name , bases , classdict ) Source code in djstripe/enums.py 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 def __new__ ( cls , name , bases , classdict ): members = [] keys = {} choices = OrderedDict () for key , value in classdict . items (): if key . startswith ( \"__\" ): continue members . append ( key ) if isinstance ( value , tuple ): value , alias = value keys [ alias ] = key else : alias = None keys [ alias or key ] = key choices [ alias or key ] = value for k , v in keys . items (): classdict [ v ] = k classdict [ \"__choices__\" ] = choices classdict [ \"__members__\" ] = members # Note: Differences between Python 2.x and Python 3.x force us to # explicitly use unicode here, and to explicitly sort the list. In # Python 2.x, class members are unordered and so the ordering will # vary on different systems based on internal hashing. Without this # Django will continually require new no-op migrations. classdict [ \"choices\" ] = tuple ( ( str ( k ), str ( v )) for k , v in sorted ( choices . items (), key = operator . itemgetter ( 0 )) ) return type . __new__ ( cls , name , bases , classdict ) djstripe . enums . EnumMetaClass . __prepare__ ( name , bases ) classmethod Source code in djstripe/enums.py 15 16 17 @classmethod def __prepare__ ( cls , name , bases ): return OrderedDict () djstripe.enums.FilePurpose Bases: Enum Source code in djstripe/enums.py 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 class FilePurpose ( Enum ): account_requirement = _ ( \"Account requirement\" ) additional_verification = _ ( \"Additional verification\" ) business_icon = _ ( \"Business icon\" ) business_logo = _ ( \"Business logo\" ) customer_signature = _ ( \"Customer signature\" ) credit_note = _ ( \"Credit Note\" ) dispute_evidence = _ ( \"Dispute evidence\" ) document_provider_identity_document = _ ( \"Document provider identity document\" ) finance_report_run = _ ( \"Finance report run\" ) identity_document = _ ( \"Identity document\" ) identity_document_downloadable = _ ( \"Identity document (downloadable)\" ) invoice_statement = _ ( \"Invoice statement\" ) pci_document = _ ( \"PCI document\" ) selfie = _ ( \"Selfie (Stripe Identity)\" ) sigma_scheduled_query = _ ( \"Sigma scheduled query\" ) tax_document_user_upload = _ ( \"Tax document user upload\" ) Attributes djstripe . enums . FilePurpose . account_requirement = _ ( 'Account requirement' ) class-attribute djstripe . enums . FilePurpose . additional_verification = _ ( 'Additional verification' ) class-attribute djstripe . enums . FilePurpose . business_icon = _ ( 'Business icon' ) class-attribute djstripe . enums . FilePurpose . business_logo = _ ( 'Business logo' ) class-attribute djstripe . enums . FilePurpose . credit_note = _ ( 'Credit Note' ) class-attribute djstripe . enums . FilePurpose . customer_signature = _ ( 'Customer signature' ) class-attribute djstripe . enums . FilePurpose . dispute_evidence = _ ( 'Dispute evidence' ) class-attribute djstripe . enums . FilePurpose . document_provider_identity_document = _ ( 'Document provider identity document' ) class-attribute djstripe . enums . FilePurpose . finance_report_run = _ ( 'Finance report run' ) class-attribute djstripe . enums . FilePurpose . identity_document = _ ( 'Identity document' ) class-attribute djstripe . enums . FilePurpose . identity_document_downloadable = _ ( 'Identity document (downloadable)' ) class-attribute djstripe . enums . FilePurpose . invoice_statement = _ ( 'Invoice statement' ) class-attribute djstripe . enums . FilePurpose . pci_document = _ ( 'PCI document' ) class-attribute djstripe . enums . FilePurpose . selfie = _ ( 'Selfie (Stripe Identity)' ) class-attribute djstripe . enums . FilePurpose . sigma_scheduled_query = _ ( 'Sigma scheduled query' ) class-attribute djstripe . enums . FilePurpose . tax_document_user_upload = _ ( 'Tax document user upload' ) class-attribute djstripe.enums.FileType Bases: Enum Source code in djstripe/enums.py 395 396 397 398 399 400 401 402 class FileType ( Enum ): pdf = _ ( \"PDF\" ) jpg = _ ( \"JPG\" ) png = _ ( \"PNG\" ) csv = _ ( \"CSV\" ) xls = _ ( \"XLS\" ) xlsx = _ ( \"XLSX\" ) docx = _ ( \"DOCX\" ) Attributes djstripe . enums . FileType . csv = _ ( 'CSV' ) class-attribute djstripe . enums . FileType . docx = _ ( 'DOCX' ) class-attribute djstripe . enums . FileType . jpg = _ ( 'JPG' ) class-attribute djstripe . enums . FileType . pdf = _ ( 'PDF' ) class-attribute djstripe . enums . FileType . png = _ ( 'PNG' ) class-attribute djstripe . enums . FileType . xls = _ ( 'XLS' ) class-attribute djstripe . enums . FileType . xlsx = _ ( 'XLSX' ) class-attribute djstripe.enums.IntentStatus Bases: Enum Status of Intents which apply both to PaymentIntents and SetupIntents. Source code in djstripe/enums.py 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 class IntentStatus ( Enum ): \"\"\" Status of Intents which apply both to PaymentIntents and SetupIntents. \"\"\" requires_payment_method = _ ( \"Intent created and requires a Payment Method to be attached.\" ) requires_confirmation = _ ( \"Intent is ready to be confirmed.\" ) requires_action = _ ( \"Payment Method require additional action, such as 3D secure.\" ) processing = _ ( \"Required actions have been handled.\" ) canceled = _ ( \"Cancellation invalidates the intent for future confirmation and \" \"cannot be undone.\" ) Attributes djstripe . enums . IntentStatus . canceled = _ ( 'Cancellation invalidates the intent for future confirmation and cannot be undone.' ) class-attribute djstripe . enums . IntentStatus . processing = _ ( 'Required actions have been handled.' ) class-attribute djstripe . enums . IntentStatus . requires_action = _ ( 'Payment Method require additional action, such as 3D secure.' ) class-attribute djstripe . enums . IntentStatus . requires_confirmation = _ ( 'Intent is ready to be confirmed.' ) class-attribute djstripe . enums . IntentStatus . requires_payment_method = _ ( 'Intent created and requires a Payment Method to be attached.' ) class-attribute djstripe.enums.IntentUsage Bases: Enum Source code in djstripe/enums.py 435 436 437 class IntentUsage ( Enum ): on_session = _ ( \"On session\" ) off_session = _ ( \"Off session\" ) Attributes djstripe . enums . IntentUsage . off_session = _ ( 'Off session' ) class-attribute djstripe . enums . IntentUsage . on_session = _ ( 'On session' ) class-attribute djstripe.enums.InvoiceBillingReason Bases: Enum Source code in djstripe/enums.py 405 406 407 408 409 410 411 412 413 class InvoiceBillingReason ( Enum ): subscription_cycle = _ ( \"Subscription cycle\" ) subscription_create = _ ( \"Subscription create\" ) subscription_update = _ ( \"Subscription update\" ) subscription = _ ( \"Subscription\" ) manual = _ ( \"Manual\" ) upcoming = _ ( \"Upcoming\" ) subscription_threshold = _ ( \"Subscription threshold\" ) automatic_pending_invoice_item_invoice = _ ( \"Automatic pending invoice item invoice\" ) Attributes djstripe . enums . InvoiceBillingReason . automatic_pending_invoice_item_invoice = _ ( 'Automatic pending invoice item invoice' ) class-attribute djstripe . enums . InvoiceBillingReason . manual = _ ( 'Manual' ) class-attribute djstripe . enums . InvoiceBillingReason . subscription = _ ( 'Subscription' ) class-attribute djstripe . enums . InvoiceBillingReason . subscription_create = _ ( 'Subscription create' ) class-attribute djstripe . enums . InvoiceBillingReason . subscription_cycle = _ ( 'Subscription cycle' ) class-attribute djstripe . enums . InvoiceBillingReason . subscription_threshold = _ ( 'Subscription threshold' ) class-attribute djstripe . enums . InvoiceBillingReason . subscription_update = _ ( 'Subscription update' ) class-attribute djstripe . enums . InvoiceBillingReason . upcoming = _ ( 'Upcoming' ) class-attribute djstripe.enums.InvoiceCollectionMethod Bases: Enum Source code in djstripe/enums.py 416 417 418 class InvoiceCollectionMethod ( Enum ): charge_automatically = _ ( \"Charge automatically\" ) send_invoice = _ ( \"Send invoice\" ) Attributes djstripe . enums . InvoiceCollectionMethod . charge_automatically = _ ( 'Charge automatically' ) class-attribute djstripe . enums . InvoiceCollectionMethod . send_invoice = _ ( 'Send invoice' ) class-attribute djstripe.enums.InvoiceStatus Bases: Enum Source code in djstripe/enums.py 421 422 423 424 425 426 class InvoiceStatus ( Enum ): draft = _ ( \"Draft\" ) open = _ ( \"Open\" ) paid = _ ( \"Paid\" ) uncollectible = _ ( \"Uncollectible\" ) void = _ ( \"Void\" ) Attributes djstripe . enums . InvoiceStatus . draft = _ ( 'Draft' ) class-attribute djstripe . enums . InvoiceStatus . open = _ ( 'Open' ) class-attribute djstripe . enums . InvoiceStatus . paid = _ ( 'Paid' ) class-attribute djstripe . enums . InvoiceStatus . uncollectible = _ ( 'Uncollectible' ) class-attribute djstripe . enums . InvoiceStatus . void = _ ( 'Void' ) class-attribute djstripe.enums.InvoiceorLineItemType Bases: Enum Source code in djstripe/enums.py 429 430 431 432 class InvoiceorLineItemType ( Enum ): invoice_item = _ ( \"Invoice Item\" ) line_item = _ ( \"Line Item\" ) unsupported = _ ( \"Unsupported\" ) Attributes djstripe . enums . InvoiceorLineItemType . invoice_item = _ ( 'Invoice Item' ) class-attribute djstripe . enums . InvoiceorLineItemType . line_item = _ ( 'Line Item' ) class-attribute djstripe . enums . InvoiceorLineItemType . unsupported = _ ( 'Unsupported' ) class-attribute djstripe.enums.LegacySourceType Bases: Enum Source code in djstripe/enums.py 708 709 710 711 712 class LegacySourceType ( Enum ): card = _ ( \"Card\" ) bank_account = _ ( \"Bank account\" ) bitcoin_receiver = _ ( \"Bitcoin receiver\" ) alipay_account = _ ( \"Alipay account\" ) Attributes djstripe . enums . LegacySourceType . alipay_account = _ ( 'Alipay account' ) class-attribute djstripe . enums . LegacySourceType . bank_account = _ ( 'Bank account' ) class-attribute djstripe . enums . LegacySourceType . bitcoin_receiver = _ ( 'Bitcoin receiver' ) class-attribute djstripe . enums . LegacySourceType . card = _ ( 'Card' ) class-attribute djstripe.enums.LineItem Bases: Enum Source code in djstripe/enums.py 458 459 460 class LineItem ( Enum ): invoiceitem = _ ( \"Invoice Item\" ) subscription = _ ( \"Subscription\" ) Attributes djstripe . enums . LineItem . invoiceitem = _ ( 'Invoice Item' ) class-attribute djstripe . enums . LineItem . subscription = _ ( 'Subscription' ) class-attribute djstripe.enums.MandateStatus Bases: Enum Source code in djstripe/enums.py 463 464 465 466 class MandateStatus ( Enum ): active = _ ( \"Active\" ) inactive = _ ( \"Inactive\" ) pending = _ ( \"Pending\" ) Attributes djstripe . enums . MandateStatus . active = _ ( 'Active' ) class-attribute djstripe . enums . MandateStatus . inactive = _ ( 'Inactive' ) class-attribute djstripe . enums . MandateStatus . pending = _ ( 'Pending' ) class-attribute djstripe.enums.MandateType Bases: Enum Source code in djstripe/enums.py 469 470 471 class MandateType ( Enum ): multi_use = _ ( \"Multi-use\" ) single_use = _ ( \"Single-use\" ) Attributes djstripe . enums . MandateType . multi_use = _ ( 'Multi-use' ) class-attribute djstripe . enums . MandateType . single_use = _ ( 'Single-use' ) class-attribute djstripe.enums.OrderStatus Bases: Enum Source code in djstripe/enums.py 474 475 476 477 478 479 class OrderStatus ( Enum ): open = _ ( \"Open\" ) submitted = _ ( \"Submitted\" ) processing = _ ( \"Processing\" ) complete = _ ( \"Complete\" ) canceled = _ ( \"Canceled\" ) Attributes djstripe . enums . OrderStatus . canceled = _ ( 'Canceled' ) class-attribute djstripe . enums . OrderStatus . complete = _ ( 'Complete' ) class-attribute djstripe . enums . OrderStatus . open = _ ( 'Open' ) class-attribute djstripe . enums . OrderStatus . processing = _ ( 'Processing' ) class-attribute djstripe . enums . OrderStatus . submitted = _ ( 'Submitted' ) class-attribute djstripe.enums.PaymentIntentCancellationReason Bases: Enum Source code in djstripe/enums.py 604 605 606 607 608 609 610 611 612 613 614 class PaymentIntentCancellationReason ( Enum ): # see also SetupIntentCancellationReason # User provided reasons: duplicate = _ ( \"Duplicate\" ) fraudulent = _ ( \"Fraudulent\" ) abandoned = _ ( \"Abandoned\" ) requested_by_customer = _ ( \"Requested by Customer\" ) # Reasons generated by Stripe internally failed_invoice = _ ( \"Failed invoice\" ) void_invoice = _ ( \"Void invoice\" ) automatic = _ ( \"Automatic\" ) Attributes djstripe . enums . PaymentIntentCancellationReason . abandoned = _ ( 'Abandoned' ) class-attribute djstripe . enums . PaymentIntentCancellationReason . automatic = _ ( 'Automatic' ) class-attribute djstripe . enums . PaymentIntentCancellationReason . duplicate = _ ( 'Duplicate' ) class-attribute djstripe . enums . PaymentIntentCancellationReason . failed_invoice = _ ( 'Failed invoice' ) class-attribute djstripe . enums . PaymentIntentCancellationReason . fraudulent = _ ( 'Fraudulent' ) class-attribute djstripe . enums . PaymentIntentCancellationReason . requested_by_customer = _ ( 'Requested by Customer' ) class-attribute djstripe . enums . PaymentIntentCancellationReason . void_invoice = _ ( 'Void invoice' ) class-attribute djstripe.enums.PaymentIntentStatus Bases: Enum Source code in djstripe/enums.py 484 485 486 487 488 489 490 491 492 493 494 495 496 class PaymentIntentStatus ( Enum ): requires_payment_method = _ ( \"Intent created and requires a Payment Method to be attached.\" ) requires_confirmation = _ ( \"Intent is ready to be confirmed.\" ) requires_action = _ ( \"Payment Method require additional action, such as 3D secure.\" ) processing = _ ( \"Required actions have been handled.\" ) requires_capture = _ ( \"Capture the funds on the cards which have been put on holds.\" ) canceled = _ ( \"Cancellation invalidates the intent for future confirmation and \" \"cannot be undone.\" ) succeeded = _ ( \"The funds are in your account.\" ) Attributes djstripe . enums . PaymentIntentStatus . canceled = _ ( 'Cancellation invalidates the intent for future confirmation and cannot be undone.' ) class-attribute djstripe . enums . PaymentIntentStatus . processing = _ ( 'Required actions have been handled.' ) class-attribute djstripe . enums . PaymentIntentStatus . requires_action = _ ( 'Payment Method require additional action, such as 3D secure.' ) class-attribute djstripe . enums . PaymentIntentStatus . requires_capture = _ ( 'Capture the funds on the cards which have been put on holds.' ) class-attribute djstripe . enums . PaymentIntentStatus . requires_confirmation = _ ( 'Intent is ready to be confirmed.' ) class-attribute djstripe . enums . PaymentIntentStatus . requires_payment_method = _ ( 'Intent created and requires a Payment Method to be attached.' ) class-attribute djstripe . enums . PaymentIntentStatus . succeeded = _ ( 'The funds are in your account.' ) class-attribute djstripe.enums.PaymentMethodType Bases: Enum Source code in djstripe/enums.py 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 class PaymentMethodType ( Enum ): acss_debit = _ ( \"Acss Dbit\" ) affirm = _ ( \"Affirm\" ) afterpay_clearpay = _ ( \"Afterpay Clearpay\" ) alipay = _ ( \"Alipay\" ) au_becs_debit = _ ( \"BECS Debit (Australia)\" ) bacs_debit = _ ( \"Bacs Direct Debit\" ) bancontact = _ ( \"Bancontact\" ) blik = _ ( \"BLIK\" ) boleto = _ ( \"Boleto\" ) card = _ ( \"Card\" ) card_present = _ ( \"Card present\" ) customer_balance = _ ( \"Customer Balance\" ) eps = _ ( \"EPS\" ) fpx = _ ( \"FPX\" ) giropay = _ ( \"Giropay\" ) grabpay = _ ( \"Grabpay\" ) ideal = _ ( \"iDEAL\" ) interac_present = _ ( \"Interac (card present)\" ) klarna = _ ( \"Klarna\" ) konbini = _ ( \"Konbini\" ) link = _ ( \"Link\" ) oxxo = _ ( \"OXXO\" ) p24 = _ ( \"Przelewy24\" ) paynow = _ ( \"PayNow\" ) pix = _ ( \"Pix\" ) promptpay = _ ( \"PromptPay\" ) sepa_debit = _ ( \"SEPA Direct Debit\" ) sofort = _ ( \"SOFORT\" ) us_bank_account = _ ( \"ACH Direct Debit\" ) wechat_pay = _ ( \"Wechat Pay\" ) Attributes djstripe . enums . PaymentMethodType . acss_debit = _ ( 'Acss Dbit' ) class-attribute djstripe . enums . PaymentMethodType . affirm = _ ( 'Affirm' ) class-attribute djstripe . enums . PaymentMethodType . afterpay_clearpay = _ ( 'Afterpay Clearpay' ) class-attribute djstripe . enums . PaymentMethodType . alipay = _ ( 'Alipay' ) class-attribute djstripe . enums . PaymentMethodType . au_becs_debit = _ ( 'BECS Debit (Australia)' ) class-attribute djstripe . enums . PaymentMethodType . bacs_debit = _ ( 'Bacs Direct Debit' ) class-attribute djstripe . enums . PaymentMethodType . bancontact = _ ( 'Bancontact' ) class-attribute djstripe . enums . PaymentMethodType . blik = _ ( 'BLIK' ) class-attribute djstripe . enums . PaymentMethodType . boleto = _ ( 'Boleto' ) class-attribute djstripe . enums . PaymentMethodType . card = _ ( 'Card' ) class-attribute djstripe . enums . PaymentMethodType . card_present = _ ( 'Card present' ) class-attribute djstripe . enums . PaymentMethodType . customer_balance = _ ( 'Customer Balance' ) class-attribute djstripe . enums . PaymentMethodType . eps = _ ( 'EPS' ) class-attribute djstripe . enums . PaymentMethodType . fpx = _ ( 'FPX' ) class-attribute djstripe . enums . PaymentMethodType . giropay = _ ( 'Giropay' ) class-attribute djstripe . enums . PaymentMethodType . grabpay = _ ( 'Grabpay' ) class-attribute djstripe . enums . PaymentMethodType . ideal = _ ( 'iDEAL' ) class-attribute djstripe . enums . PaymentMethodType . interac_present = _ ( 'Interac (card present)' ) class-attribute djstripe . enums . PaymentMethodType . klarna = _ ( 'Klarna' ) class-attribute djstripe . enums . PaymentMethodType . konbini = _ ( 'Konbini' ) class-attribute djstripe . enums . PaymentMethodType . link = _ ( 'Link' ) class-attribute djstripe . enums . PaymentMethodType . oxxo = _ ( 'OXXO' ) class-attribute djstripe . enums . PaymentMethodType . p24 = _ ( 'Przelewy24' ) class-attribute djstripe . enums . PaymentMethodType . paynow = _ ( 'PayNow' ) class-attribute djstripe . enums . PaymentMethodType . pix = _ ( 'Pix' ) class-attribute djstripe . enums . PaymentMethodType . promptpay = _ ( 'PromptPay' ) class-attribute djstripe . enums . PaymentMethodType . sepa_debit = _ ( 'SEPA Direct Debit' ) class-attribute djstripe . enums . PaymentMethodType . sofort = _ ( 'SOFORT' ) class-attribute djstripe . enums . PaymentMethodType . us_bank_account = _ ( 'ACH Direct Debit' ) class-attribute djstripe . enums . PaymentMethodType . wechat_pay = _ ( 'Wechat Pay' ) class-attribute djstripe.enums.PayoutFailureCode Bases: Enum Payout failure error codes. https://stripe.com/docs/api#payout_failures Source code in djstripe/enums.py 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 class PayoutFailureCode ( Enum ): \"\"\" Payout failure error codes. https://stripe.com/docs/api#payout_failures \"\"\" account_closed = _ ( \"Bank account has been closed.\" ) account_frozen = _ ( \"Bank account has been frozen.\" ) bank_account_restricted = _ ( \"Bank account has restrictions on payouts allowed.\" ) bank_ownership_changed = _ ( \"Destination bank account has changed ownership.\" ) could_not_process = _ ( \"Bank could not process payout.\" ) debit_not_authorized = _ ( \"Debit transactions not approved on the bank account.\" ) declined = _ ( \"The bank has declined this transfer. Please contact the bank before retrying.\" ) insufficient_funds = _ ( \"Stripe account has insufficient funds.\" ) invalid_account_number = _ ( \"Invalid account number\" ) incorrect_account_holder_name = _ ( \"Your bank notified us that the bank account holder name on file is incorrect.\" ) incorrect_account_holder_address = _ ( \"Your bank notified us that the bank account holder address on file is incorrect.\" ) incorrect_account_holder_tax_id = _ ( \"Your bank notified us that the bank account holder tax ID on file is incorrect.\" ) invalid_currency = _ ( \"Bank account does not support currency.\" ) no_account = _ ( \"Bank account could not be located.\" ) unsupported_card = _ ( \"Card no longer supported.\" ) Attributes djstripe . enums . PayoutFailureCode . account_closed = _ ( 'Bank account has been closed.' ) class-attribute djstripe . enums . PayoutFailureCode . account_frozen = _ ( 'Bank account has been frozen.' ) class-attribute djstripe . enums . PayoutFailureCode . bank_account_restricted = _ ( 'Bank account has restrictions on payouts allowed.' ) class-attribute djstripe . enums . PayoutFailureCode . bank_ownership_changed = _ ( 'Destination bank account has changed ownership.' ) class-attribute djstripe . enums . PayoutFailureCode . could_not_process = _ ( 'Bank could not process payout.' ) class-attribute djstripe . enums . PayoutFailureCode . debit_not_authorized = _ ( 'Debit transactions not approved on the bank account.' ) class-attribute djstripe . enums . PayoutFailureCode . declined = _ ( 'The bank has declined this transfer. Please contact the bank before retrying.' ) class-attribute djstripe . enums . PayoutFailureCode . incorrect_account_holder_address = _ ( 'Your bank notified us that the bank account holder address on file is incorrect.' ) class-attribute djstripe . enums . PayoutFailureCode . incorrect_account_holder_name = _ ( 'Your bank notified us that the bank account holder name on file is incorrect.' ) class-attribute djstripe . enums . PayoutFailureCode . incorrect_account_holder_tax_id = _ ( 'Your bank notified us that the bank account holder tax ID on file is incorrect.' ) class-attribute djstripe . enums . PayoutFailureCode . insufficient_funds = _ ( 'Stripe account has insufficient funds.' ) class-attribute djstripe . enums . PayoutFailureCode . invalid_account_number = _ ( 'Invalid account number' ) class-attribute djstripe . enums . PayoutFailureCode . invalid_currency = _ ( 'Bank account does not support currency.' ) class-attribute djstripe . enums . PayoutFailureCode . no_account = _ ( 'Bank account could not be located.' ) class-attribute djstripe . enums . PayoutFailureCode . unsupported_card = _ ( 'Card no longer supported.' ) class-attribute djstripe.enums.PayoutMethod Bases: Enum Source code in djstripe/enums.py 580 581 582 class PayoutMethod ( Enum ): standard = _ ( \"Standard\" ) instant = _ ( \"Instant\" ) Attributes djstripe . enums . PayoutMethod . instant = _ ( 'Instant' ) class-attribute djstripe . enums . PayoutMethod . standard = _ ( 'Standard' ) class-attribute djstripe.enums.PayoutSourceType Bases: Enum Source code in djstripe/enums.py 585 586 587 588 class PayoutSourceType ( Enum ): bank_account = _ ( \"Bank account\" ) fpx = _ ( \"Financial Process Exchange (FPX)\" ) card = _ ( \"Card\" ) Attributes djstripe . enums . PayoutSourceType . bank_account = _ ( 'Bank account' ) class-attribute djstripe . enums . PayoutSourceType . card = _ ( 'Card' ) class-attribute djstripe . enums . PayoutSourceType . fpx = _ ( 'Financial Process Exchange (FPX)' ) class-attribute djstripe.enums.PayoutStatus Bases: Enum Source code in djstripe/enums.py 591 592 593 594 595 596 class PayoutStatus ( Enum ): paid = _ ( \"Paid\" ) pending = _ ( \"Pending\" ) in_transit = _ ( \"In transit\" ) canceled = _ ( \"Canceled\" ) failed = _ ( \"Failed\" ) Attributes djstripe . enums . PayoutStatus . canceled = _ ( 'Canceled' ) class-attribute djstripe . enums . PayoutStatus . failed = _ ( 'Failed' ) class-attribute djstripe . enums . PayoutStatus . in_transit = _ ( 'In transit' ) class-attribute djstripe . enums . PayoutStatus . paid = _ ( 'Paid' ) class-attribute djstripe . enums . PayoutStatus . pending = _ ( 'Pending' ) class-attribute djstripe.enums.PayoutType Bases: Enum Source code in djstripe/enums.py 599 600 601 class PayoutType ( Enum ): bank_account = _ ( \"Bank account\" ) card = _ ( \"Card\" ) Attributes djstripe . enums . PayoutType . bank_account = _ ( 'Bank account' ) class-attribute djstripe . enums . PayoutType . card = _ ( 'Card' ) class-attribute djstripe.enums.PlanAggregateUsage Bases: Enum Source code in djstripe/enums.py 617 618 619 620 621 class PlanAggregateUsage ( Enum ): last_during_period = _ ( \"Last during period\" ) last_ever = _ ( \"Last ever\" ) max = _ ( \"Max\" ) sum = _ ( \"Sum\" ) Attributes djstripe . enums . PlanAggregateUsage . last_during_period = _ ( 'Last during period' ) class-attribute djstripe . enums . PlanAggregateUsage . last_ever = _ ( 'Last ever' ) class-attribute djstripe . enums . PlanAggregateUsage . max = _ ( 'Max' ) class-attribute djstripe . enums . PlanAggregateUsage . sum = _ ( 'Sum' ) class-attribute djstripe.enums.PlanInterval Bases: Enum Source code in djstripe/enums.py 624 625 626 627 628 class PlanInterval ( Enum ): day = _ ( \"Day\" ) week = _ ( \"Week\" ) month = _ ( \"Month\" ) year = _ ( \"Year\" ) Attributes djstripe . enums . PlanInterval . day = _ ( 'Day' ) class-attribute djstripe . enums . PlanInterval . month = _ ( 'Month' ) class-attribute djstripe . enums . PlanInterval . week = _ ( 'Week' ) class-attribute djstripe . enums . PlanInterval . year = _ ( 'Year' ) class-attribute djstripe.enums.PriceTiersMode Bases: Enum Source code in djstripe/enums.py 631 632 633 class PriceTiersMode ( Enum ): graduated = _ ( \"Graduated\" ) volume = _ ( \"Volume-based\" ) Attributes djstripe . enums . PriceTiersMode . graduated = _ ( 'Graduated' ) class-attribute djstripe . enums . PriceTiersMode . volume = _ ( 'Volume-based' ) class-attribute djstripe.enums.PriceType Bases: Enum Source code in djstripe/enums.py 636 637 638 class PriceType ( Enum ): one_time = _ ( \"One-time\" ) recurring = _ ( \"Recurring\" ) Attributes djstripe . enums . PriceType . one_time = _ ( 'One-time' ) class-attribute djstripe . enums . PriceType . recurring = _ ( 'Recurring' ) class-attribute djstripe.enums.PriceUsageType Bases: Enum Source code in djstripe/enums.py 641 642 643 class PriceUsageType ( Enum ): metered = _ ( \"Metered\" ) licensed = _ ( \"Licensed\" ) Attributes djstripe . enums . PriceUsageType . licensed = _ ( 'Licensed' ) class-attribute djstripe . enums . PriceUsageType . metered = _ ( 'Metered' ) class-attribute djstripe.enums.ProductType Bases: Enum Source code in djstripe/enums.py 651 652 653 class ProductType ( Enum ): good = _ ( \"Good\" ) service = _ ( \"Service\" ) Attributes djstripe . enums . ProductType . good = _ ( 'Good' ) class-attribute djstripe . enums . ProductType . service = _ ( 'Service' ) class-attribute djstripe.enums.RefundFailureReason Bases: Enum Source code in djstripe/enums.py 715 716 717 718 class RefundFailureReason ( Enum ): lost_or_stolen_card = _ ( \"Lost or stolen card\" ) expired_or_canceled_card = _ ( \"Expired or canceled card\" ) unknown = _ ( \"Unknown\" ) Attributes djstripe . enums . RefundFailureReason . expired_or_canceled_card = _ ( 'Expired or canceled card' ) class-attribute djstripe . enums . RefundFailureReason . lost_or_stolen_card = _ ( 'Lost or stolen card' ) class-attribute djstripe . enums . RefundFailureReason . unknown = _ ( 'Unknown' ) class-attribute djstripe.enums.RefundReason Bases: Enum Source code in djstripe/enums.py 721 722 723 724 725 class RefundReason ( Enum ): duplicate = _ ( \"Duplicate charge\" ) fraudulent = _ ( \"Fraudulent\" ) requested_by_customer = _ ( \"Requested by customer\" ) expired_uncaptured_charge = _ ( \"Expired uncaptured charge\" ) Attributes djstripe . enums . RefundReason . duplicate = _ ( 'Duplicate charge' ) class-attribute djstripe . enums . RefundReason . expired_uncaptured_charge = _ ( 'Expired uncaptured charge' ) class-attribute djstripe . enums . RefundReason . fraudulent = _ ( 'Fraudulent' ) class-attribute djstripe . enums . RefundReason . requested_by_customer = _ ( 'Requested by customer' ) class-attribute djstripe.enums.RefundStatus Bases: Enum Source code in djstripe/enums.py 728 729 730 731 732 class RefundStatus ( Enum ): pending = _ ( \"Pending\" ) succeeded = _ ( \"Succeeded\" ) failed = _ ( \"Failed\" ) canceled = _ ( \"Canceled\" ) Attributes djstripe . enums . RefundStatus . canceled = _ ( 'Canceled' ) class-attribute djstripe . enums . RefundStatus . failed = _ ( 'Failed' ) class-attribute djstripe . enums . RefundStatus . pending = _ ( 'Pending' ) class-attribute djstripe . enums . RefundStatus . succeeded = _ ( 'Succeeded' ) class-attribute djstripe.enums.ScheduledQueryRunStatus Bases: Enum Source code in djstripe/enums.py 663 664 665 666 class ScheduledQueryRunStatus ( Enum ): canceled = _ ( \"Canceled\" ) failed = _ ( \"Failed\" ) timed_out = _ ( \"Timed out\" ) Attributes djstripe . enums . ScheduledQueryRunStatus . canceled = _ ( 'Canceled' ) class-attribute djstripe . enums . ScheduledQueryRunStatus . failed = _ ( 'Failed' ) class-attribute djstripe . enums . ScheduledQueryRunStatus . timed_out = _ ( 'Timed out' ) class-attribute djstripe.enums.SessionBillingAddressCollection Bases: Enum Source code in djstripe/enums.py 735 736 737 class SessionBillingAddressCollection ( Enum ): auto = _ ( \"Auto\" ) required = _ ( \"Required\" ) Attributes djstripe . enums . SessionBillingAddressCollection . auto = _ ( 'Auto' ) class-attribute djstripe . enums . SessionBillingAddressCollection . required = _ ( 'Required' ) class-attribute djstripe.enums.SessionMode Bases: Enum Source code in djstripe/enums.py 740 741 742 743 class SessionMode ( Enum ): payment = _ ( \"Payment\" ) setup = _ ( \"Setup\" ) subscription = _ ( \"Subscription\" ) Attributes djstripe . enums . SessionMode . payment = _ ( 'Payment' ) class-attribute djstripe . enums . SessionMode . setup = _ ( 'Setup' ) class-attribute djstripe . enums . SessionMode . subscription = _ ( 'Subscription' ) class-attribute djstripe.enums.SessionPaymentStatus Bases: Enum Source code in djstripe/enums.py 326 327 328 329 class SessionPaymentStatus ( Enum ): paid = _ ( \"Paid\" ) unpaid = _ ( \"Unpaid\" ) no_payment_required = _ ( \"No Payment Required\" ) Attributes djstripe . enums . SessionPaymentStatus . no_payment_required = _ ( 'No Payment Required' ) class-attribute djstripe . enums . SessionPaymentStatus . paid = _ ( 'Paid' ) class-attribute djstripe . enums . SessionPaymentStatus . unpaid = _ ( 'Unpaid' ) class-attribute djstripe.enums.SessionStatus Bases: Enum Source code in djstripe/enums.py 320 321 322 323 class SessionStatus ( Enum ): open = _ ( \"Open\" ) complete = _ ( \"Complete\" ) expired = _ ( \"Expired\" ) Attributes djstripe . enums . SessionStatus . complete = _ ( 'Complete' ) class-attribute djstripe . enums . SessionStatus . expired = _ ( 'Expired' ) class-attribute djstripe . enums . SessionStatus . open = _ ( 'Open' ) class-attribute djstripe.enums.SetupIntentCancellationReason Bases: Enum Source code in djstripe/enums.py 656 657 658 659 660 class SetupIntentCancellationReason ( Enum ): # see also PaymentIntentCancellationReason abandoned = _ ( \"Abandoned\" ) requested_by_customer = _ ( \"Requested by Customer\" ) duplicate = _ ( \"Duplicate\" ) Attributes djstripe . enums . SetupIntentCancellationReason . abandoned = _ ( 'Abandoned' ) class-attribute djstripe . enums . SetupIntentCancellationReason . duplicate = _ ( 'Duplicate' ) class-attribute djstripe . enums . SetupIntentCancellationReason . requested_by_customer = _ ( 'Requested by Customer' ) class-attribute djstripe.enums.SetupIntentStatus Bases: Enum Source code in djstripe/enums.py 499 500 501 502 503 504 505 506 507 508 509 510 511 512 class SetupIntentStatus ( Enum ): requires_payment_method = _ ( \"Intent created and requires a Payment Method to be attached.\" ) requires_confirmation = _ ( \"Intent is ready to be confirmed.\" ) requires_action = _ ( \"Payment Method require additional action, such as 3D secure.\" ) processing = _ ( \"Required actions have been handled.\" ) canceled = _ ( \"Cancellation invalidates the intent for future confirmation and \" \"cannot be undone.\" ) succeeded = _ ( \"Setup was successful and the payment method is optimized for future payments.\" ) Attributes djstripe . enums . SetupIntentStatus . canceled = _ ( 'Cancellation invalidates the intent for future confirmation and cannot be undone.' ) class-attribute djstripe . enums . SetupIntentStatus . processing = _ ( 'Required actions have been handled.' ) class-attribute djstripe . enums . SetupIntentStatus . requires_action = _ ( 'Payment Method require additional action, such as 3D secure.' ) class-attribute djstripe . enums . SetupIntentStatus . requires_confirmation = _ ( 'Intent is ready to be confirmed.' ) class-attribute djstripe . enums . SetupIntentStatus . requires_payment_method = _ ( 'Intent created and requires a Payment Method to be attached.' ) class-attribute djstripe . enums . SetupIntentStatus . succeeded = _ ( 'Setup was successful and the payment method is optimized for future payments.' ) class-attribute djstripe.enums.ShippingRateTaxBehavior Bases: Enum Source code in djstripe/enums.py 810 811 812 813 class ShippingRateTaxBehavior ( Enum ): inclusive = _ ( \"Inclusive\" ) exclusive = _ ( \"Exclusive\" ) unspecified = _ ( \"Unspecified\" ) Attributes djstripe . enums . ShippingRateTaxBehavior . exclusive = _ ( 'Exclusive' ) class-attribute djstripe . enums . ShippingRateTaxBehavior . inclusive = _ ( 'Inclusive' ) class-attribute djstripe . enums . ShippingRateTaxBehavior . unspecified = _ ( 'Unspecified' ) class-attribute djstripe.enums.ShippingRateType Bases: Enum Source code in djstripe/enums.py 806 807 class ShippingRateType ( Enum ): fixed_amount = _ ( \"Fixed Amount\" ) Attributes djstripe . enums . ShippingRateType . fixed_amount = _ ( 'Fixed Amount' ) class-attribute djstripe.enums.SourceCodeVerificationStatus Bases: Enum Source code in djstripe/enums.py 751 752 753 754 class SourceCodeVerificationStatus ( Enum ): pending = _ ( \"Pending\" ) succeeded = _ ( \"Succeeded\" ) failed = _ ( \"Failed\" ) Attributes djstripe . enums . SourceCodeVerificationStatus . failed = _ ( 'Failed' ) class-attribute djstripe . enums . SourceCodeVerificationStatus . pending = _ ( 'Pending' ) class-attribute djstripe . enums . SourceCodeVerificationStatus . succeeded = _ ( 'Succeeded' ) class-attribute djstripe.enums.SourceFlow Bases: Enum Source code in djstripe/enums.py 669 670 671 672 673 class SourceFlow ( Enum ): redirect = _ ( \"Redirect\" ) receiver = _ ( \"Receiver\" ) code_verification = _ ( \"Code verification\" ) none = _ ( \"None\" ) Attributes djstripe . enums . SourceFlow . code_verification = _ ( 'Code verification' ) class-attribute djstripe . enums . SourceFlow . none = _ ( 'None' ) class-attribute djstripe . enums . SourceFlow . receiver = _ ( 'Receiver' ) class-attribute djstripe . enums . SourceFlow . redirect = _ ( 'Redirect' ) class-attribute djstripe.enums.SourceRedirectFailureReason Bases: Enum Source code in djstripe/enums.py 757 758 759 760 class SourceRedirectFailureReason ( Enum ): user_abort = _ ( \"User-aborted\" ) declined = _ ( \"Declined\" ) processing_error = _ ( \"Processing error\" ) Attributes djstripe . enums . SourceRedirectFailureReason . declined = _ ( 'Declined' ) class-attribute djstripe . enums . SourceRedirectFailureReason . processing_error = _ ( 'Processing error' ) class-attribute djstripe . enums . SourceRedirectFailureReason . user_abort = _ ( 'User-aborted' ) class-attribute djstripe.enums.SourceRedirectStatus Bases: Enum Source code in djstripe/enums.py 763 764 765 766 767 class SourceRedirectStatus ( Enum ): pending = _ ( \"Pending\" ) succeeded = _ ( \"Succeeded\" ) not_required = _ ( \"Not required\" ) failed = _ ( \"Failed\" ) Attributes djstripe . enums . SourceRedirectStatus . failed = _ ( 'Failed' ) class-attribute djstripe . enums . SourceRedirectStatus . not_required = _ ( 'Not required' ) class-attribute djstripe . enums . SourceRedirectStatus . pending = _ ( 'Pending' ) class-attribute djstripe . enums . SourceRedirectStatus . succeeded = _ ( 'Succeeded' ) class-attribute djstripe.enums.SourceStatus Bases: Enum Source code in djstripe/enums.py 676 677 678 679 680 681 class SourceStatus ( Enum ): canceled = _ ( \"Canceled\" ) chargeable = _ ( \"Chargeable\" ) consumed = _ ( \"Consumed\" ) failed = _ ( \"Failed\" ) pending = _ ( \"Pending\" ) Attributes djstripe . enums . SourceStatus . canceled = _ ( 'Canceled' ) class-attribute djstripe . enums . SourceStatus . chargeable = _ ( 'Chargeable' ) class-attribute djstripe . enums . SourceStatus . consumed = _ ( 'Consumed' ) class-attribute djstripe . enums . SourceStatus . failed = _ ( 'Failed' ) class-attribute djstripe . enums . SourceStatus . pending = _ ( 'Pending' ) class-attribute djstripe.enums.SourceType Bases: Enum Source code in djstripe/enums.py 684 685 686 687 688 689 690 691 692 693 694 695 696 697 698 699 700 701 702 703 704 705 class SourceType ( Enum ): ach_credit_transfer = _ ( \"ACH Credit Transfer\" ) ach_debit = _ ( \"ACH Debit\" ) acss_debit = _ ( \"ACSS Debit\" ) alipay = _ ( \"Alipay\" ) au_becs_debit = _ ( \"BECS Debit (AU)\" ) bancontact = _ ( \"Bancontact\" ) bitcoin = _ ( \"Bitcoin (Legacy)\" ) card = _ ( \"Card\" ) card_present = _ ( \"Card present\" ) eps = _ ( \"EPS\" ) giropay = _ ( \"Giropay\" ) ideal = _ ( \"iDEAL\" ) klarna = _ ( \"Klarna\" ) multibanco = _ ( \"Multibanco\" ) p24 = _ ( \"P24\" ) paper_check = _ ( \"Paper check\" ) sepa_credit_transfer = _ ( \"SEPA credit transfer\" ) sepa_debit = _ ( \"SEPA Direct Debit\" ) sofort = _ ( \"SOFORT\" ) three_d_secure = _ ( \"3D Secure\" ) wechat = _ ( \"WeChat\" ) Attributes djstripe . enums . SourceType . ach_credit_transfer = _ ( 'ACH Credit Transfer' ) class-attribute djstripe . enums . SourceType . ach_debit = _ ( 'ACH Debit' ) class-attribute djstripe . enums . SourceType . acss_debit = _ ( 'ACSS Debit' ) class-attribute djstripe . enums . SourceType . alipay = _ ( 'Alipay' ) class-attribute djstripe . enums . SourceType . au_becs_debit = _ ( 'BECS Debit (AU)' ) class-attribute djstripe . enums . SourceType . bancontact = _ ( 'Bancontact' ) class-attribute djstripe . enums . SourceType . bitcoin = _ ( 'Bitcoin (Legacy)' ) class-attribute djstripe . enums . SourceType . card = _ ( 'Card' ) class-attribute djstripe . enums . SourceType . card_present = _ ( 'Card present' ) class-attribute djstripe . enums . SourceType . eps = _ ( 'EPS' ) class-attribute djstripe . enums . SourceType . giropay = _ ( 'Giropay' ) class-attribute djstripe . enums . SourceType . ideal = _ ( 'iDEAL' ) class-attribute djstripe . enums . SourceType . klarna = _ ( 'Klarna' ) class-attribute djstripe . enums . SourceType . multibanco = _ ( 'Multibanco' ) class-attribute djstripe . enums . SourceType . p24 = _ ( 'P24' ) class-attribute djstripe . enums . SourceType . paper_check = _ ( 'Paper check' ) class-attribute djstripe . enums . SourceType . sepa_credit_transfer = _ ( 'SEPA credit transfer' ) class-attribute djstripe . enums . SourceType . sepa_debit = _ ( 'SEPA Direct Debit' ) class-attribute djstripe . enums . SourceType . sofort = _ ( 'SOFORT' ) class-attribute djstripe . enums . SourceType . three_d_secure = _ ( '3D Secure' ) class-attribute djstripe . enums . SourceType . wechat = _ ( 'WeChat' ) class-attribute djstripe.enums.SourceUsage Bases: Enum Source code in djstripe/enums.py 746 747 748 class SourceUsage ( Enum ): reusable = _ ( \"Reusable\" ) single_use = _ ( \"Single-use\" ) Attributes djstripe . enums . SourceUsage . reusable = _ ( 'Reusable' ) class-attribute djstripe . enums . SourceUsage . single_use = _ ( 'Single-use' ) class-attribute djstripe.enums.SubmitTypeStatus Bases: Enum Source code in djstripe/enums.py 770 771 772 773 774 class SubmitTypeStatus ( Enum ): auto = _ ( \"Auto\" ) book = _ ( \"Book\" ) donate = _ ( \"donate\" ) pay = _ ( \"pay\" ) Attributes djstripe . enums . SubmitTypeStatus . auto = _ ( 'Auto' ) class-attribute djstripe . enums . SubmitTypeStatus . book = _ ( 'Book' ) class-attribute djstripe . enums . SubmitTypeStatus . donate = _ ( 'donate' ) class-attribute djstripe . enums . SubmitTypeStatus . pay = _ ( 'pay' ) class-attribute djstripe.enums.SubscriptionProrationBehavior Bases: Enum Source code in djstripe/enums.py 800 801 802 803 class SubscriptionProrationBehavior ( Enum ): create_prorations = _ ( \"Create prorations\" ) always_invoice = _ ( \"Always invoice\" ) none = _ ( \"None\" ) Attributes djstripe . enums . SubscriptionProrationBehavior . always_invoice = _ ( 'Always invoice' ) class-attribute djstripe . enums . SubscriptionProrationBehavior . create_prorations = _ ( 'Create prorations' ) class-attribute djstripe . enums . SubscriptionProrationBehavior . none = _ ( 'None' ) class-attribute djstripe.enums.SubscriptionScheduleEndBehavior Bases: Enum Source code in djstripe/enums.py 777 778 779 class SubscriptionScheduleEndBehavior ( Enum ): release = _ ( \"Release\" ) cancel = _ ( \"Cancel\" ) Attributes djstripe . enums . SubscriptionScheduleEndBehavior . cancel = _ ( 'Cancel' ) class-attribute djstripe . enums . SubscriptionScheduleEndBehavior . release = _ ( 'Release' ) class-attribute djstripe.enums.SubscriptionScheduleStatus Bases: Enum Source code in djstripe/enums.py 782 783 784 785 786 787 class SubscriptionScheduleStatus ( Enum ): not_started = _ ( \"Not started\" ) active = _ ( \"Active\" ) completed = _ ( \"Completed\" ) released = _ ( \"Released\" ) canceled = _ ( \"Canceled\" ) Attributes djstripe . enums . SubscriptionScheduleStatus . active = _ ( 'Active' ) class-attribute djstripe . enums . SubscriptionScheduleStatus . canceled = _ ( 'Canceled' ) class-attribute djstripe . enums . SubscriptionScheduleStatus . completed = _ ( 'Completed' ) class-attribute djstripe . enums . SubscriptionScheduleStatus . not_started = _ ( 'Not started' ) class-attribute djstripe . enums . SubscriptionScheduleStatus . released = _ ( 'Released' ) class-attribute djstripe.enums.SubscriptionStatus Bases: Enum Source code in djstripe/enums.py 790 791 792 793 794 795 796 797 class SubscriptionStatus ( Enum ): incomplete = _ ( \"Incomplete\" ) incomplete_expired = _ ( \"Incomplete Expired\" ) trialing = _ ( \"Trialing\" ) active = _ ( \"Active\" ) past_due = _ ( \"Past due\" ) canceled = _ ( \"Canceled\" ) unpaid = _ ( \"Unpaid\" ) Attributes djstripe . enums . SubscriptionStatus . active = _ ( 'Active' ) class-attribute djstripe . enums . SubscriptionStatus . canceled = _ ( 'Canceled' ) class-attribute djstripe . enums . SubscriptionStatus . incomplete = _ ( 'Incomplete' ) class-attribute djstripe . enums . SubscriptionStatus . incomplete_expired = _ ( 'Incomplete Expired' ) class-attribute djstripe . enums . SubscriptionStatus . past_due = _ ( 'Past due' ) class-attribute djstripe . enums . SubscriptionStatus . trialing = _ ( 'Trialing' ) class-attribute djstripe . enums . SubscriptionStatus . unpaid = _ ( 'Unpaid' ) class-attribute djstripe.enums.TaxIdType Bases: Enum Source code in djstripe/enums.py 816 817 818 819 820 821 822 823 824 825 826 827 828 829 830 831 832 833 834 835 836 837 838 839 840 841 842 843 844 845 846 847 848 849 class TaxIdType ( Enum ): ae_trn = _ ( \"AE TRN\" ) au_abn = _ ( \"AU ABN\" ) br_cnp = _ ( \"BR CNP\" ) br_cpf = _ ( \"BR CPF\" ) ca_bn = _ ( \"CA BN\" ) ca_qst = _ ( \"CA QST\" ) ch_vat = _ ( \"CH VAT\" ) cl_tin = _ ( \"CL TIN\" ) es_cif = _ ( \"ES CIF\" ) eu_vat = _ ( \"EU VAT\" ) hk_br = _ ( \"HK BR\" ) id_npw = _ ( \"ID NPW\" ) in_gst = _ ( \"IN GST\" ) jp_cn = _ ( \"JP CN\" ) jp_rn = _ ( \"JP RN\" ) kr_brn = _ ( \"KR BRN\" ) li_uid = _ ( \"LI UID\" ) mx_rfc = _ ( \"MX RFC\" ) my_frp = _ ( \"MY FRP\" ) my_itn = _ ( \"MY ITN\" ) my_sst = _ ( \"MY SST\" ) no_vat = _ ( \"NO VAT\" ) nz_gst = _ ( \"NZ GST\" ) ru_inn = _ ( \"RU INN\" ) ru_kpp = _ ( \"RU KPP\" ) sa_vat = _ ( \"SA VAT\" ) sg_gst = _ ( \"SG GST\" ) sg_uen = _ ( \"SG UEN\" ) th_vat = _ ( \"TH VAT\" ) tw_vat = _ ( \"TW VAT\" ) us_ein = _ ( \"US EIN\" ) za_vat = _ ( \"ZA VAT\" ) unknown = _ ( \"Unknown\" ) Attributes djstripe . enums . TaxIdType . ae_trn = _ ( 'AE TRN' ) class-attribute djstripe . enums . TaxIdType . au_abn = _ ( 'AU ABN' ) class-attribute djstripe . enums . TaxIdType . br_cnp = _ ( 'BR CNP' ) class-attribute djstripe . enums . TaxIdType . br_cpf = _ ( 'BR CPF' ) class-attribute djstripe . enums . TaxIdType . ca_bn = _ ( 'CA BN' ) class-attribute djstripe . enums . TaxIdType . ca_qst = _ ( 'CA QST' ) class-attribute djstripe . enums . TaxIdType . ch_vat = _ ( 'CH VAT' ) class-attribute djstripe . enums . TaxIdType . cl_tin = _ ( 'CL TIN' ) class-attribute djstripe . enums . TaxIdType . es_cif = _ ( 'ES CIF' ) class-attribute djstripe . enums . TaxIdType . eu_vat = _ ( 'EU VAT' ) class-attribute djstripe . enums . TaxIdType . hk_br = _ ( 'HK BR' ) class-attribute djstripe . enums . TaxIdType . id_npw = _ ( 'ID NPW' ) class-attribute djstripe . enums . TaxIdType . in_gst = _ ( 'IN GST' ) class-attribute djstripe . enums . TaxIdType . jp_cn = _ ( 'JP CN' ) class-attribute djstripe . enums . TaxIdType . jp_rn = _ ( 'JP RN' ) class-attribute djstripe . enums . TaxIdType . kr_brn = _ ( 'KR BRN' ) class-attribute djstripe . enums . TaxIdType . li_uid = _ ( 'LI UID' ) class-attribute djstripe . enums . TaxIdType . mx_rfc = _ ( 'MX RFC' ) class-attribute djstripe . enums . TaxIdType . my_frp = _ ( 'MY FRP' ) class-attribute djstripe . enums . TaxIdType . my_itn = _ ( 'MY ITN' ) class-attribute djstripe . enums . TaxIdType . my_sst = _ ( 'MY SST' ) class-attribute djstripe . enums . TaxIdType . no_vat = _ ( 'NO VAT' ) class-attribute djstripe . enums . TaxIdType . nz_gst = _ ( 'NZ GST' ) class-attribute djstripe . enums . TaxIdType . ru_inn = _ ( 'RU INN' ) class-attribute djstripe . enums . TaxIdType . ru_kpp = _ ( 'RU KPP' ) class-attribute djstripe . enums . TaxIdType . sa_vat = _ ( 'SA VAT' ) class-attribute djstripe . enums . TaxIdType . sg_gst = _ ( 'SG GST' ) class-attribute djstripe . enums . TaxIdType . sg_uen = _ ( 'SG UEN' ) class-attribute djstripe . enums . TaxIdType . th_vat = _ ( 'TH VAT' ) class-attribute djstripe . enums . TaxIdType . tw_vat = _ ( 'TW VAT' ) class-attribute djstripe . enums . TaxIdType . unknown = _ ( 'Unknown' ) class-attribute djstripe . enums . TaxIdType . us_ein = _ ( 'US EIN' ) class-attribute djstripe . enums . TaxIdType . za_vat = _ ( 'ZA VAT' ) class-attribute djstripe.enums.UsageAction Bases: Enum Source code in djstripe/enums.py 852 853 854 class UsageAction ( Enum ): increment = _ ( \"increment\" ) set = _ ( \"set\" ) Attributes djstripe . enums . UsageAction . increment = _ ( 'increment' ) class-attribute djstripe . enums . UsageAction . set = _ ( 'set' ) class-attribute djstripe.enums.WebhookEndpointStatus Bases: Enum Source code in djstripe/enums.py 857 858 859 class WebhookEndpointStatus ( Enum ): enabled = _ ( \"enabled\" ) disabled = _ ( \"disabled\" ) Attributes djstripe . enums . WebhookEndpointStatus . disabled = _ ( 'disabled' ) class-attribute djstripe . enums . WebhookEndpointStatus . enabled = _ ( 'enabled' ) class-attribute","title":"Enumerations"},{"location":"reference/enums/#enumerations","text":"","title":"Enumerations"},{"location":"reference/enums/#djstripe.enums-attributes","text":"","title":"Attributes"},{"location":"reference/enums/#djstripe.enums.PlanTiersMode","text":"","title":"PlanTiersMode"},{"location":"reference/enums/#djstripe.enums.PlanUsageType","text":"","title":"PlanUsageType"},{"location":"reference/enums/#djstripe.enums-classes","text":"","title":"Classes"},{"location":"reference/enums/#djstripe.enums.APIKeyType","text":"Bases: Enum API Key Types (internal model only) Source code in djstripe/enums.py 58 59 60 61 62 63 64 65 class APIKeyType ( Enum ): \"\"\" API Key Types (internal model only) \"\"\" publishable = _ ( \"Publishable key\" ) secret = _ ( \"Secret key\" ) restricted = _ ( \"Restricted key\" )","title":"APIKeyType"},{"location":"reference/enums/#djstripe.enums.APIKeyType-attributes","text":"","title":"Attributes"},{"location":"reference/enums/#djstripe.enums.APIKeyType.publishable","text":"","title":"publishable"},{"location":"reference/enums/#djstripe.enums.APIKeyType.restricted","text":"","title":"restricted"},{"location":"reference/enums/#djstripe.enums.APIKeyType.secret","text":"","title":"secret"},{"location":"reference/enums/#djstripe.enums.AccountType","text":"Bases: Enum Source code in djstripe/enums.py 168 169 170 171 class AccountType ( Enum ): standard = _ ( \"Standard\" ) express = _ ( \"Express\" ) custom = _ ( \"Custom\" )","title":"AccountType"},{"location":"reference/enums/#djstripe.enums.AccountType-attributes","text":"","title":"Attributes"},{"location":"reference/enums/#djstripe.enums.AccountType.custom","text":"","title":"custom"},{"location":"reference/enums/#djstripe.enums.AccountType.express","text":"","title":"express"},{"location":"reference/enums/#djstripe.enums.AccountType.standard","text":"","title":"standard"},{"location":"reference/enums/#djstripe.enums.ApiErrorCode","text":"Bases: Enum Charge failure error codes. https://stripe.com/docs/error-codes Source code in djstripe/enums.py 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 class ApiErrorCode ( Enum ): \"\"\" Charge failure error codes. https://stripe.com/docs/error-codes \"\"\" account_already_exists = _ ( \"Account already exists\" ) account_country_invalid_address = _ ( \"Account country invalid address\" ) account_invalid = _ ( \"Account invalid\" ) account_number_invalid = _ ( \"Account number invalid\" ) alipay_upgrade_required = _ ( \"Alipay upgrade required\" ) amount_too_large = _ ( \"Amount too large\" ) amount_too_small = _ ( \"Amount too small\" ) api_key_expired = _ ( \"Api key expired\" ) balance_insufficient = _ ( \"Balance insufficient\" ) bank_account_exists = _ ( \"Bank account exists\" ) bank_account_unusable = _ ( \"Bank account unusable\" ) bank_account_unverified = _ ( \"Bank account unverified\" ) bitcoin_upgrade_required = _ ( \"Bitcoin upgrade required\" ) card_declined = _ ( \"Card was declined\" ) charge_already_captured = _ ( \"Charge already captured\" ) charge_already_refunded = _ ( \"Charge already refunded\" ) charge_disputed = _ ( \"Charge disputed\" ) charge_exceeds_source_limit = _ ( \"Charge exceeds source limit\" ) charge_expired_for_capture = _ ( \"Charge expired for capture\" ) country_unsupported = _ ( \"Country unsupported\" ) coupon_expired = _ ( \"Coupon expired\" ) customer_max_subscriptions = _ ( \"Customer max subscriptions\" ) email_invalid = _ ( \"Email invalid\" ) expired_card = _ ( \"Expired card\" ) idempotency_key_in_use = _ ( \"Idempotency key in use\" ) incorrect_address = _ ( \"Incorrect address\" ) incorrect_cvc = _ ( \"Incorrect security code\" ) incorrect_number = _ ( \"Incorrect number\" ) incorrect_zip = _ ( \"ZIP code failed validation\" ) instant_payouts_unsupported = _ ( \"Instant payouts unsupported\" ) invalid_card_type = _ ( \"Invalid card type\" ) invalid_charge_amount = _ ( \"Invalid charge amount\" ) invalid_cvc = _ ( \"Invalid security code\" ) invalid_expiry_month = _ ( \"Invalid expiration month\" ) invalid_expiry_year = _ ( \"Invalid expiration year\" ) invalid_number = _ ( \"Invalid number\" ) invalid_source_usage = _ ( \"Invalid source usage\" ) invoice_no_customer_line_items = _ ( \"Invoice no customer line items\" ) invoice_no_subscription_line_items = _ ( \"Invoice no subscription line items\" ) invoice_not_editable = _ ( \"Invoice not editable\" ) invoice_upcoming_none = _ ( \"Invoice upcoming none\" ) livemode_mismatch = _ ( \"Livemode mismatch\" ) missing = _ ( \"No card being charged\" ) not_allowed_on_standard_account = _ ( \"Not allowed on standard account\" ) order_creation_failed = _ ( \"Order creation failed\" ) order_required_settings = _ ( \"Order required settings\" ) order_status_invalid = _ ( \"Order status invalid\" ) order_upstream_timeout = _ ( \"Order upstream timeout\" ) out_of_inventory = _ ( \"Out of inventory\" ) parameter_invalid_empty = _ ( \"Parameter invalid empty\" ) parameter_invalid_integer = _ ( \"Parameter invalid integer\" ) parameter_invalid_string_blank = _ ( \"Parameter invalid string blank\" ) parameter_invalid_string_empty = _ ( \"Parameter invalid string empty\" ) parameter_missing = _ ( \"Parameter missing\" ) parameter_unknown = _ ( \"Parameter unknown\" ) parameters_exclusive = _ ( \"Parameters exclusive\" ) payment_intent_authentication_failure = _ ( \"Payment intent authentication failure\" ) payment_intent_incompatible_payment_method = _ ( \"Payment intent incompatible payment method\" ) payment_intent_invalid_parameter = _ ( \"Payment intent invalid parameter\" ) payment_intent_payment_attempt_failed = _ ( \"Payment intent payment attempt failed\" ) payment_intent_unexpected_state = _ ( \"Payment intent unexpected state\" ) payment_method_unactivated = _ ( \"Payment method unactivated\" ) payment_method_unexpected_state = _ ( \"Payment method unexpected state\" ) payouts_not_allowed = _ ( \"Payouts not allowed\" ) platform_api_key_expired = _ ( \"Platform api key expired\" ) postal_code_invalid = _ ( \"Postal code invalid\" ) processing_error = _ ( \"Processing error\" ) product_inactive = _ ( \"Product inactive\" ) rate_limit = _ ( \"Rate limit\" ) resource_already_exists = _ ( \"Resource already exists\" ) resource_missing = _ ( \"Resource missing\" ) routing_number_invalid = _ ( \"Routing number invalid\" ) secret_key_required = _ ( \"Secret key required\" ) sepa_unsupported_account = _ ( \"SEPA unsupported account\" ) shipping_calculation_failed = _ ( \"Shipping calculation failed\" ) sku_inactive = _ ( \"SKU inactive\" ) state_unsupported = _ ( \"State unsupported\" ) tax_id_invalid = _ ( \"Tax id invalid\" ) taxes_calculation_failed = _ ( \"Taxes calculation failed\" ) testmode_charges_only = _ ( \"Testmode charges only\" ) tls_version_unsupported = _ ( \"TLS version unsupported\" ) token_already_used = _ ( \"Token already used\" ) token_in_use = _ ( \"Token in use\" ) transfers_not_allowed = _ ( \"Transfers not allowed\" ) upstream_order_creation_failed = _ ( \"Upstream order creation failed\" ) url_invalid = _ ( \"URL invalid\" ) # deprecated invalid_swipe_data = _ ( \"Invalid swipe data\" )","title":"ApiErrorCode"},{"location":"reference/enums/#djstripe.enums.ApiErrorCode-attributes","text":"","title":"Attributes"},{"location":"reference/enums/#djstripe.enums.ApiErrorCode.account_already_exists","text":"","title":"account_already_exists"},{"location":"reference/enums/#djstripe.enums.ApiErrorCode.account_country_invalid_address","text":"","title":"account_country_invalid_address"},{"location":"reference/enums/#djstripe.enums.ApiErrorCode.account_invalid","text":"","title":"account_invalid"},{"location":"reference/enums/#djstripe.enums.ApiErrorCode.account_number_invalid","text":"","title":"account_number_invalid"},{"location":"reference/enums/#djstripe.enums.ApiErrorCode.alipay_upgrade_required","text":"","title":"alipay_upgrade_required"},{"location":"reference/enums/#djstripe.enums.ApiErrorCode.amount_too_large","text":"","title":"amount_too_large"},{"location":"reference/enums/#djstripe.enums.ApiErrorCode.amount_too_small","text":"","title":"amount_too_small"},{"location":"reference/enums/#djstripe.enums.ApiErrorCode.api_key_expired","text":"","title":"api_key_expired"},{"location":"reference/enums/#djstripe.enums.ApiErrorCode.balance_insufficient","text":"","title":"balance_insufficient"},{"location":"reference/enums/#djstripe.enums.ApiErrorCode.bank_account_exists","text":"","title":"bank_account_exists"},{"location":"reference/enums/#djstripe.enums.ApiErrorCode.bank_account_unusable","text":"","title":"bank_account_unusable"},{"location":"reference/enums/#djstripe.enums.ApiErrorCode.bank_account_unverified","text":"","title":"bank_account_unverified"},{"location":"reference/enums/#djstripe.enums.ApiErrorCode.bitcoin_upgrade_required","text":"","title":"bitcoin_upgrade_required"},{"location":"reference/enums/#djstripe.enums.ApiErrorCode.card_declined","text":"","title":"card_declined"},{"location":"reference/enums/#djstripe.enums.ApiErrorCode.charge_already_captured","text":"","title":"charge_already_captured"},{"location":"reference/enums/#djstripe.enums.ApiErrorCode.charge_already_refunded","text":"","title":"charge_already_refunded"},{"location":"reference/enums/#djstripe.enums.ApiErrorCode.charge_disputed","text":"","title":"charge_disputed"},{"location":"reference/enums/#djstripe.enums.ApiErrorCode.charge_exceeds_source_limit","text":"","title":"charge_exceeds_source_limit"},{"location":"reference/enums/#djstripe.enums.ApiErrorCode.charge_expired_for_capture","text":"","title":"charge_expired_for_capture"},{"location":"reference/enums/#djstripe.enums.ApiErrorCode.country_unsupported","text":"","title":"country_unsupported"},{"location":"reference/enums/#djstripe.enums.ApiErrorCode.coupon_expired","text":"","title":"coupon_expired"},{"location":"reference/enums/#djstripe.enums.ApiErrorCode.customer_max_subscriptions","text":"","title":"customer_max_subscriptions"},{"location":"reference/enums/#djstripe.enums.ApiErrorCode.email_invalid","text":"","title":"email_invalid"},{"location":"reference/enums/#djstripe.enums.ApiErrorCode.expired_card","text":"","title":"expired_card"},{"location":"reference/enums/#djstripe.enums.ApiErrorCode.idempotency_key_in_use","text":"","title":"idempotency_key_in_use"},{"location":"reference/enums/#djstripe.enums.ApiErrorCode.incorrect_address","text":"","title":"incorrect_address"},{"location":"reference/enums/#djstripe.enums.ApiErrorCode.incorrect_cvc","text":"","title":"incorrect_cvc"},{"location":"reference/enums/#djstripe.enums.ApiErrorCode.incorrect_number","text":"","title":"incorrect_number"},{"location":"reference/enums/#djstripe.enums.ApiErrorCode.incorrect_zip","text":"","title":"incorrect_zip"},{"location":"reference/enums/#djstripe.enums.ApiErrorCode.instant_payouts_unsupported","text":"","title":"instant_payouts_unsupported"},{"location":"reference/enums/#djstripe.enums.ApiErrorCode.invalid_card_type","text":"","title":"invalid_card_type"},{"location":"reference/enums/#djstripe.enums.ApiErrorCode.invalid_charge_amount","text":"","title":"invalid_charge_amount"},{"location":"reference/enums/#djstripe.enums.ApiErrorCode.invalid_cvc","text":"","title":"invalid_cvc"},{"location":"reference/enums/#djstripe.enums.ApiErrorCode.invalid_expiry_month","text":"","title":"invalid_expiry_month"},{"location":"reference/enums/#djstripe.enums.ApiErrorCode.invalid_expiry_year","text":"","title":"invalid_expiry_year"},{"location":"reference/enums/#djstripe.enums.ApiErrorCode.invalid_number","text":"","title":"invalid_number"},{"location":"reference/enums/#djstripe.enums.ApiErrorCode.invalid_source_usage","text":"","title":"invalid_source_usage"},{"location":"reference/enums/#djstripe.enums.ApiErrorCode.invalid_swipe_data","text":"","title":"invalid_swipe_data"},{"location":"reference/enums/#djstripe.enums.ApiErrorCode.invoice_no_customer_line_items","text":"","title":"invoice_no_customer_line_items"},{"location":"reference/enums/#djstripe.enums.ApiErrorCode.invoice_no_subscription_line_items","text":"","title":"invoice_no_subscription_line_items"},{"location":"reference/enums/#djstripe.enums.ApiErrorCode.invoice_not_editable","text":"","title":"invoice_not_editable"},{"location":"reference/enums/#djstripe.enums.ApiErrorCode.invoice_upcoming_none","text":"","title":"invoice_upcoming_none"},{"location":"reference/enums/#djstripe.enums.ApiErrorCode.livemode_mismatch","text":"","title":"livemode_mismatch"},{"location":"reference/enums/#djstripe.enums.ApiErrorCode.missing","text":"","title":"missing"},{"location":"reference/enums/#djstripe.enums.ApiErrorCode.not_allowed_on_standard_account","text":"","title":"not_allowed_on_standard_account"},{"location":"reference/enums/#djstripe.enums.ApiErrorCode.order_creation_failed","text":"","title":"order_creation_failed"},{"location":"reference/enums/#djstripe.enums.ApiErrorCode.order_required_settings","text":"","title":"order_required_settings"},{"location":"reference/enums/#djstripe.enums.ApiErrorCode.order_status_invalid","text":"","title":"order_status_invalid"},{"location":"reference/enums/#djstripe.enums.ApiErrorCode.order_upstream_timeout","text":"","title":"order_upstream_timeout"},{"location":"reference/enums/#djstripe.enums.ApiErrorCode.out_of_inventory","text":"","title":"out_of_inventory"},{"location":"reference/enums/#djstripe.enums.ApiErrorCode.parameter_invalid_empty","text":"","title":"parameter_invalid_empty"},{"location":"reference/enums/#djstripe.enums.ApiErrorCode.parameter_invalid_integer","text":"","title":"parameter_invalid_integer"},{"location":"reference/enums/#djstripe.enums.ApiErrorCode.parameter_invalid_string_blank","text":"","title":"parameter_invalid_string_blank"},{"location":"reference/enums/#djstripe.enums.ApiErrorCode.parameter_invalid_string_empty","text":"","title":"parameter_invalid_string_empty"},{"location":"reference/enums/#djstripe.enums.ApiErrorCode.parameter_missing","text":"","title":"parameter_missing"},{"location":"reference/enums/#djstripe.enums.ApiErrorCode.parameter_unknown","text":"","title":"parameter_unknown"},{"location":"reference/enums/#djstripe.enums.ApiErrorCode.parameters_exclusive","text":"","title":"parameters_exclusive"},{"location":"reference/enums/#djstripe.enums.ApiErrorCode.payment_intent_authentication_failure","text":"","title":"payment_intent_authentication_failure"},{"location":"reference/enums/#djstripe.enums.ApiErrorCode.payment_intent_incompatible_payment_method","text":"","title":"payment_intent_incompatible_payment_method"},{"location":"reference/enums/#djstripe.enums.ApiErrorCode.payment_intent_invalid_parameter","text":"","title":"payment_intent_invalid_parameter"},{"location":"reference/enums/#djstripe.enums.ApiErrorCode.payment_intent_payment_attempt_failed","text":"","title":"payment_intent_payment_attempt_failed"},{"location":"reference/enums/#djstripe.enums.ApiErrorCode.payment_intent_unexpected_state","text":"","title":"payment_intent_unexpected_state"},{"location":"reference/enums/#djstripe.enums.ApiErrorCode.payment_method_unactivated","text":"","title":"payment_method_unactivated"},{"location":"reference/enums/#djstripe.enums.ApiErrorCode.payment_method_unexpected_state","text":"","title":"payment_method_unexpected_state"},{"location":"reference/enums/#djstripe.enums.ApiErrorCode.payouts_not_allowed","text":"","title":"payouts_not_allowed"},{"location":"reference/enums/#djstripe.enums.ApiErrorCode.platform_api_key_expired","text":"","title":"platform_api_key_expired"},{"location":"reference/enums/#djstripe.enums.ApiErrorCode.postal_code_invalid","text":"","title":"postal_code_invalid"},{"location":"reference/enums/#djstripe.enums.ApiErrorCode.processing_error","text":"","title":"processing_error"},{"location":"reference/enums/#djstripe.enums.ApiErrorCode.product_inactive","text":"","title":"product_inactive"},{"location":"reference/enums/#djstripe.enums.ApiErrorCode.rate_limit","text":"","title":"rate_limit"},{"location":"reference/enums/#djstripe.enums.ApiErrorCode.resource_already_exists","text":"","title":"resource_already_exists"},{"location":"reference/enums/#djstripe.enums.ApiErrorCode.resource_missing","text":"","title":"resource_missing"},{"location":"reference/enums/#djstripe.enums.ApiErrorCode.routing_number_invalid","text":"","title":"routing_number_invalid"},{"location":"reference/enums/#djstripe.enums.ApiErrorCode.secret_key_required","text":"","title":"secret_key_required"},{"location":"reference/enums/#djstripe.enums.ApiErrorCode.sepa_unsupported_account","text":"","title":"sepa_unsupported_account"},{"location":"reference/enums/#djstripe.enums.ApiErrorCode.shipping_calculation_failed","text":"","title":"shipping_calculation_failed"},{"location":"reference/enums/#djstripe.enums.ApiErrorCode.sku_inactive","text":"","title":"sku_inactive"},{"location":"reference/enums/#djstripe.enums.ApiErrorCode.state_unsupported","text":"","title":"state_unsupported"},{"location":"reference/enums/#djstripe.enums.ApiErrorCode.tax_id_invalid","text":"","title":"tax_id_invalid"},{"location":"reference/enums/#djstripe.enums.ApiErrorCode.taxes_calculation_failed","text":"","title":"taxes_calculation_failed"},{"location":"reference/enums/#djstripe.enums.ApiErrorCode.testmode_charges_only","text":"","title":"testmode_charges_only"},{"location":"reference/enums/#djstripe.enums.ApiErrorCode.tls_version_unsupported","text":"","title":"tls_version_unsupported"},{"location":"reference/enums/#djstripe.enums.ApiErrorCode.token_already_used","text":"","title":"token_already_used"},{"location":"reference/enums/#djstripe.enums.ApiErrorCode.token_in_use","text":"","title":"token_in_use"},{"location":"reference/enums/#djstripe.enums.ApiErrorCode.transfers_not_allowed","text":"","title":"transfers_not_allowed"},{"location":"reference/enums/#djstripe.enums.ApiErrorCode.upstream_order_creation_failed","text":"","title":"upstream_order_creation_failed"},{"location":"reference/enums/#djstripe.enums.ApiErrorCode.url_invalid","text":"","title":"url_invalid"},{"location":"reference/enums/#djstripe.enums.BalanceTransactionReportingCategory","text":"Bases: Enum https://stripe.com/docs/reports/reporting-categories Source code in djstripe/enums.py 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 class BalanceTransactionReportingCategory ( Enum ): \"\"\" https://stripe.com/docs/reports/reporting-categories \"\"\" advance = _ ( \"Advance\" ) advance_funding = _ ( \"Advance funding\" ) anticipation_repayment = _ ( \"Anticipation loan repayment (BR)\" ) charge = _ ( \"Charge\" ) charge_failure = _ ( \"Charge failure\" ) connect_collection_transfer = _ ( \"Stripe Connect collection transfer\" ) connect_reserved_funds = _ ( \"Stripe Connect reserved funds\" ) dispute = _ ( \"Dispute\" ) dispute_reversal = _ ( \"Dispute reversal\" ) fee = _ ( \"Stripe fee\" ) issuing_authorization_hold = _ ( \"Issuing authorization hold\" ) issuing_authorization_release = _ ( \"Issuing authorization release\" ) issuing_dispute = _ ( \"Issuing dispute\" ) issuing_transaction = _ ( \"Issuing transaction\" ) other_adjustment = _ ( \"Other adjustment\" ) partial_capture_reversal = _ ( \"Partial capture reversal\" ) payout = _ ( \"Payout\" ) payout_reversal = _ ( \"Payout reversal\" ) platform_earning = _ ( \"Stripe Connect platform earning\" ) platform_earning_refund = _ ( \"Stripe Connect platform earning refund\" ) refund = _ ( \"Refund\" ) refund_failure = _ ( \"Refund failure\" ) risk_reserved_funds = _ ( \"Risk-reserved funds\" ) tax = _ ( \"Tax\" ) topup = _ ( \"Top-up\" ) topup_reversal = _ ( \"Top-up reversal\" ) transfer = _ ( \"Stripe Connect transfer\" ) transfer_reversal = _ ( \"Stripe Connect transfer reversal\" )","title":"BalanceTransactionReportingCategory"},{"location":"reference/enums/#djstripe.enums.BalanceTransactionReportingCategory-attributes","text":"","title":"Attributes"},{"location":"reference/enums/#djstripe.enums.BalanceTransactionReportingCategory.advance","text":"","title":"advance"},{"location":"reference/enums/#djstripe.enums.BalanceTransactionReportingCategory.advance_funding","text":"","title":"advance_funding"},{"location":"reference/enums/#djstripe.enums.BalanceTransactionReportingCategory.anticipation_repayment","text":"","title":"anticipation_repayment"},{"location":"reference/enums/#djstripe.enums.BalanceTransactionReportingCategory.charge","text":"","title":"charge"},{"location":"reference/enums/#djstripe.enums.BalanceTransactionReportingCategory.charge_failure","text":"","title":"charge_failure"},{"location":"reference/enums/#djstripe.enums.BalanceTransactionReportingCategory.connect_collection_transfer","text":"","title":"connect_collection_transfer"},{"location":"reference/enums/#djstripe.enums.BalanceTransactionReportingCategory.connect_reserved_funds","text":"","title":"connect_reserved_funds"},{"location":"reference/enums/#djstripe.enums.BalanceTransactionReportingCategory.dispute","text":"","title":"dispute"},{"location":"reference/enums/#djstripe.enums.BalanceTransactionReportingCategory.dispute_reversal","text":"","title":"dispute_reversal"},{"location":"reference/enums/#djstripe.enums.BalanceTransactionReportingCategory.fee","text":"","title":"fee"},{"location":"reference/enums/#djstripe.enums.BalanceTransactionReportingCategory.issuing_authorization_hold","text":"","title":"issuing_authorization_hold"},{"location":"reference/enums/#djstripe.enums.BalanceTransactionReportingCategory.issuing_authorization_release","text":"","title":"issuing_authorization_release"},{"location":"reference/enums/#djstripe.enums.BalanceTransactionReportingCategory.issuing_dispute","text":"","title":"issuing_dispute"},{"location":"reference/enums/#djstripe.enums.BalanceTransactionReportingCategory.issuing_transaction","text":"","title":"issuing_transaction"},{"location":"reference/enums/#djstripe.enums.BalanceTransactionReportingCategory.other_adjustment","text":"","title":"other_adjustment"},{"location":"reference/enums/#djstripe.enums.BalanceTransactionReportingCategory.partial_capture_reversal","text":"","title":"partial_capture_reversal"},{"location":"reference/enums/#djstripe.enums.BalanceTransactionReportingCategory.payout","text":"","title":"payout"},{"location":"reference/enums/#djstripe.enums.BalanceTransactionReportingCategory.payout_reversal","text":"","title":"payout_reversal"},{"location":"reference/enums/#djstripe.enums.BalanceTransactionReportingCategory.platform_earning","text":"","title":"platform_earning"},{"location":"reference/enums/#djstripe.enums.BalanceTransactionReportingCategory.platform_earning_refund","text":"","title":"platform_earning_refund"},{"location":"reference/enums/#djstripe.enums.BalanceTransactionReportingCategory.refund","text":"","title":"refund"},{"location":"reference/enums/#djstripe.enums.BalanceTransactionReportingCategory.refund_failure","text":"","title":"refund_failure"},{"location":"reference/enums/#djstripe.enums.BalanceTransactionReportingCategory.risk_reserved_funds","text":"","title":"risk_reserved_funds"},{"location":"reference/enums/#djstripe.enums.BalanceTransactionReportingCategory.tax","text":"","title":"tax"},{"location":"reference/enums/#djstripe.enums.BalanceTransactionReportingCategory.topup","text":"","title":"topup"},{"location":"reference/enums/#djstripe.enums.BalanceTransactionReportingCategory.topup_reversal","text":"","title":"topup_reversal"},{"location":"reference/enums/#djstripe.enums.BalanceTransactionReportingCategory.transfer","text":"","title":"transfer"},{"location":"reference/enums/#djstripe.enums.BalanceTransactionReportingCategory.transfer_reversal","text":"","title":"transfer_reversal"},{"location":"reference/enums/#djstripe.enums.BalanceTransactionStatus","text":"Bases: Enum Source code in djstripe/enums.py 209 210 211 class BalanceTransactionStatus ( Enum ): available = _ ( \"Available\" ) pending = _ ( \"Pending\" )","title":"BalanceTransactionStatus"},{"location":"reference/enums/#djstripe.enums.BalanceTransactionStatus-attributes","text":"","title":"Attributes"},{"location":"reference/enums/#djstripe.enums.BalanceTransactionStatus.available","text":"","title":"available"},{"location":"reference/enums/#djstripe.enums.BalanceTransactionStatus.pending","text":"","title":"pending"},{"location":"reference/enums/#djstripe.enums.BalanceTransactionType","text":"Bases: Enum Source code in djstripe/enums.py 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 class BalanceTransactionType ( Enum ): # https://stripe.com/docs/reports/balance-transaction-types adjustment = _ ( \"Adjustment\" ) advance = _ ( \"Advance\" ) advance_funding = _ ( \"Advance funding\" ) anticipation_repayment = _ ( \"Anticipation loan repayment\" ) application_fee = _ ( \"Application fee\" ) application_fee_refund = _ ( \"Application fee refund\" ) balance_transfer_inbound = _ ( \"Balance transfer (inbound)\" ) balance_transfer_outbound = _ ( \"Balance transfer (outbound)\" ) charge = _ ( \"Charge\" ) connect_collection_transfer = _ ( \"Connect collection transfer\" ) contribution = _ ( \"Charitable contribution\" ) issuing_authorization_hold = _ ( \"Issuing authorization hold\" ) issuing_authorization_release = _ ( \"Issuing authorization release\" ) issuing_dispute = _ ( \"Issuing dispute\" ) issuing_transaction = _ ( \"Issuing transaction\" ) network_cost = _ ( \"Network cost\" ) payment = _ ( \"Payment\" ) payment_failure_refund = _ ( \"Payment failure refund\" ) payment_refund = _ ( \"Payment refund\" ) payout = _ ( \"Payout\" ) payout_cancel = _ ( \"Payout cancellation\" ) payout_failure = _ ( \"Payout failure\" ) refund = _ ( \"Refund\" ) refund_failure = _ ( \"Refund failure\" ) reserve_transaction = _ ( \"Reserve transaction\" ) reserved_funds = _ ( \"Reserved funds\" ) stripe_fee = _ ( \"Stripe fee\" ) stripe_fx_fee = _ ( \"Stripe currency conversion fee\" ) tax_fee = _ ( \"Tax fee\" ) topup = _ ( \"Topup\" ) topup_reversal = _ ( \"Topup reversal\" ) transfer = _ ( \"Transfer\" ) transfer_cancel = _ ( \"Transfer cancel\" ) transfer_failure = _ ( \"Transfer failure\" ) transfer_refund = _ ( \"Transfer refund\" ) validation = _ ( \"Validation\" )","title":"BalanceTransactionType"},{"location":"reference/enums/#djstripe.enums.BalanceTransactionType-attributes","text":"","title":"Attributes"},{"location":"reference/enums/#djstripe.enums.BalanceTransactionType.adjustment","text":"","title":"adjustment"},{"location":"reference/enums/#djstripe.enums.BalanceTransactionType.advance","text":"","title":"advance"},{"location":"reference/enums/#djstripe.enums.BalanceTransactionType.advance_funding","text":"","title":"advance_funding"},{"location":"reference/enums/#djstripe.enums.BalanceTransactionType.anticipation_repayment","text":"","title":"anticipation_repayment"},{"location":"reference/enums/#djstripe.enums.BalanceTransactionType.application_fee","text":"","title":"application_fee"},{"location":"reference/enums/#djstripe.enums.BalanceTransactionType.application_fee_refund","text":"","title":"application_fee_refund"},{"location":"reference/enums/#djstripe.enums.BalanceTransactionType.balance_transfer_inbound","text":"","title":"balance_transfer_inbound"},{"location":"reference/enums/#djstripe.enums.BalanceTransactionType.balance_transfer_outbound","text":"","title":"balance_transfer_outbound"},{"location":"reference/enums/#djstripe.enums.BalanceTransactionType.charge","text":"","title":"charge"},{"location":"reference/enums/#djstripe.enums.BalanceTransactionType.connect_collection_transfer","text":"","title":"connect_collection_transfer"},{"location":"reference/enums/#djstripe.enums.BalanceTransactionType.contribution","text":"","title":"contribution"},{"location":"reference/enums/#djstripe.enums.BalanceTransactionType.issuing_authorization_hold","text":"","title":"issuing_authorization_hold"},{"location":"reference/enums/#djstripe.enums.BalanceTransactionType.issuing_authorization_release","text":"","title":"issuing_authorization_release"},{"location":"reference/enums/#djstripe.enums.BalanceTransactionType.issuing_dispute","text":"","title":"issuing_dispute"},{"location":"reference/enums/#djstripe.enums.BalanceTransactionType.issuing_transaction","text":"","title":"issuing_transaction"},{"location":"reference/enums/#djstripe.enums.BalanceTransactionType.network_cost","text":"","title":"network_cost"},{"location":"reference/enums/#djstripe.enums.BalanceTransactionType.payment","text":"","title":"payment"},{"location":"reference/enums/#djstripe.enums.BalanceTransactionType.payment_failure_refund","text":"","title":"payment_failure_refund"},{"location":"reference/enums/#djstripe.enums.BalanceTransactionType.payment_refund","text":"","title":"payment_refund"},{"location":"reference/enums/#djstripe.enums.BalanceTransactionType.payout","text":"","title":"payout"},{"location":"reference/enums/#djstripe.enums.BalanceTransactionType.payout_cancel","text":"","title":"payout_cancel"},{"location":"reference/enums/#djstripe.enums.BalanceTransactionType.payout_failure","text":"","title":"payout_failure"},{"location":"reference/enums/#djstripe.enums.BalanceTransactionType.refund","text":"","title":"refund"},{"location":"reference/enums/#djstripe.enums.BalanceTransactionType.refund_failure","text":"","title":"refund_failure"},{"location":"reference/enums/#djstripe.enums.BalanceTransactionType.reserve_transaction","text":"","title":"reserve_transaction"},{"location":"reference/enums/#djstripe.enums.BalanceTransactionType.reserved_funds","text":"","title":"reserved_funds"},{"location":"reference/enums/#djstripe.enums.BalanceTransactionType.stripe_fee","text":"","title":"stripe_fee"},{"location":"reference/enums/#djstripe.enums.BalanceTransactionType.stripe_fx_fee","text":"","title":"stripe_fx_fee"},{"location":"reference/enums/#djstripe.enums.BalanceTransactionType.tax_fee","text":"","title":"tax_fee"},{"location":"reference/enums/#djstripe.enums.BalanceTransactionType.topup","text":"","title":"topup"},{"location":"reference/enums/#djstripe.enums.BalanceTransactionType.topup_reversal","text":"","title":"topup_reversal"},{"location":"reference/enums/#djstripe.enums.BalanceTransactionType.transfer","text":"","title":"transfer"},{"location":"reference/enums/#djstripe.enums.BalanceTransactionType.transfer_cancel","text":"","title":"transfer_cancel"},{"location":"reference/enums/#djstripe.enums.BalanceTransactionType.transfer_failure","text":"","title":"transfer_failure"},{"location":"reference/enums/#djstripe.enums.BalanceTransactionType.transfer_refund","text":"","title":"transfer_refund"},{"location":"reference/enums/#djstripe.enums.BalanceTransactionType.validation","text":"","title":"validation"},{"location":"reference/enums/#djstripe.enums.BankAccountHolderType","text":"Bases: Enum Source code in djstripe/enums.py 254 255 256 class BankAccountHolderType ( Enum ): individual = _ ( \"Individual\" ) company = _ ( \"Company\" )","title":"BankAccountHolderType"},{"location":"reference/enums/#djstripe.enums.BankAccountHolderType-attributes","text":"","title":"Attributes"},{"location":"reference/enums/#djstripe.enums.BankAccountHolderType.company","text":"","title":"company"},{"location":"reference/enums/#djstripe.enums.BankAccountHolderType.individual","text":"","title":"individual"},{"location":"reference/enums/#djstripe.enums.BankAccountStatus","text":"Bases: Enum Source code in djstripe/enums.py 259 260 261 262 263 264 class BankAccountStatus ( Enum ): new = _ ( \"New\" ) validated = _ ( \"Validated\" ) verified = _ ( \"Verified\" ) verification_failed = _ ( \"Verification failed\" ) errored = _ ( \"Errored\" )","title":"BankAccountStatus"},{"location":"reference/enums/#djstripe.enums.BankAccountStatus-attributes","text":"","title":"Attributes"},{"location":"reference/enums/#djstripe.enums.BankAccountStatus.errored","text":"","title":"errored"},{"location":"reference/enums/#djstripe.enums.BankAccountStatus.new","text":"","title":"new"},{"location":"reference/enums/#djstripe.enums.BankAccountStatus.validated","text":"","title":"validated"},{"location":"reference/enums/#djstripe.enums.BankAccountStatus.verification_failed","text":"","title":"verification_failed"},{"location":"reference/enums/#djstripe.enums.BankAccountStatus.verified","text":"","title":"verified"},{"location":"reference/enums/#djstripe.enums.BillingScheme","text":"Bases: Enum Source code in djstripe/enums.py 267 268 269 class BillingScheme ( Enum ): per_unit = _ ( \"Per-unit\" ) tiered = _ ( \"Tiered\" )","title":"BillingScheme"},{"location":"reference/enums/#djstripe.enums.BillingScheme-attributes","text":"","title":"Attributes"},{"location":"reference/enums/#djstripe.enums.BillingScheme.per_unit","text":"","title":"per_unit"},{"location":"reference/enums/#djstripe.enums.BillingScheme.tiered","text":"","title":"tiered"},{"location":"reference/enums/#djstripe.enums.BusinessType","text":"Bases: Enum Source code in djstripe/enums.py 272 273 274 275 276 class BusinessType ( Enum ): individual = _ ( \"Individual\" ) company = _ ( \"Company\" ) non_profit = _ ( \"Non Profit\" ) government_entity = _ ( \"Government Entity\" )","title":"BusinessType"},{"location":"reference/enums/#djstripe.enums.BusinessType-attributes","text":"","title":"Attributes"},{"location":"reference/enums/#djstripe.enums.BusinessType.company","text":"","title":"company"},{"location":"reference/enums/#djstripe.enums.BusinessType.government_entity","text":"","title":"government_entity"},{"location":"reference/enums/#djstripe.enums.BusinessType.individual","text":"","title":"individual"},{"location":"reference/enums/#djstripe.enums.BusinessType.non_profit","text":"","title":"non_profit"},{"location":"reference/enums/#djstripe.enums.CaptureMethod","text":"Bases: Enum Source code in djstripe/enums.py 279 280 281 class CaptureMethod ( Enum ): automatic = _ ( \"Automatic\" ) manual = _ ( \"Manual\" )","title":"CaptureMethod"},{"location":"reference/enums/#djstripe.enums.CaptureMethod-attributes","text":"","title":"Attributes"},{"location":"reference/enums/#djstripe.enums.CaptureMethod.automatic","text":"","title":"automatic"},{"location":"reference/enums/#djstripe.enums.CaptureMethod.manual","text":"","title":"manual"},{"location":"reference/enums/#djstripe.enums.CardBrand","text":"Bases: Enum Source code in djstripe/enums.py 291 292 293 294 295 296 297 298 299 class CardBrand ( Enum ): AmericanExpress = ( _ ( \"American Express\" ), \"American Express\" ) DinersClub = ( _ ( \"Diners Club\" ), \"Diners Club\" ) Discover = _ ( \"Discover\" ) JCB = _ ( \"JCB\" ) MasterCard = _ ( \"MasterCard\" ) UnionPay = _ ( \"UnionPay\" ) Visa = _ ( \"Visa\" ) Unknown = _ ( \"Unknown\" )","title":"CardBrand"},{"location":"reference/enums/#djstripe.enums.CardBrand-attributes","text":"","title":"Attributes"},{"location":"reference/enums/#djstripe.enums.CardBrand.AmericanExpress","text":"","title":"AmericanExpress"},{"location":"reference/enums/#djstripe.enums.CardBrand.DinersClub","text":"","title":"DinersClub"},{"location":"reference/enums/#djstripe.enums.CardBrand.Discover","text":"","title":"Discover"},{"location":"reference/enums/#djstripe.enums.CardBrand.JCB","text":"","title":"JCB"},{"location":"reference/enums/#djstripe.enums.CardBrand.MasterCard","text":"","title":"MasterCard"},{"location":"reference/enums/#djstripe.enums.CardBrand.UnionPay","text":"","title":"UnionPay"},{"location":"reference/enums/#djstripe.enums.CardBrand.Unknown","text":"","title":"Unknown"},{"location":"reference/enums/#djstripe.enums.CardBrand.Visa","text":"","title":"Visa"},{"location":"reference/enums/#djstripe.enums.CardCheckResult","text":"Bases: Enum Source code in djstripe/enums.py 284 285 286 287 288 class CardCheckResult ( Enum ): pass_ = ( _ ( \"Pass\" ), \"pass\" ) fail = _ ( \"Fail\" ) unavailable = _ ( \"Unavailable\" ) unchecked = _ ( \"Unchecked\" )","title":"CardCheckResult"},{"location":"reference/enums/#djstripe.enums.CardCheckResult-attributes","text":"","title":"Attributes"},{"location":"reference/enums/#djstripe.enums.CardCheckResult.fail","text":"","title":"fail"},{"location":"reference/enums/#djstripe.enums.CardCheckResult.pass_","text":"","title":"pass_"},{"location":"reference/enums/#djstripe.enums.CardCheckResult.unavailable","text":"","title":"unavailable"},{"location":"reference/enums/#djstripe.enums.CardCheckResult.unchecked","text":"","title":"unchecked"},{"location":"reference/enums/#djstripe.enums.CardFundingType","text":"Bases: Enum Source code in djstripe/enums.py 302 303 304 305 306 class CardFundingType ( Enum ): credit = _ ( \"Credit\" ) debit = _ ( \"Debit\" ) prepaid = _ ( \"Prepaid\" ) unknown = _ ( \"Unknown\" )","title":"CardFundingType"},{"location":"reference/enums/#djstripe.enums.CardFundingType-attributes","text":"","title":"Attributes"},{"location":"reference/enums/#djstripe.enums.CardFundingType.credit","text":"","title":"credit"},{"location":"reference/enums/#djstripe.enums.CardFundingType.debit","text":"","title":"debit"},{"location":"reference/enums/#djstripe.enums.CardFundingType.prepaid","text":"","title":"prepaid"},{"location":"reference/enums/#djstripe.enums.CardFundingType.unknown","text":"","title":"unknown"},{"location":"reference/enums/#djstripe.enums.CardTokenizationMethod","text":"Bases: Enum Source code in djstripe/enums.py 309 310 311 class CardTokenizationMethod ( Enum ): apple_pay = _ ( \"Apple Pay\" ) android_pay = _ ( \"Android Pay\" )","title":"CardTokenizationMethod"},{"location":"reference/enums/#djstripe.enums.CardTokenizationMethod-attributes","text":"","title":"Attributes"},{"location":"reference/enums/#djstripe.enums.CardTokenizationMethod.android_pay","text":"","title":"android_pay"},{"location":"reference/enums/#djstripe.enums.CardTokenizationMethod.apple_pay","text":"","title":"apple_pay"},{"location":"reference/enums/#djstripe.enums.ChargeStatus","text":"Bases: Enum Source code in djstripe/enums.py 314 315 316 317 class ChargeStatus ( Enum ): succeeded = _ ( \"Succeeded\" ) pending = _ ( \"Pending\" ) failed = _ ( \"Failed\" )","title":"ChargeStatus"},{"location":"reference/enums/#djstripe.enums.ChargeStatus-attributes","text":"","title":"Attributes"},{"location":"reference/enums/#djstripe.enums.ChargeStatus.failed","text":"","title":"failed"},{"location":"reference/enums/#djstripe.enums.ChargeStatus.pending","text":"","title":"pending"},{"location":"reference/enums/#djstripe.enums.ChargeStatus.succeeded","text":"","title":"succeeded"},{"location":"reference/enums/#djstripe.enums.ConfirmationMethod","text":"Bases: Enum Source code in djstripe/enums.py 332 333 334 class ConfirmationMethod ( Enum ): automatic = _ ( \"Automatic\" ) manual = _ ( \"Manual\" )","title":"ConfirmationMethod"},{"location":"reference/enums/#djstripe.enums.ConfirmationMethod-attributes","text":"","title":"Attributes"},{"location":"reference/enums/#djstripe.enums.ConfirmationMethod.automatic","text":"","title":"automatic"},{"location":"reference/enums/#djstripe.enums.ConfirmationMethod.manual","text":"","title":"manual"},{"location":"reference/enums/#djstripe.enums.CouponDuration","text":"Bases: Enum Source code in djstripe/enums.py 337 338 339 340 class CouponDuration ( Enum ): once = _ ( \"Once\" ) repeating = _ ( \"Multi-month\" ) forever = _ ( \"Forever\" )","title":"CouponDuration"},{"location":"reference/enums/#djstripe.enums.CouponDuration-attributes","text":"","title":"Attributes"},{"location":"reference/enums/#djstripe.enums.CouponDuration.forever","text":"","title":"forever"},{"location":"reference/enums/#djstripe.enums.CouponDuration.once","text":"","title":"once"},{"location":"reference/enums/#djstripe.enums.CouponDuration.repeating","text":"","title":"repeating"},{"location":"reference/enums/#djstripe.enums.CustomerTaxExempt","text":"Bases: Enum Source code in djstripe/enums.py 343 344 345 346 class CustomerTaxExempt ( Enum ): none = _ ( \"None\" ) exempt = _ ( \"Exempt\" ) reverse = _ ( \"Reverse\" )","title":"CustomerTaxExempt"},{"location":"reference/enums/#djstripe.enums.CustomerTaxExempt-attributes","text":"","title":"Attributes"},{"location":"reference/enums/#djstripe.enums.CustomerTaxExempt.exempt","text":"","title":"exempt"},{"location":"reference/enums/#djstripe.enums.CustomerTaxExempt.none","text":"","title":"none"},{"location":"reference/enums/#djstripe.enums.CustomerTaxExempt.reverse","text":"","title":"reverse"},{"location":"reference/enums/#djstripe.enums.DisputeReason","text":"Bases: Enum Source code in djstripe/enums.py 349 350 351 352 353 354 355 356 357 358 359 360 361 362 class DisputeReason ( Enum ): duplicate = _ ( \"Duplicate\" ) fraudulent = _ ( \"Fraudulent\" ) subscription_canceled = _ ( \"Subscription canceled\" ) product_unacceptable = _ ( \"Product unacceptable\" ) product_not_received = _ ( \"Product not received\" ) unrecognized = _ ( \"Unrecognized\" ) credit_not_processed = _ ( \"Credit not processed\" ) general = _ ( \"General\" ) incorrect_account_details = _ ( \"Incorrect account details\" ) insufficient_funds = _ ( \"Insufficient funds\" ) bank_cannot_process = _ ( \"Bank cannot process\" ) debit_not_authorized = _ ( \"Debit not authorized\" ) customer_initiated = _ ( \"Customer-initiated\" )","title":"DisputeReason"},{"location":"reference/enums/#djstripe.enums.DisputeReason-attributes","text":"","title":"Attributes"},{"location":"reference/enums/#djstripe.enums.DisputeReason.bank_cannot_process","text":"","title":"bank_cannot_process"},{"location":"reference/enums/#djstripe.enums.DisputeReason.credit_not_processed","text":"","title":"credit_not_processed"},{"location":"reference/enums/#djstripe.enums.DisputeReason.customer_initiated","text":"","title":"customer_initiated"},{"location":"reference/enums/#djstripe.enums.DisputeReason.debit_not_authorized","text":"","title":"debit_not_authorized"},{"location":"reference/enums/#djstripe.enums.DisputeReason.duplicate","text":"","title":"duplicate"},{"location":"reference/enums/#djstripe.enums.DisputeReason.fraudulent","text":"","title":"fraudulent"},{"location":"reference/enums/#djstripe.enums.DisputeReason.general","text":"","title":"general"},{"location":"reference/enums/#djstripe.enums.DisputeReason.incorrect_account_details","text":"","title":"incorrect_account_details"},{"location":"reference/enums/#djstripe.enums.DisputeReason.insufficient_funds","text":"","title":"insufficient_funds"},{"location":"reference/enums/#djstripe.enums.DisputeReason.product_not_received","text":"","title":"product_not_received"},{"location":"reference/enums/#djstripe.enums.DisputeReason.product_unacceptable","text":"","title":"product_unacceptable"},{"location":"reference/enums/#djstripe.enums.DisputeReason.subscription_canceled","text":"","title":"subscription_canceled"},{"location":"reference/enums/#djstripe.enums.DisputeReason.unrecognized","text":"","title":"unrecognized"},{"location":"reference/enums/#djstripe.enums.DisputeStatus","text":"Bases: Enum Source code in djstripe/enums.py 365 366 367 368 369 370 371 372 373 class DisputeStatus ( Enum ): warning_needs_response = _ ( \"Warning needs response\" ) warning_under_review = _ ( \"Warning under review\" ) warning_closed = _ ( \"Warning closed\" ) needs_response = _ ( \"Needs response\" ) under_review = _ ( \"Under review\" ) charge_refunded = _ ( \"Charge refunded\" ) won = _ ( \"Won\" ) lost = _ ( \"Lost\" )","title":"DisputeStatus"},{"location":"reference/enums/#djstripe.enums.DisputeStatus-attributes","text":"","title":"Attributes"},{"location":"reference/enums/#djstripe.enums.DisputeStatus.charge_refunded","text":"","title":"charge_refunded"},{"location":"reference/enums/#djstripe.enums.DisputeStatus.lost","text":"","title":"lost"},{"location":"reference/enums/#djstripe.enums.DisputeStatus.needs_response","text":"","title":"needs_response"},{"location":"reference/enums/#djstripe.enums.DisputeStatus.under_review","text":"","title":"under_review"},{"location":"reference/enums/#djstripe.enums.DisputeStatus.warning_closed","text":"","title":"warning_closed"},{"location":"reference/enums/#djstripe.enums.DisputeStatus.warning_needs_response","text":"","title":"warning_needs_response"},{"location":"reference/enums/#djstripe.enums.DisputeStatus.warning_under_review","text":"","title":"warning_under_review"},{"location":"reference/enums/#djstripe.enums.DisputeStatus.won","text":"","title":"won"},{"location":"reference/enums/#djstripe.enums.DjstripePaymentMethodType","text":"Bases: Enum A djstripe-specific enum for the DjStripePaymentMethod model. Source code in djstripe/enums.py 862 863 864 865 866 867 868 869 870 class DjstripePaymentMethodType ( Enum ): \"\"\" A djstripe-specific enum for the DjStripePaymentMethod model. \"\"\" alipay_account = _ ( \"Alipay account\" ) card = _ ( \"Card\" ) bank_account = _ ( \"Bank account\" ) source = _ ( \"Source\" )","title":"DjstripePaymentMethodType"},{"location":"reference/enums/#djstripe.enums.DjstripePaymentMethodType-attributes","text":"","title":"Attributes"},{"location":"reference/enums/#djstripe.enums.DjstripePaymentMethodType.alipay_account","text":"","title":"alipay_account"},{"location":"reference/enums/#djstripe.enums.DjstripePaymentMethodType.bank_account","text":"","title":"bank_account"},{"location":"reference/enums/#djstripe.enums.DjstripePaymentMethodType.card","text":"","title":"card"},{"location":"reference/enums/#djstripe.enums.DjstripePaymentMethodType.source","text":"","title":"source"},{"location":"reference/enums/#djstripe.enums.Enum","text":"Source code in djstripe/enums.py 54 55 class Enum ( metaclass = EnumMetaClass ): pass","title":"Enum"},{"location":"reference/enums/#djstripe.enums.EnumMetaClass","text":"Bases: type Source code in djstripe/enums.py 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 class EnumMetaClass ( type ): def __init__ ( cls , name , bases , classdict ): def _human_enum_values ( enum ): return cls . __choices__ [ enum ] # add a class attribute cls . humanize = _human_enum_values @classmethod def __prepare__ ( cls , name , bases ): return OrderedDict () def __new__ ( cls , name , bases , classdict ): members = [] keys = {} choices = OrderedDict () for key , value in classdict . items (): if key . startswith ( \"__\" ): continue members . append ( key ) if isinstance ( value , tuple ): value , alias = value keys [ alias ] = key else : alias = None keys [ alias or key ] = key choices [ alias or key ] = value for k , v in keys . items (): classdict [ v ] = k classdict [ \"__choices__\" ] = choices classdict [ \"__members__\" ] = members # Note: Differences between Python 2.x and Python 3.x force us to # explicitly use unicode here, and to explicitly sort the list. In # Python 2.x, class members are unordered and so the ordering will # vary on different systems based on internal hashing. Without this # Django will continually require new no-op migrations. classdict [ \"choices\" ] = tuple ( ( str ( k ), str ( v )) for k , v in sorted ( choices . items (), key = operator . itemgetter ( 0 )) ) return type . __new__ ( cls , name , bases , classdict )","title":"EnumMetaClass"},{"location":"reference/enums/#djstripe.enums.EnumMetaClass-functions","text":"","title":"Functions"},{"location":"reference/enums/#djstripe.enums.EnumMetaClass.__init__","text":"Source code in djstripe/enums.py 8 9 10 11 12 13 def __init__ ( cls , name , bases , classdict ): def _human_enum_values ( enum ): return cls . __choices__ [ enum ] # add a class attribute cls . humanize = _human_enum_values","title":"__init__()"},{"location":"reference/enums/#djstripe.enums.EnumMetaClass.__new__","text":"Source code in djstripe/enums.py 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 def __new__ ( cls , name , bases , classdict ): members = [] keys = {} choices = OrderedDict () for key , value in classdict . items (): if key . startswith ( \"__\" ): continue members . append ( key ) if isinstance ( value , tuple ): value , alias = value keys [ alias ] = key else : alias = None keys [ alias or key ] = key choices [ alias or key ] = value for k , v in keys . items (): classdict [ v ] = k classdict [ \"__choices__\" ] = choices classdict [ \"__members__\" ] = members # Note: Differences between Python 2.x and Python 3.x force us to # explicitly use unicode here, and to explicitly sort the list. In # Python 2.x, class members are unordered and so the ordering will # vary on different systems based on internal hashing. Without this # Django will continually require new no-op migrations. classdict [ \"choices\" ] = tuple ( ( str ( k ), str ( v )) for k , v in sorted ( choices . items (), key = operator . itemgetter ( 0 )) ) return type . __new__ ( cls , name , bases , classdict )","title":"__new__()"},{"location":"reference/enums/#djstripe.enums.EnumMetaClass.__prepare__","text":"Source code in djstripe/enums.py 15 16 17 @classmethod def __prepare__ ( cls , name , bases ): return OrderedDict ()","title":"__prepare__()"},{"location":"reference/enums/#djstripe.enums.FilePurpose","text":"Bases: Enum Source code in djstripe/enums.py 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 class FilePurpose ( Enum ): account_requirement = _ ( \"Account requirement\" ) additional_verification = _ ( \"Additional verification\" ) business_icon = _ ( \"Business icon\" ) business_logo = _ ( \"Business logo\" ) customer_signature = _ ( \"Customer signature\" ) credit_note = _ ( \"Credit Note\" ) dispute_evidence = _ ( \"Dispute evidence\" ) document_provider_identity_document = _ ( \"Document provider identity document\" ) finance_report_run = _ ( \"Finance report run\" ) identity_document = _ ( \"Identity document\" ) identity_document_downloadable = _ ( \"Identity document (downloadable)\" ) invoice_statement = _ ( \"Invoice statement\" ) pci_document = _ ( \"PCI document\" ) selfie = _ ( \"Selfie (Stripe Identity)\" ) sigma_scheduled_query = _ ( \"Sigma scheduled query\" ) tax_document_user_upload = _ ( \"Tax document user upload\" )","title":"FilePurpose"},{"location":"reference/enums/#djstripe.enums.FilePurpose-attributes","text":"","title":"Attributes"},{"location":"reference/enums/#djstripe.enums.FilePurpose.account_requirement","text":"","title":"account_requirement"},{"location":"reference/enums/#djstripe.enums.FilePurpose.additional_verification","text":"","title":"additional_verification"},{"location":"reference/enums/#djstripe.enums.FilePurpose.business_icon","text":"","title":"business_icon"},{"location":"reference/enums/#djstripe.enums.FilePurpose.business_logo","text":"","title":"business_logo"},{"location":"reference/enums/#djstripe.enums.FilePurpose.credit_note","text":"","title":"credit_note"},{"location":"reference/enums/#djstripe.enums.FilePurpose.customer_signature","text":"","title":"customer_signature"},{"location":"reference/enums/#djstripe.enums.FilePurpose.dispute_evidence","text":"","title":"dispute_evidence"},{"location":"reference/enums/#djstripe.enums.FilePurpose.document_provider_identity_document","text":"","title":"document_provider_identity_document"},{"location":"reference/enums/#djstripe.enums.FilePurpose.finance_report_run","text":"","title":"finance_report_run"},{"location":"reference/enums/#djstripe.enums.FilePurpose.identity_document","text":"","title":"identity_document"},{"location":"reference/enums/#djstripe.enums.FilePurpose.identity_document_downloadable","text":"","title":"identity_document_downloadable"},{"location":"reference/enums/#djstripe.enums.FilePurpose.invoice_statement","text":"","title":"invoice_statement"},{"location":"reference/enums/#djstripe.enums.FilePurpose.pci_document","text":"","title":"pci_document"},{"location":"reference/enums/#djstripe.enums.FilePurpose.selfie","text":"","title":"selfie"},{"location":"reference/enums/#djstripe.enums.FilePurpose.sigma_scheduled_query","text":"","title":"sigma_scheduled_query"},{"location":"reference/enums/#djstripe.enums.FilePurpose.tax_document_user_upload","text":"","title":"tax_document_user_upload"},{"location":"reference/enums/#djstripe.enums.FileType","text":"Bases: Enum Source code in djstripe/enums.py 395 396 397 398 399 400 401 402 class FileType ( Enum ): pdf = _ ( \"PDF\" ) jpg = _ ( \"JPG\" ) png = _ ( \"PNG\" ) csv = _ ( \"CSV\" ) xls = _ ( \"XLS\" ) xlsx = _ ( \"XLSX\" ) docx = _ ( \"DOCX\" )","title":"FileType"},{"location":"reference/enums/#djstripe.enums.FileType-attributes","text":"","title":"Attributes"},{"location":"reference/enums/#djstripe.enums.FileType.csv","text":"","title":"csv"},{"location":"reference/enums/#djstripe.enums.FileType.docx","text":"","title":"docx"},{"location":"reference/enums/#djstripe.enums.FileType.jpg","text":"","title":"jpg"},{"location":"reference/enums/#djstripe.enums.FileType.pdf","text":"","title":"pdf"},{"location":"reference/enums/#djstripe.enums.FileType.png","text":"","title":"png"},{"location":"reference/enums/#djstripe.enums.FileType.xls","text":"","title":"xls"},{"location":"reference/enums/#djstripe.enums.FileType.xlsx","text":"","title":"xlsx"},{"location":"reference/enums/#djstripe.enums.IntentStatus","text":"Bases: Enum Status of Intents which apply both to PaymentIntents and SetupIntents. Source code in djstripe/enums.py 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 class IntentStatus ( Enum ): \"\"\" Status of Intents which apply both to PaymentIntents and SetupIntents. \"\"\" requires_payment_method = _ ( \"Intent created and requires a Payment Method to be attached.\" ) requires_confirmation = _ ( \"Intent is ready to be confirmed.\" ) requires_action = _ ( \"Payment Method require additional action, such as 3D secure.\" ) processing = _ ( \"Required actions have been handled.\" ) canceled = _ ( \"Cancellation invalidates the intent for future confirmation and \" \"cannot be undone.\" )","title":"IntentStatus"},{"location":"reference/enums/#djstripe.enums.IntentStatus-attributes","text":"","title":"Attributes"},{"location":"reference/enums/#djstripe.enums.IntentStatus.canceled","text":"","title":"canceled"},{"location":"reference/enums/#djstripe.enums.IntentStatus.processing","text":"","title":"processing"},{"location":"reference/enums/#djstripe.enums.IntentStatus.requires_action","text":"","title":"requires_action"},{"location":"reference/enums/#djstripe.enums.IntentStatus.requires_confirmation","text":"","title":"requires_confirmation"},{"location":"reference/enums/#djstripe.enums.IntentStatus.requires_payment_method","text":"","title":"requires_payment_method"},{"location":"reference/enums/#djstripe.enums.IntentUsage","text":"Bases: Enum Source code in djstripe/enums.py 435 436 437 class IntentUsage ( Enum ): on_session = _ ( \"On session\" ) off_session = _ ( \"Off session\" )","title":"IntentUsage"},{"location":"reference/enums/#djstripe.enums.IntentUsage-attributes","text":"","title":"Attributes"},{"location":"reference/enums/#djstripe.enums.IntentUsage.off_session","text":"","title":"off_session"},{"location":"reference/enums/#djstripe.enums.IntentUsage.on_session","text":"","title":"on_session"},{"location":"reference/enums/#djstripe.enums.InvoiceBillingReason","text":"Bases: Enum Source code in djstripe/enums.py 405 406 407 408 409 410 411 412 413 class InvoiceBillingReason ( Enum ): subscription_cycle = _ ( \"Subscription cycle\" ) subscription_create = _ ( \"Subscription create\" ) subscription_update = _ ( \"Subscription update\" ) subscription = _ ( \"Subscription\" ) manual = _ ( \"Manual\" ) upcoming = _ ( \"Upcoming\" ) subscription_threshold = _ ( \"Subscription threshold\" ) automatic_pending_invoice_item_invoice = _ ( \"Automatic pending invoice item invoice\" )","title":"InvoiceBillingReason"},{"location":"reference/enums/#djstripe.enums.InvoiceBillingReason-attributes","text":"","title":"Attributes"},{"location":"reference/enums/#djstripe.enums.InvoiceBillingReason.automatic_pending_invoice_item_invoice","text":"","title":"automatic_pending_invoice_item_invoice"},{"location":"reference/enums/#djstripe.enums.InvoiceBillingReason.manual","text":"","title":"manual"},{"location":"reference/enums/#djstripe.enums.InvoiceBillingReason.subscription","text":"","title":"subscription"},{"location":"reference/enums/#djstripe.enums.InvoiceBillingReason.subscription_create","text":"","title":"subscription_create"},{"location":"reference/enums/#djstripe.enums.InvoiceBillingReason.subscription_cycle","text":"","title":"subscription_cycle"},{"location":"reference/enums/#djstripe.enums.InvoiceBillingReason.subscription_threshold","text":"","title":"subscription_threshold"},{"location":"reference/enums/#djstripe.enums.InvoiceBillingReason.subscription_update","text":"","title":"subscription_update"},{"location":"reference/enums/#djstripe.enums.InvoiceBillingReason.upcoming","text":"","title":"upcoming"},{"location":"reference/enums/#djstripe.enums.InvoiceCollectionMethod","text":"Bases: Enum Source code in djstripe/enums.py 416 417 418 class InvoiceCollectionMethod ( Enum ): charge_automatically = _ ( \"Charge automatically\" ) send_invoice = _ ( \"Send invoice\" )","title":"InvoiceCollectionMethod"},{"location":"reference/enums/#djstripe.enums.InvoiceCollectionMethod-attributes","text":"","title":"Attributes"},{"location":"reference/enums/#djstripe.enums.InvoiceCollectionMethod.charge_automatically","text":"","title":"charge_automatically"},{"location":"reference/enums/#djstripe.enums.InvoiceCollectionMethod.send_invoice","text":"","title":"send_invoice"},{"location":"reference/enums/#djstripe.enums.InvoiceStatus","text":"Bases: Enum Source code in djstripe/enums.py 421 422 423 424 425 426 class InvoiceStatus ( Enum ): draft = _ ( \"Draft\" ) open = _ ( \"Open\" ) paid = _ ( \"Paid\" ) uncollectible = _ ( \"Uncollectible\" ) void = _ ( \"Void\" )","title":"InvoiceStatus"},{"location":"reference/enums/#djstripe.enums.InvoiceStatus-attributes","text":"","title":"Attributes"},{"location":"reference/enums/#djstripe.enums.InvoiceStatus.draft","text":"","title":"draft"},{"location":"reference/enums/#djstripe.enums.InvoiceStatus.open","text":"","title":"open"},{"location":"reference/enums/#djstripe.enums.InvoiceStatus.paid","text":"","title":"paid"},{"location":"reference/enums/#djstripe.enums.InvoiceStatus.uncollectible","text":"","title":"uncollectible"},{"location":"reference/enums/#djstripe.enums.InvoiceStatus.void","text":"","title":"void"},{"location":"reference/enums/#djstripe.enums.InvoiceorLineItemType","text":"Bases: Enum Source code in djstripe/enums.py 429 430 431 432 class InvoiceorLineItemType ( Enum ): invoice_item = _ ( \"Invoice Item\" ) line_item = _ ( \"Line Item\" ) unsupported = _ ( \"Unsupported\" )","title":"InvoiceorLineItemType"},{"location":"reference/enums/#djstripe.enums.InvoiceorLineItemType-attributes","text":"","title":"Attributes"},{"location":"reference/enums/#djstripe.enums.InvoiceorLineItemType.invoice_item","text":"","title":"invoice_item"},{"location":"reference/enums/#djstripe.enums.InvoiceorLineItemType.line_item","text":"","title":"line_item"},{"location":"reference/enums/#djstripe.enums.InvoiceorLineItemType.unsupported","text":"","title":"unsupported"},{"location":"reference/enums/#djstripe.enums.LegacySourceType","text":"Bases: Enum Source code in djstripe/enums.py 708 709 710 711 712 class LegacySourceType ( Enum ): card = _ ( \"Card\" ) bank_account = _ ( \"Bank account\" ) bitcoin_receiver = _ ( \"Bitcoin receiver\" ) alipay_account = _ ( \"Alipay account\" )","title":"LegacySourceType"},{"location":"reference/enums/#djstripe.enums.LegacySourceType-attributes","text":"","title":"Attributes"},{"location":"reference/enums/#djstripe.enums.LegacySourceType.alipay_account","text":"","title":"alipay_account"},{"location":"reference/enums/#djstripe.enums.LegacySourceType.bank_account","text":"","title":"bank_account"},{"location":"reference/enums/#djstripe.enums.LegacySourceType.bitcoin_receiver","text":"","title":"bitcoin_receiver"},{"location":"reference/enums/#djstripe.enums.LegacySourceType.card","text":"","title":"card"},{"location":"reference/enums/#djstripe.enums.LineItem","text":"Bases: Enum Source code in djstripe/enums.py 458 459 460 class LineItem ( Enum ): invoiceitem = _ ( \"Invoice Item\" ) subscription = _ ( \"Subscription\" )","title":"LineItem"},{"location":"reference/enums/#djstripe.enums.LineItem-attributes","text":"","title":"Attributes"},{"location":"reference/enums/#djstripe.enums.LineItem.invoiceitem","text":"","title":"invoiceitem"},{"location":"reference/enums/#djstripe.enums.LineItem.subscription","text":"","title":"subscription"},{"location":"reference/enums/#djstripe.enums.MandateStatus","text":"Bases: Enum Source code in djstripe/enums.py 463 464 465 466 class MandateStatus ( Enum ): active = _ ( \"Active\" ) inactive = _ ( \"Inactive\" ) pending = _ ( \"Pending\" )","title":"MandateStatus"},{"location":"reference/enums/#djstripe.enums.MandateStatus-attributes","text":"","title":"Attributes"},{"location":"reference/enums/#djstripe.enums.MandateStatus.active","text":"","title":"active"},{"location":"reference/enums/#djstripe.enums.MandateStatus.inactive","text":"","title":"inactive"},{"location":"reference/enums/#djstripe.enums.MandateStatus.pending","text":"","title":"pending"},{"location":"reference/enums/#djstripe.enums.MandateType","text":"Bases: Enum Source code in djstripe/enums.py 469 470 471 class MandateType ( Enum ): multi_use = _ ( \"Multi-use\" ) single_use = _ ( \"Single-use\" )","title":"MandateType"},{"location":"reference/enums/#djstripe.enums.MandateType-attributes","text":"","title":"Attributes"},{"location":"reference/enums/#djstripe.enums.MandateType.multi_use","text":"","title":"multi_use"},{"location":"reference/enums/#djstripe.enums.MandateType.single_use","text":"","title":"single_use"},{"location":"reference/enums/#djstripe.enums.OrderStatus","text":"Bases: Enum Source code in djstripe/enums.py 474 475 476 477 478 479 class OrderStatus ( Enum ): open = _ ( \"Open\" ) submitted = _ ( \"Submitted\" ) processing = _ ( \"Processing\" ) complete = _ ( \"Complete\" ) canceled = _ ( \"Canceled\" )","title":"OrderStatus"},{"location":"reference/enums/#djstripe.enums.OrderStatus-attributes","text":"","title":"Attributes"},{"location":"reference/enums/#djstripe.enums.OrderStatus.canceled","text":"","title":"canceled"},{"location":"reference/enums/#djstripe.enums.OrderStatus.complete","text":"","title":"complete"},{"location":"reference/enums/#djstripe.enums.OrderStatus.open","text":"","title":"open"},{"location":"reference/enums/#djstripe.enums.OrderStatus.processing","text":"","title":"processing"},{"location":"reference/enums/#djstripe.enums.OrderStatus.submitted","text":"","title":"submitted"},{"location":"reference/enums/#djstripe.enums.PaymentIntentCancellationReason","text":"Bases: Enum Source code in djstripe/enums.py 604 605 606 607 608 609 610 611 612 613 614 class PaymentIntentCancellationReason ( Enum ): # see also SetupIntentCancellationReason # User provided reasons: duplicate = _ ( \"Duplicate\" ) fraudulent = _ ( \"Fraudulent\" ) abandoned = _ ( \"Abandoned\" ) requested_by_customer = _ ( \"Requested by Customer\" ) # Reasons generated by Stripe internally failed_invoice = _ ( \"Failed invoice\" ) void_invoice = _ ( \"Void invoice\" ) automatic = _ ( \"Automatic\" )","title":"PaymentIntentCancellationReason"},{"location":"reference/enums/#djstripe.enums.PaymentIntentCancellationReason-attributes","text":"","title":"Attributes"},{"location":"reference/enums/#djstripe.enums.PaymentIntentCancellationReason.abandoned","text":"","title":"abandoned"},{"location":"reference/enums/#djstripe.enums.PaymentIntentCancellationReason.automatic","text":"","title":"automatic"},{"location":"reference/enums/#djstripe.enums.PaymentIntentCancellationReason.duplicate","text":"","title":"duplicate"},{"location":"reference/enums/#djstripe.enums.PaymentIntentCancellationReason.failed_invoice","text":"","title":"failed_invoice"},{"location":"reference/enums/#djstripe.enums.PaymentIntentCancellationReason.fraudulent","text":"","title":"fraudulent"},{"location":"reference/enums/#djstripe.enums.PaymentIntentCancellationReason.requested_by_customer","text":"","title":"requested_by_customer"},{"location":"reference/enums/#djstripe.enums.PaymentIntentCancellationReason.void_invoice","text":"","title":"void_invoice"},{"location":"reference/enums/#djstripe.enums.PaymentIntentStatus","text":"Bases: Enum Source code in djstripe/enums.py 484 485 486 487 488 489 490 491 492 493 494 495 496 class PaymentIntentStatus ( Enum ): requires_payment_method = _ ( \"Intent created and requires a Payment Method to be attached.\" ) requires_confirmation = _ ( \"Intent is ready to be confirmed.\" ) requires_action = _ ( \"Payment Method require additional action, such as 3D secure.\" ) processing = _ ( \"Required actions have been handled.\" ) requires_capture = _ ( \"Capture the funds on the cards which have been put on holds.\" ) canceled = _ ( \"Cancellation invalidates the intent for future confirmation and \" \"cannot be undone.\" ) succeeded = _ ( \"The funds are in your account.\" )","title":"PaymentIntentStatus"},{"location":"reference/enums/#djstripe.enums.PaymentIntentStatus-attributes","text":"","title":"Attributes"},{"location":"reference/enums/#djstripe.enums.PaymentIntentStatus.canceled","text":"","title":"canceled"},{"location":"reference/enums/#djstripe.enums.PaymentIntentStatus.processing","text":"","title":"processing"},{"location":"reference/enums/#djstripe.enums.PaymentIntentStatus.requires_action","text":"","title":"requires_action"},{"location":"reference/enums/#djstripe.enums.PaymentIntentStatus.requires_capture","text":"","title":"requires_capture"},{"location":"reference/enums/#djstripe.enums.PaymentIntentStatus.requires_confirmation","text":"","title":"requires_confirmation"},{"location":"reference/enums/#djstripe.enums.PaymentIntentStatus.requires_payment_method","text":"","title":"requires_payment_method"},{"location":"reference/enums/#djstripe.enums.PaymentIntentStatus.succeeded","text":"","title":"succeeded"},{"location":"reference/enums/#djstripe.enums.PaymentMethodType","text":"Bases: Enum Source code in djstripe/enums.py 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 class PaymentMethodType ( Enum ): acss_debit = _ ( \"Acss Dbit\" ) affirm = _ ( \"Affirm\" ) afterpay_clearpay = _ ( \"Afterpay Clearpay\" ) alipay = _ ( \"Alipay\" ) au_becs_debit = _ ( \"BECS Debit (Australia)\" ) bacs_debit = _ ( \"Bacs Direct Debit\" ) bancontact = _ ( \"Bancontact\" ) blik = _ ( \"BLIK\" ) boleto = _ ( \"Boleto\" ) card = _ ( \"Card\" ) card_present = _ ( \"Card present\" ) customer_balance = _ ( \"Customer Balance\" ) eps = _ ( \"EPS\" ) fpx = _ ( \"FPX\" ) giropay = _ ( \"Giropay\" ) grabpay = _ ( \"Grabpay\" ) ideal = _ ( \"iDEAL\" ) interac_present = _ ( \"Interac (card present)\" ) klarna = _ ( \"Klarna\" ) konbini = _ ( \"Konbini\" ) link = _ ( \"Link\" ) oxxo = _ ( \"OXXO\" ) p24 = _ ( \"Przelewy24\" ) paynow = _ ( \"PayNow\" ) pix = _ ( \"Pix\" ) promptpay = _ ( \"PromptPay\" ) sepa_debit = _ ( \"SEPA Direct Debit\" ) sofort = _ ( \"SOFORT\" ) us_bank_account = _ ( \"ACH Direct Debit\" ) wechat_pay = _ ( \"Wechat Pay\" )","title":"PaymentMethodType"},{"location":"reference/enums/#djstripe.enums.PaymentMethodType-attributes","text":"","title":"Attributes"},{"location":"reference/enums/#djstripe.enums.PaymentMethodType.acss_debit","text":"","title":"acss_debit"},{"location":"reference/enums/#djstripe.enums.PaymentMethodType.affirm","text":"","title":"affirm"},{"location":"reference/enums/#djstripe.enums.PaymentMethodType.afterpay_clearpay","text":"","title":"afterpay_clearpay"},{"location":"reference/enums/#djstripe.enums.PaymentMethodType.alipay","text":"","title":"alipay"},{"location":"reference/enums/#djstripe.enums.PaymentMethodType.au_becs_debit","text":"","title":"au_becs_debit"},{"location":"reference/enums/#djstripe.enums.PaymentMethodType.bacs_debit","text":"","title":"bacs_debit"},{"location":"reference/enums/#djstripe.enums.PaymentMethodType.bancontact","text":"","title":"bancontact"},{"location":"reference/enums/#djstripe.enums.PaymentMethodType.blik","text":"","title":"blik"},{"location":"reference/enums/#djstripe.enums.PaymentMethodType.boleto","text":"","title":"boleto"},{"location":"reference/enums/#djstripe.enums.PaymentMethodType.card","text":"","title":"card"},{"location":"reference/enums/#djstripe.enums.PaymentMethodType.card_present","text":"","title":"card_present"},{"location":"reference/enums/#djstripe.enums.PaymentMethodType.customer_balance","text":"","title":"customer_balance"},{"location":"reference/enums/#djstripe.enums.PaymentMethodType.eps","text":"","title":"eps"},{"location":"reference/enums/#djstripe.enums.PaymentMethodType.fpx","text":"","title":"fpx"},{"location":"reference/enums/#djstripe.enums.PaymentMethodType.giropay","text":"","title":"giropay"},{"location":"reference/enums/#djstripe.enums.PaymentMethodType.grabpay","text":"","title":"grabpay"},{"location":"reference/enums/#djstripe.enums.PaymentMethodType.ideal","text":"","title":"ideal"},{"location":"reference/enums/#djstripe.enums.PaymentMethodType.interac_present","text":"","title":"interac_present"},{"location":"reference/enums/#djstripe.enums.PaymentMethodType.klarna","text":"","title":"klarna"},{"location":"reference/enums/#djstripe.enums.PaymentMethodType.konbini","text":"","title":"konbini"},{"location":"reference/enums/#djstripe.enums.PaymentMethodType.link","text":"","title":"link"},{"location":"reference/enums/#djstripe.enums.PaymentMethodType.oxxo","text":"","title":"oxxo"},{"location":"reference/enums/#djstripe.enums.PaymentMethodType.p24","text":"","title":"p24"},{"location":"reference/enums/#djstripe.enums.PaymentMethodType.paynow","text":"","title":"paynow"},{"location":"reference/enums/#djstripe.enums.PaymentMethodType.pix","text":"","title":"pix"},{"location":"reference/enums/#djstripe.enums.PaymentMethodType.promptpay","text":"","title":"promptpay"},{"location":"reference/enums/#djstripe.enums.PaymentMethodType.sepa_debit","text":"","title":"sepa_debit"},{"location":"reference/enums/#djstripe.enums.PaymentMethodType.sofort","text":"","title":"sofort"},{"location":"reference/enums/#djstripe.enums.PaymentMethodType.us_bank_account","text":"","title":"us_bank_account"},{"location":"reference/enums/#djstripe.enums.PaymentMethodType.wechat_pay","text":"","title":"wechat_pay"},{"location":"reference/enums/#djstripe.enums.PayoutFailureCode","text":"Bases: Enum Payout failure error codes. https://stripe.com/docs/api#payout_failures Source code in djstripe/enums.py 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 class PayoutFailureCode ( Enum ): \"\"\" Payout failure error codes. https://stripe.com/docs/api#payout_failures \"\"\" account_closed = _ ( \"Bank account has been closed.\" ) account_frozen = _ ( \"Bank account has been frozen.\" ) bank_account_restricted = _ ( \"Bank account has restrictions on payouts allowed.\" ) bank_ownership_changed = _ ( \"Destination bank account has changed ownership.\" ) could_not_process = _ ( \"Bank could not process payout.\" ) debit_not_authorized = _ ( \"Debit transactions not approved on the bank account.\" ) declined = _ ( \"The bank has declined this transfer. Please contact the bank before retrying.\" ) insufficient_funds = _ ( \"Stripe account has insufficient funds.\" ) invalid_account_number = _ ( \"Invalid account number\" ) incorrect_account_holder_name = _ ( \"Your bank notified us that the bank account holder name on file is incorrect.\" ) incorrect_account_holder_address = _ ( \"Your bank notified us that the bank account holder address on file is incorrect.\" ) incorrect_account_holder_tax_id = _ ( \"Your bank notified us that the bank account holder tax ID on file is incorrect.\" ) invalid_currency = _ ( \"Bank account does not support currency.\" ) no_account = _ ( \"Bank account could not be located.\" ) unsupported_card = _ ( \"Card no longer supported.\" )","title":"PayoutFailureCode"},{"location":"reference/enums/#djstripe.enums.PayoutFailureCode-attributes","text":"","title":"Attributes"},{"location":"reference/enums/#djstripe.enums.PayoutFailureCode.account_closed","text":"","title":"account_closed"},{"location":"reference/enums/#djstripe.enums.PayoutFailureCode.account_frozen","text":"","title":"account_frozen"},{"location":"reference/enums/#djstripe.enums.PayoutFailureCode.bank_account_restricted","text":"","title":"bank_account_restricted"},{"location":"reference/enums/#djstripe.enums.PayoutFailureCode.bank_ownership_changed","text":"","title":"bank_ownership_changed"},{"location":"reference/enums/#djstripe.enums.PayoutFailureCode.could_not_process","text":"","title":"could_not_process"},{"location":"reference/enums/#djstripe.enums.PayoutFailureCode.debit_not_authorized","text":"","title":"debit_not_authorized"},{"location":"reference/enums/#djstripe.enums.PayoutFailureCode.declined","text":"","title":"declined"},{"location":"reference/enums/#djstripe.enums.PayoutFailureCode.incorrect_account_holder_address","text":"","title":"incorrect_account_holder_address"},{"location":"reference/enums/#djstripe.enums.PayoutFailureCode.incorrect_account_holder_name","text":"","title":"incorrect_account_holder_name"},{"location":"reference/enums/#djstripe.enums.PayoutFailureCode.incorrect_account_holder_tax_id","text":"","title":"incorrect_account_holder_tax_id"},{"location":"reference/enums/#djstripe.enums.PayoutFailureCode.insufficient_funds","text":"","title":"insufficient_funds"},{"location":"reference/enums/#djstripe.enums.PayoutFailureCode.invalid_account_number","text":"","title":"invalid_account_number"},{"location":"reference/enums/#djstripe.enums.PayoutFailureCode.invalid_currency","text":"","title":"invalid_currency"},{"location":"reference/enums/#djstripe.enums.PayoutFailureCode.no_account","text":"","title":"no_account"},{"location":"reference/enums/#djstripe.enums.PayoutFailureCode.unsupported_card","text":"","title":"unsupported_card"},{"location":"reference/enums/#djstripe.enums.PayoutMethod","text":"Bases: Enum Source code in djstripe/enums.py 580 581 582 class PayoutMethod ( Enum ): standard = _ ( \"Standard\" ) instant = _ ( \"Instant\" )","title":"PayoutMethod"},{"location":"reference/enums/#djstripe.enums.PayoutMethod-attributes","text":"","title":"Attributes"},{"location":"reference/enums/#djstripe.enums.PayoutMethod.instant","text":"","title":"instant"},{"location":"reference/enums/#djstripe.enums.PayoutMethod.standard","text":"","title":"standard"},{"location":"reference/enums/#djstripe.enums.PayoutSourceType","text":"Bases: Enum Source code in djstripe/enums.py 585 586 587 588 class PayoutSourceType ( Enum ): bank_account = _ ( \"Bank account\" ) fpx = _ ( \"Financial Process Exchange (FPX)\" ) card = _ ( \"Card\" )","title":"PayoutSourceType"},{"location":"reference/enums/#djstripe.enums.PayoutSourceType-attributes","text":"","title":"Attributes"},{"location":"reference/enums/#djstripe.enums.PayoutSourceType.bank_account","text":"","title":"bank_account"},{"location":"reference/enums/#djstripe.enums.PayoutSourceType.card","text":"","title":"card"},{"location":"reference/enums/#djstripe.enums.PayoutSourceType.fpx","text":"","title":"fpx"},{"location":"reference/enums/#djstripe.enums.PayoutStatus","text":"Bases: Enum Source code in djstripe/enums.py 591 592 593 594 595 596 class PayoutStatus ( Enum ): paid = _ ( \"Paid\" ) pending = _ ( \"Pending\" ) in_transit = _ ( \"In transit\" ) canceled = _ ( \"Canceled\" ) failed = _ ( \"Failed\" )","title":"PayoutStatus"},{"location":"reference/enums/#djstripe.enums.PayoutStatus-attributes","text":"","title":"Attributes"},{"location":"reference/enums/#djstripe.enums.PayoutStatus.canceled","text":"","title":"canceled"},{"location":"reference/enums/#djstripe.enums.PayoutStatus.failed","text":"","title":"failed"},{"location":"reference/enums/#djstripe.enums.PayoutStatus.in_transit","text":"","title":"in_transit"},{"location":"reference/enums/#djstripe.enums.PayoutStatus.paid","text":"","title":"paid"},{"location":"reference/enums/#djstripe.enums.PayoutStatus.pending","text":"","title":"pending"},{"location":"reference/enums/#djstripe.enums.PayoutType","text":"Bases: Enum Source code in djstripe/enums.py 599 600 601 class PayoutType ( Enum ): bank_account = _ ( \"Bank account\" ) card = _ ( \"Card\" )","title":"PayoutType"},{"location":"reference/enums/#djstripe.enums.PayoutType-attributes","text":"","title":"Attributes"},{"location":"reference/enums/#djstripe.enums.PayoutType.bank_account","text":"","title":"bank_account"},{"location":"reference/enums/#djstripe.enums.PayoutType.card","text":"","title":"card"},{"location":"reference/enums/#djstripe.enums.PlanAggregateUsage","text":"Bases: Enum Source code in djstripe/enums.py 617 618 619 620 621 class PlanAggregateUsage ( Enum ): last_during_period = _ ( \"Last during period\" ) last_ever = _ ( \"Last ever\" ) max = _ ( \"Max\" ) sum = _ ( \"Sum\" )","title":"PlanAggregateUsage"},{"location":"reference/enums/#djstripe.enums.PlanAggregateUsage-attributes","text":"","title":"Attributes"},{"location":"reference/enums/#djstripe.enums.PlanAggregateUsage.last_during_period","text":"","title":"last_during_period"},{"location":"reference/enums/#djstripe.enums.PlanAggregateUsage.last_ever","text":"","title":"last_ever"},{"location":"reference/enums/#djstripe.enums.PlanAggregateUsage.max","text":"","title":"max"},{"location":"reference/enums/#djstripe.enums.PlanAggregateUsage.sum","text":"","title":"sum"},{"location":"reference/enums/#djstripe.enums.PlanInterval","text":"Bases: Enum Source code in djstripe/enums.py 624 625 626 627 628 class PlanInterval ( Enum ): day = _ ( \"Day\" ) week = _ ( \"Week\" ) month = _ ( \"Month\" ) year = _ ( \"Year\" )","title":"PlanInterval"},{"location":"reference/enums/#djstripe.enums.PlanInterval-attributes","text":"","title":"Attributes"},{"location":"reference/enums/#djstripe.enums.PlanInterval.day","text":"","title":"day"},{"location":"reference/enums/#djstripe.enums.PlanInterval.month","text":"","title":"month"},{"location":"reference/enums/#djstripe.enums.PlanInterval.week","text":"","title":"week"},{"location":"reference/enums/#djstripe.enums.PlanInterval.year","text":"","title":"year"},{"location":"reference/enums/#djstripe.enums.PriceTiersMode","text":"Bases: Enum Source code in djstripe/enums.py 631 632 633 class PriceTiersMode ( Enum ): graduated = _ ( \"Graduated\" ) volume = _ ( \"Volume-based\" )","title":"PriceTiersMode"},{"location":"reference/enums/#djstripe.enums.PriceTiersMode-attributes","text":"","title":"Attributes"},{"location":"reference/enums/#djstripe.enums.PriceTiersMode.graduated","text":"","title":"graduated"},{"location":"reference/enums/#djstripe.enums.PriceTiersMode.volume","text":"","title":"volume"},{"location":"reference/enums/#djstripe.enums.PriceType","text":"Bases: Enum Source code in djstripe/enums.py 636 637 638 class PriceType ( Enum ): one_time = _ ( \"One-time\" ) recurring = _ ( \"Recurring\" )","title":"PriceType"},{"location":"reference/enums/#djstripe.enums.PriceType-attributes","text":"","title":"Attributes"},{"location":"reference/enums/#djstripe.enums.PriceType.one_time","text":"","title":"one_time"},{"location":"reference/enums/#djstripe.enums.PriceType.recurring","text":"","title":"recurring"},{"location":"reference/enums/#djstripe.enums.PriceUsageType","text":"Bases: Enum Source code in djstripe/enums.py 641 642 643 class PriceUsageType ( Enum ): metered = _ ( \"Metered\" ) licensed = _ ( \"Licensed\" )","title":"PriceUsageType"},{"location":"reference/enums/#djstripe.enums.PriceUsageType-attributes","text":"","title":"Attributes"},{"location":"reference/enums/#djstripe.enums.PriceUsageType.licensed","text":"","title":"licensed"},{"location":"reference/enums/#djstripe.enums.PriceUsageType.metered","text":"","title":"metered"},{"location":"reference/enums/#djstripe.enums.ProductType","text":"Bases: Enum Source code in djstripe/enums.py 651 652 653 class ProductType ( Enum ): good = _ ( \"Good\" ) service = _ ( \"Service\" )","title":"ProductType"},{"location":"reference/enums/#djstripe.enums.ProductType-attributes","text":"","title":"Attributes"},{"location":"reference/enums/#djstripe.enums.ProductType.good","text":"","title":"good"},{"location":"reference/enums/#djstripe.enums.ProductType.service","text":"","title":"service"},{"location":"reference/enums/#djstripe.enums.RefundFailureReason","text":"Bases: Enum Source code in djstripe/enums.py 715 716 717 718 class RefundFailureReason ( Enum ): lost_or_stolen_card = _ ( \"Lost or stolen card\" ) expired_or_canceled_card = _ ( \"Expired or canceled card\" ) unknown = _ ( \"Unknown\" )","title":"RefundFailureReason"},{"location":"reference/enums/#djstripe.enums.RefundFailureReason-attributes","text":"","title":"Attributes"},{"location":"reference/enums/#djstripe.enums.RefundFailureReason.expired_or_canceled_card","text":"","title":"expired_or_canceled_card"},{"location":"reference/enums/#djstripe.enums.RefundFailureReason.lost_or_stolen_card","text":"","title":"lost_or_stolen_card"},{"location":"reference/enums/#djstripe.enums.RefundFailureReason.unknown","text":"","title":"unknown"},{"location":"reference/enums/#djstripe.enums.RefundReason","text":"Bases: Enum Source code in djstripe/enums.py 721 722 723 724 725 class RefundReason ( Enum ): duplicate = _ ( \"Duplicate charge\" ) fraudulent = _ ( \"Fraudulent\" ) requested_by_customer = _ ( \"Requested by customer\" ) expired_uncaptured_charge = _ ( \"Expired uncaptured charge\" )","title":"RefundReason"},{"location":"reference/enums/#djstripe.enums.RefundReason-attributes","text":"","title":"Attributes"},{"location":"reference/enums/#djstripe.enums.RefundReason.duplicate","text":"","title":"duplicate"},{"location":"reference/enums/#djstripe.enums.RefundReason.expired_uncaptured_charge","text":"","title":"expired_uncaptured_charge"},{"location":"reference/enums/#djstripe.enums.RefundReason.fraudulent","text":"","title":"fraudulent"},{"location":"reference/enums/#djstripe.enums.RefundReason.requested_by_customer","text":"","title":"requested_by_customer"},{"location":"reference/enums/#djstripe.enums.RefundStatus","text":"Bases: Enum Source code in djstripe/enums.py 728 729 730 731 732 class RefundStatus ( Enum ): pending = _ ( \"Pending\" ) succeeded = _ ( \"Succeeded\" ) failed = _ ( \"Failed\" ) canceled = _ ( \"Canceled\" )","title":"RefundStatus"},{"location":"reference/enums/#djstripe.enums.RefundStatus-attributes","text":"","title":"Attributes"},{"location":"reference/enums/#djstripe.enums.RefundStatus.canceled","text":"","title":"canceled"},{"location":"reference/enums/#djstripe.enums.RefundStatus.failed","text":"","title":"failed"},{"location":"reference/enums/#djstripe.enums.RefundStatus.pending","text":"","title":"pending"},{"location":"reference/enums/#djstripe.enums.RefundStatus.succeeded","text":"","title":"succeeded"},{"location":"reference/enums/#djstripe.enums.ScheduledQueryRunStatus","text":"Bases: Enum Source code in djstripe/enums.py 663 664 665 666 class ScheduledQueryRunStatus ( Enum ): canceled = _ ( \"Canceled\" ) failed = _ ( \"Failed\" ) timed_out = _ ( \"Timed out\" )","title":"ScheduledQueryRunStatus"},{"location":"reference/enums/#djstripe.enums.ScheduledQueryRunStatus-attributes","text":"","title":"Attributes"},{"location":"reference/enums/#djstripe.enums.ScheduledQueryRunStatus.canceled","text":"","title":"canceled"},{"location":"reference/enums/#djstripe.enums.ScheduledQueryRunStatus.failed","text":"","title":"failed"},{"location":"reference/enums/#djstripe.enums.ScheduledQueryRunStatus.timed_out","text":"","title":"timed_out"},{"location":"reference/enums/#djstripe.enums.SessionBillingAddressCollection","text":"Bases: Enum Source code in djstripe/enums.py 735 736 737 class SessionBillingAddressCollection ( Enum ): auto = _ ( \"Auto\" ) required = _ ( \"Required\" )","title":"SessionBillingAddressCollection"},{"location":"reference/enums/#djstripe.enums.SessionBillingAddressCollection-attributes","text":"","title":"Attributes"},{"location":"reference/enums/#djstripe.enums.SessionBillingAddressCollection.auto","text":"","title":"auto"},{"location":"reference/enums/#djstripe.enums.SessionBillingAddressCollection.required","text":"","title":"required"},{"location":"reference/enums/#djstripe.enums.SessionMode","text":"Bases: Enum Source code in djstripe/enums.py 740 741 742 743 class SessionMode ( Enum ): payment = _ ( \"Payment\" ) setup = _ ( \"Setup\" ) subscription = _ ( \"Subscription\" )","title":"SessionMode"},{"location":"reference/enums/#djstripe.enums.SessionMode-attributes","text":"","title":"Attributes"},{"location":"reference/enums/#djstripe.enums.SessionMode.payment","text":"","title":"payment"},{"location":"reference/enums/#djstripe.enums.SessionMode.setup","text":"","title":"setup"},{"location":"reference/enums/#djstripe.enums.SessionMode.subscription","text":"","title":"subscription"},{"location":"reference/enums/#djstripe.enums.SessionPaymentStatus","text":"Bases: Enum Source code in djstripe/enums.py 326 327 328 329 class SessionPaymentStatus ( Enum ): paid = _ ( \"Paid\" ) unpaid = _ ( \"Unpaid\" ) no_payment_required = _ ( \"No Payment Required\" )","title":"SessionPaymentStatus"},{"location":"reference/enums/#djstripe.enums.SessionPaymentStatus-attributes","text":"","title":"Attributes"},{"location":"reference/enums/#djstripe.enums.SessionPaymentStatus.no_payment_required","text":"","title":"no_payment_required"},{"location":"reference/enums/#djstripe.enums.SessionPaymentStatus.paid","text":"","title":"paid"},{"location":"reference/enums/#djstripe.enums.SessionPaymentStatus.unpaid","text":"","title":"unpaid"},{"location":"reference/enums/#djstripe.enums.SessionStatus","text":"Bases: Enum Source code in djstripe/enums.py 320 321 322 323 class SessionStatus ( Enum ): open = _ ( \"Open\" ) complete = _ ( \"Complete\" ) expired = _ ( \"Expired\" )","title":"SessionStatus"},{"location":"reference/enums/#djstripe.enums.SessionStatus-attributes","text":"","title":"Attributes"},{"location":"reference/enums/#djstripe.enums.SessionStatus.complete","text":"","title":"complete"},{"location":"reference/enums/#djstripe.enums.SessionStatus.expired","text":"","title":"expired"},{"location":"reference/enums/#djstripe.enums.SessionStatus.open","text":"","title":"open"},{"location":"reference/enums/#djstripe.enums.SetupIntentCancellationReason","text":"Bases: Enum Source code in djstripe/enums.py 656 657 658 659 660 class SetupIntentCancellationReason ( Enum ): # see also PaymentIntentCancellationReason abandoned = _ ( \"Abandoned\" ) requested_by_customer = _ ( \"Requested by Customer\" ) duplicate = _ ( \"Duplicate\" )","title":"SetupIntentCancellationReason"},{"location":"reference/enums/#djstripe.enums.SetupIntentCancellationReason-attributes","text":"","title":"Attributes"},{"location":"reference/enums/#djstripe.enums.SetupIntentCancellationReason.abandoned","text":"","title":"abandoned"},{"location":"reference/enums/#djstripe.enums.SetupIntentCancellationReason.duplicate","text":"","title":"duplicate"},{"location":"reference/enums/#djstripe.enums.SetupIntentCancellationReason.requested_by_customer","text":"","title":"requested_by_customer"},{"location":"reference/enums/#djstripe.enums.SetupIntentStatus","text":"Bases: Enum Source code in djstripe/enums.py 499 500 501 502 503 504 505 506 507 508 509 510 511 512 class SetupIntentStatus ( Enum ): requires_payment_method = _ ( \"Intent created and requires a Payment Method to be attached.\" ) requires_confirmation = _ ( \"Intent is ready to be confirmed.\" ) requires_action = _ ( \"Payment Method require additional action, such as 3D secure.\" ) processing = _ ( \"Required actions have been handled.\" ) canceled = _ ( \"Cancellation invalidates the intent for future confirmation and \" \"cannot be undone.\" ) succeeded = _ ( \"Setup was successful and the payment method is optimized for future payments.\" )","title":"SetupIntentStatus"},{"location":"reference/enums/#djstripe.enums.SetupIntentStatus-attributes","text":"","title":"Attributes"},{"location":"reference/enums/#djstripe.enums.SetupIntentStatus.canceled","text":"","title":"canceled"},{"location":"reference/enums/#djstripe.enums.SetupIntentStatus.processing","text":"","title":"processing"},{"location":"reference/enums/#djstripe.enums.SetupIntentStatus.requires_action","text":"","title":"requires_action"},{"location":"reference/enums/#djstripe.enums.SetupIntentStatus.requires_confirmation","text":"","title":"requires_confirmation"},{"location":"reference/enums/#djstripe.enums.SetupIntentStatus.requires_payment_method","text":"","title":"requires_payment_method"},{"location":"reference/enums/#djstripe.enums.SetupIntentStatus.succeeded","text":"","title":"succeeded"},{"location":"reference/enums/#djstripe.enums.ShippingRateTaxBehavior","text":"Bases: Enum Source code in djstripe/enums.py 810 811 812 813 class ShippingRateTaxBehavior ( Enum ): inclusive = _ ( \"Inclusive\" ) exclusive = _ ( \"Exclusive\" ) unspecified = _ ( \"Unspecified\" )","title":"ShippingRateTaxBehavior"},{"location":"reference/enums/#djstripe.enums.ShippingRateTaxBehavior-attributes","text":"","title":"Attributes"},{"location":"reference/enums/#djstripe.enums.ShippingRateTaxBehavior.exclusive","text":"","title":"exclusive"},{"location":"reference/enums/#djstripe.enums.ShippingRateTaxBehavior.inclusive","text":"","title":"inclusive"},{"location":"reference/enums/#djstripe.enums.ShippingRateTaxBehavior.unspecified","text":"","title":"unspecified"},{"location":"reference/enums/#djstripe.enums.ShippingRateType","text":"Bases: Enum Source code in djstripe/enums.py 806 807 class ShippingRateType ( Enum ): fixed_amount = _ ( \"Fixed Amount\" )","title":"ShippingRateType"},{"location":"reference/enums/#djstripe.enums.ShippingRateType-attributes","text":"","title":"Attributes"},{"location":"reference/enums/#djstripe.enums.ShippingRateType.fixed_amount","text":"","title":"fixed_amount"},{"location":"reference/enums/#djstripe.enums.SourceCodeVerificationStatus","text":"Bases: Enum Source code in djstripe/enums.py 751 752 753 754 class SourceCodeVerificationStatus ( Enum ): pending = _ ( \"Pending\" ) succeeded = _ ( \"Succeeded\" ) failed = _ ( \"Failed\" )","title":"SourceCodeVerificationStatus"},{"location":"reference/enums/#djstripe.enums.SourceCodeVerificationStatus-attributes","text":"","title":"Attributes"},{"location":"reference/enums/#djstripe.enums.SourceCodeVerificationStatus.failed","text":"","title":"failed"},{"location":"reference/enums/#djstripe.enums.SourceCodeVerificationStatus.pending","text":"","title":"pending"},{"location":"reference/enums/#djstripe.enums.SourceCodeVerificationStatus.succeeded","text":"","title":"succeeded"},{"location":"reference/enums/#djstripe.enums.SourceFlow","text":"Bases: Enum Source code in djstripe/enums.py 669 670 671 672 673 class SourceFlow ( Enum ): redirect = _ ( \"Redirect\" ) receiver = _ ( \"Receiver\" ) code_verification = _ ( \"Code verification\" ) none = _ ( \"None\" )","title":"SourceFlow"},{"location":"reference/enums/#djstripe.enums.SourceFlow-attributes","text":"","title":"Attributes"},{"location":"reference/enums/#djstripe.enums.SourceFlow.code_verification","text":"","title":"code_verification"},{"location":"reference/enums/#djstripe.enums.SourceFlow.none","text":"","title":"none"},{"location":"reference/enums/#djstripe.enums.SourceFlow.receiver","text":"","title":"receiver"},{"location":"reference/enums/#djstripe.enums.SourceFlow.redirect","text":"","title":"redirect"},{"location":"reference/enums/#djstripe.enums.SourceRedirectFailureReason","text":"Bases: Enum Source code in djstripe/enums.py 757 758 759 760 class SourceRedirectFailureReason ( Enum ): user_abort = _ ( \"User-aborted\" ) declined = _ ( \"Declined\" ) processing_error = _ ( \"Processing error\" )","title":"SourceRedirectFailureReason"},{"location":"reference/enums/#djstripe.enums.SourceRedirectFailureReason-attributes","text":"","title":"Attributes"},{"location":"reference/enums/#djstripe.enums.SourceRedirectFailureReason.declined","text":"","title":"declined"},{"location":"reference/enums/#djstripe.enums.SourceRedirectFailureReason.processing_error","text":"","title":"processing_error"},{"location":"reference/enums/#djstripe.enums.SourceRedirectFailureReason.user_abort","text":"","title":"user_abort"},{"location":"reference/enums/#djstripe.enums.SourceRedirectStatus","text":"Bases: Enum Source code in djstripe/enums.py 763 764 765 766 767 class SourceRedirectStatus ( Enum ): pending = _ ( \"Pending\" ) succeeded = _ ( \"Succeeded\" ) not_required = _ ( \"Not required\" ) failed = _ ( \"Failed\" )","title":"SourceRedirectStatus"},{"location":"reference/enums/#djstripe.enums.SourceRedirectStatus-attributes","text":"","title":"Attributes"},{"location":"reference/enums/#djstripe.enums.SourceRedirectStatus.failed","text":"","title":"failed"},{"location":"reference/enums/#djstripe.enums.SourceRedirectStatus.not_required","text":"","title":"not_required"},{"location":"reference/enums/#djstripe.enums.SourceRedirectStatus.pending","text":"","title":"pending"},{"location":"reference/enums/#djstripe.enums.SourceRedirectStatus.succeeded","text":"","title":"succeeded"},{"location":"reference/enums/#djstripe.enums.SourceStatus","text":"Bases: Enum Source code in djstripe/enums.py 676 677 678 679 680 681 class SourceStatus ( Enum ): canceled = _ ( \"Canceled\" ) chargeable = _ ( \"Chargeable\" ) consumed = _ ( \"Consumed\" ) failed = _ ( \"Failed\" ) pending = _ ( \"Pending\" )","title":"SourceStatus"},{"location":"reference/enums/#djstripe.enums.SourceStatus-attributes","text":"","title":"Attributes"},{"location":"reference/enums/#djstripe.enums.SourceStatus.canceled","text":"","title":"canceled"},{"location":"reference/enums/#djstripe.enums.SourceStatus.chargeable","text":"","title":"chargeable"},{"location":"reference/enums/#djstripe.enums.SourceStatus.consumed","text":"","title":"consumed"},{"location":"reference/enums/#djstripe.enums.SourceStatus.failed","text":"","title":"failed"},{"location":"reference/enums/#djstripe.enums.SourceStatus.pending","text":"","title":"pending"},{"location":"reference/enums/#djstripe.enums.SourceType","text":"Bases: Enum Source code in djstripe/enums.py 684 685 686 687 688 689 690 691 692 693 694 695 696 697 698 699 700 701 702 703 704 705 class SourceType ( Enum ): ach_credit_transfer = _ ( \"ACH Credit Transfer\" ) ach_debit = _ ( \"ACH Debit\" ) acss_debit = _ ( \"ACSS Debit\" ) alipay = _ ( \"Alipay\" ) au_becs_debit = _ ( \"BECS Debit (AU)\" ) bancontact = _ ( \"Bancontact\" ) bitcoin = _ ( \"Bitcoin (Legacy)\" ) card = _ ( \"Card\" ) card_present = _ ( \"Card present\" ) eps = _ ( \"EPS\" ) giropay = _ ( \"Giropay\" ) ideal = _ ( \"iDEAL\" ) klarna = _ ( \"Klarna\" ) multibanco = _ ( \"Multibanco\" ) p24 = _ ( \"P24\" ) paper_check = _ ( \"Paper check\" ) sepa_credit_transfer = _ ( \"SEPA credit transfer\" ) sepa_debit = _ ( \"SEPA Direct Debit\" ) sofort = _ ( \"SOFORT\" ) three_d_secure = _ ( \"3D Secure\" ) wechat = _ ( \"WeChat\" )","title":"SourceType"},{"location":"reference/enums/#djstripe.enums.SourceType-attributes","text":"","title":"Attributes"},{"location":"reference/enums/#djstripe.enums.SourceType.ach_credit_transfer","text":"","title":"ach_credit_transfer"},{"location":"reference/enums/#djstripe.enums.SourceType.ach_debit","text":"","title":"ach_debit"},{"location":"reference/enums/#djstripe.enums.SourceType.acss_debit","text":"","title":"acss_debit"},{"location":"reference/enums/#djstripe.enums.SourceType.alipay","text":"","title":"alipay"},{"location":"reference/enums/#djstripe.enums.SourceType.au_becs_debit","text":"","title":"au_becs_debit"},{"location":"reference/enums/#djstripe.enums.SourceType.bancontact","text":"","title":"bancontact"},{"location":"reference/enums/#djstripe.enums.SourceType.bitcoin","text":"","title":"bitcoin"},{"location":"reference/enums/#djstripe.enums.SourceType.card","text":"","title":"card"},{"location":"reference/enums/#djstripe.enums.SourceType.card_present","text":"","title":"card_present"},{"location":"reference/enums/#djstripe.enums.SourceType.eps","text":"","title":"eps"},{"location":"reference/enums/#djstripe.enums.SourceType.giropay","text":"","title":"giropay"},{"location":"reference/enums/#djstripe.enums.SourceType.ideal","text":"","title":"ideal"},{"location":"reference/enums/#djstripe.enums.SourceType.klarna","text":"","title":"klarna"},{"location":"reference/enums/#djstripe.enums.SourceType.multibanco","text":"","title":"multibanco"},{"location":"reference/enums/#djstripe.enums.SourceType.p24","text":"","title":"p24"},{"location":"reference/enums/#djstripe.enums.SourceType.paper_check","text":"","title":"paper_check"},{"location":"reference/enums/#djstripe.enums.SourceType.sepa_credit_transfer","text":"","title":"sepa_credit_transfer"},{"location":"reference/enums/#djstripe.enums.SourceType.sepa_debit","text":"","title":"sepa_debit"},{"location":"reference/enums/#djstripe.enums.SourceType.sofort","text":"","title":"sofort"},{"location":"reference/enums/#djstripe.enums.SourceType.three_d_secure","text":"","title":"three_d_secure"},{"location":"reference/enums/#djstripe.enums.SourceType.wechat","text":"","title":"wechat"},{"location":"reference/enums/#djstripe.enums.SourceUsage","text":"Bases: Enum Source code in djstripe/enums.py 746 747 748 class SourceUsage ( Enum ): reusable = _ ( \"Reusable\" ) single_use = _ ( \"Single-use\" )","title":"SourceUsage"},{"location":"reference/enums/#djstripe.enums.SourceUsage-attributes","text":"","title":"Attributes"},{"location":"reference/enums/#djstripe.enums.SourceUsage.reusable","text":"","title":"reusable"},{"location":"reference/enums/#djstripe.enums.SourceUsage.single_use","text":"","title":"single_use"},{"location":"reference/enums/#djstripe.enums.SubmitTypeStatus","text":"Bases: Enum Source code in djstripe/enums.py 770 771 772 773 774 class SubmitTypeStatus ( Enum ): auto = _ ( \"Auto\" ) book = _ ( \"Book\" ) donate = _ ( \"donate\" ) pay = _ ( \"pay\" )","title":"SubmitTypeStatus"},{"location":"reference/enums/#djstripe.enums.SubmitTypeStatus-attributes","text":"","title":"Attributes"},{"location":"reference/enums/#djstripe.enums.SubmitTypeStatus.auto","text":"","title":"auto"},{"location":"reference/enums/#djstripe.enums.SubmitTypeStatus.book","text":"","title":"book"},{"location":"reference/enums/#djstripe.enums.SubmitTypeStatus.donate","text":"","title":"donate"},{"location":"reference/enums/#djstripe.enums.SubmitTypeStatus.pay","text":"","title":"pay"},{"location":"reference/enums/#djstripe.enums.SubscriptionProrationBehavior","text":"Bases: Enum Source code in djstripe/enums.py 800 801 802 803 class SubscriptionProrationBehavior ( Enum ): create_prorations = _ ( \"Create prorations\" ) always_invoice = _ ( \"Always invoice\" ) none = _ ( \"None\" )","title":"SubscriptionProrationBehavior"},{"location":"reference/enums/#djstripe.enums.SubscriptionProrationBehavior-attributes","text":"","title":"Attributes"},{"location":"reference/enums/#djstripe.enums.SubscriptionProrationBehavior.always_invoice","text":"","title":"always_invoice"},{"location":"reference/enums/#djstripe.enums.SubscriptionProrationBehavior.create_prorations","text":"","title":"create_prorations"},{"location":"reference/enums/#djstripe.enums.SubscriptionProrationBehavior.none","text":"","title":"none"},{"location":"reference/enums/#djstripe.enums.SubscriptionScheduleEndBehavior","text":"Bases: Enum Source code in djstripe/enums.py 777 778 779 class SubscriptionScheduleEndBehavior ( Enum ): release = _ ( \"Release\" ) cancel = _ ( \"Cancel\" )","title":"SubscriptionScheduleEndBehavior"},{"location":"reference/enums/#djstripe.enums.SubscriptionScheduleEndBehavior-attributes","text":"","title":"Attributes"},{"location":"reference/enums/#djstripe.enums.SubscriptionScheduleEndBehavior.cancel","text":"","title":"cancel"},{"location":"reference/enums/#djstripe.enums.SubscriptionScheduleEndBehavior.release","text":"","title":"release"},{"location":"reference/enums/#djstripe.enums.SubscriptionScheduleStatus","text":"Bases: Enum Source code in djstripe/enums.py 782 783 784 785 786 787 class SubscriptionScheduleStatus ( Enum ): not_started = _ ( \"Not started\" ) active = _ ( \"Active\" ) completed = _ ( \"Completed\" ) released = _ ( \"Released\" ) canceled = _ ( \"Canceled\" )","title":"SubscriptionScheduleStatus"},{"location":"reference/enums/#djstripe.enums.SubscriptionScheduleStatus-attributes","text":"","title":"Attributes"},{"location":"reference/enums/#djstripe.enums.SubscriptionScheduleStatus.active","text":"","title":"active"},{"location":"reference/enums/#djstripe.enums.SubscriptionScheduleStatus.canceled","text":"","title":"canceled"},{"location":"reference/enums/#djstripe.enums.SubscriptionScheduleStatus.completed","text":"","title":"completed"},{"location":"reference/enums/#djstripe.enums.SubscriptionScheduleStatus.not_started","text":"","title":"not_started"},{"location":"reference/enums/#djstripe.enums.SubscriptionScheduleStatus.released","text":"","title":"released"},{"location":"reference/enums/#djstripe.enums.SubscriptionStatus","text":"Bases: Enum Source code in djstripe/enums.py 790 791 792 793 794 795 796 797 class SubscriptionStatus ( Enum ): incomplete = _ ( \"Incomplete\" ) incomplete_expired = _ ( \"Incomplete Expired\" ) trialing = _ ( \"Trialing\" ) active = _ ( \"Active\" ) past_due = _ ( \"Past due\" ) canceled = _ ( \"Canceled\" ) unpaid = _ ( \"Unpaid\" )","title":"SubscriptionStatus"},{"location":"reference/enums/#djstripe.enums.SubscriptionStatus-attributes","text":"","title":"Attributes"},{"location":"reference/enums/#djstripe.enums.SubscriptionStatus.active","text":"","title":"active"},{"location":"reference/enums/#djstripe.enums.SubscriptionStatus.canceled","text":"","title":"canceled"},{"location":"reference/enums/#djstripe.enums.SubscriptionStatus.incomplete","text":"","title":"incomplete"},{"location":"reference/enums/#djstripe.enums.SubscriptionStatus.incomplete_expired","text":"","title":"incomplete_expired"},{"location":"reference/enums/#djstripe.enums.SubscriptionStatus.past_due","text":"","title":"past_due"},{"location":"reference/enums/#djstripe.enums.SubscriptionStatus.trialing","text":"","title":"trialing"},{"location":"reference/enums/#djstripe.enums.SubscriptionStatus.unpaid","text":"","title":"unpaid"},{"location":"reference/enums/#djstripe.enums.TaxIdType","text":"Bases: Enum Source code in djstripe/enums.py 816 817 818 819 820 821 822 823 824 825 826 827 828 829 830 831 832 833 834 835 836 837 838 839 840 841 842 843 844 845 846 847 848 849 class TaxIdType ( Enum ): ae_trn = _ ( \"AE TRN\" ) au_abn = _ ( \"AU ABN\" ) br_cnp = _ ( \"BR CNP\" ) br_cpf = _ ( \"BR CPF\" ) ca_bn = _ ( \"CA BN\" ) ca_qst = _ ( \"CA QST\" ) ch_vat = _ ( \"CH VAT\" ) cl_tin = _ ( \"CL TIN\" ) es_cif = _ ( \"ES CIF\" ) eu_vat = _ ( \"EU VAT\" ) hk_br = _ ( \"HK BR\" ) id_npw = _ ( \"ID NPW\" ) in_gst = _ ( \"IN GST\" ) jp_cn = _ ( \"JP CN\" ) jp_rn = _ ( \"JP RN\" ) kr_brn = _ ( \"KR BRN\" ) li_uid = _ ( \"LI UID\" ) mx_rfc = _ ( \"MX RFC\" ) my_frp = _ ( \"MY FRP\" ) my_itn = _ ( \"MY ITN\" ) my_sst = _ ( \"MY SST\" ) no_vat = _ ( \"NO VAT\" ) nz_gst = _ ( \"NZ GST\" ) ru_inn = _ ( \"RU INN\" ) ru_kpp = _ ( \"RU KPP\" ) sa_vat = _ ( \"SA VAT\" ) sg_gst = _ ( \"SG GST\" ) sg_uen = _ ( \"SG UEN\" ) th_vat = _ ( \"TH VAT\" ) tw_vat = _ ( \"TW VAT\" ) us_ein = _ ( \"US EIN\" ) za_vat = _ ( \"ZA VAT\" ) unknown = _ ( \"Unknown\" )","title":"TaxIdType"},{"location":"reference/enums/#djstripe.enums.TaxIdType-attributes","text":"","title":"Attributes"},{"location":"reference/enums/#djstripe.enums.TaxIdType.ae_trn","text":"","title":"ae_trn"},{"location":"reference/enums/#djstripe.enums.TaxIdType.au_abn","text":"","title":"au_abn"},{"location":"reference/enums/#djstripe.enums.TaxIdType.br_cnp","text":"","title":"br_cnp"},{"location":"reference/enums/#djstripe.enums.TaxIdType.br_cpf","text":"","title":"br_cpf"},{"location":"reference/enums/#djstripe.enums.TaxIdType.ca_bn","text":"","title":"ca_bn"},{"location":"reference/enums/#djstripe.enums.TaxIdType.ca_qst","text":"","title":"ca_qst"},{"location":"reference/enums/#djstripe.enums.TaxIdType.ch_vat","text":"","title":"ch_vat"},{"location":"reference/enums/#djstripe.enums.TaxIdType.cl_tin","text":"","title":"cl_tin"},{"location":"reference/enums/#djstripe.enums.TaxIdType.es_cif","text":"","title":"es_cif"},{"location":"reference/enums/#djstripe.enums.TaxIdType.eu_vat","text":"","title":"eu_vat"},{"location":"reference/enums/#djstripe.enums.TaxIdType.hk_br","text":"","title":"hk_br"},{"location":"reference/enums/#djstripe.enums.TaxIdType.id_npw","text":"","title":"id_npw"},{"location":"reference/enums/#djstripe.enums.TaxIdType.in_gst","text":"","title":"in_gst"},{"location":"reference/enums/#djstripe.enums.TaxIdType.jp_cn","text":"","title":"jp_cn"},{"location":"reference/enums/#djstripe.enums.TaxIdType.jp_rn","text":"","title":"jp_rn"},{"location":"reference/enums/#djstripe.enums.TaxIdType.kr_brn","text":"","title":"kr_brn"},{"location":"reference/enums/#djstripe.enums.TaxIdType.li_uid","text":"","title":"li_uid"},{"location":"reference/enums/#djstripe.enums.TaxIdType.mx_rfc","text":"","title":"mx_rfc"},{"location":"reference/enums/#djstripe.enums.TaxIdType.my_frp","text":"","title":"my_frp"},{"location":"reference/enums/#djstripe.enums.TaxIdType.my_itn","text":"","title":"my_itn"},{"location":"reference/enums/#djstripe.enums.TaxIdType.my_sst","text":"","title":"my_sst"},{"location":"reference/enums/#djstripe.enums.TaxIdType.no_vat","text":"","title":"no_vat"},{"location":"reference/enums/#djstripe.enums.TaxIdType.nz_gst","text":"","title":"nz_gst"},{"location":"reference/enums/#djstripe.enums.TaxIdType.ru_inn","text":"","title":"ru_inn"},{"location":"reference/enums/#djstripe.enums.TaxIdType.ru_kpp","text":"","title":"ru_kpp"},{"location":"reference/enums/#djstripe.enums.TaxIdType.sa_vat","text":"","title":"sa_vat"},{"location":"reference/enums/#djstripe.enums.TaxIdType.sg_gst","text":"","title":"sg_gst"},{"location":"reference/enums/#djstripe.enums.TaxIdType.sg_uen","text":"","title":"sg_uen"},{"location":"reference/enums/#djstripe.enums.TaxIdType.th_vat","text":"","title":"th_vat"},{"location":"reference/enums/#djstripe.enums.TaxIdType.tw_vat","text":"","title":"tw_vat"},{"location":"reference/enums/#djstripe.enums.TaxIdType.unknown","text":"","title":"unknown"},{"location":"reference/enums/#djstripe.enums.TaxIdType.us_ein","text":"","title":"us_ein"},{"location":"reference/enums/#djstripe.enums.TaxIdType.za_vat","text":"","title":"za_vat"},{"location":"reference/enums/#djstripe.enums.UsageAction","text":"Bases: Enum Source code in djstripe/enums.py 852 853 854 class UsageAction ( Enum ): increment = _ ( \"increment\" ) set = _ ( \"set\" )","title":"UsageAction"},{"location":"reference/enums/#djstripe.enums.UsageAction-attributes","text":"","title":"Attributes"},{"location":"reference/enums/#djstripe.enums.UsageAction.increment","text":"","title":"increment"},{"location":"reference/enums/#djstripe.enums.UsageAction.set","text":"","title":"set"},{"location":"reference/enums/#djstripe.enums.WebhookEndpointStatus","text":"Bases: Enum Source code in djstripe/enums.py 857 858 859 class WebhookEndpointStatus ( Enum ): enabled = _ ( \"enabled\" ) disabled = _ ( \"disabled\" )","title":"WebhookEndpointStatus"},{"location":"reference/enums/#djstripe.enums.WebhookEndpointStatus-attributes","text":"","title":"Attributes"},{"location":"reference/enums/#djstripe.enums.WebhookEndpointStatus.disabled","text":"","title":"disabled"},{"location":"reference/enums/#djstripe.enums.WebhookEndpointStatus.enabled","text":"","title":"enabled"},{"location":"reference/managers/","text":"Managers dj-stripe model managers Classes djstripe.managers.ChargeManager Bases: models . Manager Manager used by models.Charge. Source code in djstripe/managers.py 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 class ChargeManager ( models . Manager ): \"\"\"Manager used by models.Charge.\"\"\" def during ( self , year , month ): \"\"\"Return Charges between a certain time range based on `created`.\"\"\" return self . filter ( created__year = year , created__month = month ) def paid_totals_for ( self , year , month ): \"\"\" Return paid Charges during a certain year, month with total amount, fee and refunded annotated. \"\"\" return ( self . during ( year , month ) . filter ( paid = True ) . aggregate ( total_amount = models . Sum ( \"amount\" ), total_refunded = models . Sum ( \"amount_refunded\" ), ) ) Functions djstripe . managers . ChargeManager . during ( year , month ) Return Charges between a certain time range based on created . Source code in djstripe/managers.py 86 87 88 def during ( self , year , month ): \"\"\"Return Charges between a certain time range based on `created`.\"\"\" return self . filter ( created__year = year , created__month = month ) djstripe . managers . ChargeManager . paid_totals_for ( year , month ) Return paid Charges during a certain year, month with total amount, fee and refunded annotated. Source code in djstripe/managers.py 90 91 92 93 94 95 96 97 98 99 100 101 102 def paid_totals_for ( self , year , month ): \"\"\" Return paid Charges during a certain year, month with total amount, fee and refunded annotated. \"\"\" return ( self . during ( year , month ) . filter ( paid = True ) . aggregate ( total_amount = models . Sum ( \"amount\" ), total_refunded = models . Sum ( \"amount_refunded\" ), ) ) djstripe.managers.StripeModelManager Bases: models . Manager Manager used in StripeModel. Source code in djstripe/managers.py 9 10 11 12 class StripeModelManager ( models . Manager ): \"\"\"Manager used in StripeModel.\"\"\" pass djstripe.managers.SubscriptionManager Bases: models . Manager Manager used in models.Subscription. Source code in djstripe/managers.py 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 class SubscriptionManager ( models . Manager ): \"\"\"Manager used in models.Subscription.\"\"\" def started_during ( self , year , month ): \"\"\"Return Subscriptions not in trial status between a certain time range.\"\"\" return self . exclude ( status = \"trialing\" ) . filter ( start_date__year = year , start_date__month = month ) def active ( self ): \"\"\"Return active Subscriptions.\"\"\" return self . filter ( status = \"active\" ) def canceled ( self ): \"\"\"Return canceled Subscriptions.\"\"\" return self . filter ( status = \"canceled\" ) def canceled_during ( self , year , month ): \"\"\"Return Subscriptions canceled during a certain time range.\"\"\" return self . canceled () . filter ( canceled_at__year = year , canceled_at__month = month ) def started_plan_summary_for ( self , year , month ): \"\"\"Return started_during Subscriptions with plan counts annotated.\"\"\" return ( self . started_during ( year , month ) . values ( \"plan\" ) . order_by () . annotate ( count = models . Count ( \"plan\" )) ) def active_plan_summary ( self ): \"\"\"Return active Subscriptions with plan counts annotated.\"\"\" return ( self . active () . values ( \"plan\" ) . order_by () . annotate ( count = models . Count ( \"plan\" )) ) def canceled_plan_summary_for ( self , year , month ): \"\"\" Return Subscriptions canceled within a time range with plan counts annotated. \"\"\" return ( self . canceled_during ( year , month ) . values ( \"plan\" ) . order_by () . annotate ( count = models . Count ( \"plan\" )) ) def churn ( self ): \"\"\"Return number of canceled Subscriptions divided by active Subscriptions.\"\"\" canceled = self . canceled () . count () active = self . active () . count () return decimal . Decimal ( str ( canceled )) / decimal . Decimal ( str ( active )) Functions djstripe . managers . SubscriptionManager . active () Return active Subscriptions. Source code in djstripe/managers.py 24 25 26 def active ( self ): \"\"\"Return active Subscriptions.\"\"\" return self . filter ( status = \"active\" ) djstripe . managers . SubscriptionManager . active_plan_summary () Return active Subscriptions with plan counts annotated. Source code in djstripe/managers.py 45 46 47 48 49 def active_plan_summary ( self ): \"\"\"Return active Subscriptions with plan counts annotated.\"\"\" return ( self . active () . values ( \"plan\" ) . order_by () . annotate ( count = models . Count ( \"plan\" )) ) djstripe . managers . SubscriptionManager . canceled () Return canceled Subscriptions. Source code in djstripe/managers.py 28 29 30 def canceled ( self ): \"\"\"Return canceled Subscriptions.\"\"\" return self . filter ( status = \"canceled\" ) djstripe . managers . SubscriptionManager . canceled_during ( year , month ) Return Subscriptions canceled during a certain time range. Source code in djstripe/managers.py 32 33 34 def canceled_during ( self , year , month ): \"\"\"Return Subscriptions canceled during a certain time range.\"\"\" return self . canceled () . filter ( canceled_at__year = year , canceled_at__month = month ) djstripe . managers . SubscriptionManager . canceled_plan_summary_for ( year , month ) Return Subscriptions canceled within a time range with plan counts annotated. Source code in djstripe/managers.py 51 52 53 54 55 56 57 58 59 60 def canceled_plan_summary_for ( self , year , month ): \"\"\" Return Subscriptions canceled within a time range with plan counts annotated. \"\"\" return ( self . canceled_during ( year , month ) . values ( \"plan\" ) . order_by () . annotate ( count = models . Count ( \"plan\" )) ) djstripe . managers . SubscriptionManager . churn () Return number of canceled Subscriptions divided by active Subscriptions. Source code in djstripe/managers.py 62 63 64 65 66 def churn ( self ): \"\"\"Return number of canceled Subscriptions divided by active Subscriptions.\"\"\" canceled = self . canceled () . count () active = self . active () . count () return decimal . Decimal ( str ( canceled )) / decimal . Decimal ( str ( active )) djstripe . managers . SubscriptionManager . started_during ( year , month ) Return Subscriptions not in trial status between a certain time range. Source code in djstripe/managers.py 18 19 20 21 22 def started_during ( self , year , month ): \"\"\"Return Subscriptions not in trial status between a certain time range.\"\"\" return self . exclude ( status = \"trialing\" ) . filter ( start_date__year = year , start_date__month = month ) djstripe . managers . SubscriptionManager . started_plan_summary_for ( year , month ) Return started_during Subscriptions with plan counts annotated. Source code in djstripe/managers.py 36 37 38 39 40 41 42 43 def started_plan_summary_for ( self , year , month ): \"\"\"Return started_during Subscriptions with plan counts annotated.\"\"\" return ( self . started_during ( year , month ) . values ( \"plan\" ) . order_by () . annotate ( count = models . Count ( \"plan\" )) ) djstripe.managers.TransferManager Bases: models . Manager Manager used by models.Transfer. Source code in djstripe/managers.py 69 70 71 72 73 74 75 76 77 78 79 80 class TransferManager ( models . Manager ): \"\"\"Manager used by models.Transfer.\"\"\" def during ( self , year , month ): \"\"\"Return Transfers between a certain time range.\"\"\" return self . filter ( created__year = year , created__month = month ) def paid_totals_for ( self , year , month ): \"\"\" Return paid Transfers during a certain year, month with total amounts annotated. \"\"\" return self . during ( year , month ) . aggregate ( total_amount = models . Sum ( \"amount\" )) Functions djstripe . managers . TransferManager . during ( year , month ) Return Transfers between a certain time range. Source code in djstripe/managers.py 72 73 74 def during ( self , year , month ): \"\"\"Return Transfers between a certain time range.\"\"\" return self . filter ( created__year = year , created__month = month ) djstripe . managers . TransferManager . paid_totals_for ( year , month ) Return paid Transfers during a certain year, month with total amounts annotated. Source code in djstripe/managers.py 76 77 78 79 80 def paid_totals_for ( self , year , month ): \"\"\" Return paid Transfers during a certain year, month with total amounts annotated. \"\"\" return self . during ( year , month ) . aggregate ( total_amount = models . Sum ( \"amount\" ))","title":"Managers"},{"location":"reference/managers/#managers","text":"dj-stripe model managers","title":"Managers"},{"location":"reference/managers/#djstripe.managers-classes","text":"","title":"Classes"},{"location":"reference/managers/#djstripe.managers.ChargeManager","text":"Bases: models . Manager Manager used by models.Charge. Source code in djstripe/managers.py 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 class ChargeManager ( models . Manager ): \"\"\"Manager used by models.Charge.\"\"\" def during ( self , year , month ): \"\"\"Return Charges between a certain time range based on `created`.\"\"\" return self . filter ( created__year = year , created__month = month ) def paid_totals_for ( self , year , month ): \"\"\" Return paid Charges during a certain year, month with total amount, fee and refunded annotated. \"\"\" return ( self . during ( year , month ) . filter ( paid = True ) . aggregate ( total_amount = models . Sum ( \"amount\" ), total_refunded = models . Sum ( \"amount_refunded\" ), ) )","title":"ChargeManager"},{"location":"reference/managers/#djstripe.managers.ChargeManager-functions","text":"","title":"Functions"},{"location":"reference/managers/#djstripe.managers.ChargeManager.during","text":"Return Charges between a certain time range based on created . Source code in djstripe/managers.py 86 87 88 def during ( self , year , month ): \"\"\"Return Charges between a certain time range based on `created`.\"\"\" return self . filter ( created__year = year , created__month = month )","title":"during()"},{"location":"reference/managers/#djstripe.managers.ChargeManager.paid_totals_for","text":"Return paid Charges during a certain year, month with total amount, fee and refunded annotated. Source code in djstripe/managers.py 90 91 92 93 94 95 96 97 98 99 100 101 102 def paid_totals_for ( self , year , month ): \"\"\" Return paid Charges during a certain year, month with total amount, fee and refunded annotated. \"\"\" return ( self . during ( year , month ) . filter ( paid = True ) . aggregate ( total_amount = models . Sum ( \"amount\" ), total_refunded = models . Sum ( \"amount_refunded\" ), ) )","title":"paid_totals_for()"},{"location":"reference/managers/#djstripe.managers.StripeModelManager","text":"Bases: models . Manager Manager used in StripeModel. Source code in djstripe/managers.py 9 10 11 12 class StripeModelManager ( models . Manager ): \"\"\"Manager used in StripeModel.\"\"\" pass","title":"StripeModelManager"},{"location":"reference/managers/#djstripe.managers.SubscriptionManager","text":"Bases: models . Manager Manager used in models.Subscription. Source code in djstripe/managers.py 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 class SubscriptionManager ( models . Manager ): \"\"\"Manager used in models.Subscription.\"\"\" def started_during ( self , year , month ): \"\"\"Return Subscriptions not in trial status between a certain time range.\"\"\" return self . exclude ( status = \"trialing\" ) . filter ( start_date__year = year , start_date__month = month ) def active ( self ): \"\"\"Return active Subscriptions.\"\"\" return self . filter ( status = \"active\" ) def canceled ( self ): \"\"\"Return canceled Subscriptions.\"\"\" return self . filter ( status = \"canceled\" ) def canceled_during ( self , year , month ): \"\"\"Return Subscriptions canceled during a certain time range.\"\"\" return self . canceled () . filter ( canceled_at__year = year , canceled_at__month = month ) def started_plan_summary_for ( self , year , month ): \"\"\"Return started_during Subscriptions with plan counts annotated.\"\"\" return ( self . started_during ( year , month ) . values ( \"plan\" ) . order_by () . annotate ( count = models . Count ( \"plan\" )) ) def active_plan_summary ( self ): \"\"\"Return active Subscriptions with plan counts annotated.\"\"\" return ( self . active () . values ( \"plan\" ) . order_by () . annotate ( count = models . Count ( \"plan\" )) ) def canceled_plan_summary_for ( self , year , month ): \"\"\" Return Subscriptions canceled within a time range with plan counts annotated. \"\"\" return ( self . canceled_during ( year , month ) . values ( \"plan\" ) . order_by () . annotate ( count = models . Count ( \"plan\" )) ) def churn ( self ): \"\"\"Return number of canceled Subscriptions divided by active Subscriptions.\"\"\" canceled = self . canceled () . count () active = self . active () . count () return decimal . Decimal ( str ( canceled )) / decimal . Decimal ( str ( active ))","title":"SubscriptionManager"},{"location":"reference/managers/#djstripe.managers.SubscriptionManager-functions","text":"","title":"Functions"},{"location":"reference/managers/#djstripe.managers.SubscriptionManager.active","text":"Return active Subscriptions. Source code in djstripe/managers.py 24 25 26 def active ( self ): \"\"\"Return active Subscriptions.\"\"\" return self . filter ( status = \"active\" )","title":"active()"},{"location":"reference/managers/#djstripe.managers.SubscriptionManager.active_plan_summary","text":"Return active Subscriptions with plan counts annotated. Source code in djstripe/managers.py 45 46 47 48 49 def active_plan_summary ( self ): \"\"\"Return active Subscriptions with plan counts annotated.\"\"\" return ( self . active () . values ( \"plan\" ) . order_by () . annotate ( count = models . Count ( \"plan\" )) )","title":"active_plan_summary()"},{"location":"reference/managers/#djstripe.managers.SubscriptionManager.canceled","text":"Return canceled Subscriptions. Source code in djstripe/managers.py 28 29 30 def canceled ( self ): \"\"\"Return canceled Subscriptions.\"\"\" return self . filter ( status = \"canceled\" )","title":"canceled()"},{"location":"reference/managers/#djstripe.managers.SubscriptionManager.canceled_during","text":"Return Subscriptions canceled during a certain time range. Source code in djstripe/managers.py 32 33 34 def canceled_during ( self , year , month ): \"\"\"Return Subscriptions canceled during a certain time range.\"\"\" return self . canceled () . filter ( canceled_at__year = year , canceled_at__month = month )","title":"canceled_during()"},{"location":"reference/managers/#djstripe.managers.SubscriptionManager.canceled_plan_summary_for","text":"Return Subscriptions canceled within a time range with plan counts annotated. Source code in djstripe/managers.py 51 52 53 54 55 56 57 58 59 60 def canceled_plan_summary_for ( self , year , month ): \"\"\" Return Subscriptions canceled within a time range with plan counts annotated. \"\"\" return ( self . canceled_during ( year , month ) . values ( \"plan\" ) . order_by () . annotate ( count = models . Count ( \"plan\" )) )","title":"canceled_plan_summary_for()"},{"location":"reference/managers/#djstripe.managers.SubscriptionManager.churn","text":"Return number of canceled Subscriptions divided by active Subscriptions. Source code in djstripe/managers.py 62 63 64 65 66 def churn ( self ): \"\"\"Return number of canceled Subscriptions divided by active Subscriptions.\"\"\" canceled = self . canceled () . count () active = self . active () . count () return decimal . Decimal ( str ( canceled )) / decimal . Decimal ( str ( active ))","title":"churn()"},{"location":"reference/managers/#djstripe.managers.SubscriptionManager.started_during","text":"Return Subscriptions not in trial status between a certain time range. Source code in djstripe/managers.py 18 19 20 21 22 def started_during ( self , year , month ): \"\"\"Return Subscriptions not in trial status between a certain time range.\"\"\" return self . exclude ( status = \"trialing\" ) . filter ( start_date__year = year , start_date__month = month )","title":"started_during()"},{"location":"reference/managers/#djstripe.managers.SubscriptionManager.started_plan_summary_for","text":"Return started_during Subscriptions with plan counts annotated. Source code in djstripe/managers.py 36 37 38 39 40 41 42 43 def started_plan_summary_for ( self , year , month ): \"\"\"Return started_during Subscriptions with plan counts annotated.\"\"\" return ( self . started_during ( year , month ) . values ( \"plan\" ) . order_by () . annotate ( count = models . Count ( \"plan\" )) )","title":"started_plan_summary_for()"},{"location":"reference/managers/#djstripe.managers.TransferManager","text":"Bases: models . Manager Manager used by models.Transfer. Source code in djstripe/managers.py 69 70 71 72 73 74 75 76 77 78 79 80 class TransferManager ( models . Manager ): \"\"\"Manager used by models.Transfer.\"\"\" def during ( self , year , month ): \"\"\"Return Transfers between a certain time range.\"\"\" return self . filter ( created__year = year , created__month = month ) def paid_totals_for ( self , year , month ): \"\"\" Return paid Transfers during a certain year, month with total amounts annotated. \"\"\" return self . during ( year , month ) . aggregate ( total_amount = models . Sum ( \"amount\" ))","title":"TransferManager"},{"location":"reference/managers/#djstripe.managers.TransferManager-functions","text":"","title":"Functions"},{"location":"reference/managers/#djstripe.managers.TransferManager.during","text":"Return Transfers between a certain time range. Source code in djstripe/managers.py 72 73 74 def during ( self , year , month ): \"\"\"Return Transfers between a certain time range.\"\"\" return self . filter ( created__year = year , created__month = month )","title":"during()"},{"location":"reference/managers/#djstripe.managers.TransferManager.paid_totals_for","text":"Return paid Transfers during a certain year, month with total amounts annotated. Source code in djstripe/managers.py 76 77 78 79 80 def paid_totals_for ( self , year , month ): \"\"\" Return paid Transfers during a certain year, month with total amounts annotated. \"\"\" return self . during ( year , month ) . aggregate ( total_amount = models . Sum ( \"amount\" ))","title":"paid_totals_for()"},{"location":"reference/models/","text":"Models Models hold the bulk of the functionality included in the dj-stripe package. Each model is tied closely to its corresponding object in the stripe dashboard. Fields that are not implemented for each model have a short reason behind the decision in the docstring for each model. Core Resources Attributes djstripe . models . core . FileUpload = File module-attribute Classes djstripe.models.core.BalanceTransaction Bases: StripeModel A single transaction that updates the Stripe balance. Stripe documentation: https://stripe.com/docs/api?lang=python#balance_transaction_object Source code in djstripe/models/core.py 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 class BalanceTransaction ( StripeModel ): \"\"\" A single transaction that updates the Stripe balance. Stripe documentation: https://stripe.com/docs/api?lang=python#balance_transaction_object \"\"\" stripe_class = stripe . BalanceTransaction amount = StripeQuantumCurrencyAmountField ( help_text = \"Gross amount of the transaction, in cents.\" ) available_on = StripeDateTimeField ( help_text = ( \"The date the transaction's net funds \" \"will become available in the Stripe balance.\" ) ) currency = StripeCurrencyCodeField () exchange_rate = models . DecimalField ( null = True , decimal_places = 6 , max_digits = 8 ) fee = StripeQuantumCurrencyAmountField ( help_text = \"Fee (in cents) paid for this transaction.\" ) fee_details = JSONField () net = StripeQuantumCurrencyAmountField ( help_text = \"Net amount of the transaction, in cents.\" ) source = StripeIdField () reporting_category = StripeEnumField ( enum = enums . BalanceTransactionReportingCategory , help_text = ( \"More information: https://stripe.com/docs/reports/reporting-categories\" ), ) status = StripeEnumField ( enum = enums . BalanceTransactionStatus ) type = StripeEnumField ( enum = enums . BalanceTransactionType ) def __str__ ( self ): amount = get_friendly_currency_amount ( self . amount / 100 , self . currency ) status = enums . BalanceTransactionStatus . humanize ( self . status ) return f \" { amount } ( { status } )\" def get_source_class ( self ): try : return apps . get_model ( \"djstripe\" , self . type ) except LookupError : raise def get_source_instance ( self ): return self . get_source_class () . objects . get ( id = self . source ) def get_stripe_dashboard_url ( self ): return self . get_source_instance () . get_stripe_dashboard_url () Attributes djstripe . models . core . BalanceTransaction . amount = StripeQuantumCurrencyAmountField ( help_text = 'Gross amount of the transaction, in cents.' ) class-attribute djstripe . models . core . BalanceTransaction . available_on = StripeDateTimeField ( help_text = \"The date the transaction's net funds will become available in the Stripe balance.\" ) class-attribute djstripe . models . core . BalanceTransaction . currency = StripeCurrencyCodeField () class-attribute djstripe . models . core . BalanceTransaction . exchange_rate = models . DecimalField ( null = True , decimal_places = 6 , max_digits = 8 ) class-attribute djstripe . models . core . BalanceTransaction . fee = StripeQuantumCurrencyAmountField ( help_text = 'Fee (in cents) paid for this transaction.' ) class-attribute djstripe . models . core . BalanceTransaction . fee_details = JSONField () class-attribute djstripe . models . core . BalanceTransaction . net = StripeQuantumCurrencyAmountField ( help_text = 'Net amount of the transaction, in cents.' ) class-attribute djstripe . models . core . BalanceTransaction . reporting_category = StripeEnumField ( enum = enums . BalanceTransactionReportingCategory , help_text = 'More information: https://stripe.com/docs/reports/reporting-categories' ) class-attribute djstripe . models . core . BalanceTransaction . source = StripeIdField () class-attribute djstripe . models . core . BalanceTransaction . status = StripeEnumField ( enum = enums . BalanceTransactionStatus ) class-attribute djstripe . models . core . BalanceTransaction . stripe_class = stripe . BalanceTransaction class-attribute djstripe . models . core . BalanceTransaction . type = StripeEnumField ( enum = enums . BalanceTransactionType ) class-attribute Functions djstripe . models . core . BalanceTransaction . __str__ () Source code in djstripe/models/core.py 90 91 92 93 def __str__ ( self ): amount = get_friendly_currency_amount ( self . amount / 100 , self . currency ) status = enums . BalanceTransactionStatus . humanize ( self . status ) return f \" { amount } ( { status } )\" djstripe . models . core . BalanceTransaction . get_source_class () Source code in djstripe/models/core.py 95 96 97 98 99 def get_source_class ( self ): try : return apps . get_model ( \"djstripe\" , self . type ) except LookupError : raise djstripe . models . core . BalanceTransaction . get_source_instance () Source code in djstripe/models/core.py 101 102 def get_source_instance ( self ): return self . get_source_class () . objects . get ( id = self . source ) djstripe . models . core . BalanceTransaction . get_stripe_dashboard_url () Source code in djstripe/models/core.py 104 105 def get_stripe_dashboard_url ( self ): return self . get_source_instance () . get_stripe_dashboard_url () djstripe.models.core.Charge Bases: StripeModel To charge a credit or a debit card, you create a charge object. You can retrieve and refund individual charges as well as list all charges. Charges are identified by a unique random ID. Stripe documentation: https://stripe.com/docs/api?lang=python#charges Source code in djstripe/models/core.py 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 class Charge ( StripeModel ): \"\"\" To charge a credit or a debit card, you create a charge object. You can retrieve and refund individual charges as well as list all charges. Charges are identified by a unique random ID. Stripe documentation: https://stripe.com/docs/api?lang=python#charges \"\"\" stripe_class = stripe . Charge expand_fields = [ \"balance_transaction\" ] stripe_dashboard_item_name = \"payments\" amount = StripeDecimalCurrencyAmountField ( help_text = \"Amount charged (as decimal).\" ) amount_captured = StripeDecimalCurrencyAmountField ( null = True , help_text = ( \"Amount (as decimal) captured (can be less than the amount attribute \" \"on the charge if a partial capture was issued).\" ), ) amount_refunded = StripeDecimalCurrencyAmountField ( help_text = ( \"Amount (as decimal) refunded (can be less than the amount attribute on \" \"the charge if a partial refund was issued).\" ) ) application = models . CharField ( max_length = 255 , blank = True , help_text = \"ID of the Connect application that created the charge.\" , ) application_fee = StripeForeignKey ( \"ApplicationFee\" , on_delete = models . SET_NULL , null = True , blank = True , related_name = \"fee_for_charge\" , help_text = \"The application fee (if any) for the charge.\" , ) application_fee_amount = StripeDecimalCurrencyAmountField ( null = True , blank = True , help_text = \"The amount (as decimal) of the application fee (if any) \" \"requested for the charge.\" , ) balance_transaction = StripeForeignKey ( \"BalanceTransaction\" , on_delete = models . SET_NULL , null = True , help_text = ( \"The balance transaction that describes the impact of this charge \" \"on your account balance (not including refunds or disputes).\" ), ) billing_details = JSONField ( null = True , help_text = \"Billing information associated with the PaymentMethod at the \" \"time of the transaction.\" , ) calculated_statement_descriptor = models . CharField ( max_length = 22 , default = \"\" , help_text = \"The full statement descriptor that is passed to card networks, \" \"and that is displayed on your customers' credit card and bank statements. \" \"Allows you to see what the statement descriptor looks like after the \" \"static and dynamic portions are combined.\" , ) captured = models . BooleanField ( default = False , help_text = \"If the charge was created without capturing, this boolean \" \"represents whether or not it is still uncaptured or has since been captured.\" , ) currency = StripeCurrencyCodeField ( help_text = \"The currency in which the charge was made.\" ) customer = StripeForeignKey ( \"Customer\" , on_delete = models . SET_NULL , null = True , blank = True , related_name = \"charges\" , help_text = \"The customer associated with this charge.\" , ) dispute = StripeForeignKey ( \"Dispute\" , on_delete = models . SET_NULL , null = True , blank = True , related_name = \"charges\" , help_text = \"Details about the dispute if the charge has been disputed.\" , ) disputed = models . BooleanField ( default = False , help_text = \"Whether the charge has been disputed.\" , ) failure_code = StripeEnumField ( enum = enums . ApiErrorCode , default = \"\" , blank = True , help_text = \"Error code explaining reason for charge failure if available.\" , ) failure_message = models . TextField ( max_length = 5000 , default = \"\" , blank = True , help_text = \"Message to user further explaining reason \" \"for charge failure if available.\" , ) fraud_details = JSONField ( help_text = \"Hash with information on fraud assessments for the charge.\" , null = True , blank = True , ) invoice = StripeForeignKey ( \"Invoice\" , on_delete = models . CASCADE , null = True , related_name = \"charges\" , help_text = \"The invoice this charge is for if one exists.\" , ) # TODO: order (requires Order model) on_behalf_of = StripeForeignKey ( \"Account\" , on_delete = models . CASCADE , null = True , blank = True , related_name = \"charges\" , help_text = \"The account (if any) the charge was made on behalf of \" \"without triggering an automatic transfer.\" , ) outcome = JSONField ( help_text = \"Details about whether or not the payment was accepted, and why.\" , null = True , blank = True , ) paid = models . BooleanField ( default = False , help_text = \"True if the charge succeeded, \" \"or was successfully authorized for later capture, False otherwise.\" , ) payment_intent = StripeForeignKey ( \"PaymentIntent\" , null = True , on_delete = models . SET_NULL , related_name = \"charges\" , help_text = \"PaymentIntent associated with this charge, if one exists.\" , ) payment_method = StripeForeignKey ( \"PaymentMethod\" , null = True , on_delete = models . SET_NULL , related_name = \"charges\" , help_text = \"PaymentMethod used in this charge.\" , ) payment_method_details = JSONField ( help_text = \"Details about the payment method at the time of the transaction.\" , null = True , blank = True , ) receipt_email = models . TextField ( max_length = 800 , # yup, 800. default = \"\" , blank = True , help_text = \"The email address that the receipt for this charge was sent to.\" , ) receipt_number = models . CharField ( max_length = 14 , default = \"\" , blank = True , help_text = \"The transaction number that appears \" \"on email receipts sent for this charge.\" , ) receipt_url = models . TextField ( max_length = 5000 , default = \"\" , blank = True , help_text = \"This is the URL to view the receipt for this charge. \" \"The receipt is kept up-to-date to the latest state of the charge, \" \"including any refunds. If the charge is for an Invoice, \" \"the receipt will be stylized as an Invoice receipt.\" , ) refunded = models . BooleanField ( default = False , help_text = \"Whether or not the charge has been fully refunded. \" \"If the charge is only partially refunded, \" \"this attribute will still be false.\" , ) # TODO: review (requires Review model) shipping = JSONField ( null = True , blank = True , help_text = \"Shipping information for the charge\" ) source = PaymentMethodForeignKey ( on_delete = models . SET_NULL , null = True , blank = True , related_name = \"charges\" , help_text = \"The source used for this charge.\" , ) source_transfer = StripeForeignKey ( \"Transfer\" , null = True , blank = True , on_delete = models . CASCADE , help_text = \"The transfer which created this charge. Only present if the \" \"charge came from another Stripe account.\" , related_name = \"+\" , ) statement_descriptor = models . CharField ( max_length = 22 , null = True , blank = True , help_text = \"For card charges, use statement_descriptor_suffix instead. \" \"Otherwise, you can use this value as the complete description of a \" \"charge on your customers' statements. Must contain at least one letter, \" \"maximum 22 characters.\" , ) statement_descriptor_suffix = models . CharField ( max_length = 22 , null = True , blank = True , help_text = \"Provides information about the charge that customers see on \" \"their statements. Concatenated with the prefix (shortened descriptor) \" \"or statement descriptor that's set on the account to form the \" \"complete statement descriptor. \" \"Maximum 22 characters for the concatenated descriptor.\" , ) status = StripeEnumField ( enum = enums . ChargeStatus , help_text = \"The status of the payment.\" ) transfer = StripeForeignKey ( \"Transfer\" , on_delete = models . CASCADE , null = True , blank = True , help_text = ( \"The transfer to the `destination` account (only applicable if \" \"the charge was created using the `destination` parameter).\" ), ) transfer_data = JSONField ( null = True , blank = True , help_text = \"An optional dictionary including the account to automatically \" \"transfer to as part of a destination charge.\" , ) transfer_group = models . CharField ( max_length = 255 , null = True , blank = True , help_text = \"A string that identifies this transaction as part of a group.\" , ) objects = ChargeManager () def __str__ ( self ): amount = get_friendly_currency_amount ( self . amount , self . currency ) return f \" { amount } ( { self . human_readable_status } )\" @property def fee ( self ): if self . balance_transaction : return self . balance_transaction . fee @property def human_readable_status ( self ) -> str : if not self . captured : return \"Uncaptured\" elif self . disputed : return \"Disputed\" elif self . refunded : return \"Refunded\" return enums . ChargeStatus . humanize ( self . status ) @property def fraudulent ( self ) -> bool : return ( self . fraud_details and list ( self . fraud_details . values ())[ 0 ] == \"fraudulent\" ) def _calculate_refund_amount ( self , amount : Optional [ Decimal ]) -> int : \"\"\" Returns the amount that can be refunded (in cents) \"\"\" eligible_to_refund = self . amount - ( self . amount_refunded or 0 ) amount_to_refund = ( min ( eligible_to_refund , amount ) if amount else eligible_to_refund ) return int ( amount_to_refund * 100 ) def refund ( self , amount : Decimal = None , reason : str = None , api_key : str = None , stripe_account : str = None , ) -> \"Refund\" : \"\"\" Initiate a refund. Returns the refund object. :param amount: A positive decimal amount representing how much of this charge to refund. If amount is not provided, then this will be a full refund. Can only refund up to the unrefunded amount remaining of the charge. :param reason: String indicating the reason for the refund. If set, possible values are ``duplicate``, ``fraudulent``, and ``requested_by_customer``. Specifying ``fraudulent`` as the reason when you believe the charge to be fraudulent will help Stripe improve their fraud detection algorithms. \"\"\" # Prefer passed in stripe_account if set. if not stripe_account : stripe_account = self . _get_stripe_account_id ( api_key ) refund_obj = Refund . _api_create ( charge = self . id , amount = self . _calculate_refund_amount ( amount = amount ), reason = reason , api_key = api_key or self . default_api_key , stripe_account = stripe_account , ) return Refund . sync_from_stripe_data ( refund_obj , api_key = api_key or self . default_api_key , stripe_version = djstripe_settings . STRIPE_API_VERSION , ) def capture ( self , ** kwargs ) -> \"Charge\" : \"\"\" Capture the payment of an existing, uncaptured, charge. This is the second half of the two-step payment flow, where first you created a charge with the capture option set to False. See https://stripe.com/docs/api#capture_charge \"\"\" captured_charge = self . api_retrieve () . capture ( ** kwargs ) return self . __class__ . sync_from_stripe_data ( captured_charge , api_key = self . default_api_key ) def _attach_objects_post_save_hook ( self , cls , data , pending_relations = None , api_key = djstripe_settings . STRIPE_SECRET_KEY , ): super () . _attach_objects_post_save_hook ( cls , data , pending_relations = pending_relations , api_key = api_key ) cls . _stripe_object_to_refunds ( target_cls = Refund , data = data , charge = self , api_key = api_key ) Attributes djstripe . models . core . Charge . amount = StripeDecimalCurrencyAmountField ( help_text = 'Amount charged (as decimal).' ) class-attribute djstripe . models . core . Charge . amount_captured = StripeDecimalCurrencyAmountField ( null = True , help_text = 'Amount (as decimal) captured (can be less than the amount attribute on the charge if a partial capture was issued).' ) class-attribute djstripe . models . core . Charge . amount_refunded = StripeDecimalCurrencyAmountField ( help_text = 'Amount (as decimal) refunded (can be less than the amount attribute on the charge if a partial refund was issued).' ) class-attribute djstripe . models . core . Charge . application = models . CharField ( max_length = 255 , blank = True , help_text = 'ID of the Connect application that created the charge.' ) class-attribute djstripe . models . core . Charge . application_fee = StripeForeignKey ( 'ApplicationFee' , on_delete = models . SET_NULL , null = True , blank = True , related_name = 'fee_for_charge' , help_text = 'The application fee (if any) for the charge.' ) class-attribute djstripe . models . core . Charge . application_fee_amount = StripeDecimalCurrencyAmountField ( null = True , blank = True , help_text = 'The amount (as decimal) of the application fee (if any) requested for the charge.' ) class-attribute djstripe . models . core . Charge . balance_transaction = StripeForeignKey ( 'BalanceTransaction' , on_delete = models . SET_NULL , null = True , help_text = 'The balance transaction that describes the impact of this charge on your account balance (not including refunds or disputes).' ) class-attribute djstripe . models . core . Charge . billing_details = JSONField ( null = True , help_text = 'Billing information associated with the PaymentMethod at the time of the transaction.' ) class-attribute djstripe . models . core . Charge . calculated_statement_descriptor = models . CharField ( max_length = 22 , default = '' , help_text = \"The full statement descriptor that is passed to card networks, and that is displayed on your customers' credit card and bank statements. Allows you to see what the statement descriptor looks like after the static and dynamic portions are combined.\" ) class-attribute djstripe . models . core . Charge . captured = models . BooleanField ( default = False , help_text = 'If the charge was created without capturing, this boolean represents whether or not it is still uncaptured or has since been captured.' ) class-attribute djstripe . models . core . Charge . currency = StripeCurrencyCodeField ( help_text = 'The currency in which the charge was made.' ) class-attribute djstripe . models . core . Charge . customer = StripeForeignKey ( 'Customer' , on_delete = models . SET_NULL , null = True , blank = True , related_name = 'charges' , help_text = 'The customer associated with this charge.' ) class-attribute djstripe . models . core . Charge . dispute = StripeForeignKey ( 'Dispute' , on_delete = models . SET_NULL , null = True , blank = True , related_name = 'charges' , help_text = 'Details about the dispute if the charge has been disputed.' ) class-attribute djstripe . models . core . Charge . disputed = models . BooleanField ( default = False , help_text = 'Whether the charge has been disputed.' ) class-attribute djstripe . models . core . Charge . expand_fields = [ 'balance_transaction' ] class-attribute djstripe . models . core . Charge . failure_code = StripeEnumField ( enum = enums . ApiErrorCode , default = '' , blank = True , help_text = 'Error code explaining reason for charge failure if available.' ) class-attribute djstripe . models . core . Charge . failure_message = models . TextField ( max_length = 5000 , default = '' , blank = True , help_text = 'Message to user further explaining reason for charge failure if available.' ) class-attribute djstripe . models . core . Charge . fee property djstripe . models . core . Charge . fraud_details = JSONField ( help_text = 'Hash with information on fraud assessments for the charge.' , null = True , blank = True ) class-attribute djstripe . models . core . Charge . fraudulent : bool property djstripe . models . core . Charge . human_readable_status : str property djstripe . models . core . Charge . invoice = StripeForeignKey ( 'Invoice' , on_delete = models . CASCADE , null = True , related_name = 'charges' , help_text = 'The invoice this charge is for if one exists.' ) class-attribute djstripe . models . core . Charge . objects = ChargeManager () class-attribute djstripe . models . core . Charge . on_behalf_of = StripeForeignKey ( 'Account' , on_delete = models . CASCADE , null = True , blank = True , related_name = 'charges' , help_text = 'The account (if any) the charge was made on behalf of without triggering an automatic transfer.' ) class-attribute djstripe . models . core . Charge . outcome = JSONField ( help_text = 'Details about whether or not the payment was accepted, and why.' , null = True , blank = True ) class-attribute djstripe . models . core . Charge . paid = models . BooleanField ( default = False , help_text = 'True if the charge succeeded, or was successfully authorized for later capture, False otherwise.' ) class-attribute djstripe . models . core . Charge . payment_intent = StripeForeignKey ( 'PaymentIntent' , null = True , on_delete = models . SET_NULL , related_name = 'charges' , help_text = 'PaymentIntent associated with this charge, if one exists.' ) class-attribute djstripe . models . core . Charge . payment_method = StripeForeignKey ( 'PaymentMethod' , null = True , on_delete = models . SET_NULL , related_name = 'charges' , help_text = 'PaymentMethod used in this charge.' ) class-attribute djstripe . models . core . Charge . payment_method_details = JSONField ( help_text = 'Details about the payment method at the time of the transaction.' , null = True , blank = True ) class-attribute djstripe . models . core . Charge . receipt_email = models . TextField ( max_length = 800 , default = '' , blank = True , help_text = 'The email address that the receipt for this charge was sent to.' ) class-attribute djstripe . models . core . Charge . receipt_number = models . CharField ( max_length = 14 , default = '' , blank = True , help_text = 'The transaction number that appears on email receipts sent for this charge.' ) class-attribute djstripe . models . core . Charge . receipt_url = models . TextField ( max_length = 5000 , default = '' , blank = True , help_text = 'This is the URL to view the receipt for this charge. The receipt is kept up-to-date to the latest state of the charge, including any refunds. If the charge is for an Invoice, the receipt will be stylized as an Invoice receipt.' ) class-attribute djstripe . models . core . Charge . refunded = models . BooleanField ( default = False , help_text = 'Whether or not the charge has been fully refunded. If the charge is only partially refunded, this attribute will still be false.' ) class-attribute djstripe . models . core . Charge . shipping = JSONField ( null = True , blank = True , help_text = 'Shipping information for the charge' ) class-attribute djstripe . models . core . Charge . source = PaymentMethodForeignKey ( on_delete = models . SET_NULL , null = True , blank = True , related_name = 'charges' , help_text = 'The source used for this charge.' ) class-attribute djstripe . models . core . Charge . source_transfer = StripeForeignKey ( 'Transfer' , null = True , blank = True , on_delete = models . CASCADE , help_text = 'The transfer which created this charge. Only present if the charge came from another Stripe account.' , related_name = '+' ) class-attribute djstripe . models . core . Charge . statement_descriptor = models . CharField ( max_length = 22 , null = True , blank = True , help_text = \"For card charges, use statement_descriptor_suffix instead. Otherwise, you can use this value as the complete description of a charge on your customers' statements. Must contain at least one letter, maximum 22 characters.\" ) class-attribute djstripe . models . core . Charge . statement_descriptor_suffix = models . CharField ( max_length = 22 , null = True , blank = True , help_text = \"Provides information about the charge that customers see on their statements. Concatenated with the prefix (shortened descriptor) or statement descriptor that's set on the account to form the complete statement descriptor. Maximum 22 characters for the concatenated descriptor.\" ) class-attribute djstripe . models . core . Charge . status = StripeEnumField ( enum = enums . ChargeStatus , help_text = 'The status of the payment.' ) class-attribute djstripe . models . core . Charge . stripe_class = stripe . Charge class-attribute djstripe . models . core . Charge . stripe_dashboard_item_name = 'payments' class-attribute djstripe . models . core . Charge . transfer = StripeForeignKey ( 'Transfer' , on_delete = models . CASCADE , null = True , blank = True , help_text = 'The transfer to the `destination` account (only applicable if the charge was created using the `destination` parameter).' ) class-attribute djstripe . models . core . Charge . transfer_data = JSONField ( null = True , blank = True , help_text = 'An optional dictionary including the account to automatically transfer to as part of a destination charge.' ) class-attribute djstripe . models . core . Charge . transfer_group = models . CharField ( max_length = 255 , null = True , blank = True , help_text = 'A string that identifies this transaction as part of a group.' ) class-attribute Functions djstripe . models . core . Charge . __str__ () Source code in djstripe/models/core.py 364 365 366 def __str__ ( self ): amount = get_friendly_currency_amount ( self . amount , self . currency ) return f \" { amount } ( { self . human_readable_status } )\" djstripe . models . core . Charge . capture ( ** kwargs ) Capture the payment of an existing, uncaptured, charge. This is the second half of the two-step payment flow, where first you created a charge with the capture option set to False. See https://stripe.com/docs/api#capture_charge Source code in djstripe/models/core.py 437 438 439 440 441 442 443 444 445 446 447 448 449 def capture ( self , ** kwargs ) -> \"Charge\" : \"\"\" Capture the payment of an existing, uncaptured, charge. This is the second half of the two-step payment flow, where first you created a charge with the capture option set to False. See https://stripe.com/docs/api#capture_charge \"\"\" captured_charge = self . api_retrieve () . capture ( ** kwargs ) return self . __class__ . sync_from_stripe_data ( captured_charge , api_key = self . default_api_key ) djstripe . models . core . Charge . refund ( amount = None , reason = None , api_key = None , stripe_account = None ) Initiate a refund. Returns the refund object. :param amount: A positive decimal amount representing how much of this charge to refund. If amount is not provided, then this will be a full refund. Can only refund up to the unrefunded amount remaining of the charge. :param reason: String indicating the reason for the refund. If set, possible values are duplicate , fraudulent , and requested_by_customer . Specifying fraudulent as the reason when you believe the charge to be fraudulent will help Stripe improve their fraud detection algorithms. Source code in djstripe/models/core.py 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 def refund ( self , amount : Decimal = None , reason : str = None , api_key : str = None , stripe_account : str = None , ) -> \"Refund\" : \"\"\" Initiate a refund. Returns the refund object. :param amount: A positive decimal amount representing how much of this charge to refund. If amount is not provided, then this will be a full refund. Can only refund up to the unrefunded amount remaining of the charge. :param reason: String indicating the reason for the refund. If set, possible values are ``duplicate``, ``fraudulent``, and ``requested_by_customer``. Specifying ``fraudulent`` as the reason when you believe the charge to be fraudulent will help Stripe improve their fraud detection algorithms. \"\"\" # Prefer passed in stripe_account if set. if not stripe_account : stripe_account = self . _get_stripe_account_id ( api_key ) refund_obj = Refund . _api_create ( charge = self . id , amount = self . _calculate_refund_amount ( amount = amount ), reason = reason , api_key = api_key or self . default_api_key , stripe_account = stripe_account , ) return Refund . sync_from_stripe_data ( refund_obj , api_key = api_key or self . default_api_key , stripe_version = djstripe_settings . STRIPE_API_VERSION , ) djstripe.models.core.Customer Bases: StripeModel Customer objects allow you to perform recurring charges and track multiple charges that are associated with the same customer. Stripe documentation: https://stripe.com/docs/api?lang=python#customers Source code in djstripe/models/core.py 637 638 639 640 641 642 643 644 645 646 647 648 649 650 651 652 653 654 655 656 657 658 659 660 661 662 663 664 665 666 667 668 669 670 671 672 673 674 675 676 677 678 679 680 681 682 683 684 685 686 687 688 689 690 691 692 693 694 695 696 697 698 699 700 701 702 703 704 705 706 707 708 709 710 711 712 713 714 715 716 717 718 719 720 721 722 723 724 725 726 727 728 729 730 731 732 733 734 735 736 737 738 739 740 741 742 743 744 745 746 747 748 749 750 751 752 753 754 755 756 757 758 759 760 761 762 763 764 765 766 767 768 769 770 771 772 773 774 775 776 777 778 779 780 781 782 783 784 785 786 787 788 789 790 791 792 793 794 795 796 797 798 799 800 801 802 803 804 805 806 807 808 809 810 811 812 813 814 815 816 817 818 819 820 821 822 823 824 825 826 827 828 829 830 831 832 833 834 835 836 837 838 839 840 841 842 843 844 845 846 847 848 849 850 851 852 853 854 855 856 857 858 859 860 861 862 863 864 865 866 867 868 869 870 871 872 873 874 875 876 877 878 879 880 881 882 883 884 885 886 887 888 889 890 891 892 893 894 895 896 897 898 899 900 901 902 903 904 905 906 907 908 909 910 911 912 913 914 915 916 917 918 919 920 921 922 923 924 925 926 927 928 929 930 931 932 933 934 935 936 937 938 939 940 941 942 943 944 945 946 947 948 949 950 951 952 953 954 955 956 957 958 959 960 961 962 963 964 965 966 967 968 969 970 971 972 973 974 975 976 977 978 979 980 981 982 983 984 985 986 987 988 989 990 991 992 993 994 995 996 997 998 999 1000 1001 1002 1003 1004 1005 1006 1007 1008 1009 1010 1011 1012 1013 1014 1015 1016 1017 1018 1019 1020 1021 1022 1023 1024 1025 1026 1027 1028 1029 1030 1031 1032 1033 1034 1035 1036 1037 1038 1039 1040 1041 1042 1043 1044 1045 1046 1047 1048 1049 1050 1051 1052 1053 1054 1055 1056 1057 1058 1059 1060 1061 1062 1063 1064 1065 1066 1067 1068 1069 1070 1071 1072 1073 1074 1075 1076 1077 1078 1079 1080 1081 1082 1083 1084 1085 1086 1087 1088 1089 1090 1091 1092 1093 1094 1095 1096 1097 1098 1099 1100 1101 1102 1103 1104 1105 1106 1107 1108 1109 1110 1111 1112 1113 1114 1115 1116 1117 1118 1119 1120 1121 1122 1123 1124 1125 1126 1127 1128 1129 1130 1131 1132 1133 1134 1135 1136 1137 1138 1139 1140 1141 1142 1143 1144 1145 1146 1147 1148 1149 1150 1151 1152 1153 1154 1155 1156 1157 1158 1159 1160 1161 1162 1163 1164 1165 1166 1167 1168 1169 1170 1171 1172 1173 1174 1175 1176 1177 1178 1179 1180 1181 1182 1183 1184 1185 1186 1187 1188 1189 1190 1191 1192 1193 1194 1195 1196 1197 1198 1199 1200 1201 1202 1203 1204 1205 1206 1207 1208 1209 1210 1211 1212 1213 1214 1215 1216 1217 1218 1219 1220 1221 1222 1223 1224 1225 1226 1227 1228 1229 1230 1231 1232 1233 1234 1235 1236 1237 1238 1239 1240 1241 1242 1243 1244 1245 1246 1247 1248 1249 1250 1251 1252 1253 1254 1255 1256 1257 1258 1259 1260 1261 1262 1263 1264 1265 1266 1267 1268 1269 1270 1271 1272 1273 1274 1275 1276 1277 1278 1279 1280 1281 1282 1283 1284 1285 1286 1287 1288 1289 1290 1291 1292 1293 1294 1295 1296 1297 1298 1299 1300 1301 1302 1303 1304 1305 1306 1307 1308 1309 1310 1311 1312 1313 1314 1315 1316 1317 1318 1319 1320 1321 1322 1323 1324 1325 1326 1327 1328 1329 1330 1331 1332 1333 1334 1335 1336 1337 1338 1339 1340 1341 1342 1343 1344 1345 1346 1347 1348 1349 1350 1351 1352 1353 1354 1355 1356 1357 1358 1359 1360 1361 1362 1363 1364 1365 1366 1367 1368 1369 1370 1371 1372 1373 1374 1375 1376 1377 1378 1379 1380 1381 1382 1383 1384 1385 1386 1387 1388 1389 1390 1391 1392 1393 class Customer ( StripeModel ): \"\"\" Customer objects allow you to perform recurring charges and track multiple charges that are associated with the same customer. Stripe documentation: https://stripe.com/docs/api?lang=python#customers \"\"\" stripe_class = stripe . Customer expand_fields = [ \"default_source\" , \"sources\" ] stripe_dashboard_item_name = \"customers\" address = JSONField ( null = True , blank = True , help_text = \"The customer's address.\" ) balance = StripeQuantumCurrencyAmountField ( null = True , blank = True , default = 0 , help_text = ( \"Current balance (in cents), if any, being stored on the customer's \" \"account. \" \"If negative, the customer has credit to apply to the next invoice. \" \"If positive, the customer has an amount owed that will be added to the \" \"next invoice. The balance does not refer to any unpaid invoices; it \" \"solely takes into account amounts that have yet to be successfully \" \"applied to any invoice. This balance is only taken into account for \" \"recurring billing purposes (i.e., subscriptions, invoices, invoice items).\" ), ) currency = StripeCurrencyCodeField ( blank = True , default = \"\" , help_text = \"The currency the customer can be charged in for \" \"recurring billing purposes\" , ) default_source = PaymentMethodForeignKey ( on_delete = models . SET_NULL , null = True , blank = True , related_name = \"customers\" ) delinquent = models . BooleanField ( null = True , blank = True , default = False , help_text = \"Whether or not the latest charge for the customer's \" \"latest invoice has failed.\" , ) # Stripe API returns deleted customers like so: # { # \"id\": \"cus_KX439W5dKrpi22\", # \"object\": \"customer\", # \"deleted\": true, # } deleted = models . BooleanField ( default = False , null = True , blank = True , help_text = \"Whether the Customer instance has been deleted upstream in Stripe or not.\" , ) # <discount> coupon = models . ForeignKey ( \"Coupon\" , null = True , blank = True , on_delete = models . SET_NULL ) coupon_start = StripeDateTimeField ( null = True , blank = True , editable = False , help_text = \"If a coupon is present, the date at which it was applied.\" , ) coupon_end = StripeDateTimeField ( null = True , blank = True , editable = False , help_text = \"If a coupon is present and has a limited duration, \" \"the date that the discount will end.\" , ) # </discount> discount = JSONField ( null = True , blank = True , help_text = \"Describes the current discount active on the customer, if there is one.\" , ) email = models . TextField ( max_length = 5000 , default = \"\" , blank = True ) invoice_prefix = models . CharField ( default = \"\" , blank = True , max_length = 255 , help_text = ( \"The prefix for the customer used to generate unique invoice numbers.\" ), ) invoice_settings = JSONField ( null = True , blank = True , help_text = \"The customer's default invoice settings.\" ) # default_payment_method is actually nested inside invoice_settings # this field is a convenience to provide the foreign key default_payment_method = StripeForeignKey ( \"PaymentMethod\" , null = True , blank = True , on_delete = models . SET_NULL , related_name = \"+\" , help_text = \"default payment method used for subscriptions and invoices \" \"for the customer.\" , ) name = models . TextField ( max_length = 5000 , default = \"\" , blank = True , help_text = \"The customer's full name or business name.\" , ) phone = models . TextField ( max_length = 5000 , default = \"\" , blank = True , help_text = \"The customer's phone number.\" , ) preferred_locales = JSONField ( null = True , blank = True , help_text = ( \"The customer's preferred locales (languages), ordered by preference.\" ), ) shipping = JSONField ( null = True , blank = True , help_text = \"Shipping information associated with the customer.\" , ) tax_exempt = StripeEnumField ( enum = enums . CustomerTaxExempt , default = \"\" , help_text = \"Describes the customer's tax exemption status. When set to reverse, \" 'invoice and receipt PDFs include the text \"Reverse charge\".' , ) # dj-stripe fields subscriber = models . ForeignKey ( djstripe_settings . get_subscriber_model_string (), blank = True , null = True , on_delete = models . SET_NULL , related_name = \"djstripe_customers\" , ) date_purged = models . DateTimeField ( null = True , editable = False ) class Meta ( StripeModel . Meta ): unique_together = ( \"subscriber\" , \"livemode\" , \"djstripe_owner_account\" ) def __str__ ( self ): if self . subscriber : return str ( self . subscriber ) return self . name or self . description or self . id @classmethod def _manipulate_stripe_object_hook ( cls , data ): # stripe adds a deleted attribute if the Customer has been deleted upstream if data . get ( \"deleted\" ): logger . warning ( f \"This customer ( { data . get ( 'id' ) } ) has been deleted upstream, in Stripe\" ) else : # set \"deleted\" key to False (default) data [ \"deleted\" ] = False discount = data . get ( \"discount\" ) if discount : data [ \"coupon_start\" ] = discount [ \"start\" ] data [ \"coupon_end\" ] = discount [ \"end\" ] # Populate the object id for our default_payment_method field (or set it None) data [ \"default_payment_method\" ] = data . get ( \"invoice_settings\" , {}) . get ( \"default_payment_method\" ) return data @classmethod def get_or_create ( cls , subscriber , livemode = djstripe_settings . STRIPE_LIVE_MODE , stripe_account = None , ): \"\"\" Get or create a dj-stripe customer. :param subscriber: The subscriber model instance for which to get or create a customer. :type subscriber: User :param livemode: Whether to get the subscriber in live or test mode. :type livemode: bool \"\"\" try : return cls . objects . get ( subscriber = subscriber , livemode = livemode ), False except cls . DoesNotExist : action = f \"create: { subscriber . pk } \" idempotency_key = djstripe_settings . get_idempotency_key ( \"customer\" , action , livemode ) return ( cls . create ( subscriber , idempotency_key = idempotency_key , stripe_account = stripe_account , ), True , ) @classmethod def create ( cls , subscriber , idempotency_key = None , stripe_account = None ): metadata = {} subscriber_key = djstripe_settings . SUBSCRIBER_CUSTOMER_KEY if subscriber_key not in ( \"\" , None ): metadata [ subscriber_key ] = subscriber . pk stripe_customer = cls . _api_create ( email = subscriber . email , idempotency_key = idempotency_key , metadata = metadata , stripe_account = stripe_account , ) customer , created = cls . objects . get_or_create ( id = stripe_customer [ \"id\" ], defaults = { \"subscriber\" : subscriber , \"livemode\" : stripe_customer [ \"livemode\" ], \"balance\" : stripe_customer . get ( \"balance\" , 0 ), \"delinquent\" : stripe_customer . get ( \"delinquent\" , False ), }, ) return customer @property def credits ( self ): \"\"\" The customer is considered to have credits if their balance is below 0. \"\"\" return abs ( min ( self . balance , 0 )) @property def customer_payment_methods ( self ): \"\"\" An iterable of all of the customer's payment methods (sources, then legacy cards) \"\"\" for source in self . sources . iterator (): yield source for card in self . legacy_cards . iterator (): yield card @property def pending_charges ( self ): \"\"\" The customer is considered to have pending charges if their balance is above 0. \"\"\" return max ( self . balance , 0 ) def subscribe ( self , * , items = None , price = None , plan = None , ** kwargs ): \"\"\" Subscribes this customer to all the prices or plans in the items dict (Recommended). :param items: A list of up to 20 subscription items, each with an attached price :type list: :param items: A dictionary of Plan (or Plan ID) or Price (or Price ID) :type dict: The price or plan to which to subscribe the customer. :param price: The price to which to subscribe the customer. :type price: Price or string (price ID) :param plan: The plan to which to subscribe the customer. :type plan: Plan or string (plan ID) \"\"\" from .billing import Subscription if ( items and price ) or ( items and plan ) or ( price and plan ): raise TypeError ( \"Please define only one of items, price or plan arguments.\" ) if items is None : _items = [{ \"price\" : price }] else : _items = [] for item in items : price = item . get ( \"price\" , \"\" ) plan = item . get ( \"plan\" , \"\" ) price , kwargs = _sanitise_price ( price , plan , ** kwargs ) if \"price\" in item : _items . append ({ \"price\" : price }) if \"plan\" in item : _items . append ({ \"plan\" : price }) stripe_subscription = Subscription . _api_create ( items = _items , customer = self . id , ** kwargs ) api_key = kwargs . get ( \"api_key\" ) or self . default_api_key return Subscription . sync_from_stripe_data ( stripe_subscription , api_key = api_key ) def charge ( self , amount : Decimal , * , application_fee : Decimal = None , source : Union [ str , StripeModel ] = None , ** kwargs , ) -> Charge : \"\"\" Creates a charge for this customer. :param amount: The amount to charge. :type amount: Decimal. Precision is 2; anything more will be ignored. :param source: The source to use for this charge. Must be a source attributed to this customer. If None, the customer's default source is used. Can be either the id of the source or the source object itself. :type source: string, Source \"\"\" if not isinstance ( amount , Decimal ): raise ValueError ( \"You must supply a decimal value representing dollars.\" ) # Convert Source to id if source and isinstance ( source , StripeModel ): source = source . id stripe_charge = Charge . _api_create ( customer = self . id , amount = int ( amount * 100 ), # Convert dollars into cents application_fee = int ( application_fee * 100 ) if application_fee else None , # Convert dollars into cents source = source , ** kwargs , ) api_key = kwargs . get ( \"api_key\" ) or self . default_api_key return Charge . sync_from_stripe_data ( stripe_charge , api_key = api_key ) def add_invoice_item ( self , amount , currency , description = None , discountable = None , invoice = None , metadata = None , subscription = None , ): \"\"\" Adds an arbitrary charge or credit to the customer's upcoming invoice. Different than creating a charge. Charges are separate bills that get processed immediately. Invoice items are appended to the customer's next invoice. This is extremely useful when adding surcharges to subscriptions. :param amount: The amount to charge. :type amount: Decimal. Precision is 2; anything more will be ignored. :param currency: 3-letter ISO code for currency :type currency: string :param description: An arbitrary string. :type description: string :param discountable: Controls whether discounts apply to this invoice item. Defaults to False for prorations or negative invoice items, and True for all other invoice items. :type discountable: boolean :param invoice: An existing invoice to add this invoice item to. When left blank, the invoice item will be added to the next upcoming \\ scheduled invoice. \\ Use this when adding invoice items in response to an \\ ``invoice.created`` webhook. You cannot add an invoice \\ item to an invoice that has already been paid, attempted or closed. :type invoice: Invoice or string (invoice ID) :param metadata: A set of key/value pairs useful for storing additional information. :type metadata: dict :param subscription: A subscription to add this invoice item to. When left blank, the invoice item will be be added to the next upcoming \\ scheduled invoice. When set, scheduled invoices for subscriptions other \\ than the specified subscription will ignore the invoice item. \\ Use this when you want to express that an invoice item has been accrued \\ within the context of a particular subscription. :type subscription: Subscription or string (subscription ID) .. Notes: .. if you're using ``Customer.add_invoice_item()`` instead of .. ``Customer.add_invoice_item()``, ``invoice`` and ``subscriptions`` .. can only be strings \"\"\" from .billing import InvoiceItem if not isinstance ( amount , Decimal ): raise ValueError ( \"You must supply a decimal value representing dollars.\" ) # Convert Invoice to id if invoice is not None and isinstance ( invoice , StripeModel ): invoice = invoice . id # Convert Subscription to id if subscription is not None and isinstance ( subscription , StripeModel ): subscription = subscription . id stripe_invoiceitem = InvoiceItem . _api_create ( amount = int ( amount * 100 ), # Convert dollars into cents currency = currency , customer = self . id , description = description , discountable = discountable , invoice = invoice , metadata = metadata , subscription = subscription , ) return InvoiceItem . sync_from_stripe_data ( stripe_invoiceitem , api_key = self . default_api_key ) def add_card ( self , source , set_default = True ): \"\"\" Adds a card to this customer's account. :param source: Either a token, like the ones returned by our Stripe.js, or a dictionary containing a user's credit card details. Stripe will automatically validate the card. :type source: string, dict :param set_default: Whether or not to set the source as the customer's default source :type set_default: boolean \"\"\" from .payment_methods import DjstripePaymentMethod stripe_customer = self . api_retrieve () new_stripe_payment_method = stripe_customer . sources . create ( source = source ) if set_default : stripe_customer . default_source = new_stripe_payment_method [ \"id\" ] stripe_customer . save () new_payment_method = DjstripePaymentMethod . from_stripe_object ( new_stripe_payment_method ) # Change the default source if set_default : self . default_source = new_payment_method self . save () return new_payment_method . resolve () def add_payment_method ( self , payment_method , set_default = True ): \"\"\" Adds an already existing payment method to this customer's account :param payment_method: PaymentMethod to be attached to the customer :type payment_method: str, PaymentMethod :param set_default: If true, this will be set as the default_payment_method :type set_default: bool :rtype: PaymentMethod \"\"\" from .payment_methods import PaymentMethod stripe_customer = self . api_retrieve () payment_method = PaymentMethod . attach ( payment_method , stripe_customer ) if set_default : stripe_customer [ \"invoice_settings\" ][ \"default_payment_method\" ] = payment_method . id stripe_customer . save () # Refresh self from the stripe customer, this should have two effects: # 1) sets self.default_payment_method (we rely on logic in # Customer._manipulate_stripe_object_hook to do this) # 2) updates self.invoice_settings.default_payment_methods self . sync_from_stripe_data ( stripe_customer , api_key = self . default_api_key ) self . refresh_from_db () return payment_method def purge ( self ): \"\"\"Customers are soft deleted as deleted customers are still accessible by the Stripe API and sync for all RelatedModels would fail\"\"\" try : self . _api_delete () except InvalidRequestError as exc : if \"No such customer:\" in str ( exc ): # The exception was thrown because the stripe customer was already # deleted on the stripe side, ignore the exception pass else : # The exception was raised for another reason, re-raise it raise # toggle the deleted flag on Customer to indicate it has been # deleted upstream in Stripe self . deleted = True if self . subscriber : # Delete the idempotency key used by Customer.create() # So re-creating a customer for this subscriber before the key expires # doesn't return the older Customer data idempotency_key_action = f \"customer:create: { self . subscriber . pk } \" IdempotencyKey . objects . filter ( action = idempotency_key_action ) . delete () self . subscriber = None # Remove sources self . default_source = None for source in self . legacy_cards . all (): source . remove () for source in self . sources . all (): source . detach () self . date_purged = timezone . now () self . save () def _get_valid_subscriptions ( self ): \"\"\"Get a list of this customer's valid subscriptions.\"\"\" return [ subscription for subscription in self . subscriptions . all () if subscription . is_valid () ] def is_subscribed_to ( self , product : Union [ Product , str ]) -> bool : \"\"\" Checks to see if this customer has an active subscription to the given product. :param product: The product for which to check for an active subscription. :type product: Product or string (product ID) :returns: True if there exists an active subscription, False otherwise. \"\"\" if isinstance ( product , StripeModel ): product = product . id for subscription in self . _get_valid_subscriptions (): for item in subscription . items . all (): if item . price and item . price . product . id == product : return True return False def has_any_active_subscription ( self ): \"\"\" Checks to see if this customer has an active subscription to any plan. :returns: True if there exists an active subscription, False otherwise. \"\"\" return len ( self . _get_valid_subscriptions ()) != 0 @property def active_subscriptions ( self ): \"\"\" Returns active subscriptions (subscriptions with an active status that end in the future). \"\"\" return self . subscriptions . filter ( status = enums . SubscriptionStatus . active , current_period_end__gt = timezone . now (), ) @property def valid_subscriptions ( self ): \"\"\" Returns this customer's valid subscriptions (subscriptions that aren't canceled or incomplete_expired). \"\"\" return self . subscriptions . exclude ( status__in = [ enums . SubscriptionStatus . canceled , enums . SubscriptionStatus . incomplete_expired , ] ) @property def subscription ( self ): \"\"\" Shortcut to get this customer's subscription. :returns: None if the customer has no subscriptions, the subscription if the customer has a subscription. :raises MultipleSubscriptionException: Raised if the customer has multiple subscriptions. In this case, use ``Customer.subscriptions`` instead. \"\"\" subscriptions = self . valid_subscriptions if subscriptions . count () > 1 : raise MultipleSubscriptionException ( \"This customer has multiple subscriptions. Use Customer.subscriptions \" \"to access them.\" ) else : return subscriptions . first () def send_invoice ( self ): \"\"\" Pay and send the customer's latest invoice. :returns: True if an invoice was able to be created and paid, False otherwise (typically if there was nothing to invoice). \"\"\" from .billing import Invoice try : invoice = Invoice . _api_create ( customer = self . id ) invoice . pay () return True except InvalidRequestError : # TODO: Check this for a more # specific error message. return False # There was nothing to invoice def retry_unpaid_invoices ( self ): \"\"\"Attempt to retry collecting payment on the customer's unpaid invoices.\"\"\" self . _sync_invoices () for invoice in self . invoices . filter ( auto_advance = True ) . exclude ( status = \"paid\" ): try : invoice . retry () # Always retry unpaid invoices except InvalidRequestError as exc : if str ( exc ) != \"Invoice is already paid\" : raise def add_coupon ( self , coupon , idempotency_key = None ): \"\"\" Add a coupon to a Customer. The coupon can be a Coupon object, or a valid Stripe Coupon ID. \"\"\" if isinstance ( coupon , StripeModel ): coupon = coupon . id stripe_customer = self . api_retrieve () stripe_customer [ \"coupon\" ] = coupon stripe_customer . save ( idempotency_key = idempotency_key ) return self . __class__ . sync_from_stripe_data ( stripe_customer , api_key = self . default_api_key ) def upcoming_invoice ( self , ** kwargs ): \"\"\"Gets the upcoming preview invoice (singular) for this customer. See `Invoice.upcoming() <#djstripe.Invoice.upcoming>`__. The ``customer`` argument to the ``upcoming()`` call is automatically set by this method. \"\"\" from .billing import Invoice kwargs [ \"customer\" ] = self return Invoice . upcoming ( ** kwargs ) def _attach_objects_post_save_hook ( self , cls , data , pending_relations = None , api_key = djstripe_settings . STRIPE_SECRET_KEY , ): from .billing import Coupon from .payment_methods import DjstripePaymentMethod super () . _attach_objects_post_save_hook ( cls , data , pending_relations = pending_relations , api_key = api_key ) save = False customer_sources = data . get ( \"sources\" ) sources = {} if customer_sources : # Have to create sources before we handle the default_source # We save all of them in the `sources` dict, so that we can find them # by id when we look at the default_source (we need the source type). for source in customer_sources [ \"data\" ]: obj , _ = DjstripePaymentMethod . _get_or_create_source ( source , source [ \"object\" ], api_key = api_key ) sources [ source [ \"id\" ]] = obj discount = data . get ( \"discount\" ) if discount : coupon , _created = Coupon . _get_or_create_from_stripe_object ( discount , \"coupon\" , api_key = api_key ) if coupon and coupon != self . coupon : self . coupon = coupon save = True elif self . coupon : self . coupon = None save = True if save : self . save () def _attach_objects_hook ( self , cls , data , current_ids = None , api_key = djstripe_settings . STRIPE_SECRET_KEY ): # When we save a customer to Stripe, we add a reference to its Django PK # in the `django_account` key. If we find that, we re-attach that PK. subscriber_key = djstripe_settings . SUBSCRIBER_CUSTOMER_KEY if subscriber_key in ( \"\" , None ): # Disabled. Nothing else to do. return subscriber_id = data . get ( \"metadata\" , {}) . get ( subscriber_key ) if subscriber_id : cls = djstripe_settings . get_subscriber_model () try : # We have to perform a get(), instead of just attaching the PK # blindly as the object may have been deleted or not exist. # Attempting to save that would cause an IntegrityError. self . subscriber = cls . objects . get ( pk = subscriber_id ) except ( cls . DoesNotExist , ValueError ): logger . warning ( \"Could not find subscriber %r matching customer %r \" , subscriber_id , self . id , ) self . subscriber = None # SYNC methods should be dropped in favor of the master sync infrastructure proposed def _sync_invoices ( self , ** kwargs ): from .billing import Invoice api_key = kwargs . get ( \"api_key\" ) or self . default_api_key for stripe_invoice in Invoice . api_list ( customer = self . id , ** kwargs ): Invoice . sync_from_stripe_data ( stripe_invoice , api_key = api_key ) def _sync_charges ( self , ** kwargs ): api_key = kwargs . get ( \"api_key\" ) or self . default_api_key for stripe_charge in Charge . api_list ( customer = self . id , ** kwargs ): Charge . sync_from_stripe_data ( stripe_charge , api_key = api_key ) def _sync_cards ( self , ** kwargs ): from .payment_methods import Card api_key = kwargs . get ( \"api_key\" ) or self . default_api_key for stripe_card in Card . api_list ( customer = self , ** kwargs ): Card . sync_from_stripe_data ( stripe_card , api_key = api_key ) def _sync_subscriptions ( self , ** kwargs ): from .billing import Subscription api_key = kwargs . get ( \"api_key\" ) or self . default_api_key for stripe_subscription in Subscription . api_list ( customer = self . id , status = \"all\" , ** kwargs ): Subscription . sync_from_stripe_data ( stripe_subscription , api_key = api_key ) Attributes djstripe . models . core . Customer . active_subscriptions property Returns active subscriptions (subscriptions with an active status that end in the future). djstripe . models . core . Customer . address = JSONField ( null = True , blank = True , help_text = \"The customer's address.\" ) class-attribute djstripe . models . core . Customer . balance = StripeQuantumCurrencyAmountField ( null = True , blank = True , default = 0 , help_text = \"Current balance (in cents), if any, being stored on the customer's account. If negative, the customer has credit to apply to the next invoice. If positive, the customer has an amount owed that will be added to the next invoice. The balance does not refer to any unpaid invoices; it solely takes into account amounts that have yet to be successfully applied to any invoice. This balance is only taken into account for recurring billing purposes (i.e., subscriptions, invoices, invoice items).\" ) class-attribute djstripe . models . core . Customer . coupon = models . ForeignKey ( 'Coupon' , null = True , blank = True , on_delete = models . SET_NULL ) class-attribute djstripe . models . core . Customer . coupon_end = StripeDateTimeField ( null = True , blank = True , editable = False , help_text = 'If a coupon is present and has a limited duration, the date that the discount will end.' ) class-attribute djstripe . models . core . Customer . coupon_start = StripeDateTimeField ( null = True , blank = True , editable = False , help_text = 'If a coupon is present, the date at which it was applied.' ) class-attribute djstripe . models . core . Customer . credits property The customer is considered to have credits if their balance is below 0. djstripe . models . core . Customer . currency = StripeCurrencyCodeField ( blank = True , default = '' , help_text = 'The currency the customer can be charged in for recurring billing purposes' ) class-attribute djstripe . models . core . Customer . customer_payment_methods property An iterable of all of the customer's payment methods (sources, then legacy cards) djstripe . models . core . Customer . date_purged = models . DateTimeField ( null = True , editable = False ) class-attribute djstripe . models . core . Customer . default_payment_method = StripeForeignKey ( 'PaymentMethod' , null = True , blank = True , on_delete = models . SET_NULL , related_name = '+' , help_text = 'default payment method used for subscriptions and invoices for the customer.' ) class-attribute djstripe . models . core . Customer . default_source = PaymentMethodForeignKey ( on_delete = models . SET_NULL , null = True , blank = True , related_name = 'customers' ) class-attribute djstripe . models . core . Customer . deleted = models . BooleanField ( default = False , null = True , blank = True , help_text = 'Whether the Customer instance has been deleted upstream in Stripe or not.' ) class-attribute djstripe . models . core . Customer . delinquent = models . BooleanField ( null = True , blank = True , default = False , help_text = \"Whether or not the latest charge for the customer's latest invoice has failed.\" ) class-attribute djstripe . models . core . Customer . discount = JSONField ( null = True , blank = True , help_text = 'Describes the current discount active on the customer, if there is one.' ) class-attribute djstripe . models . core . Customer . email = models . TextField ( max_length = 5000 , default = '' , blank = True ) class-attribute djstripe . models . core . Customer . expand_fields = [ 'default_source' , 'sources' ] class-attribute djstripe . models . core . Customer . invoice_prefix = models . CharField ( default = '' , blank = True , max_length = 255 , help_text = 'The prefix for the customer used to generate unique invoice numbers.' ) class-attribute djstripe . models . core . Customer . invoice_settings = JSONField ( null = True , blank = True , help_text = \"The customer's default invoice settings.\" ) class-attribute djstripe . models . core . Customer . name = models . TextField ( max_length = 5000 , default = '' , blank = True , help_text = \"The customer's full name or business name.\" ) class-attribute djstripe . models . core . Customer . pending_charges property The customer is considered to have pending charges if their balance is above 0. djstripe . models . core . Customer . phone = models . TextField ( max_length = 5000 , default = '' , blank = True , help_text = \"The customer's phone number.\" ) class-attribute djstripe . models . core . Customer . preferred_locales = JSONField ( null = True , blank = True , help_text = \"The customer's preferred locales (languages), ordered by preference.\" ) class-attribute djstripe . models . core . Customer . shipping = JSONField ( null = True , blank = True , help_text = 'Shipping information associated with the customer.' ) class-attribute djstripe . models . core . Customer . stripe_class = stripe . Customer class-attribute djstripe . models . core . Customer . stripe_dashboard_item_name = 'customers' class-attribute djstripe . models . core . Customer . subscriber = models . ForeignKey ( djstripe_settings . get_subscriber_model_string (), blank = True , null = True , on_delete = models . SET_NULL , related_name = 'djstripe_customers' ) class-attribute djstripe . models . core . Customer . subscription property Shortcut to get this customer's subscription. :returns: None if the customer has no subscriptions, the subscription if the customer has a subscription. :raises MultipleSubscriptionException: Raised if the customer has multiple subscriptions. In this case, use Customer.subscriptions instead. djstripe . models . core . Customer . tax_exempt = StripeEnumField ( enum = enums . CustomerTaxExempt , default = '' , help_text = 'Describes the customer \\' s tax exemption status. When set to reverse, invoice and receipt PDFs include the text \"Reverse charge\".' ) class-attribute djstripe . models . core . Customer . valid_subscriptions property Returns this customer's valid subscriptions (subscriptions that aren't canceled or incomplete_expired). Classes djstripe.models.core.Customer.Meta Bases: StripeModel . Meta Source code in djstripe/models/core.py 781 782 class Meta ( StripeModel . Meta ): unique_together = ( \"subscriber\" , \"livemode\" , \"djstripe_owner_account\" ) Attributes djstripe . models . core . Customer . Meta . unique_together = ( 'subscriber' , 'livemode' , 'djstripe_owner_account' ) class-attribute Functions djstripe . models . core . Customer . __str__ () Source code in djstripe/models/core.py 784 785 786 787 788 def __str__ ( self ): if self . subscriber : return str ( self . subscriber ) return self . name or self . description or self . id djstripe . models . core . Customer . add_card ( source , set_default = True ) Adds a card to this customer's account. :param source: Either a token, like the ones returned by our Stripe.js, or a dictionary containing a user's credit card details. Stripe will automatically validate the card. :type source: string, dict :param set_default: Whether or not to set the source as the customer's default source :type set_default: boolean Source code in djstripe/models/core.py 1056 1057 1058 1059 1060 1061 1062 1063 1064 1065 1066 1067 1068 1069 1070 1071 1072 1073 1074 1075 1076 1077 1078 1079 1080 1081 1082 1083 1084 1085 1086 1087 def add_card ( self , source , set_default = True ): \"\"\" Adds a card to this customer's account. :param source: Either a token, like the ones returned by our Stripe.js, or a dictionary containing a user's credit card details. Stripe will automatically validate the card. :type source: string, dict :param set_default: Whether or not to set the source as the customer's default source :type set_default: boolean \"\"\" from .payment_methods import DjstripePaymentMethod stripe_customer = self . api_retrieve () new_stripe_payment_method = stripe_customer . sources . create ( source = source ) if set_default : stripe_customer . default_source = new_stripe_payment_method [ \"id\" ] stripe_customer . save () new_payment_method = DjstripePaymentMethod . from_stripe_object ( new_stripe_payment_method ) # Change the default source if set_default : self . default_source = new_payment_method self . save () return new_payment_method . resolve () djstripe . models . core . Customer . add_coupon ( coupon , idempotency_key = None ) Add a coupon to a Customer. The coupon can be a Coupon object, or a valid Stripe Coupon ID. Source code in djstripe/models/core.py 1268 1269 1270 1271 1272 1273 1274 1275 1276 1277 1278 1279 1280 1281 1282 def add_coupon ( self , coupon , idempotency_key = None ): \"\"\" Add a coupon to a Customer. The coupon can be a Coupon object, or a valid Stripe Coupon ID. \"\"\" if isinstance ( coupon , StripeModel ): coupon = coupon . id stripe_customer = self . api_retrieve () stripe_customer [ \"coupon\" ] = coupon stripe_customer . save ( idempotency_key = idempotency_key ) return self . __class__ . sync_from_stripe_data ( stripe_customer , api_key = self . default_api_key ) djstripe . models . core . Customer . add_invoice_item ( amount , currency , description = None , discountable = None , invoice = None , metadata = None , subscription = None ) Adds an arbitrary charge or credit to the customer's upcoming invoice. Different than creating a charge. Charges are separate bills that get processed immediately. Invoice items are appended to the customer's next invoice. This is extremely useful when adding surcharges to subscriptions. :param amount: The amount to charge. :type amount: Decimal. Precision is 2; anything more will be ignored. :param currency: 3-letter ISO code for currency :type currency: string :param description: An arbitrary string. :type description: string :param discountable: Controls whether discounts apply to this invoice item. Defaults to False for prorations or negative invoice items, and True for all other invoice items. :type discountable: boolean :param invoice: An existing invoice to add this invoice item to. When left blank, the invoice item will be added to the next upcoming scheduled invoice. Use this when adding invoice items in response to an invoice.created webhook. You cannot add an invoice item to an invoice that has already been paid, attempted or closed. :type invoice: Invoice or string (invoice ID) :param metadata: A set of key/value pairs useful for storing additional information. :type metadata: dict :param subscription: A subscription to add this invoice item to. When left blank, the invoice item will be be added to the next upcoming scheduled invoice. When set, scheduled invoices for subscriptions other than the specified subscription will ignore the invoice item. Use this when you want to express that an invoice item has been accrued within the context of a particular subscription. :type subscription: Subscription or string (subscription ID) .. Notes: .. if you're using Customer.add_invoice_item() instead of .. Customer.add_invoice_item() , invoice and subscriptions .. can only be strings Source code in djstripe/models/core.py 979 980 981 982 983 984 985 986 987 988 989 990 991 992 993 994 995 996 997 998 999 1000 1001 1002 1003 1004 1005 1006 1007 1008 1009 1010 1011 1012 1013 1014 1015 1016 1017 1018 1019 1020 1021 1022 1023 1024 1025 1026 1027 1028 1029 1030 1031 1032 1033 1034 1035 1036 1037 1038 1039 1040 1041 1042 1043 1044 1045 1046 1047 1048 1049 1050 1051 1052 1053 1054 def add_invoice_item ( self , amount , currency , description = None , discountable = None , invoice = None , metadata = None , subscription = None , ): \"\"\" Adds an arbitrary charge or credit to the customer's upcoming invoice. Different than creating a charge. Charges are separate bills that get processed immediately. Invoice items are appended to the customer's next invoice. This is extremely useful when adding surcharges to subscriptions. :param amount: The amount to charge. :type amount: Decimal. Precision is 2; anything more will be ignored. :param currency: 3-letter ISO code for currency :type currency: string :param description: An arbitrary string. :type description: string :param discountable: Controls whether discounts apply to this invoice item. Defaults to False for prorations or negative invoice items, and True for all other invoice items. :type discountable: boolean :param invoice: An existing invoice to add this invoice item to. When left blank, the invoice item will be added to the next upcoming \\ scheduled invoice. \\ Use this when adding invoice items in response to an \\ ``invoice.created`` webhook. You cannot add an invoice \\ item to an invoice that has already been paid, attempted or closed. :type invoice: Invoice or string (invoice ID) :param metadata: A set of key/value pairs useful for storing additional information. :type metadata: dict :param subscription: A subscription to add this invoice item to. When left blank, the invoice item will be be added to the next upcoming \\ scheduled invoice. When set, scheduled invoices for subscriptions other \\ than the specified subscription will ignore the invoice item. \\ Use this when you want to express that an invoice item has been accrued \\ within the context of a particular subscription. :type subscription: Subscription or string (subscription ID) .. Notes: .. if you're using ``Customer.add_invoice_item()`` instead of .. ``Customer.add_invoice_item()``, ``invoice`` and ``subscriptions`` .. can only be strings \"\"\" from .billing import InvoiceItem if not isinstance ( amount , Decimal ): raise ValueError ( \"You must supply a decimal value representing dollars.\" ) # Convert Invoice to id if invoice is not None and isinstance ( invoice , StripeModel ): invoice = invoice . id # Convert Subscription to id if subscription is not None and isinstance ( subscription , StripeModel ): subscription = subscription . id stripe_invoiceitem = InvoiceItem . _api_create ( amount = int ( amount * 100 ), # Convert dollars into cents currency = currency , customer = self . id , description = description , discountable = discountable , invoice = invoice , metadata = metadata , subscription = subscription , ) return InvoiceItem . sync_from_stripe_data ( stripe_invoiceitem , api_key = self . default_api_key ) djstripe . models . core . Customer . add_payment_method ( payment_method , set_default = True ) Adds an already existing payment method to this customer's account :param payment_method: PaymentMethod to be attached to the customer :type payment_method: str, PaymentMethod :param set_default: If true, this will be set as the default_payment_method :type set_default: bool :rtype: PaymentMethod Source code in djstripe/models/core.py 1089 1090 1091 1092 1093 1094 1095 1096 1097 1098 1099 1100 1101 1102 1103 1104 1105 1106 1107 1108 1109 1110 1111 1112 1113 1114 1115 1116 1117 def add_payment_method ( self , payment_method , set_default = True ): \"\"\" Adds an already existing payment method to this customer's account :param payment_method: PaymentMethod to be attached to the customer :type payment_method: str, PaymentMethod :param set_default: If true, this will be set as the default_payment_method :type set_default: bool :rtype: PaymentMethod \"\"\" from .payment_methods import PaymentMethod stripe_customer = self . api_retrieve () payment_method = PaymentMethod . attach ( payment_method , stripe_customer ) if set_default : stripe_customer [ \"invoice_settings\" ][ \"default_payment_method\" ] = payment_method . id stripe_customer . save () # Refresh self from the stripe customer, this should have two effects: # 1) sets self.default_payment_method (we rely on logic in # Customer._manipulate_stripe_object_hook to do this) # 2) updates self.invoice_settings.default_payment_methods self . sync_from_stripe_data ( stripe_customer , api_key = self . default_api_key ) self . refresh_from_db () return payment_method djstripe . models . core . Customer . charge ( amount , * , application_fee = None , source = None , ** kwargs ) Creates a charge for this customer. :param amount: The amount to charge. :type amount: Decimal. Precision is 2; anything more will be ignored. :param source: The source to use for this charge. Must be a source attributed to this customer. If None, the customer's default source is used. Can be either the id of the source or the source object itself. :type source: string, Source Source code in djstripe/models/core.py 939 940 941 942 943 944 945 946 947 948 949 950 951 952 953 954 955 956 957 958 959 960 961 962 963 964 965 966 967 968 969 970 971 972 973 974 975 976 977 def charge ( self , amount : Decimal , * , application_fee : Decimal = None , source : Union [ str , StripeModel ] = None , ** kwargs , ) -> Charge : \"\"\" Creates a charge for this customer. :param amount: The amount to charge. :type amount: Decimal. Precision is 2; anything more will be ignored. :param source: The source to use for this charge. Must be a source attributed to this customer. If None, the customer's default source is used. Can be either the id of the source or the source object itself. :type source: string, Source \"\"\" if not isinstance ( amount , Decimal ): raise ValueError ( \"You must supply a decimal value representing dollars.\" ) # Convert Source to id if source and isinstance ( source , StripeModel ): source = source . id stripe_charge = Charge . _api_create ( customer = self . id , amount = int ( amount * 100 ), # Convert dollars into cents application_fee = int ( application_fee * 100 ) if application_fee else None , # Convert dollars into cents source = source , ** kwargs , ) api_key = kwargs . get ( \"api_key\" ) or self . default_api_key return Charge . sync_from_stripe_data ( stripe_charge , api_key = api_key ) djstripe . models . core . Customer . create ( subscriber , idempotency_key = None , stripe_account = None ) classmethod Source code in djstripe/models/core.py 848 849 850 851 852 853 854 855 856 857 858 859 860 861 862 863 864 865 866 867 868 869 870 871 @classmethod def create ( cls , subscriber , idempotency_key = None , stripe_account = None ): metadata = {} subscriber_key = djstripe_settings . SUBSCRIBER_CUSTOMER_KEY if subscriber_key not in ( \"\" , None ): metadata [ subscriber_key ] = subscriber . pk stripe_customer = cls . _api_create ( email = subscriber . email , idempotency_key = idempotency_key , metadata = metadata , stripe_account = stripe_account , ) customer , created = cls . objects . get_or_create ( id = stripe_customer [ \"id\" ], defaults = { \"subscriber\" : subscriber , \"livemode\" : stripe_customer [ \"livemode\" ], \"balance\" : stripe_customer . get ( \"balance\" , 0 ), \"delinquent\" : stripe_customer . get ( \"delinquent\" , False ), }, ) return customer djstripe . models . core . Customer . get_or_create ( subscriber , livemode = djstripe_settings . STRIPE_LIVE_MODE , stripe_account = None ) classmethod Get or create a dj-stripe customer. :param subscriber: The subscriber model instance for which to get or create a customer. :type subscriber: User :param livemode: Whether to get the subscriber in live or test mode. :type livemode: bool Source code in djstripe/models/core.py 814 815 816 817 818 819 820 821 822 823 824 825 826 827 828 829 830 831 832 833 834 835 836 837 838 839 840 841 842 843 844 845 846 @classmethod def get_or_create ( cls , subscriber , livemode = djstripe_settings . STRIPE_LIVE_MODE , stripe_account = None , ): \"\"\" Get or create a dj-stripe customer. :param subscriber: The subscriber model instance for which to get or create a customer. :type subscriber: User :param livemode: Whether to get the subscriber in live or test mode. :type livemode: bool \"\"\" try : return cls . objects . get ( subscriber = subscriber , livemode = livemode ), False except cls . DoesNotExist : action = f \"create: { subscriber . pk } \" idempotency_key = djstripe_settings . get_idempotency_key ( \"customer\" , action , livemode ) return ( cls . create ( subscriber , idempotency_key = idempotency_key , stripe_account = stripe_account , ), True , ) djstripe . models . core . Customer . has_any_active_subscription () Checks to see if this customer has an active subscription to any plan. :returns: True if there exists an active subscription, False otherwise. Source code in djstripe/models/core.py 1185 1186 1187 1188 1189 1190 1191 1192 def has_any_active_subscription ( self ): \"\"\" Checks to see if this customer has an active subscription to any plan. :returns: True if there exists an active subscription, False otherwise. \"\"\" return len ( self . _get_valid_subscriptions ()) != 0 djstripe . models . core . Customer . is_subscribed_to ( product ) Checks to see if this customer has an active subscription to the given product. :param product: The product for which to check for an active subscription. :type product: Product or string (product ID) :returns: True if there exists an active subscription, False otherwise. Source code in djstripe/models/core.py 1166 1167 1168 1169 1170 1171 1172 1173 1174 1175 1176 1177 1178 1179 1180 1181 1182 1183 def is_subscribed_to ( self , product : Union [ Product , str ]) -> bool : \"\"\" Checks to see if this customer has an active subscription to the given product. :param product: The product for which to check for an active subscription. :type product: Product or string (product ID) :returns: True if there exists an active subscription, False otherwise. \"\"\" if isinstance ( product , StripeModel ): product = product . id for subscription in self . _get_valid_subscriptions (): for item in subscription . items . all (): if item . price and item . price . product . id == product : return True return False djstripe . models . core . Customer . purge () Customers are soft deleted as deleted customers are still accessible by the Stripe API and sync for all RelatedModels would fail Source code in djstripe/models/core.py 1119 1120 1121 1122 1123 1124 1125 1126 1127 1128 1129 1130 1131 1132 1133 1134 1135 1136 1137 1138 1139 1140 1141 1142 1143 1144 1145 1146 1147 1148 1149 1150 1151 1152 1153 1154 1155 def purge ( self ): \"\"\"Customers are soft deleted as deleted customers are still accessible by the Stripe API and sync for all RelatedModels would fail\"\"\" try : self . _api_delete () except InvalidRequestError as exc : if \"No such customer:\" in str ( exc ): # The exception was thrown because the stripe customer was already # deleted on the stripe side, ignore the exception pass else : # The exception was raised for another reason, re-raise it raise # toggle the deleted flag on Customer to indicate it has been # deleted upstream in Stripe self . deleted = True if self . subscriber : # Delete the idempotency key used by Customer.create() # So re-creating a customer for this subscriber before the key expires # doesn't return the older Customer data idempotency_key_action = f \"customer:create: { self . subscriber . pk } \" IdempotencyKey . objects . filter ( action = idempotency_key_action ) . delete () self . subscriber = None # Remove sources self . default_source = None for source in self . legacy_cards . all (): source . remove () for source in self . sources . all (): source . detach () self . date_purged = timezone . now () self . save () djstripe . models . core . Customer . retry_unpaid_invoices () Attempt to retry collecting payment on the customer's unpaid invoices. Source code in djstripe/models/core.py 1257 1258 1259 1260 1261 1262 1263 1264 1265 1266 def retry_unpaid_invoices ( self ): \"\"\"Attempt to retry collecting payment on the customer's unpaid invoices.\"\"\" self . _sync_invoices () for invoice in self . invoices . filter ( auto_advance = True ) . exclude ( status = \"paid\" ): try : invoice . retry () # Always retry unpaid invoices except InvalidRequestError as exc : if str ( exc ) != \"Invoice is already paid\" : raise djstripe . models . core . Customer . send_invoice () Pay and send the customer's latest invoice. :returns: True if an invoice was able to be created and paid, False otherwise (typically if there was nothing to invoice). Source code in djstripe/models/core.py 1240 1241 1242 1243 1244 1245 1246 1247 1248 1249 1250 1251 1252 1253 1254 1255 def send_invoice ( self ): \"\"\" Pay and send the customer's latest invoice. :returns: True if an invoice was able to be created and paid, False otherwise (typically if there was nothing to invoice). \"\"\" from .billing import Invoice try : invoice = Invoice . _api_create ( customer = self . id ) invoice . pay () return True except InvalidRequestError : # TODO: Check this for a more # specific error message. return False # There was nothing to invoice djstripe . models . core . Customer . subscribe ( * , items = None , price = None , plan = None , ** kwargs ) Subscribes this customer to all the prices or plans in the items dict (Recommended). :param items: A list of up to 20 subscription items, each with an attached price :type list: :param items: A dictionary of Plan (or Plan ID) or Price (or Price ID) :type dict: The price or plan to which to subscribe the customer. :param price: The price to which to subscribe the customer. :type price: Price or string (price ID) :param plan: The plan to which to subscribe the customer. :type plan: Plan or string (plan ID) Source code in djstripe/models/core.py 899 900 901 902 903 904 905 906 907 908 909 910 911 912 913 914 915 916 917 918 919 920 921 922 923 924 925 926 927 928 929 930 931 932 933 934 935 936 937 def subscribe ( self , * , items = None , price = None , plan = None , ** kwargs ): \"\"\" Subscribes this customer to all the prices or plans in the items dict (Recommended). :param items: A list of up to 20 subscription items, each with an attached price :type list: :param items: A dictionary of Plan (or Plan ID) or Price (or Price ID) :type dict: The price or plan to which to subscribe the customer. :param price: The price to which to subscribe the customer. :type price: Price or string (price ID) :param plan: The plan to which to subscribe the customer. :type plan: Plan or string (plan ID) \"\"\" from .billing import Subscription if ( items and price ) or ( items and plan ) or ( price and plan ): raise TypeError ( \"Please define only one of items, price or plan arguments.\" ) if items is None : _items = [{ \"price\" : price }] else : _items = [] for item in items : price = item . get ( \"price\" , \"\" ) plan = item . get ( \"plan\" , \"\" ) price , kwargs = _sanitise_price ( price , plan , ** kwargs ) if \"price\" in item : _items . append ({ \"price\" : price }) if \"plan\" in item : _items . append ({ \"plan\" : price }) stripe_subscription = Subscription . _api_create ( items = _items , customer = self . id , ** kwargs ) api_key = kwargs . get ( \"api_key\" ) or self . default_api_key return Subscription . sync_from_stripe_data ( stripe_subscription , api_key = api_key ) djstripe . models . core . Customer . upcoming_invoice ( ** kwargs ) Gets the upcoming preview invoice (singular) for this customer. See Invoice.upcoming() <#djstripe.Invoice.upcoming> __. The customer argument to the upcoming() call is automatically set by this method. Source code in djstripe/models/core.py 1284 1285 1286 1287 1288 1289 1290 1291 1292 1293 1294 1295 def upcoming_invoice ( self , ** kwargs ): \"\"\"Gets the upcoming preview invoice (singular) for this customer. See `Invoice.upcoming() <#djstripe.Invoice.upcoming>`__. The ``customer`` argument to the ``upcoming()`` call is automatically set by this method. \"\"\" from .billing import Invoice kwargs [ \"customer\" ] = self return Invoice . upcoming ( ** kwargs ) djstripe.models.core.Dispute Bases: StripeModel A dispute occurs when a customer questions your charge with their card issuer. When this happens, you're given the opportunity to respond to the dispute with evidence that shows that the charge is legitimate Stripe documentation: https://stripe.com/docs/api?lang=python#disputes Source code in djstripe/models/core.py 1396 1397 1398 1399 1400 1401 1402 1403 1404 1405 1406 1407 1408 1409 1410 1411 1412 1413 1414 1415 1416 1417 1418 1419 1420 1421 1422 1423 1424 1425 1426 1427 1428 1429 1430 1431 1432 1433 1434 1435 1436 1437 1438 1439 1440 1441 1442 1443 1444 1445 1446 1447 1448 1449 1450 1451 1452 1453 1454 1455 1456 1457 1458 1459 1460 1461 1462 1463 1464 1465 1466 1467 1468 1469 1470 1471 1472 1473 1474 1475 1476 1477 1478 1479 1480 1481 1482 1483 1484 1485 1486 1487 1488 1489 1490 1491 1492 1493 1494 1495 1496 1497 1498 1499 1500 1501 1502 1503 1504 1505 1506 1507 1508 1509 1510 1511 1512 class Dispute ( StripeModel ): \"\"\" A dispute occurs when a customer questions your charge with their card issuer. When this happens, you're given the opportunity to respond to the dispute with evidence that shows that the charge is legitimate Stripe documentation: https://stripe.com/docs/api?lang=python#disputes \"\"\" stripe_class = stripe . Dispute stripe_dashboard_item_name = \"payments\" amount = StripeQuantumCurrencyAmountField ( help_text = ( \"Disputed amount (in cents). Usually the amount of the charge, \" \"but can differ \" \"(usually because of currency fluctuation or because only part of \" \"the order is disputed).\" ) ) balance_transaction = StripeForeignKey ( \"BalanceTransaction\" , null = True , on_delete = models . CASCADE , related_name = \"disputes\" , help_text = \"Balance transaction that describes the impact on your \" \"account balance.\" , ) balance_transactions = JSONField ( default = list , help_text = \"List of 0, 1 or 2 Balance Transactions that show funds withdrawn and reinstated to your Stripe account as a result of this dispute.\" , ) # charge is nullable to avoid infinite sync as Charge model has a dispute field as well charge = StripeForeignKey ( \"Charge\" , null = True , on_delete = models . CASCADE , related_name = \"disputes\" , help_text = \"The charge that was disputed\" , ) currency = StripeCurrencyCodeField () evidence = JSONField ( help_text = \"Evidence provided to respond to a dispute.\" ) evidence_details = JSONField ( help_text = \"Information about the evidence submission.\" ) is_charge_refundable = models . BooleanField ( help_text = ( \"If true, it is still possible to refund the disputed payment. \" \"Once the payment has been fully refunded, no further funds will \" \"be withdrawn from your Stripe account as a result of this dispute.\" ) ) payment_intent = StripeForeignKey ( \"PaymentIntent\" , null = True , on_delete = models . CASCADE , related_name = \"disputes\" , help_text = \"The PaymentIntent that was disputed\" , ) reason = StripeEnumField ( enum = enums . DisputeReason ) status = StripeEnumField ( enum = enums . DisputeStatus ) def __str__ ( self ): amount = get_friendly_currency_amount ( self . amount / 100 , self . currency ) status = enums . DisputeStatus . humanize ( self . status ) return f \" { amount } ( { status } ) \" def get_stripe_dashboard_url ( self ) -> str : \"\"\"Get the stripe dashboard url for this object.\"\"\" return ( f \" { self . _get_base_stripe_dashboard_url () } \" f \" { self . stripe_dashboard_item_name } / { self . payment_intent . id } \" ) def _attach_objects_post_save_hook ( self , cls , data , pending_relations = None , api_key = djstripe_settings . STRIPE_SECRET_KEY , ): super () . _attach_objects_post_save_hook ( cls , data , pending_relations = pending_relations , api_key = api_key ) # Retrieve and save files from the dispute.evidence object. # todo find a better way of retrieving and syncing File Type fields from Dispute object for field in ( \"cancellation_policy\" , \"customer_communication\" , \"customer_signature\" , \"duplicate_charge_documentation\" , \"receipt\" , \"refund_policy\" , \"service_documentation\" , \"shipping_documentation\" , \"uncategorized_file\" , ): file_upload_id = self . evidence . get ( field , None ) if file_upload_id : try : File . sync_from_stripe_data ( File ( id = file_upload_id ) . api_retrieve ( api_key = api_key ), api_key = api_key , ) except stripe . error . PermissionError : # No permission to retrieve the data with the key # Log a warning message logger . warning ( \"No permission to retrieve the File Evidence Object.\" ) except stripe . error . InvalidRequestError : raise # iterate and sync every balance transaction for stripe_balance_transaction in self . balance_transactions : BalanceTransaction . sync_from_stripe_data ( stripe_balance_transaction , api_key = api_key ) Attributes djstripe . models . core . Dispute . amount = StripeQuantumCurrencyAmountField ( help_text = 'Disputed amount (in cents). Usually the amount of the charge, but can differ (usually because of currency fluctuation or because only part of the order is disputed).' ) class-attribute djstripe . models . core . Dispute . balance_transaction = StripeForeignKey ( 'BalanceTransaction' , null = True , on_delete = models . CASCADE , related_name = 'disputes' , help_text = 'Balance transaction that describes the impact on your account balance.' ) class-attribute djstripe . models . core . Dispute . balance_transactions = JSONField ( default = list , help_text = 'List of 0, 1 or 2 Balance Transactions that show funds withdrawn and reinstated to your Stripe account as a result of this dispute.' ) class-attribute djstripe . models . core . Dispute . charge = StripeForeignKey ( 'Charge' , null = True , on_delete = models . CASCADE , related_name = 'disputes' , help_text = 'The charge that was disputed' ) class-attribute djstripe . models . core . Dispute . currency = StripeCurrencyCodeField () class-attribute djstripe . models . core . Dispute . evidence = JSONField ( help_text = 'Evidence provided to respond to a dispute.' ) class-attribute djstripe . models . core . Dispute . evidence_details = JSONField ( help_text = 'Information about the evidence submission.' ) class-attribute djstripe . models . core . Dispute . is_charge_refundable = models . BooleanField ( help_text = 'If true, it is still possible to refund the disputed payment. Once the payment has been fully refunded, no further funds will be withdrawn from your Stripe account as a result of this dispute.' ) class-attribute djstripe . models . core . Dispute . payment_intent = StripeForeignKey ( 'PaymentIntent' , null = True , on_delete = models . CASCADE , related_name = 'disputes' , help_text = 'The PaymentIntent that was disputed' ) class-attribute djstripe . models . core . Dispute . reason = StripeEnumField ( enum = enums . DisputeReason ) class-attribute djstripe . models . core . Dispute . status = StripeEnumField ( enum = enums . DisputeStatus ) class-attribute djstripe . models . core . Dispute . stripe_class = stripe . Dispute class-attribute djstripe . models . core . Dispute . stripe_dashboard_item_name = 'payments' class-attribute Functions djstripe . models . core . Dispute . __str__ () Source code in djstripe/models/core.py 1456 1457 1458 1459 def __str__ ( self ): amount = get_friendly_currency_amount ( self . amount / 100 , self . currency ) status = enums . DisputeStatus . humanize ( self . status ) return f \" { amount } ( { status } ) \" djstripe . models . core . Dispute . get_stripe_dashboard_url () Get the stripe dashboard url for this object. Source code in djstripe/models/core.py 1461 1462 1463 1464 1465 1466 def get_stripe_dashboard_url ( self ) -> str : \"\"\"Get the stripe dashboard url for this object.\"\"\" return ( f \" { self . _get_base_stripe_dashboard_url () } \" f \" { self . stripe_dashboard_item_name } / { self . payment_intent . id } \" ) djstripe.models.core.Event Bases: StripeModel Events are Stripe's way of letting you know when something interesting happens in your account. When an interesting event occurs, a new Event object is created and POSTed to the configured webhook URL if the Event type matches. Stripe documentation: https://stripe.com/docs/api/events?lang=python Source code in djstripe/models/core.py 1515 1516 1517 1518 1519 1520 1521 1522 1523 1524 1525 1526 1527 1528 1529 1530 1531 1532 1533 1534 1535 1536 1537 1538 1539 1540 1541 1542 1543 1544 1545 1546 1547 1548 1549 1550 1551 1552 1553 1554 1555 1556 1557 1558 1559 1560 1561 1562 1563 1564 1565 1566 1567 1568 1569 1570 1571 1572 1573 1574 1575 1576 1577 1578 1579 1580 1581 1582 1583 1584 1585 1586 1587 1588 1589 1590 1591 1592 1593 1594 1595 1596 1597 1598 1599 1600 1601 1602 1603 1604 1605 1606 1607 1608 1609 1610 1611 1612 1613 1614 1615 1616 1617 1618 1619 1620 1621 1622 1623 1624 1625 1626 1627 1628 1629 1630 class Event ( StripeModel ): \"\"\" Events are Stripe's way of letting you know when something interesting happens in your account. When an interesting event occurs, a new Event object is created and POSTed to the configured webhook URL if the Event type matches. Stripe documentation: https://stripe.com/docs/api/events?lang=python \"\"\" stripe_class = stripe . Event stripe_dashboard_item_name = \"events\" api_version = models . CharField ( max_length = 64 , blank = True , help_text = \"the API version at which the event data was \" \"rendered. Blank for old entries only, all new entries will have this value\" , ) data = JSONField ( help_text = \"data received at webhook. data should be considered to be garbage \" \"until validity check is run and valid flag is set\" ) request_id = models . CharField ( max_length = 50 , help_text = \"Information about the request that triggered this event, \" \"for traceability purposes. If empty string then this is an old entry \" \"without that data. If Null then this is not an old entry, but a Stripe \" \"'automated' event with no associated request.\" , default = \"\" , blank = True , ) idempotency_key = models . TextField ( default = \"\" , blank = True ) type = models . CharField ( max_length = 250 , help_text = \"Stripe's event description code\" ) def __str__ ( self ): return f \"type= { self . type } , id= { self . id } \" def _attach_objects_hook ( self , cls , data , current_ids = None , api_key = djstripe_settings . STRIPE_SECRET_KEY ): if self . api_version is None : # as of api version 2017-02-14, the account.application.deauthorized # event sends None as api_version. # If we receive that, store an empty string instead. # Remove this hack if this gets fixed upstream. self . api_version = \"\" request_obj = data . get ( \"request\" , None ) if isinstance ( request_obj , dict ): # Format as of 2017-05-25 self . request_id = request_obj . get ( \"id\" ) or \"\" self . idempotency_key = request_obj . get ( \"idempotency_key\" ) or \"\" else : # Format before 2017-05-25 self . request_id = request_obj or \"\" @classmethod def process ( cls , data , api_key = djstripe_settings . STRIPE_SECRET_KEY ): qs = cls . objects . filter ( id = data [ \"id\" ]) if qs . exists (): return qs . first () # Rollback any DB operations in the case of failure so # we will retry creating and processing the event the # next time the webhook fires. with transaction . atomic (): # process the event and create an Event Object ret = cls . _create_from_stripe_object ( data , api_key = api_key ) ret . invoke_webhook_handlers () return ret def invoke_webhook_handlers ( self ): \"\"\" Invokes any webhook handlers that have been registered for this event based on event type or event sub-type. See event handlers registered in the ``djstripe.event_handlers`` module (or handlers registered in djstripe plugins or contrib packages). \"\"\" webhooks . call_handlers ( event = self ) signal = WEBHOOK_SIGNALS . get ( self . type ) if signal : return signal . send ( sender = Event , event = self ) @cached_property def parts ( self ): \"\"\"Gets the event category/verb as a list of parts.\"\"\" return str ( self . type ) . split ( \".\" ) @cached_property def category ( self ): \"\"\"Gets the event category string (e.g. 'customer').\"\"\" return self . parts [ 0 ] @cached_property def verb ( self ): \"\"\"Gets the event past-tense verb string (e.g. 'updated').\"\"\" return \".\" . join ( self . parts [ 1 :]) @property def customer ( self ): data = self . data [ \"object\" ] if data [ \"object\" ] == \"customer\" : customer_id = get_id_from_stripe_data ( data . get ( \"id\" )) else : customer_id = get_id_from_stripe_data ( data . get ( \"customer\" )) if customer_id : return Customer . _get_or_retrieve ( id = customer_id , stripe_account = getattr ( self . djstripe_owner_account , \"id\" , None ), api_key = self . default_api_key , ) Attributes djstripe . models . core . Event . api_version = models . CharField ( max_length = 64 , blank = True , help_text = 'the API version at which the event data was rendered. Blank for old entries only, all new entries will have this value' ) class-attribute djstripe . models . core . Event . customer property djstripe . models . core . Event . data = JSONField ( help_text = 'data received at webhook. data should be considered to be garbage until validity check is run and valid flag is set' ) class-attribute djstripe . models . core . Event . idempotency_key = models . TextField ( default = '' , blank = True ) class-attribute djstripe . models . core . Event . request_id = models . CharField ( max_length = 50 , help_text = \"Information about the request that triggered this event, for traceability purposes. If empty string then this is an old entry without that data. If Null then this is not an old entry, but a Stripe 'automated' event with no associated request.\" , default = '' , blank = True ) class-attribute djstripe . models . core . Event . stripe_class = stripe . Event class-attribute djstripe . models . core . Event . stripe_dashboard_item_name = 'events' class-attribute djstripe . models . core . Event . type = models . CharField ( max_length = 250 , help_text = \"Stripe's event description code\" ) class-attribute Functions djstripe . models . core . Event . __str__ () Source code in djstripe/models/core.py 1550 1551 def __str__ ( self ): return f \"type= { self . type } , id= { self . id } \" djstripe . models . core . Event . category () Gets the event category string (e.g. 'customer'). Source code in djstripe/models/core.py 1607 1608 1609 1610 @cached_property def category ( self ): \"\"\"Gets the event category string (e.g. 'customer').\"\"\" return self . parts [ 0 ] djstripe . models . core . Event . invoke_webhook_handlers () Invokes any webhook handlers that have been registered for this event based on event type or event sub-type. See event handlers registered in the djstripe.event_handlers module (or handlers registered in djstripe plugins or contrib packages). Source code in djstripe/models/core.py 1587 1588 1589 1590 1591 1592 1593 1594 1595 1596 1597 1598 1599 1600 def invoke_webhook_handlers ( self ): \"\"\" Invokes any webhook handlers that have been registered for this event based on event type or event sub-type. See event handlers registered in the ``djstripe.event_handlers`` module (or handlers registered in djstripe plugins or contrib packages). \"\"\" webhooks . call_handlers ( event = self ) signal = WEBHOOK_SIGNALS . get ( self . type ) if signal : return signal . send ( sender = Event , event = self ) djstripe . models . core . Event . parts () Gets the event category/verb as a list of parts. Source code in djstripe/models/core.py 1602 1603 1604 1605 @cached_property def parts ( self ): \"\"\"Gets the event category/verb as a list of parts.\"\"\" return str ( self . type ) . split ( \".\" ) djstripe . models . core . Event . process ( data , api_key = djstripe_settings . STRIPE_SECRET_KEY ) classmethod Source code in djstripe/models/core.py 1572 1573 1574 1575 1576 1577 1578 1579 1580 1581 1582 1583 1584 1585 @classmethod def process ( cls , data , api_key = djstripe_settings . STRIPE_SECRET_KEY ): qs = cls . objects . filter ( id = data [ \"id\" ]) if qs . exists (): return qs . first () # Rollback any DB operations in the case of failure so # we will retry creating and processing the event the # next time the webhook fires. with transaction . atomic (): # process the event and create an Event Object ret = cls . _create_from_stripe_object ( data , api_key = api_key ) ret . invoke_webhook_handlers () return ret djstripe . models . core . Event . verb () Gets the event past-tense verb string (e.g. 'updated'). Source code in djstripe/models/core.py 1612 1613 1614 1615 @cached_property def verb ( self ): \"\"\"Gets the event past-tense verb string (e.g. 'updated').\"\"\" return \".\" . join ( self . parts [ 1 :]) djstripe.models.core.File Bases: StripeModel This is an object representing a file hosted on Stripe's servers. The file may have been uploaded by yourself using the create file request (for example, when uploading dispute evidence) or it may have been created by Stripe (for example, the results of a Sigma scheduled query). Stripe documentation: https://stripe.com/docs/api/files?lang=python Source code in djstripe/models/core.py 1633 1634 1635 1636 1637 1638 1639 1640 1641 1642 1643 1644 1645 1646 1647 1648 1649 1650 1651 1652 1653 1654 1655 1656 1657 1658 1659 1660 1661 1662 1663 1664 1665 1666 class File ( StripeModel ): \"\"\" This is an object representing a file hosted on Stripe's servers. The file may have been uploaded by yourself using the create file request (for example, when uploading dispute evidence) or it may have been created by Stripe (for example, the results of a Sigma scheduled query). Stripe documentation: https://stripe.com/docs/api/files?lang=python \"\"\" stripe_class = stripe . File filename = models . CharField ( max_length = 255 , help_text = \"A filename for the file, suitable for saving to a filesystem.\" , ) purpose = StripeEnumField ( enum = enums . FilePurpose , help_text = \"The purpose of the uploaded file.\" ) size = models . IntegerField ( help_text = \"The size in bytes of the file upload object.\" ) type = StripeEnumField ( enum = enums . FileType , help_text = \"The type of the file returned.\" ) url = models . CharField ( max_length = 200 , help_text = \"A read-only URL where the uploaded file can be accessed.\" , ) @classmethod def is_valid_object ( cls , data ): return data and data . get ( \"object\" ) in ( \"file\" , \"file_upload\" ) def __str__ ( self ): return f \" { self . filename } , { enums . FilePurpose . humanize ( self . purpose ) } \" Attributes djstripe . models . core . File . filename = models . CharField ( max_length = 255 , help_text = 'A filename for the file, suitable for saving to a filesystem.' ) class-attribute djstripe . models . core . File . purpose = StripeEnumField ( enum = enums . FilePurpose , help_text = 'The purpose of the uploaded file.' ) class-attribute djstripe . models . core . File . size = models . IntegerField ( help_text = 'The size in bytes of the file upload object.' ) class-attribute djstripe . models . core . File . stripe_class = stripe . File class-attribute djstripe . models . core . File . type = StripeEnumField ( enum = enums . FileType , help_text = 'The type of the file returned.' ) class-attribute djstripe . models . core . File . url = models . CharField ( max_length = 200 , help_text = 'A read-only URL where the uploaded file can be accessed.' ) class-attribute Functions djstripe . models . core . File . __str__ () Source code in djstripe/models/core.py 1665 1666 def __str__ ( self ): return f \" { self . filename } , { enums . FilePurpose . humanize ( self . purpose ) } \" djstripe . models . core . File . is_valid_object ( data ) classmethod Source code in djstripe/models/core.py 1661 1662 1663 @classmethod def is_valid_object ( cls , data ): return data and data . get ( \"object\" ) in ( \"file\" , \"file_upload\" ) djstripe.models.core.FileLink Bases: StripeModel To share the contents of a File object with non-Stripe users, you can create a FileLink. FileLinks contain a URL that can be used to retrieve the contents of the file without authentication. Stripe documentation: https://stripe.com/docs/api/file_links?lang=python Source code in djstripe/models/core.py 1675 1676 1677 1678 1679 1680 1681 1682 1683 1684 1685 1686 1687 1688 1689 1690 1691 1692 1693 class FileLink ( StripeModel ): \"\"\" To share the contents of a File object with non-Stripe users, you can create a FileLink. FileLinks contain a URL that can be used to retrieve the contents of the file without authentication. Stripe documentation: https://stripe.com/docs/api/file_links?lang=python \"\"\" stripe_class = stripe . FileLink expires_at = StripeDateTimeField ( null = True , blank = True , help_text = \"Time at which the link expires.\" ) file = StripeForeignKey ( \"File\" , on_delete = models . CASCADE ) url = models . URLField ( help_text = \"The publicly accessible URL to download the file.\" ) def __str__ ( self ): return f \" { self . file . filename } , { self . url } \" Attributes djstripe . models . core . FileLink . expires_at = StripeDateTimeField ( null = True , blank = True , help_text = 'Time at which the link expires.' ) class-attribute djstripe . models . core . FileLink . file = StripeForeignKey ( 'File' , on_delete = models . CASCADE ) class-attribute djstripe . models . core . FileLink . stripe_class = stripe . FileLink class-attribute djstripe . models . core . FileLink . url = models . URLField ( help_text = 'The publicly accessible URL to download the file.' ) class-attribute Functions djstripe . models . core . FileLink . __str__ () Source code in djstripe/models/core.py 1692 1693 def __str__ ( self ): return f \" { self . file . filename } , { self . url } \" djstripe.models.core.Mandate Bases: StripeModel A Mandate is a record of the permission a customer has given you to debit their payment method. https://stripe.com/docs/api/mandates Source code in djstripe/models/core.py 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 class Mandate ( StripeModel ): \"\"\" A Mandate is a record of the permission a customer has given you to debit their payment method. https://stripe.com/docs/api/mandates \"\"\" stripe_class = stripe . Mandate customer_acceptance = JSONField ( help_text = \"Details about the customer's acceptance of the mandate.\" ) payment_method = StripeForeignKey ( \"paymentmethod\" , on_delete = models . CASCADE ) payment_method_details = JSONField ( help_text = \"Additional mandate information specific to the payment method type.\" ) status = StripeEnumField ( enum = enums . MandateStatus , help_text = \"The status of the mandate, which indicates whether it can be used to initiate a payment.\" , ) type = StripeEnumField ( enum = enums . MandateType , help_text = \"The status of the mandate, which indicates whether it can be used to initiate a payment.\" , ) multi_use = JSONField ( null = True , blank = True , help_text = \"If this is a `multi_use` mandate, this hash contains details about the mandate.\" , ) single_use = JSONField ( null = True , blank = True , help_text = \"If this is a `single_use` mandate, this hash contains details about the mandate.\" , ) Attributes djstripe . models . core . Mandate . customer_acceptance = JSONField ( help_text = \"Details about the customer's acceptance of the mandate.\" ) class-attribute djstripe . models . core . Mandate . multi_use = JSONField ( null = True , blank = True , help_text = 'If this is a `multi_use` mandate, this hash contains details about the mandate.' ) class-attribute djstripe . models . core . Mandate . payment_method = StripeForeignKey ( 'paymentmethod' , on_delete = models . CASCADE ) class-attribute djstripe . models . core . Mandate . payment_method_details = JSONField ( help_text = 'Additional mandate information specific to the payment method type.' ) class-attribute djstripe . models . core . Mandate . single_use = JSONField ( null = True , blank = True , help_text = 'If this is a `single_use` mandate, this hash contains details about the mandate.' ) class-attribute djstripe . models . core . Mandate . status = StripeEnumField ( enum = enums . MandateStatus , help_text = 'The status of the mandate, which indicates whether it can be used to initiate a payment.' ) class-attribute djstripe . models . core . Mandate . stripe_class = stripe . Mandate class-attribute djstripe . models . core . Mandate . type = StripeEnumField ( enum = enums . MandateType , help_text = 'The status of the mandate, which indicates whether it can be used to initiate a payment.' ) class-attribute djstripe.models.core.PaymentIntent Bases: StripeModel A PaymentIntent guides you through the process of collecting a payment from your customer. We recommend that you create exactly one PaymentIntent for each order or customer session in your system. You can reference the PaymentIntent later to see the history of payment attempts for a particular session. A PaymentIntent transitions through multiple statuses throughout its lifetime as it interfaces with Stripe.js to perform authentication flows and ultimately creates at most one successful charge. Stripe documentation: https://stripe.com/docs/api?lang=python#payment_intents Source code in djstripe/models/core.py 1696 1697 1698 1699 1700 1701 1702 1703 1704 1705 1706 1707 1708 1709 1710 1711 1712 1713 1714 1715 1716 1717 1718 1719 1720 1721 1722 1723 1724 1725 1726 1727 1728 1729 1730 1731 1732 1733 1734 1735 1736 1737 1738 1739 1740 1741 1742 1743 1744 1745 1746 1747 1748 1749 1750 1751 1752 1753 1754 1755 1756 1757 1758 1759 1760 1761 1762 1763 1764 1765 1766 1767 1768 1769 1770 1771 1772 1773 1774 1775 1776 1777 1778 1779 1780 1781 1782 1783 1784 1785 1786 1787 1788 1789 1790 1791 1792 1793 1794 1795 1796 1797 1798 1799 1800 1801 1802 1803 1804 1805 1806 1807 1808 1809 1810 1811 1812 1813 1814 1815 1816 1817 1818 1819 1820 1821 1822 1823 1824 1825 1826 1827 1828 1829 1830 1831 1832 1833 1834 1835 1836 1837 1838 1839 1840 1841 1842 1843 1844 1845 1846 1847 1848 1849 1850 1851 1852 1853 1854 1855 1856 1857 1858 1859 1860 1861 1862 1863 1864 1865 1866 1867 1868 1869 1870 1871 1872 1873 1874 1875 1876 1877 1878 1879 1880 1881 1882 1883 1884 1885 1886 1887 1888 1889 1890 1891 1892 1893 1894 1895 1896 1897 1898 1899 1900 1901 1902 1903 1904 1905 1906 1907 1908 1909 1910 1911 1912 1913 1914 1915 1916 1917 1918 1919 1920 1921 1922 1923 1924 1925 1926 1927 1928 1929 1930 1931 1932 1933 1934 class PaymentIntent ( StripeModel ): \"\"\" A PaymentIntent guides you through the process of collecting a payment from your customer. We recommend that you create exactly one PaymentIntent for each order or customer session in your system. You can reference the PaymentIntent later to see the history of payment attempts for a particular session. A PaymentIntent transitions through multiple statuses throughout its lifetime as it interfaces with Stripe.js to perform authentication flows and ultimately creates at most one successful charge. Stripe documentation: https://stripe.com/docs/api?lang=python#payment_intents \"\"\" stripe_class = stripe . PaymentIntent stripe_dashboard_item_name = \"payments\" amount = StripeQuantumCurrencyAmountField ( help_text = \"Amount (in cents) intended to be collected by this PaymentIntent.\" ) amount_capturable = StripeQuantumCurrencyAmountField ( help_text = \"Amount (in cents) that can be captured from this PaymentIntent.\" ) amount_received = StripeQuantumCurrencyAmountField ( help_text = \"Amount (in cents) that was collected by this PaymentIntent.\" ) # application # application_fee_amount canceled_at = StripeDateTimeField ( null = True , blank = True , default = None , help_text = ( \"Populated when status is canceled, this is the time at which the \" \"PaymentIntent was canceled. Measured in seconds since the Unix epoch.\" ), ) cancellation_reason = StripeEnumField ( enum = enums . PaymentIntentCancellationReason , blank = True , help_text = ( \"Reason for cancellation of this PaymentIntent, either user-provided \" \"(duplicate, fraudulent, requested_by_customer, or abandoned) or \" \"generated by Stripe internally (failed_invoice, void_invoice, \" \"or automatic).\" ), ) capture_method = StripeEnumField ( enum = enums . CaptureMethod , help_text = \"Capture method of this PaymentIntent, one of automatic or manual.\" , ) client_secret = models . TextField ( max_length = 5000 , help_text = ( \"The client secret of this PaymentIntent. \" \"Used for client-side retrieval using a publishable key.\" ), ) confirmation_method = StripeEnumField ( enum = enums . ConfirmationMethod , help_text = ( \"Confirmation method of this PaymentIntent, one of manual or automatic.\" ), ) currency = StripeCurrencyCodeField () customer = StripeForeignKey ( \"Customer\" , null = True , on_delete = models . CASCADE , help_text = \"Customer this PaymentIntent is for if one exists.\" , ) description = models . TextField ( max_length = 1000 , default = \"\" , blank = True , help_text = ( \"An arbitrary string attached to the object. \" \"Often useful for displaying to users.\" ), ) last_payment_error = JSONField ( null = True , blank = True , help_text = ( \"The payment error encountered in the previous PaymentIntent confirmation.\" ), ) next_action = JSONField ( null = True , blank = True , help_text = ( \"If present, this property tells you what actions you need to take \" \"in order for your customer to fulfill a payment using the provided source.\" ), ) on_behalf_of = StripeForeignKey ( \"Account\" , on_delete = models . CASCADE , null = True , blank = True , help_text = \"The account (if any) for which the funds of the \" \"PaymentIntent are intended.\" , related_name = \"payment_intents\" , ) payment_method = StripeForeignKey ( \"PaymentMethod\" , on_delete = models . SET_NULL , null = True , blank = True , help_text = \"Payment method used in this PaymentIntent.\" , ) payment_method_types = JSONField ( help_text = ( \"The list of payment method types (e.g. card) that this \" \"PaymentIntent is allowed to use.\" ) ) receipt_email = models . CharField ( blank = True , max_length = 255 , help_text = ( \"Email address that the receipt for the resulting payment will be sent to.\" ), ) # TODO: Add `review` field after we add Review model. setup_future_usage = StripeEnumField ( enum = enums . IntentUsage , null = True , blank = True , help_text = ( \"Indicates that you intend to make future payments with this \" \"PaymentIntent's payment method. \" \"If present, the payment method used with this PaymentIntent can \" \"be attached to a Customer, even after the transaction completes. \" \"Use `on_session` if you intend to only reuse the payment method \" \"when your customer is present in your checkout flow. Use `off_session` \" \"if your customer may or may not be in your checkout flow. \" \"Stripe uses `setup_future_usage` to dynamically optimize \" \"your payment flow and comply with regional legislation and network rules. \" \"For example, if your customer is impacted by SCA, using `off_session` \" \"will ensure that they are authenticated while processing this \" \"PaymentIntent. You will then be able to make later off-session payments \" \"for this customer.\" ), ) shipping = JSONField ( null = True , blank = True , help_text = \"Shipping information for this PaymentIntent.\" ) statement_descriptor = models . CharField ( max_length = 22 , blank = True , help_text = ( \"For non-card charges, you can use this value as the complete description \" \"that appears on your customers' statements. Must contain at least one \" \"letter, maximum 22 characters.\" ), ) status = StripeEnumField ( enum = enums . PaymentIntentStatus , help_text = ( \"Status of this PaymentIntent, one of requires_payment_method, \" \"requires_confirmation, requires_action, processing, requires_capture, \" \"canceled, or succeeded. \" \"You can read more about PaymentIntent statuses here.\" ), ) transfer_data = JSONField ( null = True , blank = True , help_text = ( \"The data with which to automatically create a Transfer when the payment \" \"is finalized. \" \"See the PaymentIntents Connect usage guide for details.\" ), ) transfer_group = models . CharField ( blank = True , max_length = 255 , help_text = ( \"A string that identifies the resulting payment as part of a group. \" \"See the PaymentIntents Connect usage guide for details.\" ), ) def __str__ ( self ): account = self . on_behalf_of customer = self . customer amount = get_friendly_currency_amount ( self . amount / 100 , self . currency ) status = enums . PaymentIntentStatus . humanize ( self . status ) if account and customer : return f \" { amount } ( { status } ) for { account } by { customer } \" if account : return f \" { amount } for { account } . { status } \" if customer : return f \" { amount } by { customer } . { status } \" return f \" { amount } ( { status } )\" def update ( self , api_key = None , ** kwargs ): \"\"\" Call the stripe API's modify operation for this model :param api_key: The api key to use for this request. Defaults to djstripe_settings.STRIPE_SECRET_KEY. :type api_key: string \"\"\" api_key = api_key or self . default_api_key response = self . api_retrieve ( api_key = api_key ) return response . modify ( response . stripe_id , api_key = api_key , ** kwargs ) def _api_cancel ( self , api_key = None , ** kwargs ): \"\"\" Call the stripe API's cancel operation for this model :param api_key: The api key to use for this request. Defaults to djstripe_settings.STRIPE_SECRET_KEY. :type api_key: string \"\"\" api_key = api_key or self . default_api_key return self . api_retrieve ( api_key = api_key ) . cancel ( ** kwargs ) def _api_confirm ( self , api_key = None , ** kwargs ): \"\"\" Call the stripe API's confirm operation for this model. Confirm that your customer intends to pay with current or provided payment method. Upon confirmation, the PaymentIntent will attempt to initiate a payment. :param api_key: The api key to use for this request. Defaults to djstripe_settings.STRIPE_SECRET_KEY. :type api_key: string \"\"\" api_key = api_key or self . default_api_key return self . api_retrieve ( api_key = api_key ) . confirm ( ** kwargs ) Attributes djstripe . models . core . PaymentIntent . amount = StripeQuantumCurrencyAmountField ( help_text = 'Amount (in cents) intended to be collected by this PaymentIntent.' ) class-attribute djstripe . models . core . PaymentIntent . amount_capturable = StripeQuantumCurrencyAmountField ( help_text = 'Amount (in cents) that can be captured from this PaymentIntent.' ) class-attribute djstripe . models . core . PaymentIntent . amount_received = StripeQuantumCurrencyAmountField ( help_text = 'Amount (in cents) that was collected by this PaymentIntent.' ) class-attribute djstripe . models . core . PaymentIntent . canceled_at = StripeDateTimeField ( null = True , blank = True , default = None , help_text = 'Populated when status is canceled, this is the time at which the PaymentIntent was canceled. Measured in seconds since the Unix epoch.' ) class-attribute djstripe . models . core . PaymentIntent . cancellation_reason = StripeEnumField ( enum = enums . PaymentIntentCancellationReason , blank = True , help_text = 'Reason for cancellation of this PaymentIntent, either user-provided (duplicate, fraudulent, requested_by_customer, or abandoned) or generated by Stripe internally (failed_invoice, void_invoice, or automatic).' ) class-attribute djstripe . models . core . PaymentIntent . capture_method = StripeEnumField ( enum = enums . CaptureMethod , help_text = 'Capture method of this PaymentIntent, one of automatic or manual.' ) class-attribute djstripe . models . core . PaymentIntent . client_secret = models . TextField ( max_length = 5000 , help_text = 'The client secret of this PaymentIntent. Used for client-side retrieval using a publishable key.' ) class-attribute djstripe . models . core . PaymentIntent . confirmation_method = StripeEnumField ( enum = enums . ConfirmationMethod , help_text = 'Confirmation method of this PaymentIntent, one of manual or automatic.' ) class-attribute djstripe . models . core . PaymentIntent . currency = StripeCurrencyCodeField () class-attribute djstripe . models . core . PaymentIntent . customer = StripeForeignKey ( 'Customer' , null = True , on_delete = models . CASCADE , help_text = 'Customer this PaymentIntent is for if one exists.' ) class-attribute djstripe . models . core . PaymentIntent . description = models . TextField ( max_length = 1000 , default = '' , blank = True , help_text = 'An arbitrary string attached to the object. Often useful for displaying to users.' ) class-attribute djstripe . models . core . PaymentIntent . last_payment_error = JSONField ( null = True , blank = True , help_text = 'The payment error encountered in the previous PaymentIntent confirmation.' ) class-attribute djstripe . models . core . PaymentIntent . next_action = JSONField ( null = True , blank = True , help_text = 'If present, this property tells you what actions you need to take in order for your customer to fulfill a payment using the provided source.' ) class-attribute djstripe . models . core . PaymentIntent . on_behalf_of = StripeForeignKey ( 'Account' , on_delete = models . CASCADE , null = True , blank = True , help_text = 'The account (if any) for which the funds of the PaymentIntent are intended.' , related_name = 'payment_intents' ) class-attribute djstripe . models . core . PaymentIntent . payment_method = StripeForeignKey ( 'PaymentMethod' , on_delete = models . SET_NULL , null = True , blank = True , help_text = 'Payment method used in this PaymentIntent.' ) class-attribute djstripe . models . core . PaymentIntent . payment_method_types = JSONField ( help_text = 'The list of payment method types (e.g. card) that this PaymentIntent is allowed to use.' ) class-attribute djstripe . models . core . PaymentIntent . receipt_email = models . CharField ( blank = True , max_length = 255 , help_text = 'Email address that the receipt for the resulting payment will be sent to.' ) class-attribute djstripe . models . core . PaymentIntent . setup_future_usage = StripeEnumField ( enum = enums . IntentUsage , null = True , blank = True , help_text = \"Indicates that you intend to make future payments with this PaymentIntent's payment method. If present, the payment method used with this PaymentIntent can be attached to a Customer, even after the transaction completes. Use `on_session` if you intend to only reuse the payment method when your customer is present in your checkout flow. Use `off_session` if your customer may or may not be in your checkout flow. Stripe uses `setup_future_usage` to dynamically optimize your payment flow and comply with regional legislation and network rules. For example, if your customer is impacted by SCA, using `off_session` will ensure that they are authenticated while processing this PaymentIntent. You will then be able to make later off-session payments for this customer.\" ) class-attribute djstripe . models . core . PaymentIntent . shipping = JSONField ( null = True , blank = True , help_text = 'Shipping information for this PaymentIntent.' ) class-attribute djstripe . models . core . PaymentIntent . statement_descriptor = models . CharField ( max_length = 22 , blank = True , help_text = \"For non-card charges, you can use this value as the complete description that appears on your customers' statements. Must contain at least one letter, maximum 22 characters.\" ) class-attribute djstripe . models . core . PaymentIntent . status = StripeEnumField ( enum = enums . PaymentIntentStatus , help_text = 'Status of this PaymentIntent, one of requires_payment_method, requires_confirmation, requires_action, processing, requires_capture, canceled, or succeeded. You can read more about PaymentIntent statuses here.' ) class-attribute djstripe . models . core . PaymentIntent . stripe_class = stripe . PaymentIntent class-attribute djstripe . models . core . PaymentIntent . stripe_dashboard_item_name = 'payments' class-attribute djstripe . models . core . PaymentIntent . transfer_data = JSONField ( null = True , blank = True , help_text = 'The data with which to automatically create a Transfer when the payment is finalized. See the PaymentIntents Connect usage guide for details.' ) class-attribute djstripe . models . core . PaymentIntent . transfer_group = models . CharField ( blank = True , max_length = 255 , help_text = 'A string that identifies the resulting payment as part of a group. See the PaymentIntents Connect usage guide for details.' ) class-attribute Functions djstripe . models . core . PaymentIntent . __str__ () Source code in djstripe/models/core.py 1881 1882 1883 1884 1885 1886 1887 1888 1889 1890 1891 1892 1893 1894 def __str__ ( self ): account = self . on_behalf_of customer = self . customer amount = get_friendly_currency_amount ( self . amount / 100 , self . currency ) status = enums . PaymentIntentStatus . humanize ( self . status ) if account and customer : return f \" { amount } ( { status } ) for { account } by { customer } \" if account : return f \" { amount } for { account } . { status } \" if customer : return f \" { amount } by { customer } . { status } \" return f \" { amount } ( { status } )\" djstripe . models . core . PaymentIntent . update ( api_key = None , ** kwargs ) Call the stripe API's modify operation for this model :param api_key: The api key to use for this request. Defaults to djstripe_settings.STRIPE_SECRET_KEY. :type api_key: string Source code in djstripe/models/core.py 1896 1897 1898 1899 1900 1901 1902 1903 1904 1905 1906 def update ( self , api_key = None , ** kwargs ): \"\"\" Call the stripe API's modify operation for this model :param api_key: The api key to use for this request. Defaults to djstripe_settings.STRIPE_SECRET_KEY. :type api_key: string \"\"\" api_key = api_key or self . default_api_key response = self . api_retrieve ( api_key = api_key ) return response . modify ( response . stripe_id , api_key = api_key , ** kwargs ) djstripe.models.core.Payout Bases: StripeModel A Payout object is created when you receive funds from Stripe, or when you initiate a payout to either a bank account or debit card of a connected Stripe account. Stripe documentation: https://stripe.com/docs/api?lang=python#payouts Source code in djstripe/models/core.py 2051 2052 2053 2054 2055 2056 2057 2058 2059 2060 2061 2062 2063 2064 2065 2066 2067 2068 2069 2070 2071 2072 2073 2074 2075 2076 2077 2078 2079 2080 2081 2082 2083 2084 2085 2086 2087 2088 2089 2090 2091 2092 2093 2094 2095 2096 2097 2098 2099 2100 2101 2102 2103 2104 2105 2106 2107 2108 2109 2110 2111 2112 2113 2114 2115 2116 2117 2118 2119 2120 2121 2122 2123 2124 2125 2126 2127 2128 2129 2130 2131 2132 2133 2134 2135 2136 2137 2138 2139 2140 2141 2142 2143 2144 2145 2146 2147 2148 2149 2150 2151 2152 2153 2154 2155 2156 2157 2158 2159 2160 2161 2162 class Payout ( StripeModel ): \"\"\" A Payout object is created when you receive funds from Stripe, or when you initiate a payout to either a bank account or debit card of a connected Stripe account. Stripe documentation: https://stripe.com/docs/api?lang=python#payouts \"\"\" expand_fields = [ \"destination\" ] stripe_class = stripe . Payout stripe_dashboard_item_name = \"payouts\" amount = StripeDecimalCurrencyAmountField ( help_text = \"Amount (as decimal) to be transferred to your bank account or \" \"debit card.\" ) arrival_date = StripeDateTimeField ( help_text = ( \"Date the payout is expected to arrive in the bank. \" \"This factors in delays like weekends or bank holidays.\" ) ) automatic = models . BooleanField ( help_text = ( \"`true` if the payout was created by an automated payout schedule, \" \"and `false` if it was requested manually.\" ) ) balance_transaction = StripeForeignKey ( \"BalanceTransaction\" , on_delete = models . SET_NULL , null = True , help_text = \"Balance transaction that describes the impact on your \" \"account balance.\" , ) currency = StripeCurrencyCodeField () destination = PaymentMethodForeignKey ( on_delete = models . PROTECT , null = True , help_text = \"Bank account or card the payout was sent to.\" , ) failure_balance_transaction = StripeForeignKey ( \"BalanceTransaction\" , on_delete = models . SET_NULL , related_name = \"failure_payouts\" , null = True , blank = True , help_text = ( \"If the payout failed or was canceled, this will be the balance \" \"transaction that reversed the initial balance transaction, and \" \"puts the funds from the failed payout back in your balance.\" ), ) failure_code = StripeEnumField ( enum = enums . PayoutFailureCode , default = \"\" , blank = True , help_text = ( \"Error code explaining reason for transfer failure if available. \" \"See https://stripe.com/docs/api?lang=python#transfer_failures.\" ), ) failure_message = models . TextField ( default = \"\" , blank = True , help_text = ( \"Message to user further explaining reason for \" \"payout failure if available.\" ), ) method = StripeEnumField ( max_length = 8 , enum = enums . PayoutMethod , help_text = ( \"The method used to send this payout. \" \"`instant` is only supported for payouts to debit cards.\" ), ) # TODO: `original_payout` impl as OneToOne, with `reversed_by` reverse relation # original_payout = StripeForeignKey( # \"Payout\", # on_delete=models.SET_NULL, # null=True, # blank=True, # help_text=\"If the payout reverses another, this is the original payout.\", # ) source_type = StripeEnumField ( enum = enums . PayoutSourceType , help_text = \"The source balance this payout came from.\" , ) statement_descriptor = models . CharField ( max_length = 255 , default = \"\" , blank = True , help_text = \"Extra information about a payout to be displayed \" \"on the user's bank statement.\" , ) status = StripeEnumField ( enum = enums . PayoutStatus , help_text = ( \"Current status of the payout. \" \"A payout will be `pending` until it is submitted to the bank, \" \"at which point it becomes `in_transit`. \" \"It will then change to paid if the transaction goes through. \" \"If it does not go through successfully, \" \"its status will change to `failed` or `canceled`.\" ), ) type = StripeEnumField ( enum = enums . PayoutType ) def __str__ ( self ): return f \" { self . amount } ( { enums . PayoutStatus . humanize ( self . status ) } )\" Attributes djstripe . models . core . Payout . amount = StripeDecimalCurrencyAmountField ( help_text = 'Amount (as decimal) to be transferred to your bank account or debit card.' ) class-attribute djstripe . models . core . Payout . arrival_date = StripeDateTimeField ( help_text = 'Date the payout is expected to arrive in the bank. This factors in delays like weekends or bank holidays.' ) class-attribute djstripe . models . core . Payout . automatic = models . BooleanField ( help_text = '`true` if the payout was created by an automated payout schedule, and `false` if it was requested manually.' ) class-attribute djstripe . models . core . Payout . balance_transaction = StripeForeignKey ( 'BalanceTransaction' , on_delete = models . SET_NULL , null = True , help_text = 'Balance transaction that describes the impact on your account balance.' ) class-attribute djstripe . models . core . Payout . currency = StripeCurrencyCodeField () class-attribute djstripe . models . core . Payout . destination = PaymentMethodForeignKey ( on_delete = models . PROTECT , null = True , help_text = 'Bank account or card the payout was sent to.' ) class-attribute djstripe . models . core . Payout . expand_fields = [ 'destination' ] class-attribute djstripe . models . core . Payout . failure_balance_transaction = StripeForeignKey ( 'BalanceTransaction' , on_delete = models . SET_NULL , related_name = 'failure_payouts' , null = True , blank = True , help_text = 'If the payout failed or was canceled, this will be the balance transaction that reversed the initial balance transaction, and puts the funds from the failed payout back in your balance.' ) class-attribute djstripe . models . core . Payout . failure_code = StripeEnumField ( enum = enums . PayoutFailureCode , default = '' , blank = True , help_text = 'Error code explaining reason for transfer failure if available. See https://stripe.com/docs/api?lang=python#transfer_failures.' ) class-attribute djstripe . models . core . Payout . failure_message = models . TextField ( default = '' , blank = True , help_text = 'Message to user further explaining reason for payout failure if available.' ) class-attribute djstripe . models . core . Payout . method = StripeEnumField ( max_length = 8 , enum = enums . PayoutMethod , help_text = 'The method used to send this payout. `instant` is only supported for payouts to debit cards.' ) class-attribute djstripe . models . core . Payout . source_type = StripeEnumField ( enum = enums . PayoutSourceType , help_text = 'The source balance this payout came from.' ) class-attribute djstripe . models . core . Payout . statement_descriptor = models . CharField ( max_length = 255 , default = '' , blank = True , help_text = \"Extra information about a payout to be displayed on the user's bank statement.\" ) class-attribute djstripe . models . core . Payout . status = StripeEnumField ( enum = enums . PayoutStatus , help_text = 'Current status of the payout. A payout will be `pending` until it is submitted to the bank, at which point it becomes `in_transit`. It will then change to paid if the transaction goes through. If it does not go through successfully, its status will change to `failed` or `canceled`.' ) class-attribute djstripe . models . core . Payout . stripe_class = stripe . Payout class-attribute djstripe . models . core . Payout . stripe_dashboard_item_name = 'payouts' class-attribute djstripe . models . core . Payout . type = StripeEnumField ( enum = enums . PayoutType ) class-attribute Functions djstripe . models . core . Payout . __str__ () Source code in djstripe/models/core.py 2161 2162 def __str__ ( self ): return f \" { self . amount } ( { enums . PayoutStatus . humanize ( self . status ) } )\" djstripe.models.core.Price Bases: StripeModel Prices define the unit cost, currency, and (optional) billing cycle for both recurring and one-time purchases of products. Price and Plan objects are the same, but use a different representation. Creating a recurring Price in Stripe also makes a Plan available, and vice versa. This is not the case for a Price with interval=one_time. Price objects are a more recent API representation, support more features and its usage is encouraged instead of Plan objects. Stripe documentation: - https://stripe.com/docs/api/prices - https://stripe.com/docs/billing/prices-guide Source code in djstripe/models/core.py 2165 2166 2167 2168 2169 2170 2171 2172 2173 2174 2175 2176 2177 2178 2179 2180 2181 2182 2183 2184 2185 2186 2187 2188 2189 2190 2191 2192 2193 2194 2195 2196 2197 2198 2199 2200 2201 2202 2203 2204 2205 2206 2207 2208 2209 2210 2211 2212 2213 2214 2215 2216 2217 2218 2219 2220 2221 2222 2223 2224 2225 2226 2227 2228 2229 2230 2231 2232 2233 2234 2235 2236 2237 2238 2239 2240 2241 2242 2243 2244 2245 2246 2247 2248 2249 2250 2251 2252 2253 2254 2255 2256 2257 2258 2259 2260 2261 2262 2263 2264 2265 2266 2267 2268 2269 2270 2271 2272 2273 2274 2275 2276 2277 2278 2279 2280 2281 2282 2283 2284 2285 2286 2287 2288 2289 2290 2291 2292 2293 2294 2295 2296 2297 2298 2299 2300 2301 2302 2303 2304 2305 2306 2307 2308 2309 2310 2311 2312 2313 2314 2315 2316 2317 2318 2319 2320 2321 2322 2323 2324 2325 2326 2327 2328 2329 2330 2331 2332 2333 2334 2335 2336 2337 2338 2339 2340 2341 2342 2343 2344 2345 2346 2347 2348 2349 2350 2351 2352 2353 2354 2355 2356 2357 2358 2359 2360 2361 2362 2363 2364 2365 2366 class Price ( StripeModel ): \"\"\" Prices define the unit cost, currency, and (optional) billing cycle for both recurring and one-time purchases of products. Price and Plan objects are the same, but use a different representation. Creating a recurring Price in Stripe also makes a Plan available, and vice versa. This is not the case for a Price with interval=one_time. Price objects are a more recent API representation, support more features and its usage is encouraged instead of Plan objects. Stripe documentation: - https://stripe.com/docs/api/prices - https://stripe.com/docs/billing/prices-guide \"\"\" stripe_class = stripe . Price expand_fields = [ \"product\" , \"tiers\" ] stripe_dashboard_item_name = \"prices\" active = models . BooleanField ( help_text = \"Whether the price can be used for new purchases.\" ) currency = StripeCurrencyCodeField () nickname = models . CharField ( max_length = 250 , blank = True , help_text = \"A brief description of the plan, hidden from customers.\" , ) product = StripeForeignKey ( \"Product\" , on_delete = models . CASCADE , related_name = \"prices\" , help_text = \"The product this price is associated with.\" , ) recurring = JSONField ( default = None , blank = True , null = True , help_text = ( \"The recurring components of a price such as `interval` and `usage_type`.\" ), ) type = StripeEnumField ( enum = enums . PriceType , help_text = ( \"Whether the price is for a one-time purchase or a recurring \" \"(subscription) purchase.\" ), ) unit_amount = StripeQuantumCurrencyAmountField ( null = True , blank = True , help_text = ( \"The unit amount in cents to be charged, represented as a whole \" \"integer if possible. Null if a sub-cent precision is required.\" ), ) unit_amount_decimal = StripeDecimalCurrencyAmountField ( null = True , blank = True , max_digits = 19 , decimal_places = 12 , help_text = ( \"The unit amount in cents to be charged, represented as a decimal \" \"string with at most 12 decimal places.\" ), ) # More attributes\u2026 billing_scheme = StripeEnumField ( enum = enums . BillingScheme , blank = True , help_text = ( \"Describes how to compute the price per period. \" \"Either `per_unit` or `tiered`. \" \"`per_unit` indicates that the fixed amount (specified in `unit_amount` \" \"or `unit_amount_decimal`) will be charged per unit in `quantity` \" \"(for prices with `usage_type=licensed`), or per unit of total \" \"usage (for prices with `usage_type=metered`). \" \"`tiered` indicates that the unit pricing will be computed using \" \"a tiering strategy as defined using the `tiers` and `tiers_mode` \" \"attributes.\" ), ) lookup_key = models . CharField ( max_length = 250 , null = True , blank = True , help_text = \"A lookup key used to retrieve prices dynamically from a \" \"static string.\" , ) tiers = JSONField ( null = True , blank = True , help_text = ( \"Each element represents a pricing tier. \" \"This parameter requires `billing_scheme` to be set to `tiered`.\" ), ) tiers_mode = StripeEnumField ( enum = enums . PriceTiersMode , null = True , blank = True , help_text = ( \"Defines if the tiering price should be `graduated` or `volume` based. \" \"In `volume`-based tiering, the maximum quantity within a period \" \"determines the per unit price, in `graduated` tiering pricing can \" \"successively change as the quantity grows.\" ), ) transform_quantity = JSONField ( null = True , blank = True , help_text = ( \"Apply a transformation to the reported usage or set quantity \" \"before computing the amount billed. Cannot be combined with `tiers`.\" ), ) class Meta ( object ): ordering = [ \"unit_amount\" ] @classmethod def get_or_create ( cls , ** kwargs ): \"\"\"Get or create a Price.\"\"\" try : return cls . objects . get ( id = kwargs [ \"id\" ]), False except cls . DoesNotExist : return cls . create ( ** kwargs ), True @classmethod def create ( cls , ** kwargs ): # A few minor things are changed in the api-version of the create call api_kwargs = dict ( kwargs ) if api_kwargs [ \"unit_amount\" ]: api_kwargs [ \"unit_amount\" ] = int ( api_kwargs [ \"unit_amount\" ] * 100 ) if isinstance ( api_kwargs . get ( \"product\" ), StripeModel ): api_kwargs [ \"product\" ] = api_kwargs [ \"product\" ] . id stripe_price = cls . _api_create ( ** api_kwargs ) api_key = api_kwargs . get ( \"api_key\" ) or djstripe_settings . STRIPE_SECRET_KEY price = cls . sync_from_stripe_data ( stripe_price , api_key = api_key ) return price def __str__ ( self ): return f \" { self . human_readable_price } for { self . product . name } \" @property def human_readable_price ( self ): if self . billing_scheme == \"per_unit\" : unit_amount = ( self . unit_amount or 0 ) / 100 amount = get_friendly_currency_amount ( unit_amount , self . currency ) else : # tiered billing scheme tier_1 = self . tiers [ 0 ] formatted_unit_amount_tier_1 = get_friendly_currency_amount ( ( tier_1 [ \"unit_amount\" ] or 0 ) / 100 , self . currency ) amount = f \"Starts at { formatted_unit_amount_tier_1 } per unit\" # stripe shows flat fee even if it is set to 0.00 flat_amount_tier_1 = tier_1 [ \"flat_amount\" ] if flat_amount_tier_1 is not None : formatted_flat_amount_tier_1 = get_friendly_currency_amount ( flat_amount_tier_1 / 100 , self . currency ) amount = f \" { amount } + { formatted_flat_amount_tier_1 } \" format_args = { \"amount\" : amount } if self . recurring : interval_count = self . recurring [ \"interval_count\" ] if interval_count == 1 : interval = { \"day\" : _ ( \"day\" ), \"week\" : _ ( \"week\" ), \"month\" : _ ( \"month\" ), \"year\" : _ ( \"year\" ), }[ self . recurring [ \"interval\" ]] template = _ ( \" {amount} / {interval} \" ) format_args [ \"interval\" ] = interval else : interval = { \"day\" : _ ( \"days\" ), \"week\" : _ ( \"weeks\" ), \"month\" : _ ( \"months\" ), \"year\" : _ ( \"years\" ), }[ self . recurring [ \"interval\" ]] template = _ ( \" {amount} / every {interval_count} {interval} \" ) format_args [ \"interval\" ] = interval format_args [ \"interval_count\" ] = interval_count else : template = _ ( \" {amount} (one time)\" ) return format_lazy ( template , ** format_args ) Attributes djstripe . models . core . Price . active = models . BooleanField ( help_text = 'Whether the price can be used for new purchases.' ) class-attribute djstripe . models . core . Price . billing_scheme = StripeEnumField ( enum = enums . BillingScheme , blank = True , help_text = 'Describes how to compute the price per period. Either `per_unit` or `tiered`. `per_unit` indicates that the fixed amount (specified in `unit_amount` or `unit_amount_decimal`) will be charged per unit in `quantity` (for prices with `usage_type=licensed`), or per unit of total usage (for prices with `usage_type=metered`). `tiered` indicates that the unit pricing will be computed using a tiering strategy as defined using the `tiers` and `tiers_mode` attributes.' ) class-attribute djstripe . models . core . Price . currency = StripeCurrencyCodeField () class-attribute djstripe . models . core . Price . expand_fields = [ 'product' , 'tiers' ] class-attribute djstripe . models . core . Price . human_readable_price property djstripe . models . core . Price . lookup_key = models . CharField ( max_length = 250 , null = True , blank = True , help_text = 'A lookup key used to retrieve prices dynamically from a static string.' ) class-attribute djstripe . models . core . Price . nickname = models . CharField ( max_length = 250 , blank = True , help_text = 'A brief description of the plan, hidden from customers.' ) class-attribute djstripe . models . core . Price . product = StripeForeignKey ( 'Product' , on_delete = models . CASCADE , related_name = 'prices' , help_text = 'The product this price is associated with.' ) class-attribute djstripe . models . core . Price . recurring = JSONField ( default = None , blank = True , null = True , help_text = 'The recurring components of a price such as `interval` and `usage_type`.' ) class-attribute djstripe . models . core . Price . stripe_class = stripe . Price class-attribute djstripe . models . core . Price . stripe_dashboard_item_name = 'prices' class-attribute djstripe . models . core . Price . tiers = JSONField ( null = True , blank = True , help_text = 'Each element represents a pricing tier. This parameter requires `billing_scheme` to be set to `tiered`.' ) class-attribute djstripe . models . core . Price . tiers_mode = StripeEnumField ( enum = enums . PriceTiersMode , null = True , blank = True , help_text = 'Defines if the tiering price should be `graduated` or `volume` based. In `volume`-based tiering, the maximum quantity within a period determines the per unit price, in `graduated` tiering pricing can successively change as the quantity grows.' ) class-attribute djstripe . models . core . Price . transform_quantity = JSONField ( null = True , blank = True , help_text = 'Apply a transformation to the reported usage or set quantity before computing the amount billed. Cannot be combined with `tiers`.' ) class-attribute djstripe . models . core . Price . type = StripeEnumField ( enum = enums . PriceType , help_text = 'Whether the price is for a one-time purchase or a recurring (subscription) purchase.' ) class-attribute djstripe . models . core . Price . unit_amount = StripeQuantumCurrencyAmountField ( null = True , blank = True , help_text = 'The unit amount in cents to be charged, represented as a whole integer if possible. Null if a sub-cent precision is required.' ) class-attribute djstripe . models . core . Price . unit_amount_decimal = StripeDecimalCurrencyAmountField ( null = True , blank = True , max_digits = 19 , decimal_places = 12 , help_text = 'The unit amount in cents to be charged, represented as a decimal string with at most 12 decimal places.' ) class-attribute Classes djstripe.models.core.Price.Meta Bases: object Source code in djstripe/models/core.py 2286 2287 class Meta ( object ): ordering = [ \"unit_amount\" ] Attributes djstripe . models . core . Price . Meta . ordering = [ 'unit_amount' ] class-attribute Functions djstripe . models . core . Price . __str__ () Source code in djstripe/models/core.py 2315 2316 def __str__ ( self ): return f \" { self . human_readable_price } for { self . product . name } \" djstripe . models . core . Price . create ( ** kwargs ) classmethod Source code in djstripe/models/core.py 2298 2299 2300 2301 2302 2303 2304 2305 2306 2307 2308 2309 2310 2311 2312 2313 @classmethod def create ( cls , ** kwargs ): # A few minor things are changed in the api-version of the create call api_kwargs = dict ( kwargs ) if api_kwargs [ \"unit_amount\" ]: api_kwargs [ \"unit_amount\" ] = int ( api_kwargs [ \"unit_amount\" ] * 100 ) if isinstance ( api_kwargs . get ( \"product\" ), StripeModel ): api_kwargs [ \"product\" ] = api_kwargs [ \"product\" ] . id stripe_price = cls . _api_create ( ** api_kwargs ) api_key = api_kwargs . get ( \"api_key\" ) or djstripe_settings . STRIPE_SECRET_KEY price = cls . sync_from_stripe_data ( stripe_price , api_key = api_key ) return price djstripe . models . core . Price . get_or_create ( ** kwargs ) classmethod Get or create a Price. Source code in djstripe/models/core.py 2289 2290 2291 2292 2293 2294 2295 2296 @classmethod def get_or_create ( cls , ** kwargs ): \"\"\"Get or create a Price.\"\"\" try : return cls . objects . get ( id = kwargs [ \"id\" ]), False except cls . DoesNotExist : return cls . create ( ** kwargs ), True djstripe.models.core.Product Bases: StripeModel Products describe the specific goods or services you offer to your customers. For example, you might offer a Standard and Premium version of your goods or service; each version would be a separate Product. They can be used in conjunction with Prices to configure pricing in Payment Links, Checkout, and Subscriptions. Stripe documentation: https://stripe.com/docs/api?lang=python#products Source code in djstripe/models/core.py 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 class Product ( StripeModel ): \"\"\" Products describe the specific goods or services you offer to your customers. For example, you might offer a Standard and Premium version of your goods or service; each version would be a separate Product. They can be used in conjunction with Prices to configure pricing in Payment Links, Checkout, and Subscriptions. Stripe documentation: https://stripe.com/docs/api?lang=python#products \"\"\" stripe_class = stripe . Product stripe_dashboard_item_name = \"products\" # Fields applicable to both `good` and `service` name = models . TextField ( max_length = 5000 , help_text = ( \"The product's name, meant to be displayable to the customer. \" \"Applicable to both `service` and `good` types.\" ), ) default_price = StripeForeignKey ( \"Price\" , on_delete = models . SET_NULL , null = True , blank = True , related_name = \"products\" , help_text = \"The default price this product is associated with.\" , ) type = StripeEnumField ( enum = enums . ProductType , help_text = ( \"The type of the product. The product is either of type `good`, which is \" \"eligible for use with Orders and SKUs, or `service`, which is eligible \" \"for use with Subscriptions and Plans.\" ), ) # Fields applicable to `good` only active = models . BooleanField ( null = True , help_text = ( \"Whether the product is currently available for purchase. \" \"Only applicable to products of `type=good`.\" ), ) attributes = JSONField ( null = True , blank = True , help_text = ( \"A list of up to 5 attributes that each SKU can provide values for \" '(e.g., `[\"color\", \"size\"]`). Only applicable to products of `type=good`.' ), ) caption = models . TextField ( default = \"\" , blank = True , max_length = 5000 , help_text = ( \"A short one-line description of the product, meant to be displayable\" \"to the customer. Only applicable to products of `type=good`.\" ), ) deactivate_on = JSONField ( null = True , blank = True , help_text = ( \"An array of connect application identifiers that cannot purchase \" \"this product. Only applicable to products of `type=good`.\" ), ) images = JSONField ( null = True , blank = True , help_text = ( \"A list of up to 8 URLs of images for this product, meant to be \" \"displayable to the customer. Only applicable to products of `type=good`.\" ), ) package_dimensions = JSONField ( null = True , blank = True , help_text = ( \"The dimensions of this product for shipping purposes. \" \"A SKU associated with this product can override this value by having its \" \"own `package_dimensions`. Only applicable to products of `type=good`.\" ), ) shippable = models . BooleanField ( null = True , blank = True , help_text = ( \"Whether this product is a shipped good. \" \"Only applicable to products of `type=good`.\" ), ) url = models . CharField ( max_length = 799 , null = True , blank = True , help_text = ( \"A URL of a publicly-accessible webpage for this product. \" \"Only applicable to products of `type=good`.\" ), ) # Fields available to `service` only statement_descriptor = models . CharField ( max_length = 22 , default = \"\" , blank = True , help_text = ( \"Extra information about a product which will appear on your customer's \" \"credit card statement. In the case that multiple products are billed at \" \"once, the first statement descriptor will be used. \" \"Only available on products of type=`service`.\" ), ) unit_label = models . CharField ( max_length = 12 , default = \"\" , blank = True ) def __str__ ( self ): # 1 product can have 1 or more than 1 related price price_qs = self . prices . all () price_count = price_qs . count () if price_count > 1 : return f \" { self . name } ( { price_count } prices)\" elif price_count == 1 : return f \" { self . name } ( { price_qs [ 0 ] . human_readable_price } )\" else : return self . name Attributes djstripe . models . core . Product . active = models . BooleanField ( null = True , help_text = 'Whether the product is currently available for purchase. Only applicable to products of `type=good`.' ) class-attribute djstripe . models . core . Product . attributes = JSONField ( null = True , blank = True , help_text = 'A list of up to 5 attributes that each SKU can provide values for (e.g., `[\"color\", \"size\"]`). Only applicable to products of `type=good`.' ) class-attribute djstripe . models . core . Product . caption = models . TextField ( default = '' , blank = True , max_length = 5000 , help_text = 'A short one-line description of the product, meant to be displayableto the customer. Only applicable to products of `type=good`.' ) class-attribute djstripe . models . core . Product . deactivate_on = JSONField ( null = True , blank = True , help_text = 'An array of connect application identifiers that cannot purchase this product. Only applicable to products of `type=good`.' ) class-attribute djstripe . models . core . Product . default_price = StripeForeignKey ( 'Price' , on_delete = models . SET_NULL , null = True , blank = True , related_name = 'products' , help_text = 'The default price this product is associated with.' ) class-attribute djstripe . models . core . Product . images = JSONField ( null = True , blank = True , help_text = 'A list of up to 8 URLs of images for this product, meant to be displayable to the customer. Only applicable to products of `type=good`.' ) class-attribute djstripe . models . core . Product . name = models . TextField ( max_length = 5000 , help_text = \"The product's name, meant to be displayable to the customer. Applicable to both `service` and `good` types.\" ) class-attribute djstripe . models . core . Product . package_dimensions = JSONField ( null = True , blank = True , help_text = 'The dimensions of this product for shipping purposes. A SKU associated with this product can override this value by having its own `package_dimensions`. Only applicable to products of `type=good`.' ) class-attribute djstripe . models . core . Product . shippable = models . BooleanField ( null = True , blank = True , help_text = 'Whether this product is a shipped good. Only applicable to products of `type=good`.' ) class-attribute djstripe . models . core . Product . statement_descriptor = models . CharField ( max_length = 22 , default = '' , blank = True , help_text = \"Extra information about a product which will appear on your customer's credit card statement. In the case that multiple products are billed at once, the first statement descriptor will be used. Only available on products of type=`service`.\" ) class-attribute djstripe . models . core . Product . stripe_class = stripe . Product class-attribute djstripe . models . core . Product . stripe_dashboard_item_name = 'products' class-attribute djstripe . models . core . Product . type = StripeEnumField ( enum = enums . ProductType , help_text = 'The type of the product. The product is either of type `good`, which is eligible for use with Orders and SKUs, or `service`, which is eligible for use with Subscriptions and Plans.' ) class-attribute djstripe . models . core . Product . unit_label = models . CharField ( max_length = 12 , default = '' , blank = True ) class-attribute djstripe . models . core . Product . url = models . CharField ( max_length = 799 , null = True , blank = True , help_text = 'A URL of a publicly-accessible webpage for this product. Only applicable to products of `type=good`.' ) class-attribute Functions djstripe . models . core . Product . __str__ () Source code in djstripe/models/core.py 624 625 626 627 628 629 630 631 632 633 634 def __str__ ( self ): # 1 product can have 1 or more than 1 related price price_qs = self . prices . all () price_count = price_qs . count () if price_count > 1 : return f \" { self . name } ( { price_count } prices)\" elif price_count == 1 : return f \" { self . name } ( { price_qs [ 0 ] . human_readable_price } )\" else : return self . name djstripe.models.core.Refund Bases: StripeModel Refund objects allow you to refund a charge that has previously been created but not yet refunded. Funds will be refunded to the credit or debit card that was originally charged. Stripe documentation: https://stripe.com/docs/api?lang=python#refund_object Source code in djstripe/models/core.py 2369 2370 2371 2372 2373 2374 2375 2376 2377 2378 2379 2380 2381 2382 2383 2384 2385 2386 2387 2388 2389 2390 2391 2392 2393 2394 2395 2396 2397 2398 2399 2400 2401 2402 2403 2404 2405 2406 2407 2408 2409 2410 2411 2412 2413 2414 2415 2416 2417 2418 2419 2420 2421 2422 2423 2424 2425 2426 2427 2428 2429 2430 2431 2432 2433 2434 2435 class Refund ( StripeModel ): \"\"\" Refund objects allow you to refund a charge that has previously been created but not yet refunded. Funds will be refunded to the credit or debit card that was originally charged. Stripe documentation: https://stripe.com/docs/api?lang=python#refund_object \"\"\" stripe_class = stripe . Refund amount = StripeQuantumCurrencyAmountField ( help_text = \"Amount, in cents.\" ) balance_transaction = StripeForeignKey ( \"BalanceTransaction\" , on_delete = models . SET_NULL , null = True , help_text = \"Balance transaction that describes the impact on your account \" \"balance.\" , ) charge = StripeForeignKey ( \"Charge\" , on_delete = models . CASCADE , related_name = \"refunds\" , help_text = \"The charge that was refunded\" , ) currency = StripeCurrencyCodeField () failure_balance_transaction = StripeForeignKey ( \"BalanceTransaction\" , on_delete = models . SET_NULL , related_name = \"failure_refunds\" , null = True , blank = True , help_text = \"If the refund failed, this balance transaction describes the \" \"adjustment made on your account balance that reverses the initial \" \"balance transaction.\" , ) failure_reason = StripeEnumField ( enum = enums . RefundFailureReason , default = \"\" , blank = True , help_text = \"If the refund failed, the reason for refund failure if known.\" , ) reason = StripeEnumField ( enum = enums . RefundReason , blank = True , default = \"\" , help_text = \"Reason for the refund.\" , ) receipt_number = models . CharField ( max_length = 9 , default = \"\" , blank = True , help_text = \"The transaction number that appears on email receipts sent \" \"for this charge.\" , ) status = StripeEnumField ( blank = True , enum = enums . RefundStatus , help_text = \"Status of the refund.\" ) # todo implement source_transfer_reversal and transfer_reversal def get_stripe_dashboard_url ( self ): return self . charge . get_stripe_dashboard_url () def __str__ ( self ): amount = get_friendly_currency_amount ( self . amount / 100 , self . currency ) status = enums . RefundStatus . humanize ( self . status ) return f \" { amount } ( { status } )\" Attributes djstripe . models . core . Refund . amount = StripeQuantumCurrencyAmountField ( help_text = 'Amount, in cents.' ) class-attribute djstripe . models . core . Refund . balance_transaction = StripeForeignKey ( 'BalanceTransaction' , on_delete = models . SET_NULL , null = True , help_text = 'Balance transaction that describes the impact on your account balance.' ) class-attribute djstripe . models . core . Refund . charge = StripeForeignKey ( 'Charge' , on_delete = models . CASCADE , related_name = 'refunds' , help_text = 'The charge that was refunded' ) class-attribute djstripe . models . core . Refund . currency = StripeCurrencyCodeField () class-attribute djstripe . models . core . Refund . failure_balance_transaction = StripeForeignKey ( 'BalanceTransaction' , on_delete = models . SET_NULL , related_name = 'failure_refunds' , null = True , blank = True , help_text = 'If the refund failed, this balance transaction describes the adjustment made on your account balance that reverses the initial balance transaction.' ) class-attribute djstripe . models . core . Refund . failure_reason = StripeEnumField ( enum = enums . RefundFailureReason , default = '' , blank = True , help_text = 'If the refund failed, the reason for refund failure if known.' ) class-attribute djstripe . models . core . Refund . reason = StripeEnumField ( enum = enums . RefundReason , blank = True , default = '' , help_text = 'Reason for the refund.' ) class-attribute djstripe . models . core . Refund . receipt_number = models . CharField ( max_length = 9 , default = '' , blank = True , help_text = 'The transaction number that appears on email receipts sent for this charge.' ) class-attribute djstripe . models . core . Refund . status = StripeEnumField ( blank = True , enum = enums . RefundStatus , help_text = 'Status of the refund.' ) class-attribute djstripe . models . core . Refund . stripe_class = stripe . Refund class-attribute Functions djstripe . models . core . Refund . __str__ () Source code in djstripe/models/core.py 2432 2433 2434 2435 def __str__ ( self ): amount = get_friendly_currency_amount ( self . amount / 100 , self . currency ) status = enums . RefundStatus . humanize ( self . status ) return f \" { amount } ( { status } )\" djstripe . models . core . Refund . get_stripe_dashboard_url () Source code in djstripe/models/core.py 2429 2430 def get_stripe_dashboard_url ( self ): return self . charge . get_stripe_dashboard_url () djstripe.models.core.SetupIntent Bases: StripeModel A SetupIntent guides you through the process of setting up a customer's payment credentials for future payments. For example, you could use a SetupIntent to set up your customer's card without immediately collecting a payment. Later, you can use PaymentIntents to drive the payment flow. NOTE: You should not maintain long-lived, unconfirmed SetupIntents. For security purposes, SetupIntents older than 24 hours may no longer be valid. Stripe documentation: https://stripe.com/docs/api?lang=python#setup_intents Source code in djstripe/models/core.py 1937 1938 1939 1940 1941 1942 1943 1944 1945 1946 1947 1948 1949 1950 1951 1952 1953 1954 1955 1956 1957 1958 1959 1960 1961 1962 1963 1964 1965 1966 1967 1968 1969 1970 1971 1972 1973 1974 1975 1976 1977 1978 1979 1980 1981 1982 1983 1984 1985 1986 1987 1988 1989 1990 1991 1992 1993 1994 1995 1996 1997 1998 1999 2000 2001 2002 2003 2004 2005 2006 2007 2008 2009 2010 2011 2012 2013 2014 2015 2016 2017 2018 2019 2020 2021 2022 2023 2024 2025 2026 2027 2028 2029 2030 2031 2032 2033 2034 2035 2036 2037 2038 2039 2040 2041 2042 2043 2044 2045 2046 2047 class SetupIntent ( StripeModel ): \"\"\" A SetupIntent guides you through the process of setting up a customer's payment credentials for future payments. For example, you could use a SetupIntent to set up your customer's card without immediately collecting a payment. Later, you can use PaymentIntents to drive the payment flow. NOTE: You should not maintain long-lived, unconfirmed SetupIntents. For security purposes, SetupIntents older than 24 hours may no longer be valid. Stripe documentation: https://stripe.com/docs/api?lang=python#setup_intents \"\"\" stripe_class = stripe . SetupIntent application = models . CharField ( max_length = 255 , blank = True , help_text = \"ID of the Connect application that created the SetupIntent.\" , ) cancellation_reason = StripeEnumField ( enum = enums . SetupIntentCancellationReason , blank = True , help_text = ( \"Reason for cancellation of this SetupIntent, one of abandoned, \" \"requested_by_customer, or duplicate\" ), ) client_secret = models . TextField ( max_length = 5000 , blank = True , help_text = ( \"The client secret of this SetupIntent. \" \"Used for client-side retrieval using a publishable key.\" ), ) customer = StripeForeignKey ( \"Customer\" , null = True , blank = True , on_delete = models . SET_NULL , help_text = \"Customer this SetupIntent belongs to, if one exists.\" , ) last_setup_error = JSONField ( null = True , blank = True , help_text = \"The error encountered in the previous SetupIntent confirmation.\" , ) next_action = JSONField ( null = True , blank = True , help_text = ( \"If present, this property tells you what actions you need to take in\" \"order for your customer to continue payment setup.\" ), ) on_behalf_of = StripeForeignKey ( \"Account\" , on_delete = models . SET_NULL , null = True , blank = True , help_text = \"The account (if any) for which the setup is intended.\" , related_name = \"setup_intents\" , ) payment_method = StripeForeignKey ( \"PaymentMethod\" , on_delete = models . SET_NULL , null = True , blank = True , help_text = \"Payment method used in this PaymentIntent.\" , ) payment_method_types = JSONField ( help_text = ( \"The list of payment method types (e.g. card) that this PaymentIntent is \" \"allowed to use.\" ) ) status = StripeEnumField ( enum = enums . SetupIntentStatus , help_text = ( \"Status of this SetupIntent, one of requires_payment_method, \" \"requires_confirmation, requires_action, processing, \" \"canceled, or succeeded.\" ), ) usage = StripeEnumField ( enum = enums . IntentUsage , default = enums . IntentUsage . off_session , help_text = ( \"Indicates how the payment method is intended to be used in the future.\" ), ) def __str__ ( self ): account = self . on_behalf_of customer = self . customer if account and customer : return ( f \" { self . payment_method } ( { enums . SetupIntentStatus . humanize ( self . status ) } ) \" f \"for { account } \" f \"by { customer } \" ) if account : return f \" { self . payment_method } for { account } . { enums . SetupIntentStatus . humanize ( self . status ) } \" if customer : return f \" { self . payment_method } by { customer } . { enums . SetupIntentStatus . humanize ( self . status ) } \" return ( f \" { self . payment_method } ( { enums . SetupIntentStatus . humanize ( self . status ) } )\" ) Attributes djstripe . models . core . SetupIntent . application = models . CharField ( max_length = 255 , blank = True , help_text = 'ID of the Connect application that created the SetupIntent.' ) class-attribute djstripe . models . core . SetupIntent . cancellation_reason = StripeEnumField ( enum = enums . SetupIntentCancellationReason , blank = True , help_text = 'Reason for cancellation of this SetupIntent, one of abandoned, requested_by_customer, or duplicate' ) class-attribute djstripe . models . core . SetupIntent . client_secret = models . TextField ( max_length = 5000 , blank = True , help_text = 'The client secret of this SetupIntent. Used for client-side retrieval using a publishable key.' ) class-attribute djstripe . models . core . SetupIntent . customer = StripeForeignKey ( 'Customer' , null = True , blank = True , on_delete = models . SET_NULL , help_text = 'Customer this SetupIntent belongs to, if one exists.' ) class-attribute djstripe . models . core . SetupIntent . last_setup_error = JSONField ( null = True , blank = True , help_text = 'The error encountered in the previous SetupIntent confirmation.' ) class-attribute djstripe . models . core . SetupIntent . next_action = JSONField ( null = True , blank = True , help_text = 'If present, this property tells you what actions you need to take inorder for your customer to continue payment setup.' ) class-attribute djstripe . models . core . SetupIntent . on_behalf_of = StripeForeignKey ( 'Account' , on_delete = models . SET_NULL , null = True , blank = True , help_text = 'The account (if any) for which the setup is intended.' , related_name = 'setup_intents' ) class-attribute djstripe . models . core . SetupIntent . payment_method = StripeForeignKey ( 'PaymentMethod' , on_delete = models . SET_NULL , null = True , blank = True , help_text = 'Payment method used in this PaymentIntent.' ) class-attribute djstripe . models . core . SetupIntent . payment_method_types = JSONField ( help_text = 'The list of payment method types (e.g. card) that this PaymentIntent is allowed to use.' ) class-attribute djstripe . models . core . SetupIntent . status = StripeEnumField ( enum = enums . SetupIntentStatus , help_text = 'Status of this SetupIntent, one of requires_payment_method, requires_confirmation, requires_action, processing, canceled, or succeeded.' ) class-attribute djstripe . models . core . SetupIntent . stripe_class = stripe . SetupIntent class-attribute djstripe . models . core . SetupIntent . usage = StripeEnumField ( enum = enums . IntentUsage , default = enums . IntentUsage . off_session , help_text = 'Indicates how the payment method is intended to be used in the future.' ) class-attribute Functions djstripe . models . core . SetupIntent . __str__ () Source code in djstripe/models/core.py 2030 2031 2032 2033 2034 2035 2036 2037 2038 2039 2040 2041 2042 2043 2044 2045 2046 2047 def __str__ ( self ): account = self . on_behalf_of customer = self . customer if account and customer : return ( f \" { self . payment_method } ( { enums . SetupIntentStatus . humanize ( self . status ) } ) \" f \"for { account } \" f \"by { customer } \" ) if account : return f \" { self . payment_method } for { account } . { enums . SetupIntentStatus . humanize ( self . status ) } \" if customer : return f \" { self . payment_method } by { customer } . { enums . SetupIntentStatus . humanize ( self . status ) } \" return ( f \" { self . payment_method } ( { enums . SetupIntentStatus . humanize ( self . status ) } )\" ) Functions Payment Methods Attributes Classes djstripe.models.payment_methods.BankAccount Bases: LegacySourceMixin , StripeModel These bank accounts are payment methods on Customer objects. On the other hand External Accounts are transfer destinations on Account objects for Custom accounts. They can be bank accounts or debit cards as well. Stripe documentation:https://stripe.com/docs/api/customer_bank_accounts Source code in djstripe/models/payment_methods.py 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 class BankAccount ( LegacySourceMixin , StripeModel ): \"\"\" These bank accounts are payment methods on Customer objects. On the other hand External Accounts are transfer destinations on Account objects for Custom accounts. They can be bank accounts or debit cards as well. Stripe documentation:https://stripe.com/docs/api/customer_bank_accounts \"\"\" stripe_class = stripe . BankAccount account = StripeForeignKey ( \"Account\" , on_delete = models . PROTECT , null = True , blank = True , related_name = \"bank_accounts\" , help_text = \"The external account the charge was made on behalf of. Null here indicates \" \"that this value was never set.\" , ) account_holder_name = models . TextField ( max_length = 5000 , blank = True , help_text = \"The name of the person or business that owns the bank account.\" , ) account_holder_type = StripeEnumField ( enum = enums . BankAccountHolderType , help_text = \"The type of entity that holds the account.\" , ) bank_name = models . CharField ( max_length = 255 , help_text = \"Name of the bank associated with the routing number \" \"(e.g., `WELLS FARGO`).\" , ) country = models . CharField ( max_length = 2 , help_text = \"Two-letter ISO code representing the country the bank account \" \"is located in.\" , ) currency = StripeCurrencyCodeField () customer = StripeForeignKey ( \"Customer\" , on_delete = models . SET_NULL , null = True , related_name = \"bank_account\" ) default_for_currency = models . BooleanField ( null = True , help_text = \"Whether this external account (BankAccount) is the default account for \" \"its currency.\" , ) fingerprint = models . CharField ( max_length = 16 , help_text = ( \"Uniquely identifies this particular bank account. \" \"You can use this attribute to check whether two bank accounts are \" \"the same.\" ), ) last4 = models . CharField ( max_length = 4 ) routing_number = models . CharField ( max_length = 255 , help_text = \"The routing transit number for the bank account.\" ) status = StripeEnumField ( enum = enums . BankAccountStatus ) def __str__ ( self ): default = False # prefer to show it by customer format if present if self . customer : default_source = self . customer . default_source default_payment_method = self . customer . default_payment_method if ( default_payment_method and self . id == default_payment_method . id ) or ( default_source and self . id == default_source . id ): # current card is the default payment method or source default = True customer_template = f \" { self . bank_name } { self . routing_number } ( { self . human_readable_status } ) { 'Default' if default else '' } { self . currency } \" return customer_template default = getattr ( self , \"default_for_currency\" , False ) account_template = f \" { self . bank_name } { self . currency } { 'Default' if default else '' } { self . routing_number } { self . last4 } \" return account_template @property def human_readable_status ( self ): if self . status == \"new\" : return \"Pending Verification\" return enums . BankAccountStatus . humanize ( self . status ) def api_retrieve ( self , ** kwargs ): if not self . customer and not self . account : raise ImpossibleAPIRequest ( \"Can't retrieve a bank account without a customer or account object.\" \" This may happen if not all accounts or customer objects are in the db.\" ' Please run \"python manage.py djstripe_sync_models Account Customer\" as a potential fix.' ) return super () . api_retrieve ( ** kwargs ) Attributes djstripe . models . payment_methods . BankAccount . account = StripeForeignKey ( 'Account' , on_delete = models . PROTECT , null = True , blank = True , related_name = 'bank_accounts' , help_text = 'The external account the charge was made on behalf of. Null here indicates that this value was never set.' ) class-attribute djstripe . models . payment_methods . BankAccount . account_holder_name = models . TextField ( max_length = 5000 , blank = True , help_text = 'The name of the person or business that owns the bank account.' ) class-attribute djstripe . models . payment_methods . BankAccount . account_holder_type = StripeEnumField ( enum = enums . BankAccountHolderType , help_text = 'The type of entity that holds the account.' ) class-attribute djstripe . models . payment_methods . BankAccount . bank_name = models . CharField ( max_length = 255 , help_text = 'Name of the bank associated with the routing number (e.g., `WELLS FARGO`).' ) class-attribute djstripe . models . payment_methods . BankAccount . country = models . CharField ( max_length = 2 , help_text = 'Two-letter ISO code representing the country the bank account is located in.' ) class-attribute djstripe . models . payment_methods . BankAccount . currency = StripeCurrencyCodeField () class-attribute djstripe . models . payment_methods . BankAccount . customer = StripeForeignKey ( 'Customer' , on_delete = models . SET_NULL , null = True , related_name = 'bank_account' ) class-attribute djstripe . models . payment_methods . BankAccount . default_for_currency = models . BooleanField ( null = True , help_text = 'Whether this external account (BankAccount) is the default account for its currency.' ) class-attribute djstripe . models . payment_methods . BankAccount . fingerprint = models . CharField ( max_length = 16 , help_text = 'Uniquely identifies this particular bank account. You can use this attribute to check whether two bank accounts are the same.' ) class-attribute djstripe . models . payment_methods . BankAccount . human_readable_status property djstripe . models . payment_methods . BankAccount . last4 = models . CharField ( max_length = 4 ) class-attribute djstripe . models . payment_methods . BankAccount . routing_number = models . CharField ( max_length = 255 , help_text = 'The routing transit number for the bank account.' ) class-attribute djstripe . models . payment_methods . BankAccount . status = StripeEnumField ( enum = enums . BankAccountStatus ) class-attribute djstripe . models . payment_methods . BankAccount . stripe_class = stripe . BankAccount class-attribute Functions djstripe . models . payment_methods . BankAccount . __str__ () Source code in djstripe/models/payment_methods.py 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 def __str__ ( self ): default = False # prefer to show it by customer format if present if self . customer : default_source = self . customer . default_source default_payment_method = self . customer . default_payment_method if ( default_payment_method and self . id == default_payment_method . id ) or ( default_source and self . id == default_source . id ): # current card is the default payment method or source default = True customer_template = f \" { self . bank_name } { self . routing_number } ( { self . human_readable_status } ) { 'Default' if default else '' } { self . currency } \" return customer_template default = getattr ( self , \"default_for_currency\" , False ) account_template = f \" { self . bank_name } { self . currency } { 'Default' if default else '' } { self . routing_number } { self . last4 } \" return account_template djstripe . models . payment_methods . BankAccount . api_retrieve ( ** kwargs ) Source code in djstripe/models/payment_methods.py 452 453 454 455 456 457 458 459 460 def api_retrieve ( self , ** kwargs ): if not self . customer and not self . account : raise ImpossibleAPIRequest ( \"Can't retrieve a bank account without a customer or account object.\" \" This may happen if not all accounts or customer objects are in the db.\" ' Please run \"python manage.py djstripe_sync_models Account Customer\" as a potential fix.' ) return super () . api_retrieve ( ** kwargs ) djstripe.models.payment_methods.Card Bases: LegacySourceMixin , StripeModel You can store multiple cards on a customer in order to charge the customer later. This is a legacy model which only applies to the \"v2\" Stripe API (eg. Checkout.js). You should strive to use the Stripe \"v3\" API (eg. Stripe Elements). Also see: https://stripe.com/docs/stripe-js/elements/migrating When using Elements, you will not be using Card objects. Instead, you will use Source objects. A Source object of type \"card\" is equivalent to a Card object. However, Card objects cannot be converted into Source objects by Stripe at this time. Stripe documentation: https://stripe.com/docs/api?lang=python#cards Source code in djstripe/models/payment_methods.py 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 class Card ( LegacySourceMixin , StripeModel ): \"\"\" You can store multiple cards on a customer in order to charge the customer later. This is a legacy model which only applies to the \"v2\" Stripe API (eg. Checkout.js). You should strive to use the Stripe \"v3\" API (eg. Stripe Elements). Also see: https://stripe.com/docs/stripe-js/elements/migrating When using Elements, you will not be using Card objects. Instead, you will use Source objects. A Source object of type \"card\" is equivalent to a Card object. However, Card objects cannot be converted into Source objects by Stripe at this time. Stripe documentation: https://stripe.com/docs/api?lang=python#cards \"\"\" stripe_class = stripe . Card # Stripe Custom Connected Accounts can have cards as \"Payout Sources\" account = StripeForeignKey ( \"Account\" , on_delete = models . PROTECT , null = True , blank = True , related_name = \"cards\" , help_text = \"The external account the charge was made on behalf of. Null here indicates \" \"that this value was never set.\" , ) address_city = models . TextField ( max_length = 5000 , blank = True , default = \"\" , help_text = \"City/District/Suburb/Town/Village.\" , ) address_country = models . TextField ( max_length = 5000 , blank = True , default = \"\" , help_text = \"Billing address country.\" ) address_line1 = models . TextField ( max_length = 5000 , blank = True , default = \"\" , help_text = \"Street address/PO Box/Company name.\" , ) address_line1_check = StripeEnumField ( enum = enums . CardCheckResult , blank = True , default = \"\" , help_text = \"If `address_line1` was provided, results of the check.\" , ) address_line2 = models . TextField ( max_length = 5000 , blank = True , default = \"\" , help_text = \"Apartment/Suite/Unit/Building.\" , ) address_state = models . TextField ( max_length = 5000 , blank = True , default = \"\" , help_text = \"State/County/Province/Region.\" , ) address_zip = models . TextField ( max_length = 5000 , blank = True , default = \"\" , help_text = \"ZIP or postal code.\" ) address_zip_check = StripeEnumField ( enum = enums . CardCheckResult , blank = True , default = \"\" , help_text = \"If `address_zip` was provided, results of the check.\" , ) brand = StripeEnumField ( enum = enums . CardBrand , help_text = \"Card brand.\" ) country = models . CharField ( max_length = 2 , default = \"\" , blank = True , help_text = \"Two-letter ISO code representing the country of the card.\" , ) customer = StripeForeignKey ( \"Customer\" , on_delete = models . SET_NULL , null = True , related_name = \"legacy_cards\" ) cvc_check = StripeEnumField ( enum = enums . CardCheckResult , default = \"\" , blank = True , help_text = \"If a CVC was provided, results of the check.\" , ) default_for_currency = models . BooleanField ( null = True , help_text = \"Whether this external account (Card) is the default account for \" \"its currency.\" , ) dynamic_last4 = models . CharField ( max_length = 4 , default = \"\" , blank = True , help_text = \"(For tokenized numbers only.) The last four digits of the device \" \"account number.\" , ) exp_month = models . IntegerField ( help_text = \"Card expiration month.\" ) exp_year = models . IntegerField ( help_text = \"Card expiration year.\" ) fingerprint = models . CharField ( default = \"\" , blank = True , max_length = 16 , help_text = \"Uniquely identifies this particular card number.\" , ) funding = StripeEnumField ( enum = enums . CardFundingType , help_text = \"Card funding type.\" ) last4 = models . CharField ( max_length = 4 , help_text = \"Last four digits of Card number.\" ) name = models . TextField ( max_length = 5000 , default = \"\" , blank = True , help_text = \"Cardholder name.\" ) tokenization_method = StripeEnumField ( enum = enums . CardTokenizationMethod , default = \"\" , blank = True , help_text = \"If the card number is tokenized, this is the method that was used.\" , ) def __str__ ( self ): default = False # prefer to show it by customer format if present if self . customer : default_source = self . customer . default_source default_payment_method = self . customer . default_payment_method if ( default_payment_method and self . id == default_payment_method . id ) or ( default_source and self . id == default_source . id ): # current card is the default payment method or source default = True customer_template = f \" { enums . CardBrand . humanize ( self . brand ) } { self . last4 } { 'Default' if default else '' } Expires { self . exp_month } { self . exp_year } \" return customer_template elif self . account : default = getattr ( self , \"default_for_currency\" , False ) account_template = f \" { enums . CardBrand . humanize ( self . brand ) } { self . account . default_currency } { 'Default' if default else '' } { self . last4 } \" return account_template return self . id or \"\" @classmethod def create_token ( cls , number : str , exp_month : int , exp_year : int , cvc : str , api_key : str = djstripe_settings . STRIPE_SECRET_KEY , ** kwargs , ) -> stripe . Token : \"\"\" Creates a single use token that wraps the details of a credit card. This token can be used in place of a credit card dictionary with any API method. These tokens can only be used once: by creating a new charge object, or attaching them to a customer. (Source: https://stripe.com/docs/api?lang=python#create_card_token) :param number: The card number without any separators (no spaces) :param exp_month: The card's expiration month. (two digits) :param exp_year: The card's expiration year. (four digits) :param cvc: Card security code. :param api_key: The API key to use \"\"\" card = { \"number\" : number , \"exp_month\" : exp_month , \"exp_year\" : exp_year , \"cvc\" : cvc , } card . update ( kwargs ) return stripe . Token . create ( api_key = api_key , card = card ) Attributes djstripe . models . payment_methods . Card . account = StripeForeignKey ( 'Account' , on_delete = models . PROTECT , null = True , blank = True , related_name = 'cards' , help_text = 'The external account the charge was made on behalf of. Null here indicates that this value was never set.' ) class-attribute djstripe . models . payment_methods . Card . address_city = models . TextField ( max_length = 5000 , blank = True , default = '' , help_text = 'City/District/Suburb/Town/Village.' ) class-attribute djstripe . models . payment_methods . Card . address_country = models . TextField ( max_length = 5000 , blank = True , default = '' , help_text = 'Billing address country.' ) class-attribute djstripe . models . payment_methods . Card . address_line1 = models . TextField ( max_length = 5000 , blank = True , default = '' , help_text = 'Street address/PO Box/Company name.' ) class-attribute djstripe . models . payment_methods . Card . address_line1_check = StripeEnumField ( enum = enums . CardCheckResult , blank = True , default = '' , help_text = 'If `address_line1` was provided, results of the check.' ) class-attribute djstripe . models . payment_methods . Card . address_line2 = models . TextField ( max_length = 5000 , blank = True , default = '' , help_text = 'Apartment/Suite/Unit/Building.' ) class-attribute djstripe . models . payment_methods . Card . address_state = models . TextField ( max_length = 5000 , blank = True , default = '' , help_text = 'State/County/Province/Region.' ) class-attribute djstripe . models . payment_methods . Card . address_zip = models . TextField ( max_length = 5000 , blank = True , default = '' , help_text = 'ZIP or postal code.' ) class-attribute djstripe . models . payment_methods . Card . address_zip_check = StripeEnumField ( enum = enums . CardCheckResult , blank = True , default = '' , help_text = 'If `address_zip` was provided, results of the check.' ) class-attribute djstripe . models . payment_methods . Card . brand = StripeEnumField ( enum = enums . CardBrand , help_text = 'Card brand.' ) class-attribute djstripe . models . payment_methods . Card . country = models . CharField ( max_length = 2 , default = '' , blank = True , help_text = 'Two-letter ISO code representing the country of the card.' ) class-attribute djstripe . models . payment_methods . Card . customer = StripeForeignKey ( 'Customer' , on_delete = models . SET_NULL , null = True , related_name = 'legacy_cards' ) class-attribute djstripe . models . payment_methods . Card . cvc_check = StripeEnumField ( enum = enums . CardCheckResult , default = '' , blank = True , help_text = 'If a CVC was provided, results of the check.' ) class-attribute djstripe . models . payment_methods . Card . default_for_currency = models . BooleanField ( null = True , help_text = 'Whether this external account (Card) is the default account for its currency.' ) class-attribute djstripe . models . payment_methods . Card . dynamic_last4 = models . CharField ( max_length = 4 , default = '' , blank = True , help_text = '(For tokenized numbers only.) The last four digits of the device account number.' ) class-attribute djstripe . models . payment_methods . Card . exp_month = models . IntegerField ( help_text = 'Card expiration month.' ) class-attribute djstripe . models . payment_methods . Card . exp_year = models . IntegerField ( help_text = 'Card expiration year.' ) class-attribute djstripe . models . payment_methods . Card . fingerprint = models . CharField ( default = '' , blank = True , max_length = 16 , help_text = 'Uniquely identifies this particular card number.' ) class-attribute djstripe . models . payment_methods . Card . funding = StripeEnumField ( enum = enums . CardFundingType , help_text = 'Card funding type.' ) class-attribute djstripe . models . payment_methods . Card . last4 = models . CharField ( max_length = 4 , help_text = 'Last four digits of Card number.' ) class-attribute djstripe . models . payment_methods . Card . name = models . TextField ( max_length = 5000 , default = '' , blank = True , help_text = 'Cardholder name.' ) class-attribute djstripe . models . payment_methods . Card . stripe_class = stripe . Card class-attribute djstripe . models . payment_methods . Card . tokenization_method = StripeEnumField ( enum = enums . CardTokenizationMethod , default = '' , blank = True , help_text = 'If the card number is tokenized, this is the method that was used.' ) class-attribute Functions djstripe . models . payment_methods . Card . __str__ () Source code in djstripe/models/payment_methods.py 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 def __str__ ( self ): default = False # prefer to show it by customer format if present if self . customer : default_source = self . customer . default_source default_payment_method = self . customer . default_payment_method if ( default_payment_method and self . id == default_payment_method . id ) or ( default_source and self . id == default_source . id ): # current card is the default payment method or source default = True customer_template = f \" { enums . CardBrand . humanize ( self . brand ) } { self . last4 } { 'Default' if default else '' } Expires { self . exp_month } { self . exp_year } \" return customer_template elif self . account : default = getattr ( self , \"default_for_currency\" , False ) account_template = f \" { enums . CardBrand . humanize ( self . brand ) } { self . account . default_currency } { 'Default' if default else '' } { self . last4 } \" return account_template return self . id or \"\" djstripe . models . payment_methods . Card . create_token ( number , exp_month , exp_year , cvc , api_key = djstripe_settings . STRIPE_SECRET_KEY , ** kwargs ) classmethod Creates a single use token that wraps the details of a credit card. This token can be used in place of a credit card dictionary with any API method. These tokens can only be used once: by creating a new charge object, or attaching them to a customer. (Source: https://stripe.com/docs/api?lang=python#create_card_token) :param number: The card number without any separators (no spaces) :param exp_month: The card's expiration month. (two digits) :param exp_year: The card's expiration year. (four digits) :param cvc: Card security code. :param api_key: The API key to use Source code in djstripe/models/payment_methods.py 604 605 606 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 @classmethod def create_token ( cls , number : str , exp_month : int , exp_year : int , cvc : str , api_key : str = djstripe_settings . STRIPE_SECRET_KEY , ** kwargs , ) -> stripe . Token : \"\"\" Creates a single use token that wraps the details of a credit card. This token can be used in place of a credit card dictionary with any API method. These tokens can only be used once: by creating a new charge object, or attaching them to a customer. (Source: https://stripe.com/docs/api?lang=python#create_card_token) :param number: The card number without any separators (no spaces) :param exp_month: The card's expiration month. (two digits) :param exp_year: The card's expiration year. (four digits) :param cvc: Card security code. :param api_key: The API key to use \"\"\" card = { \"number\" : number , \"exp_month\" : exp_month , \"exp_year\" : exp_year , \"cvc\" : cvc , } card . update ( kwargs ) return stripe . Token . create ( api_key = api_key , card = card ) djstripe.models.payment_methods.PaymentMethod Bases: StripeModel PaymentMethod objects represent your customer's payment instruments. You can use them with PaymentIntents to collect payments or save them to Customer objects to store instrument details for future payments. Stripe documentation: https://stripe.com/docs/api?lang=python#payment_methods Source code in djstripe/models/payment_methods.py 797 798 799 800 801 802 803 804 805 806 807 808 809 810 811 812 813 814 815 816 817 818 819 820 821 822 823 824 825 826 827 828 829 830 831 832 833 834 835 836 837 838 839 840 841 842 843 844 845 846 847 848 849 850 851 852 853 854 855 856 857 858 859 860 861 862 863 864 865 866 867 868 869 870 871 872 873 874 875 876 877 878 879 880 881 882 883 884 885 886 887 888 889 890 891 892 893 894 895 896 897 898 899 900 901 902 903 904 905 906 907 908 909 910 911 912 913 914 915 916 917 918 919 920 921 922 923 924 925 926 927 928 929 930 931 932 933 934 935 936 937 938 939 940 941 942 943 944 945 946 947 948 949 950 951 952 953 954 955 956 957 958 959 960 961 962 963 964 965 966 967 968 969 970 971 972 973 974 975 976 977 978 979 980 981 982 983 984 985 986 987 988 989 990 991 992 993 994 995 996 997 998 999 1000 1001 1002 1003 1004 1005 1006 1007 1008 1009 1010 1011 1012 1013 1014 1015 1016 1017 1018 1019 1020 1021 1022 1023 1024 1025 1026 1027 1028 1029 1030 1031 1032 1033 1034 1035 1036 1037 1038 1039 1040 1041 1042 1043 1044 1045 1046 1047 1048 1049 1050 1051 1052 1053 1054 1055 1056 1057 1058 1059 1060 1061 1062 1063 1064 1065 1066 1067 1068 1069 1070 1071 1072 1073 1074 1075 1076 1077 1078 class PaymentMethod ( StripeModel ): \"\"\" PaymentMethod objects represent your customer's payment instruments. You can use them with PaymentIntents to collect payments or save them to Customer objects to store instrument details for future payments. Stripe documentation: https://stripe.com/docs/api?lang=python#payment_methods \"\"\" stripe_class = stripe . PaymentMethod description = None billing_details = JSONField ( help_text = ( \"Billing information associated with the PaymentMethod that may be used or \" \"required by particular types of payment methods.\" ) ) customer = StripeForeignKey ( \"Customer\" , on_delete = models . SET_NULL , null = True , blank = True , related_name = \"payment_methods\" , help_text = ( \"Customer to which this PaymentMethod is saved. \" \"This will not be set when the PaymentMethod has \" \"not been saved to a Customer.\" ), ) type = StripeEnumField ( enum = enums . PaymentMethodType , help_text = \"The type of the PaymentMethod.\" , ) acss_debit = JSONField ( null = True , blank = True , help_text = \"Additional information for payment methods of type `acss_debit`\" , ) affirm = JSONField ( null = True , blank = True , help_text = \"Additional information for payment methods of type `affirm`\" , ) afterpay_clearpay = JSONField ( null = True , blank = True , help_text = \"Additional information for payment methods of type `afterpay_clearpay`\" , ) alipay = JSONField ( null = True , blank = True , help_text = \"Additional information for payment methods of type `alipay`\" , ) au_becs_debit = JSONField ( null = True , blank = True , help_text = \"Additional information for payment methods of type `au_becs_debit`\" , ) bacs_debit = JSONField ( null = True , blank = True , help_text = \"Additional information for payment methods of type `bacs_debit`\" , ) bancontact = JSONField ( null = True , blank = True , help_text = \"Additional information for payment methods of type `bancontact`\" , ) blik = JSONField ( null = True , blank = True , help_text = \"Additional information for payment methods of type `blik`\" , ) boleto = JSONField ( null = True , blank = True , help_text = \"Additional information for payment methods of type `boleto`\" , ) card = JSONField ( null = True , blank = True , help_text = \"Additional information for payment methods of type `card`\" , ) card_present = JSONField ( null = True , blank = True , help_text = \"Additional information for payment methods of type `card_present`\" , ) customer_balance = JSONField ( null = True , blank = True , help_text = \"Additional information for payment methods of type `customer_balance`\" , ) eps = JSONField ( null = True , blank = True , help_text = \"Additional information for payment methods of type `eps`\" , ) fpx = JSONField ( null = True , blank = True , help_text = \"Additional information for payment methods of type `fpx`\" , ) giropay = JSONField ( null = True , blank = True , help_text = \"Additional information for payment methods of type `giropay`\" , ) grabpay = JSONField ( null = True , blank = True , help_text = \"Additional information for payment methods of type `grabpay`\" , ) ideal = JSONField ( null = True , blank = True , help_text = \"Additional information for payment methods of type `ideal`\" , ) interac_present = JSONField ( null = True , blank = True , help_text = ( \"Additional information for payment methods of type `interac_present`\" ), ) klarna = JSONField ( null = True , blank = True , help_text = \"Additional information for payment methods of type `klarna`\" , ) konbini = JSONField ( null = True , blank = True , help_text = \"Additional information for payment methods of type `konbini`\" , ) link = JSONField ( null = True , blank = True , help_text = \"Additional information for payment methods of type `link`\" , ) oxxo = JSONField ( null = True , blank = True , help_text = \"Additional information for payment methods of type `oxxo`\" , ) p24 = JSONField ( null = True , blank = True , help_text = \"Additional information for payment methods of type `p24`\" , ) paynow = JSONField ( null = True , blank = True , help_text = \"Additional information for payment methods of type `paynow`\" , ) pix = JSONField ( null = True , blank = True , help_text = \"Additional information for payment methods of type `pix`\" , ) promptpay = JSONField ( null = True , blank = True , help_text = \"Additional information for payment methods of type `promptpay`\" , ) sepa_debit = JSONField ( null = True , blank = True , help_text = \"Additional information for payment methods of type `sepa_debit`\" , ) sofort = JSONField ( null = True , blank = True , help_text = \"Additional information for payment methods of type `sofort`\" , ) us_bank_account = JSONField ( null = True , blank = True , help_text = \"Additional information for payment methods of type `us_bank_account`\" , ) wechat_pay = JSONField ( null = True , blank = True , help_text = \"Additional information for payment methods of type `wechat_pay`\" , ) def __str__ ( self ): if self . customer : return f \" { enums . PaymentMethodType . humanize ( self . type ) } for { self . customer } \" return f \" { enums . PaymentMethodType . humanize ( self . type ) } is not associated with any customer\" def get_stripe_dashboard_url ( self ) -> str : if self . customer : return self . customer . get_stripe_dashboard_url () return \"\" def _attach_objects_hook ( self , cls , data , api_key = djstripe_settings . STRIPE_SECRET_KEY , current_ids = None ): customer = None # \"customer\" key could be like \"cus_6lsBvm5rJ0zyHc\" or {\"id\": \"cus_6lsBvm5rJ0zyHc\"} customer_id = get_id_from_stripe_data ( data . get ( \"customer\" )) if current_ids is None or customer_id not in current_ids : customer = cls . _stripe_object_to_customer ( target_cls = Customer , data = data , current_ids = current_ids , api_key = api_key ) if customer : self . customer = customer else : self . customer = None @classmethod def attach ( cls , payment_method : Union [ str , \"PaymentMethod\" ], customer : Union [ str , Customer ], api_key : str = djstripe_settings . STRIPE_SECRET_KEY , ) -> \"PaymentMethod\" : \"\"\" Attach a payment method to a customer \"\"\" if isinstance ( payment_method , StripeModel ): payment_method = payment_method . id if isinstance ( customer , StripeModel ): customer = customer . id extra_kwargs = {} if not isinstance ( payment_method , stripe . PaymentMethod ): # send api_key if we're not passing in a Stripe object # avoids \"Received unknown parameter: api_key\" since api uses the # key cached in the Stripe object extra_kwargs = { \"api_key\" : api_key } stripe_payment_method = stripe . PaymentMethod . attach ( payment_method , customer = customer , ** extra_kwargs ) return cls . sync_from_stripe_data ( stripe_payment_method , api_key = api_key ) def detach ( self ): \"\"\" Detach the payment method from its customer. :return: Returns true if the payment method was newly detached, \\ false if it was already detached :rtype: bool \"\"\" # Find customers that use this customers = Customer . objects . filter ( default_payment_method = self ) . all () changed = True # special handling is needed for legacy \"card\"-type PaymentMethods, # since detaching them deletes them within Stripe. # see https://github.com/dj-stripe/dj-stripe/pull/967 is_legacy_card = self . id . startswith ( \"card_\" ) try : self . sync_from_stripe_data ( self . api_retrieve () . detach ()) # resync customer to update .default_payment_method and # .invoice_settings.default_payment_method for customer in customers : Customer . sync_from_stripe_data ( customer . api_retrieve ()) except ( InvalidRequestError ,): # The source was already detached. Resyncing. if self . pk and not is_legacy_card : self . sync_from_stripe_data ( self . api_retrieve ()) changed = False if self . pk : if is_legacy_card : self . delete () else : self . refresh_from_db () return changed Attributes djstripe . models . payment_methods . PaymentMethod . acss_debit = JSONField ( null = True , blank = True , help_text = 'Additional information for payment methods of type `acss_debit`' ) class-attribute djstripe . models . payment_methods . PaymentMethod . affirm = JSONField ( null = True , blank = True , help_text = 'Additional information for payment methods of type `affirm`' ) class-attribute djstripe . models . payment_methods . PaymentMethod . afterpay_clearpay = JSONField ( null = True , blank = True , help_text = 'Additional information for payment methods of type `afterpay_clearpay`' ) class-attribute djstripe . models . payment_methods . PaymentMethod . alipay = JSONField ( null = True , blank = True , help_text = 'Additional information for payment methods of type `alipay`' ) class-attribute djstripe . models . payment_methods . PaymentMethod . au_becs_debit = JSONField ( null = True , blank = True , help_text = 'Additional information for payment methods of type `au_becs_debit`' ) class-attribute djstripe . models . payment_methods . PaymentMethod . bacs_debit = JSONField ( null = True , blank = True , help_text = 'Additional information for payment methods of type `bacs_debit`' ) class-attribute djstripe . models . payment_methods . PaymentMethod . bancontact = JSONField ( null = True , blank = True , help_text = 'Additional information for payment methods of type `bancontact`' ) class-attribute djstripe . models . payment_methods . PaymentMethod . billing_details = JSONField ( help_text = 'Billing information associated with the PaymentMethod that may be used or required by particular types of payment methods.' ) class-attribute djstripe . models . payment_methods . PaymentMethod . blik = JSONField ( null = True , blank = True , help_text = 'Additional information for payment methods of type `blik`' ) class-attribute djstripe . models . payment_methods . PaymentMethod . boleto = JSONField ( null = True , blank = True , help_text = 'Additional information for payment methods of type `boleto`' ) class-attribute djstripe . models . payment_methods . PaymentMethod . card = JSONField ( null = True , blank = True , help_text = 'Additional information for payment methods of type `card`' ) class-attribute djstripe . models . payment_methods . PaymentMethod . card_present = JSONField ( null = True , blank = True , help_text = 'Additional information for payment methods of type `card_present`' ) class-attribute djstripe . models . payment_methods . PaymentMethod . customer = StripeForeignKey ( 'Customer' , on_delete = models . SET_NULL , null = True , blank = True , related_name = 'payment_methods' , help_text = 'Customer to which this PaymentMethod is saved. This will not be set when the PaymentMethod has not been saved to a Customer.' ) class-attribute djstripe . models . payment_methods . PaymentMethod . customer_balance = JSONField ( null = True , blank = True , help_text = 'Additional information for payment methods of type `customer_balance`' ) class-attribute djstripe . models . payment_methods . PaymentMethod . description = None class-attribute djstripe . models . payment_methods . PaymentMethod . eps = JSONField ( null = True , blank = True , help_text = 'Additional information for payment methods of type `eps`' ) class-attribute djstripe . models . payment_methods . PaymentMethod . fpx = JSONField ( null = True , blank = True , help_text = 'Additional information for payment methods of type `fpx`' ) class-attribute djstripe . models . payment_methods . PaymentMethod . giropay = JSONField ( null = True , blank = True , help_text = 'Additional information for payment methods of type `giropay`' ) class-attribute djstripe . models . payment_methods . PaymentMethod . grabpay = JSONField ( null = True , blank = True , help_text = 'Additional information for payment methods of type `grabpay`' ) class-attribute djstripe . models . payment_methods . PaymentMethod . ideal = JSONField ( null = True , blank = True , help_text = 'Additional information for payment methods of type `ideal`' ) class-attribute djstripe . models . payment_methods . PaymentMethod . interac_present = JSONField ( null = True , blank = True , help_text = 'Additional information for payment methods of type `interac_present`' ) class-attribute djstripe . models . payment_methods . PaymentMethod . klarna = JSONField ( null = True , blank = True , help_text = 'Additional information for payment methods of type `klarna`' ) class-attribute djstripe . models . payment_methods . PaymentMethod . konbini = JSONField ( null = True , blank = True , help_text = 'Additional information for payment methods of type `konbini`' ) class-attribute djstripe . models . payment_methods . PaymentMethod . link = JSONField ( null = True , blank = True , help_text = 'Additional information for payment methods of type `link`' ) class-attribute djstripe . models . payment_methods . PaymentMethod . oxxo = JSONField ( null = True , blank = True , help_text = 'Additional information for payment methods of type `oxxo`' ) class-attribute djstripe . models . payment_methods . PaymentMethod . p24 = JSONField ( null = True , blank = True , help_text = 'Additional information for payment methods of type `p24`' ) class-attribute djstripe . models . payment_methods . PaymentMethod . paynow = JSONField ( null = True , blank = True , help_text = 'Additional information for payment methods of type `paynow`' ) class-attribute djstripe . models . payment_methods . PaymentMethod . pix = JSONField ( null = True , blank = True , help_text = 'Additional information for payment methods of type `pix`' ) class-attribute djstripe . models . payment_methods . PaymentMethod . promptpay = JSONField ( null = True , blank = True , help_text = 'Additional information for payment methods of type `promptpay`' ) class-attribute djstripe . models . payment_methods . PaymentMethod . sepa_debit = JSONField ( null = True , blank = True , help_text = 'Additional information for payment methods of type `sepa_debit`' ) class-attribute djstripe . models . payment_methods . PaymentMethod . sofort = JSONField ( null = True , blank = True , help_text = 'Additional information for payment methods of type `sofort`' ) class-attribute djstripe . models . payment_methods . PaymentMethod . stripe_class = stripe . PaymentMethod class-attribute djstripe . models . payment_methods . PaymentMethod . type = StripeEnumField ( enum = enums . PaymentMethodType , help_text = 'The type of the PaymentMethod.' ) class-attribute djstripe . models . payment_methods . PaymentMethod . us_bank_account = JSONField ( null = True , blank = True , help_text = 'Additional information for payment methods of type `us_bank_account`' ) class-attribute djstripe . models . payment_methods . PaymentMethod . wechat_pay = JSONField ( null = True , blank = True , help_text = 'Additional information for payment methods of type `wechat_pay`' ) class-attribute Functions djstripe . models . payment_methods . PaymentMethod . __str__ () Source code in djstripe/models/payment_methods.py 984 985 986 987 def __str__ ( self ): if self . customer : return f \" { enums . PaymentMethodType . humanize ( self . type ) } for { self . customer } \" return f \" { enums . PaymentMethodType . humanize ( self . type ) } is not associated with any customer\" djstripe . models . payment_methods . PaymentMethod . _attach_objects_hook ( cls , data , api_key = djstripe_settings . STRIPE_SECRET_KEY , current_ids = None ) Source code in djstripe/models/payment_methods.py 994 995 996 997 998 999 1000 1001 1002 1003 1004 1005 1006 1007 1008 1009 def _attach_objects_hook ( self , cls , data , api_key = djstripe_settings . STRIPE_SECRET_KEY , current_ids = None ): customer = None # \"customer\" key could be like \"cus_6lsBvm5rJ0zyHc\" or {\"id\": \"cus_6lsBvm5rJ0zyHc\"} customer_id = get_id_from_stripe_data ( data . get ( \"customer\" )) if current_ids is None or customer_id not in current_ids : customer = cls . _stripe_object_to_customer ( target_cls = Customer , data = data , current_ids = current_ids , api_key = api_key ) if customer : self . customer = customer else : self . customer = None djstripe . models . payment_methods . PaymentMethod . attach ( payment_method , customer , api_key = djstripe_settings . STRIPE_SECRET_KEY ) classmethod Attach a payment method to a customer Source code in djstripe/models/payment_methods.py 1011 1012 1013 1014 1015 1016 1017 1018 1019 1020 1021 1022 1023 1024 1025 1026 1027 1028 1029 1030 1031 1032 1033 1034 1035 1036 1037 1038 @classmethod def attach ( cls , payment_method : Union [ str , \"PaymentMethod\" ], customer : Union [ str , Customer ], api_key : str = djstripe_settings . STRIPE_SECRET_KEY , ) -> \"PaymentMethod\" : \"\"\" Attach a payment method to a customer \"\"\" if isinstance ( payment_method , StripeModel ): payment_method = payment_method . id if isinstance ( customer , StripeModel ): customer = customer . id extra_kwargs = {} if not isinstance ( payment_method , stripe . PaymentMethod ): # send api_key if we're not passing in a Stripe object # avoids \"Received unknown parameter: api_key\" since api uses the # key cached in the Stripe object extra_kwargs = { \"api_key\" : api_key } stripe_payment_method = stripe . PaymentMethod . attach ( payment_method , customer = customer , ** extra_kwargs ) return cls . sync_from_stripe_data ( stripe_payment_method , api_key = api_key ) djstripe . models . payment_methods . PaymentMethod . detach () Detach the payment method from its customer. :return: Returns true if the payment method was newly detached, false if it was already detached :rtype: bool Source code in djstripe/models/payment_methods.py 1040 1041 1042 1043 1044 1045 1046 1047 1048 1049 1050 1051 1052 1053 1054 1055 1056 1057 1058 1059 1060 1061 1062 1063 1064 1065 1066 1067 1068 1069 1070 1071 1072 1073 1074 1075 1076 1077 1078 def detach ( self ): \"\"\" Detach the payment method from its customer. :return: Returns true if the payment method was newly detached, \\ false if it was already detached :rtype: bool \"\"\" # Find customers that use this customers = Customer . objects . filter ( default_payment_method = self ) . all () changed = True # special handling is needed for legacy \"card\"-type PaymentMethods, # since detaching them deletes them within Stripe. # see https://github.com/dj-stripe/dj-stripe/pull/967 is_legacy_card = self . id . startswith ( \"card_\" ) try : self . sync_from_stripe_data ( self . api_retrieve () . detach ()) # resync customer to update .default_payment_method and # .invoice_settings.default_payment_method for customer in customers : Customer . sync_from_stripe_data ( customer . api_retrieve ()) except ( InvalidRequestError ,): # The source was already detached. Resyncing. if self . pk and not is_legacy_card : self . sync_from_stripe_data ( self . api_retrieve ()) changed = False if self . pk : if is_legacy_card : self . delete () else : self . refresh_from_db () return changed djstripe . models . payment_methods . PaymentMethod . get_stripe_dashboard_url () Source code in djstripe/models/payment_methods.py 989 990 991 992 def get_stripe_dashboard_url ( self ) -> str : if self . customer : return self . customer . get_stripe_dashboard_url () return \"\" djstripe.models.payment_methods.Source Bases: StripeModel Source objects allow you to accept a variety of payment methods. They represent a customer's payment instrument, and can be used with the Stripe API just like a Card object: once chargeable, they can be charged, or can be attached to customers. Stripe documentation: https://stripe.com/docs/api?lang=python#sources Source code in djstripe/models/payment_methods.py 639 640 641 642 643 644 645 646 647 648 649 650 651 652 653 654 655 656 657 658 659 660 661 662 663 664 665 666 667 668 669 670 671 672 673 674 675 676 677 678 679 680 681 682 683 684 685 686 687 688 689 690 691 692 693 694 695 696 697 698 699 700 701 702 703 704 705 706 707 708 709 710 711 712 713 714 715 716 717 718 719 720 721 722 723 724 725 726 727 728 729 730 731 732 733 734 735 736 737 738 739 740 741 742 743 744 745 746 747 748 749 750 751 752 753 754 755 756 757 758 759 760 761 762 763 764 765 766 767 768 769 770 771 772 773 774 775 776 777 778 779 780 781 782 783 784 785 786 787 788 789 790 791 792 793 794 class Source ( StripeModel ): \"\"\" Source objects allow you to accept a variety of payment methods. They represent a customer's payment instrument, and can be used with the Stripe API just like a Card object: once chargeable, they can be charged, or can be attached to customers. Stripe documentation: https://stripe.com/docs/api?lang=python#sources \"\"\" amount = StripeDecimalCurrencyAmountField ( null = True , blank = True , help_text = ( \"Amount (as decimal) associated with the source. \" \"This is the amount for which the source will be chargeable once ready. \" \"Required for `single_use` sources.\" ), ) client_secret = models . CharField ( max_length = 255 , help_text = ( \"The client secret of the source. \" \"Used for client-side retrieval using a publishable key.\" ), ) currency = StripeCurrencyCodeField ( default = \"\" , blank = True ) flow = StripeEnumField ( enum = enums . SourceFlow , help_text = \"The authentication flow of the source.\" ) owner = JSONField ( help_text = ( \"Information about the owner of the payment instrument that may be \" \"used or required by particular source types.\" ) ) statement_descriptor = models . CharField ( max_length = 255 , default = \"\" , blank = True , help_text = \"Extra information about a source. This will appear on your \" \"customer's statement every time you charge the source.\" , ) status = StripeEnumField ( enum = enums . SourceStatus , help_text = \"The status of the source. Only `chargeable` sources can be used \" \"to create a charge.\" , ) type = StripeEnumField ( enum = enums . SourceType , help_text = \"The type of the source.\" ) usage = StripeEnumField ( enum = enums . SourceUsage , help_text = \"Whether this source should be reusable or not. \" \"Some source types may or may not be reusable by construction, \" \"while other may leave the option at creation.\" , ) # Flows code_verification = JSONField ( null = True , blank = True , help_text = \"Information related to the code verification flow. \" \"Present if the source is authenticated by a verification code \" \"(`flow` is `code_verification`).\" , ) receiver = JSONField ( null = True , blank = True , help_text = \"Information related to the receiver flow. \" \"Present if the source is a receiver (`flow` is `receiver`).\" , ) redirect = JSONField ( null = True , blank = True , help_text = \"Information related to the redirect flow. \" \"Present if the source is authenticated by a redirect (`flow` is `redirect`).\" , ) source_data = JSONField ( help_text = \"The data corresponding to the source type.\" ) customer = StripeForeignKey ( \"Customer\" , on_delete = models . SET_NULL , null = True , blank = True , related_name = \"sources\" , ) stripe_class = stripe . Source stripe_dashboard_item_name = \"sources\" def __str__ ( self ): return f \" { self . type } { self . id } \" @classmethod def _manipulate_stripe_object_hook ( cls , data ): # The source_data dict is an alias of all the source types data [ \"source_data\" ] = data [ data [ \"type\" ]] return data def _attach_objects_hook ( self , cls , data , api_key = djstripe_settings . STRIPE_SECRET_KEY , current_ids = None ): customer = None # \"customer\" key could be like \"cus_6lsBvm5rJ0zyHc\" or {\"id\": \"cus_6lsBvm5rJ0zyHc\"} customer_id = get_id_from_stripe_data ( data . get ( \"customer\" )) if current_ids is None or customer_id not in current_ids : customer = cls . _stripe_object_to_customer ( target_cls = Customer , data = data , current_ids = current_ids , api_key = api_key ) if customer : self . customer = customer else : self . customer = None def detach ( self ) -> bool : \"\"\" Detach the source from its customer. \"\"\" # First, wipe default source on all customers that use this. Customer . objects . filter ( default_source = self . id ) . update ( default_source = None ) api_key = self . default_api_key try : # TODO - we could use the return value of sync_from_stripe_data # or call its internals - self._sync/_attach_objects_hook etc here # to update `self` at this point? self . sync_from_stripe_data ( self . api_retrieve ( api_key = api_key ) . detach (), api_key = api_key ) return True except InvalidRequestError : # The source was already detached. Resyncing. self . sync_from_stripe_data ( self . api_retrieve ( api_key = self . default_api_key ), api_key = self . default_api_key , ) return False @classmethod def api_list ( cls , api_key = djstripe_settings . STRIPE_SECRET_KEY , ** kwargs ): \"\"\" Call the stripe API's list operation for this model. :param api_key: The api key to use for this request. \\ Defaults to djstripe_settings.STRIPE_SECRET_KEY. :type api_key: string See Stripe documentation for accepted kwargs for each object. :returns: an iterator over all items in the query \"\"\" return Customer . stripe_class . list_sources ( object = \"source\" , api_key = api_key , stripe_version = djstripe_settings . STRIPE_API_VERSION , ** kwargs , ) . auto_paging_iter () Attributes djstripe . models . payment_methods . Source . amount = StripeDecimalCurrencyAmountField ( null = True , blank = True , help_text = 'Amount (as decimal) associated with the source. This is the amount for which the source will be chargeable once ready. Required for `single_use` sources.' ) class-attribute djstripe . models . payment_methods . Source . client_secret = models . CharField ( max_length = 255 , help_text = 'The client secret of the source. Used for client-side retrieval using a publishable key.' ) class-attribute djstripe . models . payment_methods . Source . code_verification = JSONField ( null = True , blank = True , help_text = 'Information related to the code verification flow. Present if the source is authenticated by a verification code (`flow` is `code_verification`).' ) class-attribute djstripe . models . payment_methods . Source . currency = StripeCurrencyCodeField ( default = '' , blank = True ) class-attribute djstripe . models . payment_methods . Source . customer = StripeForeignKey ( 'Customer' , on_delete = models . SET_NULL , null = True , blank = True , related_name = 'sources' ) class-attribute djstripe . models . payment_methods . Source . flow = StripeEnumField ( enum = enums . SourceFlow , help_text = 'The authentication flow of the source.' ) class-attribute djstripe . models . payment_methods . Source . owner = JSONField ( help_text = 'Information about the owner of the payment instrument that may be used or required by particular source types.' ) class-attribute djstripe . models . payment_methods . Source . receiver = JSONField ( null = True , blank = True , help_text = 'Information related to the receiver flow. Present if the source is a receiver (`flow` is `receiver`).' ) class-attribute djstripe . models . payment_methods . Source . redirect = JSONField ( null = True , blank = True , help_text = 'Information related to the redirect flow. Present if the source is authenticated by a redirect (`flow` is `redirect`).' ) class-attribute djstripe . models . payment_methods . Source . source_data = JSONField ( help_text = 'The data corresponding to the source type.' ) class-attribute djstripe . models . payment_methods . Source . statement_descriptor = models . CharField ( max_length = 255 , default = '' , blank = True , help_text = \"Extra information about a source. This will appear on your customer's statement every time you charge the source.\" ) class-attribute djstripe . models . payment_methods . Source . status = StripeEnumField ( enum = enums . SourceStatus , help_text = 'The status of the source. Only `chargeable` sources can be used to create a charge.' ) class-attribute djstripe . models . payment_methods . Source . stripe_class = stripe . Source class-attribute djstripe . models . payment_methods . Source . stripe_dashboard_item_name = 'sources' class-attribute djstripe . models . payment_methods . Source . type = StripeEnumField ( enum = enums . SourceType , help_text = 'The type of the source.' ) class-attribute djstripe . models . payment_methods . Source . usage = StripeEnumField ( enum = enums . SourceUsage , help_text = 'Whether this source should be reusable or not. Some source types may or may not be reusable by construction, while other may leave the option at creation.' ) class-attribute Functions djstripe . models . payment_methods . Source . __str__ () Source code in djstripe/models/payment_methods.py 729 730 def __str__ ( self ): return f \" { self . type } { self . id } \" djstripe . models . payment_methods . Source . _attach_objects_hook ( cls , data , api_key = djstripe_settings . STRIPE_SECRET_KEY , current_ids = None ) Source code in djstripe/models/payment_methods.py 738 739 740 741 742 743 744 745 746 747 748 749 750 751 752 753 def _attach_objects_hook ( self , cls , data , api_key = djstripe_settings . STRIPE_SECRET_KEY , current_ids = None ): customer = None # \"customer\" key could be like \"cus_6lsBvm5rJ0zyHc\" or {\"id\": \"cus_6lsBvm5rJ0zyHc\"} customer_id = get_id_from_stripe_data ( data . get ( \"customer\" )) if current_ids is None or customer_id not in current_ids : customer = cls . _stripe_object_to_customer ( target_cls = Customer , data = data , current_ids = current_ids , api_key = api_key ) if customer : self . customer = customer else : self . customer = None djstripe . models . payment_methods . Source . _manipulate_stripe_object_hook ( data ) classmethod Source code in djstripe/models/payment_methods.py 732 733 734 735 736 @classmethod def _manipulate_stripe_object_hook ( cls , data ): # The source_data dict is an alias of all the source types data [ \"source_data\" ] = data [ data [ \"type\" ]] return data djstripe . models . payment_methods . Source . api_list ( api_key = djstripe_settings . STRIPE_SECRET_KEY , ** kwargs ) classmethod Call the stripe API's list operation for this model. :param api_key: The api key to use for this request. Defaults to djstripe_settings.STRIPE_SECRET_KEY. :type api_key: string See Stripe documentation for accepted kwargs for each object. :returns: an iterator over all items in the query Source code in djstripe/models/payment_methods.py 779 780 781 782 783 784 785 786 787 788 789 790 791 792 793 794 @classmethod def api_list ( cls , api_key = djstripe_settings . STRIPE_SECRET_KEY , ** kwargs ): \"\"\" Call the stripe API's list operation for this model. :param api_key: The api key to use for this request. \\ Defaults to djstripe_settings.STRIPE_SECRET_KEY. :type api_key: string See Stripe documentation for accepted kwargs for each object. :returns: an iterator over all items in the query \"\"\" return Customer . stripe_class . list_sources ( object = \"source\" , api_key = api_key , stripe_version = djstripe_settings . STRIPE_API_VERSION , ** kwargs , ) . auto_paging_iter () djstripe . models . payment_methods . Source . detach () Detach the source from its customer. Source code in djstripe/models/payment_methods.py 755 756 757 758 759 760 761 762 763 764 765 766 767 768 769 770 771 772 773 774 775 776 777 def detach ( self ) -> bool : \"\"\" Detach the source from its customer. \"\"\" # First, wipe default source on all customers that use this. Customer . objects . filter ( default_source = self . id ) . update ( default_source = None ) api_key = self . default_api_key try : # TODO - we could use the return value of sync_from_stripe_data # or call its internals - self._sync/_attach_objects_hook etc here # to update `self` at this point? self . sync_from_stripe_data ( self . api_retrieve ( api_key = api_key ) . detach (), api_key = api_key ) return True except InvalidRequestError : # The source was already detached. Resyncing. self . sync_from_stripe_data ( self . api_retrieve ( api_key = self . default_api_key ), api_key = self . default_api_key , ) return False Functions Billing Attributes djstripe . models . billing . logger = logging . getLogger ( __name__ ) module-attribute Classes djstripe.models.billing.Coupon Bases: StripeModel A coupon contains information about a percent-off or amount-off discount you might want to apply to a customer. Coupons may be applied to invoices or orders. Coupons do not work with conventional one-off charges. Stripe documentation: https://stripe.com/docs/api/coupons?lang=python Source code in djstripe/models/billing.py 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 class Coupon ( StripeModel ): \"\"\" A coupon contains information about a percent-off or amount-off discount you might want to apply to a customer. Coupons may be applied to invoices or orders. Coupons do not work with conventional one-off charges. Stripe documentation: https://stripe.com/docs/api/coupons?lang=python \"\"\" stripe_class = stripe . Coupon expand_fields = [ \"applies_to\" ] stripe_dashboard_item_name = \"coupons\" id = StripeIdField ( max_length = 500 ) applies_to = JSONField ( null = True , blank = True , help_text = \"Contains information about what this coupon applies to.\" , ) amount_off = StripeDecimalCurrencyAmountField ( null = True , blank = True , help_text = \"Amount (as decimal) that will be taken off the subtotal of any \" \"invoices for this customer.\" , ) currency = StripeCurrencyCodeField ( null = True , blank = True ) duration = StripeEnumField ( enum = enums . CouponDuration , help_text = ( \"Describes how long a customer who applies this coupon \" \"will get the discount.\" ), default = enums . CouponDuration . once , ) duration_in_months = models . PositiveIntegerField ( null = True , blank = True , help_text = \"If `duration` is `repeating`, the number of months \" \"the coupon applies.\" , ) max_redemptions = models . PositiveIntegerField ( null = True , blank = True , help_text = \"Maximum number of times this coupon can be redeemed, in total, \" \"before it is no longer valid.\" , ) name = models . TextField ( max_length = 5000 , default = \"\" , blank = True , help_text = ( \"Name of the coupon displayed to customers on for instance invoices \" \"or receipts.\" ), ) percent_off = StripePercentField ( null = True , blank = True , help_text = ( \"Percent that will be taken off the subtotal of any invoices for \" \"this customer for the duration of the coupon. \" \"For example, a coupon with percent_off of 50 will make a \" \"$100 invoice $50 instead.\" ), ) redeem_by = StripeDateTimeField ( null = True , blank = True , help_text = \"Date after which the coupon can no longer be redeemed. \" \"Max 5 years in the future.\" , ) times_redeemed = models . PositiveIntegerField ( editable = False , default = 0 , help_text = \"Number of times this coupon has been applied to a customer.\" , ) # valid = models.BooleanField(editable=False) class Meta ( StripeModel . Meta ): unique_together = ( \"id\" , \"livemode\" ) def __str__ ( self ): if self . name : return self . name return self . human_readable @property def human_readable_amount ( self ): if self . percent_off : amount = f \" { self . percent_off } %\" elif self . currency : amount = get_friendly_currency_amount ( self . amount_off or 0 , self . currency ) else : amount = \"(invalid amount)\" return f \" { amount } off\" @property def human_readable ( self ): if self . duration == enums . CouponDuration . repeating : if self . duration_in_months == 1 : duration = \"for 1 month\" else : duration = f \"for { self . duration_in_months } months\" else : duration = self . duration return f \" { self . human_readable_amount } { duration } \" Attributes djstripe . models . billing . Coupon . amount_off = StripeDecimalCurrencyAmountField ( null = True , blank = True , help_text = 'Amount (as decimal) that will be taken off the subtotal of any invoices for this customer.' ) class-attribute djstripe . models . billing . Coupon . applies_to = JSONField ( null = True , blank = True , help_text = 'Contains information about what this coupon applies to.' ) class-attribute djstripe . models . billing . Coupon . currency = StripeCurrencyCodeField ( null = True , blank = True ) class-attribute djstripe . models . billing . Coupon . duration = StripeEnumField ( enum = enums . CouponDuration , help_text = 'Describes how long a customer who applies this coupon will get the discount.' , default = enums . CouponDuration . once ) class-attribute djstripe . models . billing . Coupon . duration_in_months = models . PositiveIntegerField ( null = True , blank = True , help_text = 'If `duration` is `repeating`, the number of months the coupon applies.' ) class-attribute djstripe . models . billing . Coupon . expand_fields = [ 'applies_to' ] class-attribute djstripe . models . billing . Coupon . human_readable property djstripe . models . billing . Coupon . human_readable_amount property djstripe . models . billing . Coupon . id = StripeIdField ( max_length = 500 ) class-attribute djstripe . models . billing . Coupon . max_redemptions = models . PositiveIntegerField ( null = True , blank = True , help_text = 'Maximum number of times this coupon can be redeemed, in total, before it is no longer valid.' ) class-attribute djstripe . models . billing . Coupon . name = models . TextField ( max_length = 5000 , default = '' , blank = True , help_text = 'Name of the coupon displayed to customers on for instance invoices or receipts.' ) class-attribute djstripe . models . billing . Coupon . percent_off = StripePercentField ( null = True , blank = True , help_text = 'Percent that will be taken off the subtotal of any invoices for this customer for the duration of the coupon. For example, a coupon with percent_off of 50 will make a $100 invoice $50 instead.' ) class-attribute djstripe . models . billing . Coupon . redeem_by = StripeDateTimeField ( null = True , blank = True , help_text = 'Date after which the coupon can no longer be redeemed. Max 5 years in the future.' ) class-attribute djstripe . models . billing . Coupon . stripe_class = stripe . Coupon class-attribute djstripe . models . billing . Coupon . stripe_dashboard_item_name = 'coupons' class-attribute djstripe . models . billing . Coupon . times_redeemed = models . PositiveIntegerField ( editable = False , default = 0 , help_text = 'Number of times this coupon has been applied to a customer.' ) class-attribute Classes djstripe.models.billing.Coupon.Meta Bases: StripeModel . Meta Source code in djstripe/models/billing.py 172 173 class Meta ( StripeModel . Meta ): unique_together = ( \"id\" , \"livemode\" ) Attributes djstripe . models . billing . Coupon . Meta . unique_together = ( 'id' , 'livemode' ) class-attribute Functions djstripe . models . billing . Coupon . __str__ () Source code in djstripe/models/billing.py 175 176 177 178 def __str__ ( self ): if self . name : return self . name return self . human_readable djstripe.models.billing.Discount Bases: StripeModel A discount represents the actual application of a coupon or promotion code. It contains information about when the discount began, when it will end, and what it is applied to. Stripe documentation: https://stripe.com/docs/api/discounts Source code in djstripe/models/billing.py 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 class Discount ( StripeModel ): \"\"\" A discount represents the actual application of a coupon or promotion code. It contains information about when the discount began, when it will end, and what it is applied to. Stripe documentation: https://stripe.com/docs/api/discounts \"\"\" expand_fields = [ \"customer\" ] stripe_class = None checkout_session = StripeForeignKey ( \"Session\" , null = True , blank = True , on_delete = models . CASCADE , help_text = \"The Checkout session that this coupon is applied to, if it is applied to a particular session in payment mode. Will not be present for subscription mode.\" , ) coupon = JSONField ( null = True , blank = True , help_text = \"Hash describing the coupon applied to create this discount.\" , ) customer = StripeForeignKey ( \"Customer\" , null = True , blank = True , on_delete = models . CASCADE , help_text = \"The ID of the customer associated with this discount.\" , related_name = \"customer_discounts\" , ) end = StripeDateTimeField ( null = True , blank = True , help_text = ( \"If the coupon has a duration of repeating, the date that this discount will end. If the coupon has a duration of once or forever, this attribute will be null.\" ), ) invoice = StripeForeignKey ( \"Invoice\" , null = True , blank = True , on_delete = models . CASCADE , help_text = \"The invoice that the discount\u2019s coupon was applied to, if it was applied directly to a particular invoice.\" , related_name = \"invoice_discounts\" , ) invoice_item = InvoiceOrLineItemForeignKey ( null = True , blank = True , on_delete = models . CASCADE , help_text = \"The invoice item id (or invoice line item id for invoice line items of type=\u2018subscription\u2019) that the discount\u2019s coupon was applied to, if it was applied directly to a particular invoice item or invoice line item.\" , ) promotion_code = models . CharField ( max_length = 255 , blank = True , help_text = \"The promotion code applied to create this discount.\" , ) start = StripeDateTimeField ( null = True , blank = True , help_text = ( \"Date that the coupon was applied.\" ), ) subscription = StripeForeignKey ( \"subscription\" , null = True , blank = True , on_delete = models . CASCADE , help_text = \"The subscription that this coupon is applied to, if it is applied to a particular subscription.\" , related_name = \"subscription_discounts\" , ) @classmethod def is_valid_object ( cls , data ): \"\"\" Returns whether the data is a valid object for the class \"\"\" return \"object\" in data and data [ \"object\" ] == \"discount\" Attributes djstripe . models . billing . Discount . checkout_session = StripeForeignKey ( 'Session' , null = True , blank = True , on_delete = models . CASCADE , help_text = 'The Checkout session that this coupon is applied to, if it is applied to a particular session in payment mode. Will not be present for subscription mode.' ) class-attribute djstripe . models . billing . Discount . coupon = JSONField ( null = True , blank = True , help_text = 'Hash describing the coupon applied to create this discount.' ) class-attribute djstripe . models . billing . Discount . customer = StripeForeignKey ( 'Customer' , null = True , blank = True , on_delete = models . CASCADE , help_text = 'The ID of the customer associated with this discount.' , related_name = 'customer_discounts' ) class-attribute djstripe . models . billing . Discount . end = StripeDateTimeField ( null = True , blank = True , help_text = 'If the coupon has a duration of repeating, the date that this discount will end. If the coupon has a duration of once or forever, this attribute will be null.' ) class-attribute djstripe . models . billing . Discount . expand_fields = [ 'customer' ] class-attribute djstripe . models . billing . Discount . invoice = StripeForeignKey ( 'Invoice' , null = True , blank = True , on_delete = models . CASCADE , help_text = 'The invoice that the discount\u2019s coupon was applied to, if it was applied directly to a particular invoice.' , related_name = 'invoice_discounts' ) class-attribute djstripe . models . billing . Discount . invoice_item = InvoiceOrLineItemForeignKey ( null = True , blank = True , on_delete = models . CASCADE , help_text = 'The invoice item id (or invoice line item id for invoice line items of type=\u2018subscription\u2019) that the discount\u2019s coupon was applied to, if it was applied directly to a particular invoice item or invoice line item.' ) class-attribute djstripe . models . billing . Discount . promotion_code = models . CharField ( max_length = 255 , blank = True , help_text = 'The promotion code applied to create this discount.' ) class-attribute djstripe . models . billing . Discount . start = StripeDateTimeField ( null = True , blank = True , help_text = 'Date that the coupon was applied.' ) class-attribute djstripe . models . billing . Discount . stripe_class = None class-attribute djstripe . models . billing . Discount . subscription = StripeForeignKey ( 'subscription' , null = True , blank = True , on_delete = models . CASCADE , help_text = 'The subscription that this coupon is applied to, if it is applied to a particular subscription.' , related_name = 'subscription_discounts' ) class-attribute Functions djstripe . models . billing . Discount . is_valid_object ( data ) classmethod Returns whether the data is a valid object for the class Source code in djstripe/models/billing.py 274 275 276 277 278 279 @classmethod def is_valid_object ( cls , data ): \"\"\" Returns whether the data is a valid object for the class \"\"\" return \"object\" in data and data [ \"object\" ] == \"discount\" djstripe.models.billing.Invoice Bases: BaseInvoice Invoices are statements of what a customer owes for a particular billing period, including subscriptions, invoice items, and any automatic proration adjustments if necessary. Once an invoice is created, payment is automatically attempted. Note that the payment, while automatic, does not happen exactly at the time of invoice creation. If you have configured webhooks, the invoice will wait until one hour after the last webhook is successfully sent (or the last webhook times out after failing). Any customer credit on the account is applied before determining how much is due for that invoice (the amount that will be actually charged). If the amount due for the invoice is less than 50 cents (the minimum for a charge), we add the amount to the customer's running account balance to be added to the next invoice. If this amount is negative, it will act as a credit to offset the next invoice. Note that the customer account balance does not include unpaid invoices; it only includes balances that need to be taken into account when calculating the amount due for the next invoice. Stripe documentation: https://stripe.com/docs/api?lang=python#invoices Source code in djstripe/models/billing.py 780 781 782 783 784 785 786 787 788 789 790 791 792 793 794 795 796 797 798 799 800 801 802 803 804 805 806 807 808 809 810 811 812 813 814 815 816 817 818 819 820 821 822 823 824 825 826 827 828 829 830 831 832 833 834 835 836 837 838 839 840 841 842 843 844 845 846 847 848 849 850 class Invoice ( BaseInvoice ): \"\"\" Invoices are statements of what a customer owes for a particular billing period, including subscriptions, invoice items, and any automatic proration adjustments if necessary. Once an invoice is created, payment is automatically attempted. Note that the payment, while automatic, does not happen exactly at the time of invoice creation. If you have configured webhooks, the invoice will wait until one hour after the last webhook is successfully sent (or the last webhook times out after failing). Any customer credit on the account is applied before determining how much is due for that invoice (the amount that will be actually charged). If the amount due for the invoice is less than 50 cents (the minimum for a charge), we add the amount to the customer's running account balance to be added to the next invoice. If this amount is negative, it will act as a credit to offset the next invoice. Note that the customer account balance does not include unpaid invoices; it only includes balances that need to be taken into account when calculating the amount due for the next invoice. Stripe documentation: https://stripe.com/docs/api?lang=python#invoices \"\"\" default_source = PaymentMethodForeignKey ( on_delete = models . SET_NULL , null = True , blank = True , related_name = \"invoices\" , help_text = \"The default payment source for the invoice. \" \"It must belong to the customer associated with the invoice and be \" \"in a chargeable state. If not set, defaults to the subscription's \" \"default source, if any, or to the customer's default source.\" , ) # Note: # Most fields are defined on BaseInvoice so they're shared with UpcomingInvoice. # ManyToManyFields are an exception, since UpcomingInvoice doesn't exist in the db. default_tax_rates = models . ManyToManyField ( \"TaxRate\" , # explicitly specify the joining table name as though the joining model # was defined with through=\"DjstripeInvoiceDefaultTaxRate\" db_table = \"djstripe_djstripeinvoicedefaulttaxrate\" , related_name = \"+\" , blank = True , help_text = \"The tax rates applied to this invoice, if any.\" , ) def _attach_objects_post_save_hook ( self , cls , data , api_key = djstripe_settings . STRIPE_SECRET_KEY , pending_relations = None , ): super () . _attach_objects_post_save_hook ( cls , data , api_key = api_key , pending_relations = pending_relations ) self . default_tax_rates . set ( cls . _stripe_object_to_default_tax_rates ( target_cls = TaxRate , data = data , api_key = api_key ) ) cls . _stripe_object_set_total_tax_amounts ( target_cls = DjstripeInvoiceTotalTaxAmount , data = data , instance = self , api_key = api_key , ) Attributes djstripe . models . billing . Invoice . default_source = PaymentMethodForeignKey ( on_delete = models . SET_NULL , null = True , blank = True , related_name = 'invoices' , help_text = \"The default payment source for the invoice. It must belong to the customer associated with the invoice and be in a chargeable state. If not set, defaults to the subscription's default source, if any, or to the customer's default source.\" ) class-attribute djstripe . models . billing . Invoice . default_tax_rates = models . ManyToManyField ( 'TaxRate' , db_table = 'djstripe_djstripeinvoicedefaulttaxrate' , related_name = '+' , blank = True , help_text = 'The tax rates applied to this invoice, if any.' ) class-attribute Functions djstripe . models . billing . Invoice . _attach_objects_post_save_hook ( cls , data , api_key = djstripe_settings . STRIPE_SECRET_KEY , pending_relations = None ) Source code in djstripe/models/billing.py 828 829 830 831 832 833 834 835 836 837 838 839 840 841 842 843 844 845 846 847 848 849 850 def _attach_objects_post_save_hook ( self , cls , data , api_key = djstripe_settings . STRIPE_SECRET_KEY , pending_relations = None , ): super () . _attach_objects_post_save_hook ( cls , data , api_key = api_key , pending_relations = pending_relations ) self . default_tax_rates . set ( cls . _stripe_object_to_default_tax_rates ( target_cls = TaxRate , data = data , api_key = api_key ) ) cls . _stripe_object_set_total_tax_amounts ( target_cls = DjstripeInvoiceTotalTaxAmount , data = data , instance = self , api_key = api_key , ) djstripe.models.billing.InvoiceItem Bases: StripeModel Sometimes you want to add a charge or credit to a customer but only actually charge the customer's card at the end of a regular billing cycle. This is useful for combining several charges to minimize per-transaction fees or having Stripe tabulate your usage-based billing totals. Stripe documentation: https://stripe.com/docs/api?lang=python#invoiceitems Source code in djstripe/models/billing.py 995 996 997 998 999 1000 1001 1002 1003 1004 1005 1006 1007 1008 1009 1010 1011 1012 1013 1014 1015 1016 1017 1018 1019 1020 1021 1022 1023 1024 1025 1026 1027 1028 1029 1030 1031 1032 1033 1034 1035 1036 1037 1038 1039 1040 1041 1042 1043 1044 1045 1046 1047 1048 1049 1050 1051 1052 1053 1054 1055 1056 1057 1058 1059 1060 1061 1062 1063 1064 1065 1066 1067 1068 1069 1070 1071 1072 1073 1074 1075 1076 1077 1078 1079 1080 1081 1082 1083 1084 1085 1086 1087 1088 1089 1090 1091 1092 1093 1094 1095 1096 1097 1098 1099 1100 1101 1102 1103 1104 1105 1106 1107 1108 1109 1110 1111 1112 1113 1114 1115 1116 1117 1118 1119 1120 1121 1122 1123 1124 1125 1126 1127 1128 1129 1130 1131 1132 1133 1134 1135 1136 1137 1138 1139 1140 1141 1142 1143 1144 1145 1146 1147 class InvoiceItem ( StripeModel ): \"\"\" Sometimes you want to add a charge or credit to a customer but only actually charge the customer's card at the end of a regular billing cycle. This is useful for combining several charges to minimize per-transaction fees or having Stripe tabulate your usage-based billing totals. Stripe documentation: https://stripe.com/docs/api?lang=python#invoiceitems \"\"\" stripe_class = stripe . InvoiceItem expand_fields = [ \"discounts\" ] amount = StripeDecimalCurrencyAmountField ( help_text = \"Amount invoiced (as decimal).\" ) currency = StripeCurrencyCodeField () customer = StripeForeignKey ( \"Customer\" , on_delete = models . CASCADE , related_name = \"invoiceitems\" , help_text = \"The customer associated with this invoiceitem.\" , ) date = StripeDateTimeField ( help_text = \"The date on the invoiceitem.\" ) discountable = models . BooleanField ( default = False , help_text = \"If True, discounts will apply to this invoice item. \" \"Always False for prorations.\" , ) discounts = JSONField ( null = True , blank = True , help_text = \"The discounts which apply to the invoice item. Item discounts are applied before invoice discounts.\" , ) invoice = StripeForeignKey ( \"Invoice\" , on_delete = models . CASCADE , null = True , related_name = \"invoiceitems\" , help_text = \"The invoice to which this invoiceitem is attached.\" , ) period = JSONField () period_end = StripeDateTimeField ( help_text = \"Might be the date when this invoiceitem's invoice was sent.\" ) period_start = StripeDateTimeField ( help_text = \"Might be the date when this invoiceitem was added to the invoice\" ) plan = models . ForeignKey ( \"Plan\" , null = True , on_delete = models . SET_NULL , help_text = \"If the invoice item is a proration, the plan of the subscription \" \"for which the proration was computed.\" , ) price = models . ForeignKey ( \"Price\" , null = True , related_name = \"invoiceitems\" , on_delete = models . SET_NULL , help_text = \"If the invoice item is a proration, the price of the subscription \" \"for which the proration was computed.\" , ) proration = models . BooleanField ( default = False , help_text = \"Whether or not the invoice item was created automatically as a \" \"proration adjustment when the customer switched plans.\" , ) quantity = models . IntegerField ( null = True , blank = True , help_text = \"If the invoice item is a proration, the quantity of the \" \"subscription for which the proration was computed.\" , ) subscription = StripeForeignKey ( \"Subscription\" , null = True , related_name = \"invoiceitems\" , on_delete = models . SET_NULL , help_text = \"The subscription that this invoice item has been created for, \" \"if any.\" , ) # XXX: subscription_item tax_rates = models . ManyToManyField ( \"TaxRate\" , # explicitly specify the joining table name as though the joining model # was defined with through=\"DjstripeInvoiceItemTaxRate\" db_table = \"djstripe_djstripeinvoiceitemtaxrate\" , related_name = \"+\" , blank = True , help_text = \"The tax rates which apply to this invoice item. When set, \" \"the default_tax_rates on the invoice do not apply to this \" \"invoice item.\" , ) unit_amount = StripeQuantumCurrencyAmountField ( null = True , blank = True , help_text = \"Unit amount (in the `currency` specified) of the invoice item.\" , ) unit_amount_decimal = StripeDecimalCurrencyAmountField ( null = True , blank = True , max_digits = 19 , decimal_places = 12 , help_text = ( \"Same as `unit_amount`, but contains a decimal value with \" \"at most 12 decimal places.\" ), ) @classmethod def _manipulate_stripe_object_hook ( cls , data ): data [ \"period_start\" ] = data [ \"period\" ][ \"start\" ] data [ \"period_end\" ] = data [ \"period\" ][ \"end\" ] return data def _attach_objects_post_save_hook ( self , cls , data , api_key = djstripe_settings . STRIPE_SECRET_KEY , pending_relations = None , ): super () . _attach_objects_post_save_hook ( cls , data , api_key = api_key , pending_relations = pending_relations ) if self . pk : # only call .set() on saved instance (ie don't on items of UpcomingInvoice) self . tax_rates . set ( cls . _stripe_object_to_tax_rates ( target_cls = TaxRate , data = data , api_key = api_key ) ) # sync every discount for discount in self . discounts : Discount . sync_from_stripe_data ( discount , api_key = api_key ) def __str__ ( self ): return self . description def get_stripe_dashboard_url ( self ): return self . invoice . get_stripe_dashboard_url () def api_retrieve ( self , * args , ** kwargs ): if \"-il_\" in self . id : warnings . warn ( f \"Attempting to retrieve InvoiceItem with id= { self . id !r} \" \" will most likely fail. \" \"Run manage.py djstripe_update_invoiceitem_ids if this is a problem.\" ) return super () . api_retrieve ( * args , ** kwargs ) Attributes djstripe . models . billing . InvoiceItem . amount = StripeDecimalCurrencyAmountField ( help_text = 'Amount invoiced (as decimal).' ) class-attribute djstripe . models . billing . InvoiceItem . currency = StripeCurrencyCodeField () class-attribute djstripe . models . billing . InvoiceItem . customer = StripeForeignKey ( 'Customer' , on_delete = models . CASCADE , related_name = 'invoiceitems' , help_text = 'The customer associated with this invoiceitem.' ) class-attribute djstripe . models . billing . InvoiceItem . date = StripeDateTimeField ( help_text = 'The date on the invoiceitem.' ) class-attribute djstripe . models . billing . InvoiceItem . discountable = models . BooleanField ( default = False , help_text = 'If True, discounts will apply to this invoice item. Always False for prorations.' ) class-attribute djstripe . models . billing . InvoiceItem . discounts = JSONField ( null = True , blank = True , help_text = 'The discounts which apply to the invoice item. Item discounts are applied before invoice discounts.' ) class-attribute djstripe . models . billing . InvoiceItem . expand_fields = [ 'discounts' ] class-attribute djstripe . models . billing . InvoiceItem . invoice = StripeForeignKey ( 'Invoice' , on_delete = models . CASCADE , null = True , related_name = 'invoiceitems' , help_text = 'The invoice to which this invoiceitem is attached.' ) class-attribute djstripe . models . billing . InvoiceItem . period = JSONField () class-attribute djstripe . models . billing . InvoiceItem . period_end = StripeDateTimeField ( help_text = \"Might be the date when this invoiceitem's invoice was sent.\" ) class-attribute djstripe . models . billing . InvoiceItem . period_start = StripeDateTimeField ( help_text = 'Might be the date when this invoiceitem was added to the invoice' ) class-attribute djstripe . models . billing . InvoiceItem . plan = models . ForeignKey ( 'Plan' , null = True , on_delete = models . SET_NULL , help_text = 'If the invoice item is a proration, the plan of the subscription for which the proration was computed.' ) class-attribute djstripe . models . billing . InvoiceItem . price = models . ForeignKey ( 'Price' , null = True , related_name = 'invoiceitems' , on_delete = models . SET_NULL , help_text = 'If the invoice item is a proration, the price of the subscription for which the proration was computed.' ) class-attribute djstripe . models . billing . InvoiceItem . proration = models . BooleanField ( default = False , help_text = 'Whether or not the invoice item was created automatically as a proration adjustment when the customer switched plans.' ) class-attribute djstripe . models . billing . InvoiceItem . quantity = models . IntegerField ( null = True , blank = True , help_text = 'If the invoice item is a proration, the quantity of the subscription for which the proration was computed.' ) class-attribute djstripe . models . billing . InvoiceItem . stripe_class = stripe . InvoiceItem class-attribute djstripe . models . billing . InvoiceItem . subscription = StripeForeignKey ( 'Subscription' , null = True , related_name = 'invoiceitems' , on_delete = models . SET_NULL , help_text = 'The subscription that this invoice item has been created for, if any.' ) class-attribute djstripe . models . billing . InvoiceItem . tax_rates = models . ManyToManyField ( 'TaxRate' , db_table = 'djstripe_djstripeinvoiceitemtaxrate' , related_name = '+' , blank = True , help_text = 'The tax rates which apply to this invoice item. When set, the default_tax_rates on the invoice do not apply to this invoice item.' ) class-attribute djstripe . models . billing . InvoiceItem . unit_amount = StripeQuantumCurrencyAmountField ( null = True , blank = True , help_text = 'Unit amount (in the `currency` specified) of the invoice item.' ) class-attribute djstripe . models . billing . InvoiceItem . unit_amount_decimal = StripeDecimalCurrencyAmountField ( null = True , blank = True , max_digits = 19 , decimal_places = 12 , help_text = 'Same as `unit_amount`, but contains a decimal value with at most 12 decimal places.' ) class-attribute Functions djstripe . models . billing . InvoiceItem . __str__ () Source code in djstripe/models/billing.py 1133 1134 def __str__ ( self ): return self . description djstripe . models . billing . InvoiceItem . _attach_objects_post_save_hook ( cls , data , api_key = djstripe_settings . STRIPE_SECRET_KEY , pending_relations = None ) Source code in djstripe/models/billing.py 1110 1111 1112 1113 1114 1115 1116 1117 1118 1119 1120 1121 1122 1123 1124 1125 1126 1127 1128 1129 1130 1131 def _attach_objects_post_save_hook ( self , cls , data , api_key = djstripe_settings . STRIPE_SECRET_KEY , pending_relations = None , ): super () . _attach_objects_post_save_hook ( cls , data , api_key = api_key , pending_relations = pending_relations ) if self . pk : # only call .set() on saved instance (ie don't on items of UpcomingInvoice) self . tax_rates . set ( cls . _stripe_object_to_tax_rates ( target_cls = TaxRate , data = data , api_key = api_key ) ) # sync every discount for discount in self . discounts : Discount . sync_from_stripe_data ( discount , api_key = api_key ) djstripe . models . billing . InvoiceItem . _manipulate_stripe_object_hook ( data ) classmethod Source code in djstripe/models/billing.py 1103 1104 1105 1106 1107 1108 @classmethod def _manipulate_stripe_object_hook ( cls , data ): data [ \"period_start\" ] = data [ \"period\" ][ \"start\" ] data [ \"period_end\" ] = data [ \"period\" ][ \"end\" ] return data djstripe . models . billing . InvoiceItem . api_retrieve ( * args , ** kwargs ) Source code in djstripe/models/billing.py 1139 1140 1141 1142 1143 1144 1145 1146 1147 def api_retrieve ( self , * args , ** kwargs ): if \"-il_\" in self . id : warnings . warn ( f \"Attempting to retrieve InvoiceItem with id= { self . id !r} \" \" will most likely fail. \" \"Run manage.py djstripe_update_invoiceitem_ids if this is a problem.\" ) return super () . api_retrieve ( * args , ** kwargs ) djstripe . models . billing . InvoiceItem . get_stripe_dashboard_url () Source code in djstripe/models/billing.py 1136 1137 def get_stripe_dashboard_url ( self ): return self . invoice . get_stripe_dashboard_url () djstripe.models.billing.InvoiceOrLineItem Bases: models . Model An Internal Model that abstracts InvoiceItem and lineItem objects Contains two fields: id and type : - id is the id of the Stripe object. - type can be line_item , invoice_item or unsupported Source code in djstripe/models/billing.py 1295 1296 1297 1298 1299 1300 1301 1302 1303 1304 1305 1306 1307 1308 1309 1310 1311 1312 1313 1314 1315 1316 1317 1318 1319 1320 1321 1322 1323 1324 1325 1326 1327 1328 1329 1330 1331 1332 1333 1334 1335 1336 1337 1338 1339 1340 1341 1342 1343 1344 1345 1346 1347 1348 1349 1350 1351 1352 1353 class InvoiceOrLineItem ( models . Model ): \"\"\"An Internal Model that abstracts InvoiceItem and lineItem objects Contains two fields: `id` and `type`: - `id` is the id of the Stripe object. - `type` can be `line_item`, `invoice_item` or `unsupported` \"\"\" id = models . CharField ( max_length = 255 , primary_key = True ) type = StripeEnumField ( enum = enums . InvoiceorLineItemType , help_text = \"Indicates whether the underlying model is LineItem or InvoiceItem. Can be one of: 'invoice_item', 'line_item' or 'unsupported'\" , ) @classmethod def _model_type ( cls , id_ ): if id_ . startswith ( \"ii\" ): return InvoiceItem , \"invoice_item\" elif id_ . startswith ( \"il\" ): return LineItem , \"line_item\" raise ValueError ( f \"Unknown object type with id: { id_ } \" ) @classmethod def _get_or_create_from_stripe_object ( cls , data , field_name = \"id\" , refetch = True , current_ids = None , pending_relations = None , save = True , stripe_account = None , api_key = djstripe_settings . STRIPE_SECRET_KEY , ): raw_field_data = data . get ( field_name ) id_ = get_id_from_stripe_data ( raw_field_data ) try : object_cls , object_type = cls . _model_type ( id_ ) except ValueError : # This may happen if we have object types we don't know about. # Let's not make dj-stripe entirely unusable if that happens. logger . warning ( f \"Unknown Object. Could not sync object with id: { id_ } \" ) return cls . objects . get_or_create ( id = id_ , defaults = { \"type\" : \"unsupported\" }) # call model's _get_or_create_from_stripe_object to ensure # that object exists before getting or creating its InvoiceorLineItem mapping object_cls . _get_or_create_from_stripe_object ( data , field_name , refetch = refetch , current_ids = current_ids , pending_relations = pending_relations , stripe_account = stripe_account , api_key = api_key , ) return cls . objects . get_or_create ( id = id_ , defaults = { \"type\" : object_type }) Attributes djstripe . models . billing . InvoiceOrLineItem . id = models . CharField ( max_length = 255 , primary_key = True ) class-attribute djstripe . models . billing . InvoiceOrLineItem . type = StripeEnumField ( enum = enums . InvoiceorLineItemType , help_text = \"Indicates whether the underlying model is LineItem or InvoiceItem. Can be one of: 'invoice_item', 'line_item' or 'unsupported'\" ) class-attribute Functions djstripe . models . billing . InvoiceOrLineItem . _get_or_create_from_stripe_object ( data , field_name = 'id' , refetch = True , current_ids = None , pending_relations = None , save = True , stripe_account = None , api_key = djstripe_settings . STRIPE_SECRET_KEY ) classmethod Source code in djstripe/models/billing.py 1318 1319 1320 1321 1322 1323 1324 1325 1326 1327 1328 1329 1330 1331 1332 1333 1334 1335 1336 1337 1338 1339 1340 1341 1342 1343 1344 1345 1346 1347 1348 1349 1350 1351 1352 1353 @classmethod def _get_or_create_from_stripe_object ( cls , data , field_name = \"id\" , refetch = True , current_ids = None , pending_relations = None , save = True , stripe_account = None , api_key = djstripe_settings . STRIPE_SECRET_KEY , ): raw_field_data = data . get ( field_name ) id_ = get_id_from_stripe_data ( raw_field_data ) try : object_cls , object_type = cls . _model_type ( id_ ) except ValueError : # This may happen if we have object types we don't know about. # Let's not make dj-stripe entirely unusable if that happens. logger . warning ( f \"Unknown Object. Could not sync object with id: { id_ } \" ) return cls . objects . get_or_create ( id = id_ , defaults = { \"type\" : \"unsupported\" }) # call model's _get_or_create_from_stripe_object to ensure # that object exists before getting or creating its InvoiceorLineItem mapping object_cls . _get_or_create_from_stripe_object ( data , field_name , refetch = refetch , current_ids = current_ids , pending_relations = pending_relations , stripe_account = stripe_account , api_key = api_key , ) return cls . objects . get_or_create ( id = id_ , defaults = { \"type\" : object_type }) djstripe . models . billing . InvoiceOrLineItem . _model_type ( id_ ) classmethod Source code in djstripe/models/billing.py 1310 1311 1312 1313 1314 1315 1316 @classmethod def _model_type ( cls , id_ ): if id_ . startswith ( \"ii\" ): return InvoiceItem , \"invoice_item\" elif id_ . startswith ( \"il\" ): return LineItem , \"line_item\" raise ValueError ( f \"Unknown object type with id: { id_ } \" ) djstripe.models.billing.LineItem Bases: StripeModel The individual line items that make up the invoice. Stripe documentation: https://stripe.com/docs/api/invoices/line_item Source code in djstripe/models/billing.py 1150 1151 1152 1153 1154 1155 1156 1157 1158 1159 1160 1161 1162 1163 1164 1165 1166 1167 1168 1169 1170 1171 1172 1173 1174 1175 1176 1177 1178 1179 1180 1181 1182 1183 1184 1185 1186 1187 1188 1189 1190 1191 1192 1193 1194 1195 1196 1197 1198 1199 1200 1201 1202 1203 1204 1205 1206 1207 1208 1209 1210 1211 1212 1213 1214 1215 1216 1217 1218 1219 1220 1221 1222 1223 1224 1225 1226 1227 1228 1229 1230 1231 1232 1233 1234 1235 1236 1237 1238 1239 1240 1241 1242 1243 1244 1245 1246 1247 1248 1249 1250 1251 1252 1253 1254 1255 1256 1257 1258 1259 1260 1261 1262 1263 1264 1265 1266 1267 1268 1269 1270 1271 1272 1273 1274 1275 1276 1277 1278 1279 1280 1281 1282 1283 1284 1285 1286 1287 1288 1289 1290 1291 1292 class LineItem ( StripeModel ): \"\"\" The individual line items that make up the invoice. Stripe documentation: https://stripe.com/docs/api/invoices/line_item \"\"\" stripe_class = stripe . InvoiceLineItem expand_fields = [ \"discounts\" ] amount = StripeQuantumCurrencyAmountField ( help_text = \"The amount, in cents.\" ) amount_excluding_tax = StripeQuantumCurrencyAmountField ( help_text = \"The integer amount in cents representing the amount for this line item, excluding all tax and discounts.\" ) currency = StripeCurrencyCodeField () discount_amounts = JSONField ( null = True , blank = True , help_text = \"The amount of discount calculated per discount for this line item.\" , ) discountable = models . BooleanField ( default = False , help_text = \"If True, discounts will apply to this line item. \" \"Always False for prorations.\" , ) discounts = JSONField ( null = True , blank = True , help_text = \"The discounts applied to the invoice line item. Line item discounts are applied before invoice discounts.\" , ) invoice_item = StripeForeignKey ( \"InvoiceItem\" , null = True , blank = True , on_delete = models . CASCADE , help_text = \"The ID of the invoice item associated with this line item if any.\" , ) period = JSONField ( help_text = \"The period this line_item covers. For subscription line items, this is the subscription period. For prorations, this starts when the proration was calculated, and ends at the period end of the subscription. For invoice items, this is the time at which the invoice item was created or the period of the item.\" ) period_end = StripeDateTimeField ( help_text = \"The end of the period, which must be greater than or equal to the start.\" ) period_start = StripeDateTimeField ( help_text = \"The start of the period.\" ) price = JSONField ( help_text = \"The price of the line item.\" , ) proration = models . BooleanField ( default = False , help_text = \"Whether or not the invoice item was created automatically as a \" \"proration adjustment when the customer switched plans.\" , ) proration_details = JSONField ( help_text = \"Additional details for proration line items\" ) subscription = StripeForeignKey ( \"Subscription\" , null = True , blank = True , on_delete = models . CASCADE , help_text = \"The subscription that the invoice item pertains to, if any.\" , ) subscription_item = StripeForeignKey ( \"SubscriptionItem\" , null = True , blank = True , on_delete = models . CASCADE , help_text = \"The subscription item that generated this invoice item. Left empty if the line item is not an explicit result of a subscription.\" , ) tax_amounts = JSONField ( null = True , blank = True , help_text = \"The amount of tax calculated per tax rate for this line item\" , ) tax_rates = JSONField ( null = True , blank = True , help_text = \"The tax rates which apply to the line item.\" ) type = StripeEnumField ( enum = enums . LineItem ) unit_amount_excluding_tax = StripeDecimalCurrencyAmountField ( null = True , blank = True , help_text = ( \"The amount in cents representing the unit amount for this line item, excluding all tax and discounts.\" ), ) quantity = models . IntegerField ( null = True , blank = True , help_text = \"The quantity of the subscription, if the line item is a subscription or a proration.\" , ) @classmethod def _manipulate_stripe_object_hook ( cls , data ): data [ \"period_start\" ] = data [ \"period\" ][ \"start\" ] data [ \"period_end\" ] = data [ \"period\" ][ \"end\" ] return data def _attach_objects_post_save_hook ( self , cls , data , api_key = djstripe_settings . STRIPE_SECRET_KEY , pending_relations = None , ): super () . _attach_objects_post_save_hook ( cls , data , api_key = api_key , pending_relations = pending_relations ) # sync every discount for discount in self . discounts : Discount . sync_from_stripe_data ( discount , api_key = api_key ) @classmethod def api_list ( cls , api_key = djstripe_settings . STRIPE_SECRET_KEY , ** kwargs ): \"\"\" Call the stripe API's list operation for this model. Note that we only iterate and sync the LineItem associated with the passed in Invoice. Upcoming invoices are virtual and are not saved and hence their line items are also not retrieved and synced :param api_key: The api key to use for this request. \\ Defaults to djstripe_settings.STRIPE_SECRET_KEY. :type api_key: string See Stripe documentation for accepted kwargs for each object. :returns: an iterator over all items in the query \"\"\" # get current invoice if any invoice_id = kwargs . pop ( \"id\" ) # get expand parameter that needs to be passed to invoice.lines.list call expand_fields = kwargs . pop ( \"expand\" ) invoice = Invoice . stripe_class . retrieve ( invoice_id , api_key = api_key , ** kwargs ) # iterate over all the line items on the current invoice return invoice . lines . list ( api_key = api_key , expand = expand_fields , ** kwargs ) . auto_paging_iter () Attributes djstripe . models . billing . LineItem . amount = StripeQuantumCurrencyAmountField ( help_text = 'The amount, in cents.' ) class-attribute djstripe . models . billing . LineItem . amount_excluding_tax = StripeQuantumCurrencyAmountField ( help_text = 'The integer amount in cents representing the amount for this line item, excluding all tax and discounts.' ) class-attribute djstripe . models . billing . LineItem . currency = StripeCurrencyCodeField () class-attribute djstripe . models . billing . LineItem . discount_amounts = JSONField ( null = True , blank = True , help_text = 'The amount of discount calculated per discount for this line item.' ) class-attribute djstripe . models . billing . LineItem . discountable = models . BooleanField ( default = False , help_text = 'If True, discounts will apply to this line item. Always False for prorations.' ) class-attribute djstripe . models . billing . LineItem . discounts = JSONField ( null = True , blank = True , help_text = 'The discounts applied to the invoice line item. Line item discounts are applied before invoice discounts.' ) class-attribute djstripe . models . billing . LineItem . expand_fields = [ 'discounts' ] class-attribute djstripe . models . billing . LineItem . invoice_item = StripeForeignKey ( 'InvoiceItem' , null = True , blank = True , on_delete = models . CASCADE , help_text = 'The ID of the invoice item associated with this line item if any.' ) class-attribute djstripe . models . billing . LineItem . period = JSONField ( help_text = 'The period this line_item covers. For subscription line items, this is the subscription period. For prorations, this starts when the proration was calculated, and ends at the period end of the subscription. For invoice items, this is the time at which the invoice item was created or the period of the item.' ) class-attribute djstripe . models . billing . LineItem . period_end = StripeDateTimeField ( help_text = 'The end of the period, which must be greater than or equal to the start.' ) class-attribute djstripe . models . billing . LineItem . period_start = StripeDateTimeField ( help_text = 'The start of the period.' ) class-attribute djstripe . models . billing . LineItem . price = JSONField ( help_text = 'The price of the line item.' ) class-attribute djstripe . models . billing . LineItem . proration = models . BooleanField ( default = False , help_text = 'Whether or not the invoice item was created automatically as a proration adjustment when the customer switched plans.' ) class-attribute djstripe . models . billing . LineItem . proration_details = JSONField ( help_text = 'Additional details for proration line items' ) class-attribute djstripe . models . billing . LineItem . quantity = models . IntegerField ( null = True , blank = True , help_text = 'The quantity of the subscription, if the line item is a subscription or a proration.' ) class-attribute djstripe . models . billing . LineItem . stripe_class = stripe . InvoiceLineItem class-attribute djstripe . models . billing . LineItem . subscription = StripeForeignKey ( 'Subscription' , null = True , blank = True , on_delete = models . CASCADE , help_text = 'The subscription that the invoice item pertains to, if any.' ) class-attribute djstripe . models . billing . LineItem . subscription_item = StripeForeignKey ( 'SubscriptionItem' , null = True , blank = True , on_delete = models . CASCADE , help_text = 'The subscription item that generated this invoice item. Left empty if the line item is not an explicit result of a subscription.' ) class-attribute djstripe . models . billing . LineItem . tax_amounts = JSONField ( null = True , blank = True , help_text = 'The amount of tax calculated per tax rate for this line item' ) class-attribute djstripe . models . billing . LineItem . tax_rates = JSONField ( null = True , blank = True , help_text = 'The tax rates which apply to the line item.' ) class-attribute djstripe . models . billing . LineItem . type = StripeEnumField ( enum = enums . LineItem ) class-attribute djstripe . models . billing . LineItem . unit_amount_excluding_tax = StripeDecimalCurrencyAmountField ( null = True , blank = True , help_text = 'The amount in cents representing the unit amount for this line item, excluding all tax and discounts.' ) class-attribute Functions djstripe . models . billing . LineItem . _attach_objects_post_save_hook ( cls , data , api_key = djstripe_settings . STRIPE_SECRET_KEY , pending_relations = None ) Source code in djstripe/models/billing.py 1248 1249 1250 1251 1252 1253 1254 1255 1256 1257 1258 1259 1260 1261 def _attach_objects_post_save_hook ( self , cls , data , api_key = djstripe_settings . STRIPE_SECRET_KEY , pending_relations = None , ): super () . _attach_objects_post_save_hook ( cls , data , api_key = api_key , pending_relations = pending_relations ) # sync every discount for discount in self . discounts : Discount . sync_from_stripe_data ( discount , api_key = api_key ) djstripe . models . billing . LineItem . _manipulate_stripe_object_hook ( data ) classmethod Source code in djstripe/models/billing.py 1241 1242 1243 1244 1245 1246 @classmethod def _manipulate_stripe_object_hook ( cls , data ): data [ \"period_start\" ] = data [ \"period\" ][ \"start\" ] data [ \"period_end\" ] = data [ \"period\" ][ \"end\" ] return data djstripe . models . billing . LineItem . api_list ( api_key = djstripe_settings . STRIPE_SECRET_KEY , ** kwargs ) classmethod Call the stripe API's list operation for this model. Note that we only iterate and sync the LineItem associated with the passed in Invoice. Upcoming invoices are virtual and are not saved and hence their line items are also not retrieved and synced :param api_key: The api key to use for this request. Defaults to djstripe_settings.STRIPE_SECRET_KEY. :type api_key: string See Stripe documentation for accepted kwargs for each object. :returns: an iterator over all items in the query Source code in djstripe/models/billing.py 1263 1264 1265 1266 1267 1268 1269 1270 1271 1272 1273 1274 1275 1276 1277 1278 1279 1280 1281 1282 1283 1284 1285 1286 1287 1288 1289 1290 1291 1292 @classmethod def api_list ( cls , api_key = djstripe_settings . STRIPE_SECRET_KEY , ** kwargs ): \"\"\" Call the stripe API's list operation for this model. Note that we only iterate and sync the LineItem associated with the passed in Invoice. Upcoming invoices are virtual and are not saved and hence their line items are also not retrieved and synced :param api_key: The api key to use for this request. \\ Defaults to djstripe_settings.STRIPE_SECRET_KEY. :type api_key: string See Stripe documentation for accepted kwargs for each object. :returns: an iterator over all items in the query \"\"\" # get current invoice if any invoice_id = kwargs . pop ( \"id\" ) # get expand parameter that needs to be passed to invoice.lines.list call expand_fields = kwargs . pop ( \"expand\" ) invoice = Invoice . stripe_class . retrieve ( invoice_id , api_key = api_key , ** kwargs ) # iterate over all the line items on the current invoice return invoice . lines . list ( api_key = api_key , expand = expand_fields , ** kwargs ) . auto_paging_iter () djstripe.models.billing.Plan Bases: StripeModel A subscription plan contains the pricing information for different products and feature levels on your site. Stripe documentation: https://stripe.com/docs/api/plans?lang=python NOTE: The Stripe Plans API has been deprecated in favor of the Prices API. You may want to upgrade to use the Price model instead of the Plan model. Source code in djstripe/models/billing.py 1356 1357 1358 1359 1360 1361 1362 1363 1364 1365 1366 1367 1368 1369 1370 1371 1372 1373 1374 1375 1376 1377 1378 1379 1380 1381 1382 1383 1384 1385 1386 1387 1388 1389 1390 1391 1392 1393 1394 1395 1396 1397 1398 1399 1400 1401 1402 1403 1404 1405 1406 1407 1408 1409 1410 1411 1412 1413 1414 1415 1416 1417 1418 1419 1420 1421 1422 1423 1424 1425 1426 1427 1428 1429 1430 1431 1432 1433 1434 1435 1436 1437 1438 1439 1440 1441 1442 1443 1444 1445 1446 1447 1448 1449 1450 1451 1452 1453 1454 1455 1456 1457 1458 1459 1460 1461 1462 1463 1464 1465 1466 1467 1468 1469 1470 1471 1472 1473 1474 1475 1476 1477 1478 1479 1480 1481 1482 1483 1484 1485 1486 1487 1488 1489 1490 1491 1492 1493 1494 1495 1496 1497 1498 1499 1500 1501 1502 1503 1504 1505 1506 1507 1508 1509 1510 1511 1512 1513 1514 1515 1516 1517 1518 1519 1520 1521 1522 1523 1524 1525 1526 1527 1528 1529 1530 1531 1532 1533 1534 1535 1536 1537 1538 1539 1540 1541 1542 1543 1544 1545 1546 1547 1548 1549 1550 1551 1552 1553 1554 1555 1556 1557 1558 1559 1560 1561 1562 1563 1564 1565 1566 1567 1568 1569 1570 class Plan ( StripeModel ): \"\"\" A subscription plan contains the pricing information for different products and feature levels on your site. Stripe documentation: https://stripe.com/docs/api/plans?lang=python NOTE: The Stripe Plans API has been deprecated in favor of the Prices API. You may want to upgrade to use the Price model instead of the Plan model. \"\"\" stripe_class = stripe . Plan expand_fields = [ \"product\" , \"tiers\" ] stripe_dashboard_item_name = \"plans\" active = models . BooleanField ( help_text = \"Whether the plan can be used for new purchases.\" ) aggregate_usage = StripeEnumField ( enum = enums . PlanAggregateUsage , default = \"\" , blank = True , help_text = ( \"Specifies a usage aggregation strategy for plans of usage_type=metered. \" \"Allowed values are `sum` for summing up all usage during a period, \" \"`last_during_period` for picking the last usage record reported within a \" \"period, `last_ever` for picking the last usage record ever (across period \" \"bounds) or max which picks the usage record with the maximum reported \" \"usage during a period. Defaults to `sum`.\" ), ) amount = StripeDecimalCurrencyAmountField ( null = True , blank = True , help_text = \"Amount (as decimal) to be charged on the interval specified.\" , ) amount_decimal = StripeDecimalCurrencyAmountField ( null = True , blank = True , max_digits = 19 , decimal_places = 12 , help_text = ( \"The unit amount in cents to be charged, represented as a decimal \" \"string with at most 12 decimal places.\" ), ) billing_scheme = StripeEnumField ( enum = enums . BillingScheme , default = \"\" , blank = True , help_text = ( \"Describes how to compute the price per period. \" \"Either `per_unit` or `tiered`. \" \"`per_unit` indicates that the fixed amount (specified in amount) \" \"will be charged per unit in quantity \" \"(for plans with `usage_type=licensed`), or per unit of total \" \"usage (for plans with `usage_type=metered`). \" \"`tiered` indicates that the unit pricing will be computed using \" \"a tiering strategy as defined using the tiers and tiers_mode attributes.\" ), ) currency = StripeCurrencyCodeField () interval = StripeEnumField ( enum = enums . PlanInterval , help_text = \"The frequency with which a subscription should be billed.\" , ) interval_count = models . PositiveIntegerField ( null = True , blank = True , help_text = ( \"The number of intervals (specified in the interval property) \" \"between each subscription billing.\" ), ) nickname = models . TextField ( max_length = 5000 , default = \"\" , blank = True , help_text = \"A brief description of the plan, hidden from customers.\" , ) product = StripeForeignKey ( \"Product\" , on_delete = models . SET_NULL , null = True , blank = True , help_text = \"The product whose pricing this plan determines.\" , ) tiers = JSONField ( null = True , blank = True , help_text = ( \"Each element represents a pricing tier. \" \"This parameter requires `billing_scheme` to be set to `tiered`.\" ), ) tiers_mode = StripeEnumField ( enum = enums . PriceTiersMode , null = True , blank = True , help_text = ( \"Defines if the tiering price should be `graduated` or `volume` based. \" \"In `volume`-based tiering, the maximum quantity within a period \" \"determines the per unit price, in `graduated` tiering pricing can \" \"successively change as the quantity grows.\" ), ) transform_usage = JSONField ( null = True , blank = True , help_text = ( \"Apply a transformation to the reported usage or set quantity \" \"before computing the billed price. Cannot be combined with `tiers`.\" ), ) trial_period_days = models . IntegerField ( null = True , blank = True , help_text = ( \"Number of trial period days granted when subscribing a customer \" \"to this plan. Null if the plan has no trial period.\" ), ) usage_type = StripeEnumField ( enum = enums . PriceUsageType , default = enums . PriceUsageType . licensed , help_text = ( \"Configures how the quantity per period should be determined, \" \"can be either `metered` or `licensed`. `licensed` will automatically \" \"bill the `quantity` set for a plan when adding it to a subscription, \" \"`metered` will aggregate the total usage based on usage records. \" \"Defaults to `licensed`.\" ), ) class Meta ( object ): ordering = [ \"amount\" ] @classmethod def get_or_create ( cls , ** kwargs ): \"\"\"Get or create a Plan.\"\"\" try : return cls . objects . get ( id = kwargs [ \"id\" ]), False except cls . DoesNotExist : return cls . create ( ** kwargs ), True @classmethod def create ( cls , ** kwargs ): # A few minor things are changed in the api-version of the create call api_kwargs = dict ( kwargs ) api_kwargs [ \"amount\" ] = int ( api_kwargs [ \"amount\" ] * 100 ) if isinstance ( api_kwargs . get ( \"product\" ), StripeModel ): api_kwargs [ \"product\" ] = api_kwargs [ \"product\" ] . id stripe_plan = cls . _api_create ( ** api_kwargs ) api_key = api_kwargs . get ( \"api_key\" ) or djstripe_settings . STRIPE_SECRET_KEY plan = cls . sync_from_stripe_data ( stripe_plan , api_key = api_key ) return plan def __str__ ( self ): if self . product and self . product . name : return f \" { self . human_readable_price } for { self . product . name } \" return self . human_readable_price @property def amount_in_cents ( self ): return int ( self . amount * 100 ) @property def human_readable_price ( self ) -> str : if self . billing_scheme == \"per_unit\" : unit_amount = self . amount amount = get_friendly_currency_amount ( unit_amount , self . currency ) else : # tiered billing scheme tier_1 = self . tiers [ 0 ] flat_amount_tier_1 = tier_1 [ \"flat_amount\" ] formatted_unit_amount_tier_1 = get_friendly_currency_amount ( ( tier_1 [ \"unit_amount\" ] or 0 ) / 100 , self . currency ) amount = f \"Starts at { formatted_unit_amount_tier_1 } per unit\" # stripe shows flat fee even if it is set to 0.00 if flat_amount_tier_1 is not None : formatted_flat_amount_tier_1 = get_friendly_currency_amount ( flat_amount_tier_1 / 100 , self . currency ) amount = f \" { amount } + { formatted_flat_amount_tier_1 } \" format_args = { \"amount\" : amount } interval_count = self . interval_count if interval_count == 1 : interval = { \"day\" : _ ( \"day\" ), \"week\" : _ ( \"week\" ), \"month\" : _ ( \"month\" ), \"year\" : _ ( \"year\" ), }[ self . interval ] template = _ ( \" {amount} / {interval} \" ) format_args [ \"interval\" ] = interval else : interval = { \"day\" : _ ( \"days\" ), \"week\" : _ ( \"weeks\" ), \"month\" : _ ( \"months\" ), \"year\" : _ ( \"years\" ), }[ self . interval ] template = _ ( \" {amount} / every {interval_count} {interval} \" ) format_args [ \"interval\" ] = interval format_args [ \"interval_count\" ] = interval_count return str ( format_lazy ( template , ** format_args )) Attributes djstripe . models . billing . Plan . active = models . BooleanField ( help_text = 'Whether the plan can be used for new purchases.' ) class-attribute djstripe . models . billing . Plan . aggregate_usage = StripeEnumField ( enum = enums . PlanAggregateUsage , default = '' , blank = True , help_text = 'Specifies a usage aggregation strategy for plans of usage_type=metered. Allowed values are `sum` for summing up all usage during a period, `last_during_period` for picking the last usage record reported within a period, `last_ever` for picking the last usage record ever (across period bounds) or max which picks the usage record with the maximum reported usage during a period. Defaults to `sum`.' ) class-attribute djstripe . models . billing . Plan . amount = StripeDecimalCurrencyAmountField ( null = True , blank = True , help_text = 'Amount (as decimal) to be charged on the interval specified.' ) class-attribute djstripe . models . billing . Plan . amount_decimal = StripeDecimalCurrencyAmountField ( null = True , blank = True , max_digits = 19 , decimal_places = 12 , help_text = 'The unit amount in cents to be charged, represented as a decimal string with at most 12 decimal places.' ) class-attribute djstripe . models . billing . Plan . amount_in_cents property djstripe . models . billing . Plan . billing_scheme = StripeEnumField ( enum = enums . BillingScheme , default = '' , blank = True , help_text = 'Describes how to compute the price per period. Either `per_unit` or `tiered`. `per_unit` indicates that the fixed amount (specified in amount) will be charged per unit in quantity (for plans with `usage_type=licensed`), or per unit of total usage (for plans with `usage_type=metered`). `tiered` indicates that the unit pricing will be computed using a tiering strategy as defined using the tiers and tiers_mode attributes.' ) class-attribute djstripe . models . billing . Plan . currency = StripeCurrencyCodeField () class-attribute djstripe . models . billing . Plan . expand_fields = [ 'product' , 'tiers' ] class-attribute djstripe . models . billing . Plan . human_readable_price : str property djstripe . models . billing . Plan . interval = StripeEnumField ( enum = enums . PlanInterval , help_text = 'The frequency with which a subscription should be billed.' ) class-attribute djstripe . models . billing . Plan . interval_count = models . PositiveIntegerField ( null = True , blank = True , help_text = 'The number of intervals (specified in the interval property) between each subscription billing.' ) class-attribute djstripe . models . billing . Plan . nickname = models . TextField ( max_length = 5000 , default = '' , blank = True , help_text = 'A brief description of the plan, hidden from customers.' ) class-attribute djstripe . models . billing . Plan . product = StripeForeignKey ( 'Product' , on_delete = models . SET_NULL , null = True , blank = True , help_text = 'The product whose pricing this plan determines.' ) class-attribute djstripe . models . billing . Plan . stripe_class = stripe . Plan class-attribute djstripe . models . billing . Plan . stripe_dashboard_item_name = 'plans' class-attribute djstripe . models . billing . Plan . tiers = JSONField ( null = True , blank = True , help_text = 'Each element represents a pricing tier. This parameter requires `billing_scheme` to be set to `tiered`.' ) class-attribute djstripe . models . billing . Plan . tiers_mode = StripeEnumField ( enum = enums . PriceTiersMode , null = True , blank = True , help_text = 'Defines if the tiering price should be `graduated` or `volume` based. In `volume`-based tiering, the maximum quantity within a period determines the per unit price, in `graduated` tiering pricing can successively change as the quantity grows.' ) class-attribute djstripe . models . billing . Plan . transform_usage = JSONField ( null = True , blank = True , help_text = 'Apply a transformation to the reported usage or set quantity before computing the billed price. Cannot be combined with `tiers`.' ) class-attribute djstripe . models . billing . Plan . trial_period_days = models . IntegerField ( null = True , blank = True , help_text = 'Number of trial period days granted when subscribing a customer to this plan. Null if the plan has no trial period.' ) class-attribute djstripe . models . billing . Plan . usage_type = StripeEnumField ( enum = enums . PriceUsageType , default = enums . PriceUsageType . licensed , help_text = 'Configures how the quantity per period should be determined, can be either `metered` or `licensed`. `licensed` will automatically bill the `quantity` set for a plan when adding it to a subscription, `metered` will aggregate the total usage based on usage records. Defaults to `licensed`.' ) class-attribute Classes djstripe.models.billing.Plan.Meta Bases: object Source code in djstripe/models/billing.py 1490 1491 class Meta ( object ): ordering = [ \"amount\" ] Attributes djstripe . models . billing . Plan . Meta . ordering = [ 'amount' ] class-attribute Functions djstripe . models . billing . Plan . __str__ () Source code in djstripe/models/billing.py 1517 1518 1519 1520 def __str__ ( self ): if self . product and self . product . name : return f \" { self . human_readable_price } for { self . product . name } \" return self . human_readable_price djstripe . models . billing . Plan . create ( ** kwargs ) classmethod Source code in djstripe/models/billing.py 1502 1503 1504 1505 1506 1507 1508 1509 1510 1511 1512 1513 1514 1515 @classmethod def create ( cls , ** kwargs ): # A few minor things are changed in the api-version of the create call api_kwargs = dict ( kwargs ) api_kwargs [ \"amount\" ] = int ( api_kwargs [ \"amount\" ] * 100 ) if isinstance ( api_kwargs . get ( \"product\" ), StripeModel ): api_kwargs [ \"product\" ] = api_kwargs [ \"product\" ] . id stripe_plan = cls . _api_create ( ** api_kwargs ) api_key = api_kwargs . get ( \"api_key\" ) or djstripe_settings . STRIPE_SECRET_KEY plan = cls . sync_from_stripe_data ( stripe_plan , api_key = api_key ) return plan djstripe . models . billing . Plan . get_or_create ( ** kwargs ) classmethod Get or create a Plan. Source code in djstripe/models/billing.py 1493 1494 1495 1496 1497 1498 1499 1500 @classmethod def get_or_create ( cls , ** kwargs ): \"\"\"Get or create a Plan.\"\"\" try : return cls . objects . get ( id = kwargs [ \"id\" ]), False except cls . DoesNotExist : return cls . create ( ** kwargs ), True djstripe.models.billing.ShippingRate Bases: StripeModel Shipping rates describe the price of shipping presented to your customers and can be applied to Checkout Sessions to collect shipping costs. Stripe documentation: https://stripe.com/docs/api/shipping_rates Source code in djstripe/models/billing.py 2263 2264 2265 2266 2267 2268 2269 2270 2271 2272 2273 2274 2275 2276 2277 2278 2279 2280 2281 2282 2283 2284 2285 2286 2287 2288 2289 2290 2291 2292 2293 2294 2295 2296 2297 2298 2299 2300 2301 2302 2303 2304 2305 2306 2307 2308 2309 2310 2311 2312 2313 2314 2315 2316 2317 2318 2319 2320 2321 2322 2323 2324 2325 class ShippingRate ( StripeModel ): \"\"\" Shipping rates describe the price of shipping presented to your customers and can be applied to Checkout Sessions to collect shipping costs. Stripe documentation: https://stripe.com/docs/api/shipping_rates \"\"\" stripe_class = stripe . ShippingRate stripe_dashboard_item_name = \"shipping-rates\" description = None active = models . BooleanField ( default = True , help_text = \"Whether the shipping rate can be used for new purchases. Defaults to true\" , ) display_name = models . CharField ( max_length = 50 , default = \"\" , blank = True , help_text = \"The name of the shipping rate, meant to be displayable to the customer. This will appear on CheckoutSessions.\" , ) fixed_amount = JSONField ( help_text = \"Describes a fixed amount to charge for shipping. Must be present if type is fixed_amount\" , ) type = StripeEnumField ( enum = enums . ShippingRateType , default = enums . ShippingRateType . fixed_amount , help_text = _ ( \"The type of calculation to use on the shipping rate. Can only be fixed_amount for now.\" ), ) delivery_estimate = JSONField ( null = True , blank = True , help_text = \"The estimated range for how long shipping will take, meant to be displayable to the customer. This will appear on CheckoutSessions.\" , ) tax_behavior = StripeEnumField ( enum = enums . ShippingRateTaxBehavior , help_text = _ ( \"Specifies whether the rate is considered inclusive of taxes or exclusive of taxes.\" ), ) tax_code = StripeForeignKey ( \"TaxCode\" , null = True , blank = True , on_delete = models . CASCADE , help_text = \"The shipping tax code\" , ) class Meta ( StripeModel . Meta ): verbose_name = \"Shipping Rate\" def __str__ ( self ): amount = get_friendly_currency_amount ( self . fixed_amount . get ( \"amount\" ) / 100 , self . fixed_amount . get ( \"currency\" ) ) if self . active : return f \" { self . display_name } - { amount } (Active)\" else : return f \" { self . display_name } - { amount } (Archived)\" Attributes djstripe . models . billing . ShippingRate . active = models . BooleanField ( default = True , help_text = 'Whether the shipping rate can be used for new purchases. Defaults to true' ) class-attribute djstripe . models . billing . ShippingRate . delivery_estimate = JSONField ( null = True , blank = True , help_text = 'The estimated range for how long shipping will take, meant to be displayable to the customer. This will appear on CheckoutSessions.' ) class-attribute djstripe . models . billing . ShippingRate . description = None class-attribute djstripe . models . billing . ShippingRate . display_name = models . CharField ( max_length = 50 , default = '' , blank = True , help_text = 'The name of the shipping rate, meant to be displayable to the customer. This will appear on CheckoutSessions.' ) class-attribute djstripe . models . billing . ShippingRate . fixed_amount = JSONField ( help_text = 'Describes a fixed amount to charge for shipping. Must be present if type is fixed_amount' ) class-attribute djstripe . models . billing . ShippingRate . stripe_class = stripe . ShippingRate class-attribute djstripe . models . billing . ShippingRate . stripe_dashboard_item_name = 'shipping-rates' class-attribute djstripe . models . billing . ShippingRate . tax_behavior = StripeEnumField ( enum = enums . ShippingRateTaxBehavior , help_text = _ ( 'Specifies whether the rate is considered inclusive of taxes or exclusive of taxes.' )) class-attribute djstripe . models . billing . ShippingRate . tax_code = StripeForeignKey ( 'TaxCode' , null = True , blank = True , on_delete = models . CASCADE , help_text = 'The shipping tax code' ) class-attribute djstripe . models . billing . ShippingRate . type = StripeEnumField ( enum = enums . ShippingRateType , default = enums . ShippingRateType . fixed_amount , help_text = _ ( 'The type of calculation to use on the shipping rate. Can only be fixed_amount for now.' )) class-attribute Classes djstripe.models.billing.ShippingRate.Meta Bases: StripeModel . Meta Source code in djstripe/models/billing.py 2315 2316 class Meta ( StripeModel . Meta ): verbose_name = \"Shipping Rate\" Attributes djstripe . models . billing . ShippingRate . Meta . verbose_name = 'Shipping Rate' class-attribute Functions djstripe . models . billing . ShippingRate . __str__ () Source code in djstripe/models/billing.py 2318 2319 2320 2321 2322 2323 2324 2325 def __str__ ( self ): amount = get_friendly_currency_amount ( self . fixed_amount . get ( \"amount\" ) / 100 , self . fixed_amount . get ( \"currency\" ) ) if self . active : return f \" { self . display_name } - { amount } (Active)\" else : return f \" { self . display_name } - { amount } (Archived)\" djstripe.models.billing.Subscription Bases: StripeModel Subscriptions allow you to charge a customer's card on a recurring basis. A subscription ties a customer to a particular plan you've created. A subscription still in its trial period is trialing and moves to active when the trial period is over. When payment to renew the subscription fails, the subscription becomes past_due . After Stripe has exhausted all payment retry attempts, the subscription ends up with a status of either canceled or unpaid depending on your retry settings. Note that when a subscription has a status of unpaid , no subsequent invoices will be attempted (invoices will be created, but then immediately automatically closed. Additionally, updating customer card details will not lead to Stripe retrying the latest invoice.). After receiving updated card details from a customer, you may choose to reopen and pay their closed invoices. Stripe documentation: https://stripe.com/docs/api?lang=python#subscriptions Source code in djstripe/models/billing.py 1573 1574 1575 1576 1577 1578 1579 1580 1581 1582 1583 1584 1585 1586 1587 1588 1589 1590 1591 1592 1593 1594 1595 1596 1597 1598 1599 1600 1601 1602 1603 1604 1605 1606 1607 1608 1609 1610 1611 1612 1613 1614 1615 1616 1617 1618 1619 1620 1621 1622 1623 1624 1625 1626 1627 1628 1629 1630 1631 1632 1633 1634 1635 1636 1637 1638 1639 1640 1641 1642 1643 1644 1645 1646 1647 1648 1649 1650 1651 1652 1653 1654 1655 1656 1657 1658 1659 1660 1661 1662 1663 1664 1665 1666 1667 1668 1669 1670 1671 1672 1673 1674 1675 1676 1677 1678 1679 1680 1681 1682 1683 1684 1685 1686 1687 1688 1689 1690 1691 1692 1693 1694 1695 1696 1697 1698 1699 1700 1701 1702 1703 1704 1705 1706 1707 1708 1709 1710 1711 1712 1713 1714 1715 1716 1717 1718 1719 1720 1721 1722 1723 1724 1725 1726 1727 1728 1729 1730 1731 1732 1733 1734 1735 1736 1737 1738 1739 1740 1741 1742 1743 1744 1745 1746 1747 1748 1749 1750 1751 1752 1753 1754 1755 1756 1757 1758 1759 1760 1761 1762 1763 1764 1765 1766 1767 1768 1769 1770 1771 1772 1773 1774 1775 1776 1777 1778 1779 1780 1781 1782 1783 1784 1785 1786 1787 1788 1789 1790 1791 1792 1793 1794 1795 1796 1797 1798 1799 1800 1801 1802 1803 1804 1805 1806 1807 1808 1809 1810 1811 1812 1813 1814 1815 1816 1817 1818 1819 1820 1821 1822 1823 1824 1825 1826 1827 1828 1829 1830 1831 1832 1833 1834 1835 1836 1837 1838 1839 1840 1841 1842 1843 1844 1845 1846 1847 1848 1849 1850 1851 1852 1853 1854 1855 1856 1857 1858 1859 1860 1861 1862 1863 1864 1865 1866 1867 1868 1869 1870 1871 1872 1873 1874 1875 1876 1877 1878 1879 1880 1881 1882 1883 1884 1885 1886 1887 1888 1889 1890 1891 1892 1893 1894 1895 1896 1897 1898 1899 1900 1901 1902 1903 1904 1905 1906 1907 1908 1909 1910 1911 1912 1913 1914 1915 1916 1917 1918 1919 1920 1921 1922 1923 1924 1925 1926 1927 1928 1929 1930 1931 1932 1933 1934 1935 1936 1937 1938 1939 1940 1941 1942 1943 1944 1945 1946 1947 1948 1949 1950 1951 1952 1953 1954 1955 1956 1957 1958 1959 1960 1961 1962 1963 1964 1965 1966 1967 1968 1969 1970 1971 1972 1973 1974 1975 1976 1977 1978 1979 1980 1981 1982 1983 1984 1985 1986 1987 1988 1989 1990 1991 1992 1993 1994 1995 1996 1997 1998 1999 2000 2001 2002 2003 2004 2005 2006 2007 2008 2009 2010 2011 2012 2013 2014 2015 2016 2017 2018 2019 2020 2021 2022 class Subscription ( StripeModel ): \"\"\" Subscriptions allow you to charge a customer's card on a recurring basis. A subscription ties a customer to a particular plan you've created. A subscription still in its trial period is ``trialing`` and moves to ``active`` when the trial period is over. When payment to renew the subscription fails, the subscription becomes ``past_due``. After Stripe has exhausted all payment retry attempts, the subscription ends up with a status of either ``canceled`` or ``unpaid`` depending on your retry settings. Note that when a subscription has a status of ``unpaid``, no subsequent invoices will be attempted (invoices will be created, but then immediately automatically closed. Additionally, updating customer card details will not lead to Stripe retrying the latest invoice.). After receiving updated card details from a customer, you may choose to reopen and pay their closed invoices. Stripe documentation: https://stripe.com/docs/api?lang=python#subscriptions \"\"\" stripe_class = stripe . Subscription stripe_dashboard_item_name = \"subscriptions\" application_fee_percent = StripePercentField ( null = True , blank = True , help_text = \"A positive decimal that represents the fee percentage of the \" \"subscription invoice amount that will be transferred to the application \" \"owner's Stripe account each billing period.\" , ) billing_cycle_anchor = StripeDateTimeField ( null = True , blank = True , help_text = ( \"Determines the date of the first full invoice, and, for plans \" \"with `month` or `year` intervals, the day of the month for subsequent \" \"invoices.\" ), ) billing_thresholds = JSONField ( null = True , blank = True , help_text = \"Define thresholds at which an invoice will be sent, and the \" \"subscription advanced to a new billing period.\" , ) cancel_at = StripeDateTimeField ( null = True , blank = True , help_text = \"A date in the future at which the subscription will automatically \" \"get canceled.\" , ) cancel_at_period_end = models . BooleanField ( default = False , help_text = \"If the subscription has been canceled with the ``at_period_end`` \" \"flag set to true, ``cancel_at_period_end`` on the subscription will be true. \" \"You can use this attribute to determine whether a subscription that has a \" \"status of active is scheduled to be canceled at the end of the \" \"current period.\" , ) canceled_at = StripeDateTimeField ( null = True , blank = True , help_text = \"If the subscription has been canceled, the date of that \" \"cancellation. If the subscription was canceled with ``cancel_at_period_end``, \" \"canceled_at will still reflect the date of the initial cancellation request, \" \"not the end of the subscription period when the subscription is automatically \" \"moved to a canceled state.\" , ) collection_method = StripeEnumField ( enum = enums . InvoiceCollectionMethod , help_text = \"Either `charge_automatically`, or `send_invoice`. When charging \" \"automatically, Stripe will attempt to pay this subscription at the end of the \" \"cycle using the default source attached to the customer. \" \"When sending an invoice, Stripe will email your customer an invoice with \" \"payment instructions.\" , ) current_period_end = StripeDateTimeField ( help_text = \"End of the current period for which the subscription has been \" \"invoiced. At the end of this period, a new invoice will be created.\" ) current_period_start = StripeDateTimeField ( help_text = \"Start of the current period for which the subscription has \" \"been invoiced.\" ) customer = StripeForeignKey ( \"Customer\" , on_delete = models . CASCADE , related_name = \"subscriptions\" , help_text = \"The customer associated with this subscription.\" , ) days_until_due = models . IntegerField ( null = True , blank = True , help_text = \"Number of days a customer has to pay invoices generated by this \" \"subscription. This value will be `null` for subscriptions where \" \"`billing=charge_automatically`.\" , ) default_payment_method = StripeForeignKey ( \"PaymentMethod\" , null = True , blank = True , on_delete = models . SET_NULL , related_name = \"+\" , help_text = \"The default payment method for the subscription. \" \"It must belong to the customer associated with the subscription. \" \"If not set, invoices will use the default payment method in the \" \"customer's invoice settings.\" , ) default_source = PaymentMethodForeignKey ( on_delete = models . SET_NULL , null = True , blank = True , related_name = \"subscriptions\" , help_text = \"The default payment source for the subscription. \" \"It must belong to the customer associated with the subscription \" \"and be in a chargeable state. If not set, defaults to the customer's \" \"default source.\" , ) default_tax_rates = models . ManyToManyField ( \"TaxRate\" , # explicitly specify the joining table name as though the joining model # was defined with through=\"DjstripeSubscriptionDefaultTaxRate\" db_table = \"djstripe_djstripesubscriptiondefaulttaxrate\" , related_name = \"+\" , blank = True , help_text = \"The tax rates that will apply to any subscription item \" \"that does not have tax_rates set. Invoices created will have their \" \"default_tax_rates populated from the subscription.\" , ) discount = JSONField ( null = True , blank = True , help_text = \"Describes the current discount applied to this subscription, if there is one. When billing, a discount applied to a subscription overrides a discount applied on a customer-wide basis.\" , ) ended_at = StripeDateTimeField ( null = True , blank = True , help_text = \"If the subscription has ended (either because it was canceled or \" \"because the customer was switched to a subscription to a new plan), \" \"the date the subscription ended.\" , ) latest_invoice = StripeForeignKey ( \"Invoice\" , null = True , blank = True , related_name = \"+\" , on_delete = models . SET_NULL , help_text = \"The most recent invoice this subscription has generated.\" , ) next_pending_invoice_item_invoice = StripeDateTimeField ( null = True , blank = True , help_text = \"Specifies the approximate timestamp on which any pending \" \"invoice items will be billed according to the schedule provided at \" \"pending_invoice_item_interval.\" , ) pause_collection = JSONField ( null = True , blank = True , help_text = \"If specified, payment collection for this subscription will be paused.\" , ) pending_invoice_item_interval = JSONField ( null = True , blank = True , help_text = \"Specifies an interval for how often to bill for any \" \"pending invoice items. It is analogous to calling Create an invoice \" \"for the given subscription at the specified interval.\" , ) pending_setup_intent = StripeForeignKey ( \"SetupIntent\" , null = True , blank = True , on_delete = models . CASCADE , related_name = \"setup_intents\" , help_text = \"We can use this SetupIntent to collect user authentication \" \"when creating a subscription without immediate payment or updating a \" \"subscription's payment method, allowing you to \" \"optimize for off-session payments.\" , ) pending_update = JSONField ( null = True , blank = True , help_text = \"If specified, pending updates that will be applied to the \" \"subscription once the latest_invoice has been paid.\" , ) plan = models . ForeignKey ( \"Plan\" , null = True , blank = True , on_delete = models . CASCADE , related_name = \"subscriptions\" , help_text = \"The plan associated with this subscription. This value will be \" \"`null` for multi-plan subscriptions\" , ) proration_behavior = StripeEnumField ( enum = enums . SubscriptionProrationBehavior , help_text = \"Determines how to handle prorations when the billing cycle changes (e.g., when switching plans, resetting billing_cycle_anchor=now, or starting a trial), or if an item\u2019s quantity changes\" , default = enums . SubscriptionProrationBehavior . create_prorations , blank = True , ) proration_date = StripeDateTimeField ( null = True , blank = True , help_text = \"If set, the proration will be calculated as though the subscription was updated at the given time. This can be used to apply exactly the same proration that was previewed with upcoming invoice endpoint. It can also be used to implement custom proration logic, such as prorating by day instead of by second, by providing the time that you wish to use for proration calculations\" , ) quantity = models . IntegerField ( null = True , blank = True , help_text = \"The quantity applied to this subscription. This value will be \" \"`null` for multi-plan subscriptions\" , ) schedule = models . ForeignKey ( \"SubscriptionSchedule\" , null = True , blank = True , on_delete = models . CASCADE , related_name = \"subscriptions\" , help_text = \"The schedule associated with this subscription.\" , ) start_date = StripeDateTimeField ( null = True , blank = True , help_text = \"Date when the subscription was first created. The date \" \"might differ from the created date due to backdating.\" , ) status = StripeEnumField ( enum = enums . SubscriptionStatus , help_text = \"The status of this subscription.\" ) trial_end = StripeDateTimeField ( null = True , blank = True , help_text = \"If the subscription has a trial, the end of that trial.\" , ) trial_start = StripeDateTimeField ( null = True , blank = True , help_text = \"If the subscription has a trial, the beginning of that trial.\" , ) objects = SubscriptionManager () @classmethod def api_list ( cls , api_key = djstripe_settings . STRIPE_SECRET_KEY , ** kwargs ): \"\"\" Call the stripe API's list operation for this model. :param api_key: The api key to use for this request. \\ Defaults to djstripe_settings.STRIPE_SECRET_KEY. :type api_key: string See Stripe documentation for accepted kwargs for each object. :returns: an iterator over all items in the query \"\"\" if not kwargs . get ( \"status\" ): # special case: https://stripe.com/docs/api/subscriptions/list#list_subscriptions-status # See Issue: https://github.com/dj-stripe/dj-stripe/issues/1763 kwargs [ \"status\" ] = \"all\" return super () . api_list ( api_key = api_key , ** kwargs ) def update ( self , plan : Union [ StripeModel , str ] = None , ** kwargs ): \"\"\" See `Customer.subscribe() <#djstripe.models.Customer.subscribe>`__ :param plan: The plan to which to subscribe the customer. :type plan: Plan or string (plan ID) .. important:: Updating a subscription by changing the plan or quantity \\ creates a new ``Subscription`` in \\ Stripe (and dj-stripe). \"\"\" # Convert Plan to id if plan is not None and isinstance ( plan , StripeModel ): plan = plan . id stripe_subscription = self . _api_update ( plan = plan , ** kwargs ) api_key = kwargs . get ( \"api_key\" ) or self . default_api_key return Subscription . sync_from_stripe_data ( stripe_subscription , api_key = api_key ) def extend ( self , delta ): \"\"\" Extends this subscription by the provided delta. :param delta: The timedelta by which to extend this subscription. :type delta: timedelta \"\"\" if delta . total_seconds () < 0 : raise ValueError ( \"delta must be a positive timedelta.\" ) if self . trial_end is not None and self . trial_end > timezone . now (): period_end = self . trial_end else : period_end = self . current_period_end period_end += delta return self . update ( proration_behavior = \"none\" , trial_end = period_end ) def cancel ( self , at_period_end : bool = False , ** kwargs ): \"\"\" Cancels this subscription. If you set the at_period_end parameter to true, the subscription will remain active until the end of the period, at which point it will be canceled and not renewed. By default, the subscription is terminated immediately. In either case, the customer will not be charged again for the subscription. Note, however, that any pending invoice items or metered usage will still be charged at the end of the period unless manually deleted. Depending on how `proration_behavior` is set, any pending prorations will also be left in place and collected at the end of the period. However, if the subscription is set to cancel immediately, you can pass the `prorate` and `invoice_now` flags in `kwargs` to configure how the pending metered usage is invoiced and how proration must work. By default, all unpaid invoices for the customer will be closed upon subscription cancellation. We do this in order to prevent unexpected payment retries once the customer has canceled a subscription. However, you can reopen the invoices manually after subscription cancellation to have us proceed with automatic retries, or you could even re-attempt payment yourself on all unpaid invoices before allowing the customer to cancel the subscription at all. :param at_period_end: A flag that if set to true will delay the cancellation \\ of the subscription until the end of the current period. Default is False. :type at_period_end: boolean .. important:: If a subscription is canceled during a trial period, \\ the ``at_period_end`` flag will be overridden to False so that the trial ends \\ immediately and the customer's card isn't charged. \"\"\" # If plan has trial days and customer cancels before # trial period ends, then end subscription now, # i.e. at_period_end=False if self . trial_end and self . trial_end > timezone . now (): at_period_end = False if at_period_end : stripe_subscription = self . _api_update ( cancel_at_period_end = True ) else : try : stripe_subscription = self . _api_delete ( ** kwargs ) except InvalidRequestError as exc : if \"No such subscription:\" in str ( exc ): # cancel() works by deleting the subscription. The object still # exists in Stripe however, and can still be retrieved. # If the subscription was already canceled (status=canceled), # that api_retrieve() call will fail with \"No such subscription\". # However, this may also happen if the subscription legitimately # does not exist, in which case the following line will re-raise. stripe_subscription = self . api_retrieve () else : raise return Subscription . sync_from_stripe_data ( stripe_subscription , api_key = self . default_api_key ) def reactivate ( self ): \"\"\" Reactivates this subscription. If a customer's subscription is canceled with ``at_period_end`` set to True and it has not yet reached the end of the billing period, it can be reactivated. Subscriptions canceled immediately cannot be reactivated. (Source: https://stripe.com/docs/billing/subscriptions/cancel) .. warning:: Reactivating a fully canceled Subscription will fail silently. \\ Be sure to check the returned Subscription's status. \"\"\" stripe_subscription = self . api_retrieve () stripe_subscription . plan = self . plan . id stripe_subscription . cancel_at_period_end = False return Subscription . sync_from_stripe_data ( stripe_subscription . save ()) def is_period_current ( self ): \"\"\" Returns True if this subscription's period is current, false otherwise. \"\"\" return self . current_period_end > timezone . now () or ( self . trial_end and self . trial_end > timezone . now () ) def is_status_current ( self ): \"\"\" Returns True if this subscription's status is current (active or trialing), false otherwise. \"\"\" return self . status in [ \"trialing\" , \"active\" ] def is_status_temporarily_current ( self ): \"\"\" A status is temporarily current when the subscription is canceled with the ``at_period_end`` flag. The subscription is still active, but is technically canceled and we're just waiting for it to run out. You could use this method to give customers limited service after they've canceled. For example, a video on demand service could only allow customers to download their libraries and do nothing else when their subscription is temporarily current. \"\"\" return ( self . canceled_at and self . cancel_at_period_end and timezone . now () < self . current_period_end ) def is_valid ( self ): \"\"\" Returns True if this subscription's status and period are current, false otherwise. \"\"\" if not self . is_status_current (): return False if not self . is_period_current (): return False return True def _attach_objects_post_save_hook ( self , cls , data , api_key = djstripe_settings . STRIPE_SECRET_KEY , pending_relations = None , ): super () . _attach_objects_post_save_hook ( cls , data , api_key = api_key , pending_relations = pending_relations ) cls . _stripe_object_to_subscription_items ( target_cls = SubscriptionItem , data = data , subscription = self , api_key = api_key ) self . default_tax_rates . set ( cls . _stripe_object_to_default_tax_rates ( target_cls = TaxRate , data = data , api_key = api_key ) ) Attributes djstripe . models . billing . Subscription . application_fee_percent = StripePercentField ( null = True , blank = True , help_text = \"A positive decimal that represents the fee percentage of the subscription invoice amount that will be transferred to the application owner's Stripe account each billing period.\" ) class-attribute djstripe . models . billing . Subscription . billing_cycle_anchor = StripeDateTimeField ( null = True , blank = True , help_text = 'Determines the date of the first full invoice, and, for plans with `month` or `year` intervals, the day of the month for subsequent invoices.' ) class-attribute djstripe . models . billing . Subscription . billing_thresholds = JSONField ( null = True , blank = True , help_text = 'Define thresholds at which an invoice will be sent, and the subscription advanced to a new billing period.' ) class-attribute djstripe . models . billing . Subscription . cancel_at = StripeDateTimeField ( null = True , blank = True , help_text = 'A date in the future at which the subscription will automatically get canceled.' ) class-attribute djstripe . models . billing . Subscription . cancel_at_period_end = models . BooleanField ( default = False , help_text = 'If the subscription has been canceled with the ``at_period_end`` flag set to true, ``cancel_at_period_end`` on the subscription will be true. You can use this attribute to determine whether a subscription that has a status of active is scheduled to be canceled at the end of the current period.' ) class-attribute djstripe . models . billing . Subscription . canceled_at = StripeDateTimeField ( null = True , blank = True , help_text = 'If the subscription has been canceled, the date of that cancellation. If the subscription was canceled with ``cancel_at_period_end``, canceled_at will still reflect the date of the initial cancellation request, not the end of the subscription period when the subscription is automatically moved to a canceled state.' ) class-attribute djstripe . models . billing . Subscription . collection_method = StripeEnumField ( enum = enums . InvoiceCollectionMethod , help_text = 'Either `charge_automatically`, or `send_invoice`. When charging automatically, Stripe will attempt to pay this subscription at the end of the cycle using the default source attached to the customer. When sending an invoice, Stripe will email your customer an invoice with payment instructions.' ) class-attribute djstripe . models . billing . Subscription . current_period_end = StripeDateTimeField ( help_text = 'End of the current period for which the subscription has been invoiced. At the end of this period, a new invoice will be created.' ) class-attribute djstripe . models . billing . Subscription . current_period_start = StripeDateTimeField ( help_text = 'Start of the current period for which the subscription has been invoiced.' ) class-attribute djstripe . models . billing . Subscription . customer = StripeForeignKey ( 'Customer' , on_delete = models . CASCADE , related_name = 'subscriptions' , help_text = 'The customer associated with this subscription.' ) class-attribute djstripe . models . billing . Subscription . days_until_due = models . IntegerField ( null = True , blank = True , help_text = 'Number of days a customer has to pay invoices generated by this subscription. This value will be `null` for subscriptions where `billing=charge_automatically`.' ) class-attribute djstripe . models . billing . Subscription . default_payment_method = StripeForeignKey ( 'PaymentMethod' , null = True , blank = True , on_delete = models . SET_NULL , related_name = '+' , help_text = \"The default payment method for the subscription. It must belong to the customer associated with the subscription. If not set, invoices will use the default payment method in the customer's invoice settings.\" ) class-attribute djstripe . models . billing . Subscription . default_source = PaymentMethodForeignKey ( on_delete = models . SET_NULL , null = True , blank = True , related_name = 'subscriptions' , help_text = \"The default payment source for the subscription. It must belong to the customer associated with the subscription and be in a chargeable state. If not set, defaults to the customer's default source.\" ) class-attribute djstripe . models . billing . Subscription . default_tax_rates = models . ManyToManyField ( 'TaxRate' , db_table = 'djstripe_djstripesubscriptiondefaulttaxrate' , related_name = '+' , blank = True , help_text = 'The tax rates that will apply to any subscription item that does not have tax_rates set. Invoices created will have their default_tax_rates populated from the subscription.' ) class-attribute djstripe . models . billing . Subscription . discount = JSONField ( null = True , blank = True , help_text = 'Describes the current discount applied to this subscription, if there is one. When billing, a discount applied to a subscription overrides a discount applied on a customer-wide basis.' ) class-attribute djstripe . models . billing . Subscription . ended_at = StripeDateTimeField ( null = True , blank = True , help_text = 'If the subscription has ended (either because it was canceled or because the customer was switched to a subscription to a new plan), the date the subscription ended.' ) class-attribute djstripe . models . billing . Subscription . latest_invoice = StripeForeignKey ( 'Invoice' , null = True , blank = True , related_name = '+' , on_delete = models . SET_NULL , help_text = 'The most recent invoice this subscription has generated.' ) class-attribute djstripe . models . billing . Subscription . next_pending_invoice_item_invoice = StripeDateTimeField ( null = True , blank = True , help_text = 'Specifies the approximate timestamp on which any pending invoice items will be billed according to the schedule provided at pending_invoice_item_interval.' ) class-attribute djstripe . models . billing . Subscription . objects = SubscriptionManager () class-attribute djstripe . models . billing . Subscription . pause_collection = JSONField ( null = True , blank = True , help_text = 'If specified, payment collection for this subscription will be paused.' ) class-attribute djstripe . models . billing . Subscription . pending_invoice_item_interval = JSONField ( null = True , blank = True , help_text = 'Specifies an interval for how often to bill for any pending invoice items. It is analogous to calling Create an invoice for the given subscription at the specified interval.' ) class-attribute djstripe . models . billing . Subscription . pending_setup_intent = StripeForeignKey ( 'SetupIntent' , null = True , blank = True , on_delete = models . CASCADE , related_name = 'setup_intents' , help_text = \"We can use this SetupIntent to collect user authentication when creating a subscription without immediate payment or updating a subscription's payment method, allowing you to optimize for off-session payments.\" ) class-attribute djstripe . models . billing . Subscription . pending_update = JSONField ( null = True , blank = True , help_text = 'If specified, pending updates that will be applied to the subscription once the latest_invoice has been paid.' ) class-attribute djstripe . models . billing . Subscription . plan = models . ForeignKey ( 'Plan' , null = True , blank = True , on_delete = models . CASCADE , related_name = 'subscriptions' , help_text = 'The plan associated with this subscription. This value will be `null` for multi-plan subscriptions' ) class-attribute djstripe . models . billing . Subscription . proration_behavior = StripeEnumField ( enum = enums . SubscriptionProrationBehavior , help_text = 'Determines how to handle prorations when the billing cycle changes (e.g., when switching plans, resetting billing_cycle_anchor=now, or starting a trial), or if an item\u2019s quantity changes' , default = enums . SubscriptionProrationBehavior . create_prorations , blank = True ) class-attribute djstripe . models . billing . Subscription . proration_date = StripeDateTimeField ( null = True , blank = True , help_text = 'If set, the proration will be calculated as though the subscription was updated at the given time. This can be used to apply exactly the same proration that was previewed with upcoming invoice endpoint. It can also be used to implement custom proration logic, such as prorating by day instead of by second, by providing the time that you wish to use for proration calculations' ) class-attribute djstripe . models . billing . Subscription . quantity = models . IntegerField ( null = True , blank = True , help_text = 'The quantity applied to this subscription. This value will be `null` for multi-plan subscriptions' ) class-attribute djstripe . models . billing . Subscription . schedule = models . ForeignKey ( 'SubscriptionSchedule' , null = True , blank = True , on_delete = models . CASCADE , related_name = 'subscriptions' , help_text = 'The schedule associated with this subscription.' ) class-attribute djstripe . models . billing . Subscription . start_date = StripeDateTimeField ( null = True , blank = True , help_text = 'Date when the subscription was first created. The date might differ from the created date due to backdating.' ) class-attribute djstripe . models . billing . Subscription . status = StripeEnumField ( enum = enums . SubscriptionStatus , help_text = 'The status of this subscription.' ) class-attribute djstripe . models . billing . Subscription . stripe_class = stripe . Subscription class-attribute djstripe . models . billing . Subscription . stripe_dashboard_item_name = 'subscriptions' class-attribute djstripe . models . billing . Subscription . trial_end = StripeDateTimeField ( null = True , blank = True , help_text = 'If the subscription has a trial, the end of that trial.' ) class-attribute djstripe . models . billing . Subscription . trial_start = StripeDateTimeField ( null = True , blank = True , help_text = 'If the subscription has a trial, the beginning of that trial.' ) class-attribute Functions djstripe . models . billing . Subscription . _attach_objects_post_save_hook ( cls , data , api_key = djstripe_settings . STRIPE_SECRET_KEY , pending_relations = None ) Source code in djstripe/models/billing.py 2003 2004 2005 2006 2007 2008 2009 2010 2011 2012 2013 2014 2015 2016 2017 2018 2019 2020 2021 2022 def _attach_objects_post_save_hook ( self , cls , data , api_key = djstripe_settings . STRIPE_SECRET_KEY , pending_relations = None , ): super () . _attach_objects_post_save_hook ( cls , data , api_key = api_key , pending_relations = pending_relations ) cls . _stripe_object_to_subscription_items ( target_cls = SubscriptionItem , data = data , subscription = self , api_key = api_key ) self . default_tax_rates . set ( cls . _stripe_object_to_default_tax_rates ( target_cls = TaxRate , data = data , api_key = api_key ) ) djstripe . models . billing . Subscription . api_list ( api_key = djstripe_settings . STRIPE_SECRET_KEY , ** kwargs ) classmethod Call the stripe API's list operation for this model. :param api_key: The api key to use for this request. Defaults to djstripe_settings.STRIPE_SECRET_KEY. :type api_key: string See Stripe documentation for accepted kwargs for each object. :returns: an iterator over all items in the query Source code in djstripe/models/billing.py 1818 1819 1820 1821 1822 1823 1824 1825 1826 1827 1828 1829 1830 1831 1832 @classmethod def api_list ( cls , api_key = djstripe_settings . STRIPE_SECRET_KEY , ** kwargs ): \"\"\" Call the stripe API's list operation for this model. :param api_key: The api key to use for this request. \\ Defaults to djstripe_settings.STRIPE_SECRET_KEY. :type api_key: string See Stripe documentation for accepted kwargs for each object. :returns: an iterator over all items in the query \"\"\" if not kwargs . get ( \"status\" ): # special case: https://stripe.com/docs/api/subscriptions/list#list_subscriptions-status # See Issue: https://github.com/dj-stripe/dj-stripe/issues/1763 kwargs [ \"status\" ] = \"all\" return super () . api_list ( api_key = api_key , ** kwargs ) djstripe . models . billing . Subscription . cancel ( at_period_end = False , ** kwargs ) Cancels this subscription. If you set the at_period_end parameter to true, the subscription will remain active until the end of the period, at which point it will be canceled and not renewed. By default, the subscription is terminated immediately. In either case, the customer will not be charged again for the subscription. Note, however, that any pending invoice items or metered usage will still be charged at the end of the period unless manually deleted. Depending on how proration_behavior is set, any pending prorations will also be left in place and collected at the end of the period. However, if the subscription is set to cancel immediately, you can pass the prorate and invoice_now flags in kwargs to configure how the pending metered usage is invoiced and how proration must work. By default, all unpaid invoices for the customer will be closed upon subscription cancellation. We do this in order to prevent unexpected payment retries once the customer has canceled a subscription. However, you can reopen the invoices manually after subscription cancellation to have us proceed with automatic retries, or you could even re-attempt payment yourself on all unpaid invoices before allowing the customer to cancel the subscription at all. :param at_period_end: A flag that if set to true will delay the cancellation of the subscription until the end of the current period. Default is False. :type at_period_end: boolean .. important:: If a subscription is canceled during a trial period, the at_period_end flag will be overridden to False so that the trial ends immediately and the customer's card isn't charged. Source code in djstripe/models/billing.py 1875 1876 1877 1878 1879 1880 1881 1882 1883 1884 1885 1886 1887 1888 1889 1890 1891 1892 1893 1894 1895 1896 1897 1898 1899 1900 1901 1902 1903 1904 1905 1906 1907 1908 1909 1910 1911 1912 1913 1914 1915 1916 1917 1918 1919 1920 1921 1922 1923 1924 1925 1926 1927 1928 1929 1930 1931 1932 1933 def cancel ( self , at_period_end : bool = False , ** kwargs ): \"\"\" Cancels this subscription. If you set the at_period_end parameter to true, the subscription will remain active until the end of the period, at which point it will be canceled and not renewed. By default, the subscription is terminated immediately. In either case, the customer will not be charged again for the subscription. Note, however, that any pending invoice items or metered usage will still be charged at the end of the period unless manually deleted. Depending on how `proration_behavior` is set, any pending prorations will also be left in place and collected at the end of the period. However, if the subscription is set to cancel immediately, you can pass the `prorate` and `invoice_now` flags in `kwargs` to configure how the pending metered usage is invoiced and how proration must work. By default, all unpaid invoices for the customer will be closed upon subscription cancellation. We do this in order to prevent unexpected payment retries once the customer has canceled a subscription. However, you can reopen the invoices manually after subscription cancellation to have us proceed with automatic retries, or you could even re-attempt payment yourself on all unpaid invoices before allowing the customer to cancel the subscription at all. :param at_period_end: A flag that if set to true will delay the cancellation \\ of the subscription until the end of the current period. Default is False. :type at_period_end: boolean .. important:: If a subscription is canceled during a trial period, \\ the ``at_period_end`` flag will be overridden to False so that the trial ends \\ immediately and the customer's card isn't charged. \"\"\" # If plan has trial days and customer cancels before # trial period ends, then end subscription now, # i.e. at_period_end=False if self . trial_end and self . trial_end > timezone . now (): at_period_end = False if at_period_end : stripe_subscription = self . _api_update ( cancel_at_period_end = True ) else : try : stripe_subscription = self . _api_delete ( ** kwargs ) except InvalidRequestError as exc : if \"No such subscription:\" in str ( exc ): # cancel() works by deleting the subscription. The object still # exists in Stripe however, and can still be retrieved. # If the subscription was already canceled (status=canceled), # that api_retrieve() call will fail with \"No such subscription\". # However, this may also happen if the subscription legitimately # does not exist, in which case the following line will re-raise. stripe_subscription = self . api_retrieve () else : raise return Subscription . sync_from_stripe_data ( stripe_subscription , api_key = self . default_api_key ) djstripe . models . billing . Subscription . extend ( delta ) Extends this subscription by the provided delta. :param delta: The timedelta by which to extend this subscription. :type delta: timedelta Source code in djstripe/models/billing.py 1855 1856 1857 1858 1859 1860 1861 1862 1863 1864 1865 1866 1867 1868 1869 1870 1871 1872 1873 def extend ( self , delta ): \"\"\" Extends this subscription by the provided delta. :param delta: The timedelta by which to extend this subscription. :type delta: timedelta \"\"\" if delta . total_seconds () < 0 : raise ValueError ( \"delta must be a positive timedelta.\" ) if self . trial_end is not None and self . trial_end > timezone . now (): period_end = self . trial_end else : period_end = self . current_period_end period_end += delta return self . update ( proration_behavior = \"none\" , trial_end = period_end ) djstripe . models . billing . Subscription . is_period_current () Returns True if this subscription's period is current, false otherwise. Source code in djstripe/models/billing.py 1953 1954 1955 1956 1957 1958 1959 1960 def is_period_current ( self ): \"\"\" Returns True if this subscription's period is current, false otherwise. \"\"\" return self . current_period_end > timezone . now () or ( self . trial_end and self . trial_end > timezone . now () ) djstripe . models . billing . Subscription . is_status_current () Returns True if this subscription's status is current (active or trialing), false otherwise. Source code in djstripe/models/billing.py 1962 1963 1964 1965 1966 1967 1968 def is_status_current ( self ): \"\"\" Returns True if this subscription's status is current (active or trialing), false otherwise. \"\"\" return self . status in [ \"trialing\" , \"active\" ] djstripe . models . billing . Subscription . is_status_temporarily_current () A status is temporarily current when the subscription is canceled with the at_period_end flag. The subscription is still active, but is technically canceled and we're just waiting for it to run out. You could use this method to give customers limited service after they've canceled. For example, a video on demand service could only allow customers to download their libraries and do nothing else when their subscription is temporarily current. Source code in djstripe/models/billing.py 1970 1971 1972 1973 1974 1975 1976 1977 1978 1979 1980 1981 1982 1983 1984 1985 1986 1987 def is_status_temporarily_current ( self ): \"\"\" A status is temporarily current when the subscription is canceled with the ``at_period_end`` flag. The subscription is still active, but is technically canceled and we're just waiting for it to run out. You could use this method to give customers limited service after they've canceled. For example, a video on demand service could only allow customers to download their libraries and do nothing else when their subscription is temporarily current. \"\"\" return ( self . canceled_at and self . cancel_at_period_end and timezone . now () < self . current_period_end ) djstripe . models . billing . Subscription . is_valid () Returns True if this subscription's status and period are current, false otherwise. Source code in djstripe/models/billing.py 1989 1990 1991 1992 1993 1994 1995 1996 1997 1998 1999 2000 2001 def is_valid ( self ): \"\"\" Returns True if this subscription's status and period are current, false otherwise. \"\"\" if not self . is_status_current (): return False if not self . is_period_current (): return False return True djstripe . models . billing . Subscription . reactivate () Reactivates this subscription. If a customer's subscription is canceled with at_period_end set to True and it has not yet reached the end of the billing period, it can be reactivated. Subscriptions canceled immediately cannot be reactivated. (Source: https://stripe.com/docs/billing/subscriptions/cancel) .. warning:: Reactivating a fully canceled Subscription will fail silently. Be sure to check the returned Subscription's status. Source code in djstripe/models/billing.py 1935 1936 1937 1938 1939 1940 1941 1942 1943 1944 1945 1946 1947 1948 1949 1950 1951 def reactivate ( self ): \"\"\" Reactivates this subscription. If a customer's subscription is canceled with ``at_period_end`` set to True and it has not yet reached the end of the billing period, it can be reactivated. Subscriptions canceled immediately cannot be reactivated. (Source: https://stripe.com/docs/billing/subscriptions/cancel) .. warning:: Reactivating a fully canceled Subscription will fail silently. \\ Be sure to check the returned Subscription's status. \"\"\" stripe_subscription = self . api_retrieve () stripe_subscription . plan = self . plan . id stripe_subscription . cancel_at_period_end = False return Subscription . sync_from_stripe_data ( stripe_subscription . save ()) djstripe . models . billing . Subscription . update ( plan = None , ** kwargs ) See Customer.subscribe() <#djstripe.models.Customer.subscribe> __ :param plan: The plan to which to subscribe the customer. :type plan: Plan or string (plan ID) .. important:: Updating a subscription by changing the plan or quantity creates a new Subscription in Stripe (and dj-stripe). Source code in djstripe/models/billing.py 1834 1835 1836 1837 1838 1839 1840 1841 1842 1843 1844 1845 1846 1847 1848 1849 1850 1851 1852 1853 def update ( self , plan : Union [ StripeModel , str ] = None , ** kwargs ): \"\"\" See `Customer.subscribe() <#djstripe.models.Customer.subscribe>`__ :param plan: The plan to which to subscribe the customer. :type plan: Plan or string (plan ID) .. important:: Updating a subscription by changing the plan or quantity \\ creates a new ``Subscription`` in \\ Stripe (and dj-stripe). \"\"\" # Convert Plan to id if plan is not None and isinstance ( plan , StripeModel ): plan = plan . id stripe_subscription = self . _api_update ( plan = plan , ** kwargs ) api_key = kwargs . get ( \"api_key\" ) or self . default_api_key return Subscription . sync_from_stripe_data ( stripe_subscription , api_key = api_key ) djstripe.models.billing.SubscriptionItem Bases: StripeModel Subscription items allow you to create customer subscriptions with more than one plan, making it easy to represent complex billing relationships. Stripe documentation: https://stripe.com/docs/api?lang=python#subscription_items Source code in djstripe/models/billing.py 2025 2026 2027 2028 2029 2030 2031 2032 2033 2034 2035 2036 2037 2038 2039 2040 2041 2042 2043 2044 2045 2046 2047 2048 2049 2050 2051 2052 2053 2054 2055 2056 2057 2058 2059 2060 2061 2062 2063 2064 2065 2066 2067 2068 2069 2070 2071 2072 2073 2074 2075 2076 2077 2078 2079 2080 2081 2082 2083 2084 2085 2086 2087 2088 2089 2090 2091 2092 2093 2094 2095 2096 2097 2098 2099 2100 2101 2102 2103 2104 2105 2106 class SubscriptionItem ( StripeModel ): \"\"\" Subscription items allow you to create customer subscriptions with more than one plan, making it easy to represent complex billing relationships. Stripe documentation: https://stripe.com/docs/api?lang=python#subscription_items \"\"\" stripe_class = stripe . SubscriptionItem billing_thresholds = JSONField ( null = True , blank = True , help_text = \"Define thresholds at which an invoice will be sent, and the \" \"related subscription advanced to a new billing period.\" , ) plan = models . ForeignKey ( \"Plan\" , on_delete = models . CASCADE , related_name = \"subscription_items\" , help_text = \"The plan the customer is subscribed to.\" , ) price = models . ForeignKey ( \"Price\" , null = True , blank = True , on_delete = models . CASCADE , related_name = \"subscription_items\" , help_text = \"The price the customer is subscribed to.\" , ) proration_behavior = StripeEnumField ( enum = enums . SubscriptionProrationBehavior , help_text = \"Determines how to handle prorations when the billing cycle changes (e.g., when switching plans, resetting billing_cycle_anchor=now, or starting a trial), or if an item\u2019s quantity changes\" , default = enums . SubscriptionProrationBehavior . create_prorations , blank = True , ) proration_date = StripeDateTimeField ( null = True , blank = True , help_text = \"If set, the proration will be calculated as though the subscription was updated at the given time. This can be used to apply exactly the same proration that was previewed with upcoming invoice endpoint. It can also be used to implement custom proration logic, such as prorating by day instead of by second, by providing the time that you wish to use for proration calculations\" , ) quantity = models . PositiveIntegerField ( null = True , blank = True , help_text = ( \"The quantity of the plan to which the customer should be subscribed.\" ), ) subscription = StripeForeignKey ( \"Subscription\" , on_delete = models . CASCADE , related_name = \"items\" , help_text = \"The subscription this subscription item belongs to.\" , ) tax_rates = models . ManyToManyField ( \"TaxRate\" , # explicitly specify the joining table name as though the joining model # was defined with through=\"DjstripeSubscriptionItemTaxRate\" db_table = \"djstripe_djstripesubscriptionitemtaxrate\" , related_name = \"+\" , blank = True , help_text = \"The tax rates which apply to this subscription_item. When set, \" \"the default_tax_rates on the subscription do not apply to this \" \"subscription_item.\" , ) def _attach_objects_post_save_hook ( self , cls , data , api_key = djstripe_settings . STRIPE_SECRET_KEY , pending_relations = None , ): super () . _attach_objects_post_save_hook ( cls , data , api_key = api_key , pending_relations = pending_relations ) self . tax_rates . set ( cls . _stripe_object_to_tax_rates ( target_cls = TaxRate , data = data , api_key = api_key ) ) Attributes djstripe . models . billing . SubscriptionItem . billing_thresholds = JSONField ( null = True , blank = True , help_text = 'Define thresholds at which an invoice will be sent, and the related subscription advanced to a new billing period.' ) class-attribute djstripe . models . billing . SubscriptionItem . plan = models . ForeignKey ( 'Plan' , on_delete = models . CASCADE , related_name = 'subscription_items' , help_text = 'The plan the customer is subscribed to.' ) class-attribute djstripe . models . billing . SubscriptionItem . price = models . ForeignKey ( 'Price' , null = True , blank = True , on_delete = models . CASCADE , related_name = 'subscription_items' , help_text = 'The price the customer is subscribed to.' ) class-attribute djstripe . models . billing . SubscriptionItem . proration_behavior = StripeEnumField ( enum = enums . SubscriptionProrationBehavior , help_text = 'Determines how to handle prorations when the billing cycle changes (e.g., when switching plans, resetting billing_cycle_anchor=now, or starting a trial), or if an item\u2019s quantity changes' , default = enums . SubscriptionProrationBehavior . create_prorations , blank = True ) class-attribute djstripe . models . billing . SubscriptionItem . proration_date = StripeDateTimeField ( null = True , blank = True , help_text = 'If set, the proration will be calculated as though the subscription was updated at the given time. This can be used to apply exactly the same proration that was previewed with upcoming invoice endpoint. It can also be used to implement custom proration logic, such as prorating by day instead of by second, by providing the time that you wish to use for proration calculations' ) class-attribute djstripe . models . billing . SubscriptionItem . quantity = models . PositiveIntegerField ( null = True , blank = True , help_text = 'The quantity of the plan to which the customer should be subscribed.' ) class-attribute djstripe . models . billing . SubscriptionItem . stripe_class = stripe . SubscriptionItem class-attribute djstripe . models . billing . SubscriptionItem . subscription = StripeForeignKey ( 'Subscription' , on_delete = models . CASCADE , related_name = 'items' , help_text = 'The subscription this subscription item belongs to.' ) class-attribute djstripe . models . billing . SubscriptionItem . tax_rates = models . ManyToManyField ( 'TaxRate' , db_table = 'djstripe_djstripesubscriptionitemtaxrate' , related_name = '+' , blank = True , help_text = 'The tax rates which apply to this subscription_item. When set, the default_tax_rates on the subscription do not apply to this subscription_item.' ) class-attribute Functions djstripe . models . billing . SubscriptionItem . _attach_objects_post_save_hook ( cls , data , api_key = djstripe_settings . STRIPE_SECRET_KEY , pending_relations = None ) Source code in djstripe/models/billing.py 2091 2092 2093 2094 2095 2096 2097 2098 2099 2100 2101 2102 2103 2104 2105 2106 def _attach_objects_post_save_hook ( self , cls , data , api_key = djstripe_settings . STRIPE_SECRET_KEY , pending_relations = None , ): super () . _attach_objects_post_save_hook ( cls , data , api_key = api_key , pending_relations = pending_relations ) self . tax_rates . set ( cls . _stripe_object_to_tax_rates ( target_cls = TaxRate , data = data , api_key = api_key ) ) djstripe.models.billing.SubscriptionSchedule Bases: StripeModel Subscription schedules allow you to create and manage the lifecycle of a subscription by predefining expected changes. Stripe documentation: https://stripe.com/docs/api/subscription_schedules?lang=python Source code in djstripe/models/billing.py 2109 2110 2111 2112 2113 2114 2115 2116 2117 2118 2119 2120 2121 2122 2123 2124 2125 2126 2127 2128 2129 2130 2131 2132 2133 2134 2135 2136 2137 2138 2139 2140 2141 2142 2143 2144 2145 2146 2147 2148 2149 2150 2151 2152 2153 2154 2155 2156 2157 2158 2159 2160 2161 2162 2163 2164 2165 2166 2167 2168 2169 2170 2171 2172 2173 2174 2175 2176 2177 2178 2179 2180 2181 2182 2183 2184 2185 2186 2187 2188 2189 2190 2191 2192 2193 2194 2195 2196 2197 2198 2199 2200 2201 2202 2203 2204 2205 2206 2207 2208 2209 2210 2211 2212 2213 2214 2215 2216 2217 2218 2219 2220 2221 2222 2223 2224 2225 2226 2227 2228 2229 2230 2231 2232 2233 2234 2235 2236 2237 2238 2239 2240 2241 2242 2243 2244 2245 2246 2247 2248 2249 2250 2251 2252 2253 2254 2255 2256 2257 2258 2259 2260 class SubscriptionSchedule ( StripeModel ): \"\"\" Subscription schedules allow you to create and manage the lifecycle of a subscription by predefining expected changes. Stripe documentation: https://stripe.com/docs/api/subscription_schedules?lang=python \"\"\" stripe_class = stripe . SubscriptionSchedule stripe_dashboard_item_name = \"subscription_schedules\" canceled_at = StripeDateTimeField ( null = True , blank = True , help_text = \"Time at which the subscription schedule was canceled.\" , ) completed_at = StripeDateTimeField ( null = True , blank = True , help_text = \"Time at which the subscription schedule was completed.\" , ) current_phase = JSONField ( null = True , blank = True , help_text = \"Object representing the start and end dates for the \" \"current phase of the subscription schedule, if it is `active`.\" , ) customer = models . ForeignKey ( \"Customer\" , on_delete = models . CASCADE , related_name = \"schedules\" , help_text = \"The customer who owns the subscription schedule.\" , ) default_settings = JSONField ( null = True , blank = True , help_text = \"Object representing the subscription schedule's default settings.\" , ) end_behavior = StripeEnumField ( enum = enums . SubscriptionScheduleEndBehavior , help_text = \"Behavior of the subscription schedule and underlying \" \"subscription when it ends.\" , ) phases = JSONField ( null = True , blank = True , help_text = \"Configuration for the subscription schedule's phases.\" , ) released_at = StripeDateTimeField ( null = True , blank = True , help_text = \"Time at which the subscription schedule was released.\" , ) released_subscription = models . ForeignKey ( \"Subscription\" , null = True , blank = True , on_delete = models . SET_NULL , related_name = \"released_schedules\" , help_text = \"The subscription once managed by this subscription schedule \" \"(if it is released).\" , ) status = StripeEnumField ( enum = enums . SubscriptionScheduleStatus , help_text = \"The present status of the subscription schedule. Possible \" \"values are `not_started`, `active`, `completed`, `released`, and \" \"`canceled`.\" , ) subscription = models . ForeignKey ( \"Subscription\" , null = True , blank = True , on_delete = models . SET_NULL , related_name = \"subscriptions\" , help_text = \"ID of the subscription managed by the subscription schedule.\" , ) def release ( self , api_key = None , stripe_account = None , ** kwargs ): \"\"\" Releases the subscription schedule immediately, which will stop scheduling of its phases, but leave any existing subscription in place. A schedule can only be released if its status is not_started or active. If the subscription schedule is currently associated with a subscription, releasing it will remove its subscription property and set the subscription\u2019s ID to the released_subscription property and returns the Released SubscriptionSchedule. :param api_key: The api key to use for this request. Defaults to djstripe_settings.STRIPE_SECRET_KEY. :type api_key: string :param stripe_account: The optional connected account \\ for which this request is being made. :type stripe_account: string \"\"\" api_key = api_key or self . default_api_key # Prefer passed in stripe_account if set. if not stripe_account : stripe_account = self . _get_stripe_account_id ( api_key ) stripe_subscription_schedule = self . stripe_class . release ( self . id , api_key = api_key , stripe_account = stripe_account , stripe_version = djstripe_settings . STRIPE_API_VERSION , ** kwargs , ) return SubscriptionSchedule . sync_from_stripe_data ( stripe_subscription_schedule ) def cancel ( self , api_key = None , stripe_account = None , ** kwargs ): \"\"\" Cancels a subscription schedule and its associated subscription immediately (if the subscription schedule has an active subscription). A subscription schedule can only be canceled if its status is not_started or active and returns the Canceled SubscriptionSchedule. :param api_key: The api key to use for this request. Defaults to djstripe_settings.STRIPE_SECRET_KEY. :type api_key: string :param stripe_account: The optional connected account \\ for which this request is being made. :type stripe_account: string \"\"\" api_key = api_key or self . default_api_key # Prefer passed in stripe_account if set. if not stripe_account : stripe_account = self . _get_stripe_account_id ( api_key ) stripe_subscription_schedule = self . stripe_class . cancel ( self . id , api_key = api_key , stripe_account = stripe_account , stripe_version = djstripe_settings . STRIPE_API_VERSION , ** kwargs , ) return SubscriptionSchedule . sync_from_stripe_data ( stripe_subscription_schedule ) def update ( self , api_key = None , stripe_account = None , ** kwargs ): \"\"\" Updates an existing subscription schedule and returns the updated SubscriptionSchedule. :param api_key: The api key to use for this request. Defaults to djstripe_settings.STRIPE_SECRET_KEY. :type api_key: string :param stripe_account: The optional connected account \\ for which this request is being made. :type stripe_account: string \"\"\" stripe_subscription_schedule = self . _api_update ( api_key = api_key , stripe_account = stripe_account , ** kwargs ) return SubscriptionSchedule . sync_from_stripe_data ( stripe_subscription_schedule ) Attributes djstripe . models . billing . SubscriptionSchedule . canceled_at = StripeDateTimeField ( null = True , blank = True , help_text = 'Time at which the subscription schedule was canceled.' ) class-attribute djstripe . models . billing . SubscriptionSchedule . completed_at = StripeDateTimeField ( null = True , blank = True , help_text = 'Time at which the subscription schedule was completed.' ) class-attribute djstripe . models . billing . SubscriptionSchedule . current_phase = JSONField ( null = True , blank = True , help_text = 'Object representing the start and end dates for the current phase of the subscription schedule, if it is `active`.' ) class-attribute djstripe . models . billing . SubscriptionSchedule . customer = models . ForeignKey ( 'Customer' , on_delete = models . CASCADE , related_name = 'schedules' , help_text = 'The customer who owns the subscription schedule.' ) class-attribute djstripe . models . billing . SubscriptionSchedule . default_settings = JSONField ( null = True , blank = True , help_text = \"Object representing the subscription schedule's default settings.\" ) class-attribute djstripe . models . billing . SubscriptionSchedule . end_behavior = StripeEnumField ( enum = enums . SubscriptionScheduleEndBehavior , help_text = 'Behavior of the subscription schedule and underlying subscription when it ends.' ) class-attribute djstripe . models . billing . SubscriptionSchedule . phases = JSONField ( null = True , blank = True , help_text = \"Configuration for the subscription schedule's phases.\" ) class-attribute djstripe . models . billing . SubscriptionSchedule . released_at = StripeDateTimeField ( null = True , blank = True , help_text = 'Time at which the subscription schedule was released.' ) class-attribute djstripe . models . billing . SubscriptionSchedule . released_subscription = models . ForeignKey ( 'Subscription' , null = True , blank = True , on_delete = models . SET_NULL , related_name = 'released_schedules' , help_text = 'The subscription once managed by this subscription schedule (if it is released).' ) class-attribute djstripe . models . billing . SubscriptionSchedule . status = StripeEnumField ( enum = enums . SubscriptionScheduleStatus , help_text = 'The present status of the subscription schedule. Possible values are `not_started`, `active`, `completed`, `released`, and `canceled`.' ) class-attribute djstripe . models . billing . SubscriptionSchedule . stripe_class = stripe . SubscriptionSchedule class-attribute djstripe . models . billing . SubscriptionSchedule . stripe_dashboard_item_name = 'subscription_schedules' class-attribute djstripe . models . billing . SubscriptionSchedule . subscription = models . ForeignKey ( 'Subscription' , null = True , blank = True , on_delete = models . SET_NULL , related_name = 'subscriptions' , help_text = 'ID of the subscription managed by the subscription schedule.' ) class-attribute Functions djstripe . models . billing . SubscriptionSchedule . cancel ( api_key = None , stripe_account = None , ** kwargs ) Cancels a subscription schedule and its associated subscription immediately (if the subscription schedule has an active subscription). A subscription schedule can only be canceled if its status is not_started or active and returns the Canceled SubscriptionSchedule. :param api_key: The api key to use for this request. Defaults to djstripe_settings.STRIPE_SECRET_KEY. :type api_key: string :param stripe_account: The optional connected account for which this request is being made. :type stripe_account: string Source code in djstripe/models/billing.py 2218 2219 2220 2221 2222 2223 2224 2225 2226 2227 2228 2229 2230 2231 2232 2233 2234 2235 2236 2237 2238 2239 2240 2241 2242 2243 2244 def cancel ( self , api_key = None , stripe_account = None , ** kwargs ): \"\"\" Cancels a subscription schedule and its associated subscription immediately (if the subscription schedule has an active subscription). A subscription schedule can only be canceled if its status is not_started or active and returns the Canceled SubscriptionSchedule. :param api_key: The api key to use for this request. Defaults to djstripe_settings.STRIPE_SECRET_KEY. :type api_key: string :param stripe_account: The optional connected account \\ for which this request is being made. :type stripe_account: string \"\"\" api_key = api_key or self . default_api_key # Prefer passed in stripe_account if set. if not stripe_account : stripe_account = self . _get_stripe_account_id ( api_key ) stripe_subscription_schedule = self . stripe_class . cancel ( self . id , api_key = api_key , stripe_account = stripe_account , stripe_version = djstripe_settings . STRIPE_API_VERSION , ** kwargs , ) return SubscriptionSchedule . sync_from_stripe_data ( stripe_subscription_schedule ) djstripe . models . billing . SubscriptionSchedule . release ( api_key = None , stripe_account = None , ** kwargs ) Releases the subscription schedule immediately, which will stop scheduling of its phases, but leave any existing subscription in place. A schedule can only be released if its status is not_started or active. If the subscription schedule is currently associated with a subscription, releasing it will remove its subscription property and set the subscription\u2019s ID to the released_subscription property and returns the Released SubscriptionSchedule. :param api_key: The api key to use for this request. Defaults to djstripe_settings.STRIPE_SECRET_KEY. :type api_key: string :param stripe_account: The optional connected account for which this request is being made. :type stripe_account: string Source code in djstripe/models/billing.py 2186 2187 2188 2189 2190 2191 2192 2193 2194 2195 2196 2197 2198 2199 2200 2201 2202 2203 2204 2205 2206 2207 2208 2209 2210 2211 2212 2213 2214 2215 2216 def release ( self , api_key = None , stripe_account = None , ** kwargs ): \"\"\" Releases the subscription schedule immediately, which will stop scheduling of its phases, but leave any existing subscription in place. A schedule can only be released if its status is not_started or active. If the subscription schedule is currently associated with a subscription, releasing it will remove its subscription property and set the subscription\u2019s ID to the released_subscription property and returns the Released SubscriptionSchedule. :param api_key: The api key to use for this request. Defaults to djstripe_settings.STRIPE_SECRET_KEY. :type api_key: string :param stripe_account: The optional connected account \\ for which this request is being made. :type stripe_account: string \"\"\" api_key = api_key or self . default_api_key # Prefer passed in stripe_account if set. if not stripe_account : stripe_account = self . _get_stripe_account_id ( api_key ) stripe_subscription_schedule = self . stripe_class . release ( self . id , api_key = api_key , stripe_account = stripe_account , stripe_version = djstripe_settings . STRIPE_API_VERSION , ** kwargs , ) return SubscriptionSchedule . sync_from_stripe_data ( stripe_subscription_schedule ) djstripe . models . billing . SubscriptionSchedule . update ( api_key = None , stripe_account = None , ** kwargs ) Updates an existing subscription schedule and returns the updated SubscriptionSchedule. :param api_key: The api key to use for this request. Defaults to djstripe_settings.STRIPE_SECRET_KEY. :type api_key: string :param stripe_account: The optional connected account for which this request is being made. :type stripe_account: string Source code in djstripe/models/billing.py 2246 2247 2248 2249 2250 2251 2252 2253 2254 2255 2256 2257 2258 2259 2260 def update ( self , api_key = None , stripe_account = None , ** kwargs ): \"\"\" Updates an existing subscription schedule and returns the updated SubscriptionSchedule. :param api_key: The api key to use for this request. Defaults to djstripe_settings.STRIPE_SECRET_KEY. :type api_key: string :param stripe_account: The optional connected account \\ for which this request is being made. :type stripe_account: string \"\"\" stripe_subscription_schedule = self . _api_update ( api_key = api_key , stripe_account = stripe_account , ** kwargs ) return SubscriptionSchedule . sync_from_stripe_data ( stripe_subscription_schedule ) djstripe.models.billing.TaxCode Bases: StripeModel Tax codes classify goods and services for tax purposes. Stripe documentation: https://stripe.com/docs/api/tax_codes Source code in djstripe/models/billing.py 2328 2329 2330 2331 2332 2333 2334 2335 2336 2337 2338 2339 2340 2341 2342 2343 2344 2345 2346 2347 2348 2349 2350 2351 2352 class TaxCode ( StripeModel ): \"\"\" Tax codes classify goods and services for tax purposes. Stripe documentation: https://stripe.com/docs/api/tax_codes \"\"\" stripe_class = stripe . TaxCode metadata = None name = models . CharField ( max_length = 128 , help_text = \"A short name for the tax code.\" , ) class Meta ( StripeModel . Meta ): verbose_name = \"Tax Code\" def __str__ ( self ): return f \" { self . name } : { self . id } \" @classmethod def _find_owner_account ( cls , data , api_key = djstripe_settings . STRIPE_SECRET_KEY ): # Tax Codes do not belong to any Stripe Account pass Attributes djstripe . models . billing . TaxCode . metadata = None class-attribute djstripe . models . billing . TaxCode . name = models . CharField ( max_length = 128 , help_text = 'A short name for the tax code.' ) class-attribute djstripe . models . billing . TaxCode . stripe_class = stripe . TaxCode class-attribute Classes djstripe.models.billing.TaxCode.Meta Bases: StripeModel . Meta Source code in djstripe/models/billing.py 2343 2344 class Meta ( StripeModel . Meta ): verbose_name = \"Tax Code\" Attributes djstripe . models . billing . TaxCode . Meta . verbose_name = 'Tax Code' class-attribute Functions djstripe . models . billing . TaxCode . __str__ () Source code in djstripe/models/billing.py 2346 2347 def __str__ ( self ): return f \" { self . name } : { self . id } \" djstripe . models . billing . TaxCode . _find_owner_account ( data , api_key = djstripe_settings . STRIPE_SECRET_KEY ) classmethod Source code in djstripe/models/billing.py 2349 2350 2351 2352 @classmethod def _find_owner_account ( cls , data , api_key = djstripe_settings . STRIPE_SECRET_KEY ): # Tax Codes do not belong to any Stripe Account pass djstripe.models.billing.TaxId Bases: StripeModel Add one or multiple tax IDs to a customer. A customer's tax IDs are displayed on invoices and credit notes issued for the customer. Stripe documentation: https://stripe.com/docs/api/customer_tax_ids?lang=python Source code in djstripe/models/billing.py 2355 2356 2357 2358 2359 2360 2361 2362 2363 2364 2365 2366 2367 2368 2369 2370 2371 2372 2373 2374 2375 2376 2377 2378 2379 2380 2381 2382 2383 2384 2385 2386 2387 2388 2389 2390 2391 2392 2393 2394 2395 2396 2397 2398 2399 2400 2401 2402 2403 2404 2405 2406 2407 2408 2409 2410 2411 2412 2413 2414 2415 2416 2417 2418 2419 2420 2421 2422 2423 2424 2425 2426 2427 2428 2429 2430 2431 2432 2433 2434 2435 2436 2437 2438 2439 2440 2441 2442 2443 2444 2445 2446 2447 class TaxId ( StripeModel ): \"\"\" Add one or multiple tax IDs to a customer. A customer's tax IDs are displayed on invoices and credit notes issued for the customer. Stripe documentation: https://stripe.com/docs/api/customer_tax_ids?lang=python \"\"\" stripe_class = stripe . TaxId description = None metadata = None country = models . CharField ( max_length = 2 , help_text = \"Two-letter ISO code representing the country of the tax ID.\" , ) customer = StripeForeignKey ( \"djstripe.customer\" , on_delete = models . CASCADE , related_name = \"tax_ids\" ) type = StripeEnumField ( enum = enums . TaxIdType , help_text = \"The status of this subscription.\" ) value = models . CharField ( max_length = 50 , help_text = \"Value of the tax ID.\" ) verification = JSONField ( help_text = \"Tax ID verification information.\" ) def __str__ ( self ): return f \" { enums . TaxIdType . humanize ( self . type ) } { self . value } ( { self . verification . get ( 'status' ) } )\" class Meta ( StripeModel . Meta ): verbose_name = \"Tax ID\" @classmethod def _api_create ( cls , api_key = djstripe_settings . STRIPE_SECRET_KEY , ** kwargs ): \"\"\" Call the stripe API's create operation for this model. :param api_key: The api key to use for this request. \\ Defaults to djstripe_settings.STRIPE_SECRET_KEY. :type api_key: string \"\"\" if not kwargs . get ( \"id\" ): raise KeyError ( \"Customer Object ID is missing\" ) try : Customer . objects . get ( id = kwargs [ \"id\" ]) except Customer . DoesNotExist : raise return stripe . Customer . create_tax_id ( api_key = api_key , ** kwargs ) def api_retrieve ( self , api_key = None , stripe_account = None ): \"\"\" Call the stripe API's retrieve operation for this model. :param api_key: The api key to use for this request. \\ Defaults to djstripe_settings.STRIPE_SECRET_KEY. :type api_key: string :param stripe_account: The optional connected account \\ for which this request is being made. :type stripe_account: string \"\"\" nested_id = self . id id = self . customer . id # Prefer passed in stripe_account if set. if not stripe_account : stripe_account = self . _get_stripe_account_id ( api_key ) return stripe . Customer . retrieve_tax_id ( id = id , nested_id = nested_id , api_key = api_key or self . default_api_key , expand = self . expand_fields , stripe_account = stripe_account , stripe_version = djstripe_settings . STRIPE_API_VERSION , ) @classmethod def api_list ( cls , api_key = djstripe_settings . STRIPE_SECRET_KEY , ** kwargs ): \"\"\" Call the stripe API's list operation for this model. :param api_key: The api key to use for this request. \\ Defaults to djstripe_settings.STRIPE_SECRET_KEY. :type api_key: string See Stripe documentation for accepted kwargs for each object. :returns: an iterator over all items in the query \"\"\" return stripe . Customer . list_tax_ids ( api_key = api_key , stripe_version = djstripe_settings . STRIPE_API_VERSION , ** kwargs , ) . auto_paging_iter () Attributes djstripe . models . billing . TaxId . country = models . CharField ( max_length = 2 , help_text = 'Two-letter ISO code representing the country of the tax ID.' ) class-attribute djstripe . models . billing . TaxId . customer = StripeForeignKey ( 'djstripe.customer' , on_delete = models . CASCADE , related_name = 'tax_ids' ) class-attribute djstripe . models . billing . TaxId . description = None class-attribute djstripe . models . billing . TaxId . metadata = None class-attribute djstripe . models . billing . TaxId . stripe_class = stripe . TaxId class-attribute djstripe . models . billing . TaxId . type = StripeEnumField ( enum = enums . TaxIdType , help_text = 'The status of this subscription.' ) class-attribute djstripe . models . billing . TaxId . value = models . CharField ( max_length = 50 , help_text = 'Value of the tax ID.' ) class-attribute djstripe . models . billing . TaxId . verification = JSONField ( help_text = 'Tax ID verification information.' ) class-attribute Classes djstripe.models.billing.TaxId.Meta Bases: StripeModel . Meta Source code in djstripe/models/billing.py 2384 2385 class Meta ( StripeModel . Meta ): verbose_name = \"Tax ID\" Attributes djstripe . models . billing . TaxId . Meta . verbose_name = 'Tax ID' class-attribute Functions djstripe . models . billing . TaxId . __str__ () Source code in djstripe/models/billing.py 2381 2382 def __str__ ( self ): return f \" { enums . TaxIdType . humanize ( self . type ) } { self . value } ( { self . verification . get ( 'status' ) } )\" djstripe . models . billing . TaxId . _api_create ( api_key = djstripe_settings . STRIPE_SECRET_KEY , ** kwargs ) classmethod Call the stripe API's create operation for this model. :param api_key: The api key to use for this request. Defaults to djstripe_settings.STRIPE_SECRET_KEY. :type api_key: string Source code in djstripe/models/billing.py 2387 2388 2389 2390 2391 2392 2393 2394 2395 2396 2397 2398 2399 2400 2401 2402 2403 2404 2405 @classmethod def _api_create ( cls , api_key = djstripe_settings . STRIPE_SECRET_KEY , ** kwargs ): \"\"\" Call the stripe API's create operation for this model. :param api_key: The api key to use for this request. \\ Defaults to djstripe_settings.STRIPE_SECRET_KEY. :type api_key: string \"\"\" if not kwargs . get ( \"id\" ): raise KeyError ( \"Customer Object ID is missing\" ) try : Customer . objects . get ( id = kwargs [ \"id\" ]) except Customer . DoesNotExist : raise return stripe . Customer . create_tax_id ( api_key = api_key , ** kwargs ) djstripe . models . billing . TaxId . api_list ( api_key = djstripe_settings . STRIPE_SECRET_KEY , ** kwargs ) classmethod Call the stripe API's list operation for this model. :param api_key: The api key to use for this request. Defaults to djstripe_settings.STRIPE_SECRET_KEY. :type api_key: string See Stripe documentation for accepted kwargs for each object. :returns: an iterator over all items in the query Source code in djstripe/models/billing.py 2433 2434 2435 2436 2437 2438 2439 2440 2441 2442 2443 2444 2445 2446 2447 @classmethod def api_list ( cls , api_key = djstripe_settings . STRIPE_SECRET_KEY , ** kwargs ): \"\"\" Call the stripe API's list operation for this model. :param api_key: The api key to use for this request. \\ Defaults to djstripe_settings.STRIPE_SECRET_KEY. :type api_key: string See Stripe documentation for accepted kwargs for each object. :returns: an iterator over all items in the query \"\"\" return stripe . Customer . list_tax_ids ( api_key = api_key , stripe_version = djstripe_settings . STRIPE_API_VERSION , ** kwargs , ) . auto_paging_iter () djstripe . models . billing . TaxId . api_retrieve ( api_key = None , stripe_account = None ) Call the stripe API's retrieve operation for this model. :param api_key: The api key to use for this request. Defaults to djstripe_settings.STRIPE_SECRET_KEY. :type api_key: string :param stripe_account: The optional connected account for which this request is being made. :type stripe_account: string Source code in djstripe/models/billing.py 2407 2408 2409 2410 2411 2412 2413 2414 2415 2416 2417 2418 2419 2420 2421 2422 2423 2424 2425 2426 2427 2428 2429 2430 2431 def api_retrieve ( self , api_key = None , stripe_account = None ): \"\"\" Call the stripe API's retrieve operation for this model. :param api_key: The api key to use for this request. \\ Defaults to djstripe_settings.STRIPE_SECRET_KEY. :type api_key: string :param stripe_account: The optional connected account \\ for which this request is being made. :type stripe_account: string \"\"\" nested_id = self . id id = self . customer . id # Prefer passed in stripe_account if set. if not stripe_account : stripe_account = self . _get_stripe_account_id ( api_key ) return stripe . Customer . retrieve_tax_id ( id = id , nested_id = nested_id , api_key = api_key or self . default_api_key , expand = self . expand_fields , stripe_account = stripe_account , stripe_version = djstripe_settings . STRIPE_API_VERSION , ) djstripe.models.billing.TaxRate Bases: StripeModel Tax rates can be applied to invoices and subscriptions to collect tax. Stripe documentation: https://stripe.com/docs/api/tax_rates?lang=python Source code in djstripe/models/billing.py 2450 2451 2452 2453 2454 2455 2456 2457 2458 2459 2460 2461 2462 2463 2464 2465 2466 2467 2468 2469 2470 2471 2472 2473 2474 2475 2476 2477 2478 2479 2480 2481 2482 2483 2484 2485 2486 2487 2488 2489 2490 2491 2492 2493 2494 2495 2496 2497 2498 2499 2500 2501 2502 2503 2504 2505 2506 2507 2508 2509 2510 class TaxRate ( StripeModel ): \"\"\" Tax rates can be applied to invoices and subscriptions to collect tax. Stripe documentation: https://stripe.com/docs/api/tax_rates?lang=python \"\"\" stripe_class = stripe . TaxRate stripe_dashboard_item_name = \"tax-rates\" active = models . BooleanField ( default = True , help_text = \"Defaults to true. When set to false, this tax rate cannot be \" \"applied to objects in the API, but will still be applied to subscriptions \" \"and invoices that already have it set.\" , ) country = models . CharField ( max_length = 2 , default = \"\" , blank = True , help_text = \"Two-letter country code.\" , ) display_name = models . CharField ( max_length = 50 , default = \"\" , blank = True , help_text = \"The display name of the tax rates as it will appear to your \" \"customer on their receipt email, PDF, and the hosted invoice page.\" , ) inclusive = models . BooleanField ( help_text = \"This specifies if the tax rate is inclusive or exclusive.\" ) jurisdiction = models . CharField ( max_length = 50 , default = \"\" , blank = True , help_text = \"The jurisdiction for the tax rate.\" , ) percentage = StripePercentField ( decimal_places = 4 , max_digits = 7 , help_text = \"This represents the tax rate percent out of 100.\" , ) state = models . CharField ( max_length = 2 , default = \"\" , blank = True , help_text = \"ISO 3166-2 subdivision code, without country prefix.\" , ) tax_type = models . CharField ( default = \"\" , blank = True , max_length = 50 , help_text = \"The high-level tax type, such as vat, gst, sales_tax or custom.\" , ) def __str__ ( self ): return f \" { self . display_name } at { self . percentage } %\" class Meta ( StripeModel . Meta ): verbose_name = \"Tax Rate\" Attributes djstripe . models . billing . TaxRate . active = models . BooleanField ( default = True , help_text = 'Defaults to true. When set to false, this tax rate cannot be applied to objects in the API, but will still be applied to subscriptions and invoices that already have it set.' ) class-attribute djstripe . models . billing . TaxRate . country = models . CharField ( max_length = 2 , default = '' , blank = True , help_text = 'Two-letter country code.' ) class-attribute djstripe . models . billing . TaxRate . display_name = models . CharField ( max_length = 50 , default = '' , blank = True , help_text = 'The display name of the tax rates as it will appear to your customer on their receipt email, PDF, and the hosted invoice page.' ) class-attribute djstripe . models . billing . TaxRate . inclusive = models . BooleanField ( help_text = 'This specifies if the tax rate is inclusive or exclusive.' ) class-attribute djstripe . models . billing . TaxRate . jurisdiction = models . CharField ( max_length = 50 , default = '' , blank = True , help_text = 'The jurisdiction for the tax rate.' ) class-attribute djstripe . models . billing . TaxRate . percentage = StripePercentField ( decimal_places = 4 , max_digits = 7 , help_text = 'This represents the tax rate percent out of 100.' ) class-attribute djstripe . models . billing . TaxRate . state = models . CharField ( max_length = 2 , default = '' , blank = True , help_text = 'ISO 3166-2 subdivision code, without country prefix.' ) class-attribute djstripe . models . billing . TaxRate . stripe_class = stripe . TaxRate class-attribute djstripe . models . billing . TaxRate . stripe_dashboard_item_name = 'tax-rates' class-attribute djstripe . models . billing . TaxRate . tax_type = models . CharField ( default = '' , blank = True , max_length = 50 , help_text = 'The high-level tax type, such as vat, gst, sales_tax or custom.' ) class-attribute Classes djstripe.models.billing.TaxRate.Meta Bases: StripeModel . Meta Source code in djstripe/models/billing.py 2509 2510 class Meta ( StripeModel . Meta ): verbose_name = \"Tax Rate\" Attributes djstripe . models . billing . TaxRate . Meta . verbose_name = 'Tax Rate' class-attribute Functions djstripe . models . billing . TaxRate . __str__ () Source code in djstripe/models/billing.py 2506 2507 def __str__ ( self ): return f \" { self . display_name } at { self . percentage } %\" djstripe.models.billing.UpcomingInvoice Bases: BaseInvoice The preview of an upcoming invoice - does not exist in the Django database. See BaseInvoice.upcoming() Logically it should be set abstract, but that doesn't quite work since we do actually want to instantiate the model and use relations. Source code in djstripe/models/billing.py 853 854 855 856 857 858 859 860 861 862 863 864 865 866 867 868 869 870 871 872 873 874 875 876 877 878 879 880 881 882 883 884 885 886 887 888 889 890 891 892 893 894 895 896 897 898 899 900 901 902 903 904 905 906 907 908 909 910 911 912 913 914 915 916 917 918 919 920 921 922 923 924 925 926 927 928 929 930 931 932 933 934 935 936 937 938 939 940 941 942 943 944 945 946 947 948 949 950 951 952 953 954 955 956 957 958 959 960 961 962 963 964 965 966 967 968 969 970 971 972 973 974 975 976 977 978 979 980 981 982 983 984 985 986 987 988 989 990 991 992 class UpcomingInvoice ( BaseInvoice ): \"\"\" The preview of an upcoming invoice - does not exist in the Django database. See BaseInvoice.upcoming() Logically it should be set abstract, but that doesn't quite work since we do actually want to instantiate the model and use relations. \"\"\" default_source = PaymentMethodForeignKey ( on_delete = models . SET_NULL , null = True , related_name = \"upcoming_invoices\" , help_text = \"The default payment source for the invoice. \" \"It must belong to the customer associated with the invoice and be \" \"in a chargeable state. If not set, defaults to the subscription's \" \"default source, if any, or to the customer's default source.\" , ) def __init__ ( self , * args , ** kwargs ): super () . __init__ ( * args , ** kwargs ) self . _lineitems = [] self . _default_tax_rates = [] self . _total_tax_amounts = [] def get_stripe_dashboard_url ( self ): return \"\" def _attach_objects_hook ( self , cls , data , api_key = djstripe_settings . STRIPE_SECRET_KEY , current_ids = None ): super () . _attach_objects_hook ( cls , data , api_key = api_key , current_ids = current_ids ) self . _lineitems = cls . _stripe_object_to_line_items ( target_cls = LineItem , data = data , invoice = self , api_key = api_key ) def _attach_objects_post_save_hook ( self , cls , data , api_key = djstripe_settings . STRIPE_SECRET_KEY , pending_relations = None , ): super () . _attach_objects_post_save_hook ( cls , data , api_key = api_key , pending_relations = pending_relations ) self . _default_tax_rates = cls . _stripe_object_to_default_tax_rates ( target_cls = TaxRate , data = data , api_key = api_key ) total_tax_amounts = [] for tax_amount_data in data . get ( \"total_tax_amounts\" , []): tax_rate_id = tax_amount_data [ \"tax_rate\" ] if not isinstance ( tax_rate_id , str ): tax_rate_id = tax_rate_id [ \"tax_rate\" ] tax_rate = TaxRate . _get_or_retrieve ( id = tax_rate_id , api_key = api_key ) tax_amount = DjstripeUpcomingInvoiceTotalTaxAmount ( invoice = self , amount = tax_amount_data [ \"amount\" ], inclusive = tax_amount_data [ \"inclusive\" ], tax_rate = tax_rate , ) total_tax_amounts . append ( tax_amount ) self . _total_tax_amounts = total_tax_amounts @property def invoiceitems ( self ): \"\"\" Gets the invoice items associated with this upcoming invoice. This differs from normal (non-upcoming) invoices, in that upcoming invoices are in-memory and do not persist to the database. Therefore, all of the data comes from the Stripe API itself. Instead of returning a normal queryset for the invoiceitems, this will return a mock of a queryset, but with the data fetched from Stripe - It will act like a normal queryset, but mutation will silently fail. \"\"\" # filter lineitems with type=\"invoice_item\" and fetch all the actual InvoiceItem objects items = [] for item in self . _lineitems : if item . type == \"invoice_item\" : items . append ( item . invoice_item ) return QuerySetMock . from_iterable ( InvoiceItem , items ) @property def lineitems ( self ): \"\"\" Gets the line items associated with this upcoming invoice. This differs from normal (non-upcoming) invoices, in that upcoming invoices are in-memory and do not persist to the database. Therefore, all of the data comes from the Stripe API itself. Instead of returning a normal queryset for the lineitems, this will return a mock of a queryset, but with the data fetched from Stripe - It will act like a normal queryset, but mutation will silently fail. \"\"\" return QuerySetMock . from_iterable ( LineItem , self . _lineitems ) @property def default_tax_rates ( self ): \"\"\" Gets the default tax rates associated with this upcoming invoice. :return: \"\"\" return QuerySetMock . from_iterable ( TaxRate , self . _default_tax_rates ) @property def total_tax_amounts ( self ): \"\"\" Gets the total tax amounts associated with this upcoming invoice. :return: \"\"\" return QuerySetMock . from_iterable ( DjstripeUpcomingInvoiceTotalTaxAmount , self . _total_tax_amounts ) @property def id ( self ): return None @id . setter def id ( self , value ): return # noop def save ( self , * args , ** kwargs ): return # noop Attributes djstripe . models . billing . UpcomingInvoice . _default_tax_rates = [] instance-attribute djstripe . models . billing . UpcomingInvoice . _lineitems = [] instance-attribute djstripe . models . billing . UpcomingInvoice . _total_tax_amounts = [] instance-attribute djstripe . models . billing . UpcomingInvoice . default_source = PaymentMethodForeignKey ( on_delete = models . SET_NULL , null = True , related_name = 'upcoming_invoices' , help_text = \"The default payment source for the invoice. It must belong to the customer associated with the invoice and be in a chargeable state. If not set, defaults to the subscription's default source, if any, or to the customer's default source.\" ) class-attribute djstripe . models . billing . UpcomingInvoice . default_tax_rates property Gets the default tax rates associated with this upcoming invoice. :return: djstripe . models . billing . UpcomingInvoice . id property writable djstripe . models . billing . UpcomingInvoice . invoiceitems property Gets the invoice items associated with this upcoming invoice. This differs from normal (non-upcoming) invoices, in that upcoming invoices are in-memory and do not persist to the database. Therefore, all of the data comes from the Stripe API itself. Instead of returning a normal queryset for the invoiceitems, this will return a mock of a queryset, but with the data fetched from Stripe - It will act like a normal queryset, but mutation will silently fail. djstripe . models . billing . UpcomingInvoice . lineitems property Gets the line items associated with this upcoming invoice. This differs from normal (non-upcoming) invoices, in that upcoming invoices are in-memory and do not persist to the database. Therefore, all of the data comes from the Stripe API itself. Instead of returning a normal queryset for the lineitems, this will return a mock of a queryset, but with the data fetched from Stripe - It will act like a normal queryset, but mutation will silently fail. djstripe . models . billing . UpcomingInvoice . total_tax_amounts property Gets the total tax amounts associated with this upcoming invoice. :return: Functions djstripe . models . billing . UpcomingInvoice . __init__ ( * args , ** kwargs ) Source code in djstripe/models/billing.py 873 874 875 876 877 878 def __init__ ( self , * args , ** kwargs ): super () . __init__ ( * args , ** kwargs ) self . _lineitems = [] self . _default_tax_rates = [] self . _total_tax_amounts = [] djstripe . models . billing . UpcomingInvoice . _attach_objects_hook ( cls , data , api_key = djstripe_settings . STRIPE_SECRET_KEY , current_ids = None ) Source code in djstripe/models/billing.py 883 884 885 886 887 888 889 890 891 892 def _attach_objects_hook ( self , cls , data , api_key = djstripe_settings . STRIPE_SECRET_KEY , current_ids = None ): super () . _attach_objects_hook ( cls , data , api_key = api_key , current_ids = current_ids ) self . _lineitems = cls . _stripe_object_to_line_items ( target_cls = LineItem , data = data , invoice = self , api_key = api_key ) djstripe . models . billing . UpcomingInvoice . _attach_objects_post_save_hook ( cls , data , api_key = djstripe_settings . STRIPE_SECRET_KEY , pending_relations = None ) Source code in djstripe/models/billing.py 894 895 896 897 898 899 900 901 902 903 904 905 906 907 908 909 910 911 912 913 914 915 916 917 918 919 920 921 922 923 924 925 926 927 def _attach_objects_post_save_hook ( self , cls , data , api_key = djstripe_settings . STRIPE_SECRET_KEY , pending_relations = None , ): super () . _attach_objects_post_save_hook ( cls , data , api_key = api_key , pending_relations = pending_relations ) self . _default_tax_rates = cls . _stripe_object_to_default_tax_rates ( target_cls = TaxRate , data = data , api_key = api_key ) total_tax_amounts = [] for tax_amount_data in data . get ( \"total_tax_amounts\" , []): tax_rate_id = tax_amount_data [ \"tax_rate\" ] if not isinstance ( tax_rate_id , str ): tax_rate_id = tax_rate_id [ \"tax_rate\" ] tax_rate = TaxRate . _get_or_retrieve ( id = tax_rate_id , api_key = api_key ) tax_amount = DjstripeUpcomingInvoiceTotalTaxAmount ( invoice = self , amount = tax_amount_data [ \"amount\" ], inclusive = tax_amount_data [ \"inclusive\" ], tax_rate = tax_rate , ) total_tax_amounts . append ( tax_amount ) self . _total_tax_amounts = total_tax_amounts djstripe . models . billing . UpcomingInvoice . get_stripe_dashboard_url () Source code in djstripe/models/billing.py 880 881 def get_stripe_dashboard_url ( self ): return \"\" djstripe . models . billing . UpcomingInvoice . save ( * args , ** kwargs ) Source code in djstripe/models/billing.py 991 992 def save ( self , * args , ** kwargs ): return # noop djstripe.models.billing.UsageRecord Bases: StripeModel Usage records allow you to continually report usage and metrics to Stripe for metered billing of plans. Stripe documentation: https://stripe.com/docs/api?lang=python#usage_records Source code in djstripe/models/billing.py 2513 2514 2515 2516 2517 2518 2519 2520 2521 2522 2523 2524 2525 2526 2527 2528 2529 2530 2531 2532 2533 2534 2535 2536 2537 2538 2539 2540 2541 2542 2543 2544 2545 2546 2547 2548 2549 2550 2551 2552 2553 2554 2555 2556 2557 2558 2559 2560 2561 2562 2563 2564 2565 2566 2567 2568 2569 2570 2571 2572 2573 2574 2575 2576 2577 2578 2579 2580 2581 2582 2583 2584 2585 2586 class UsageRecord ( StripeModel ): \"\"\" Usage records allow you to continually report usage and metrics to Stripe for metered billing of plans. Stripe documentation: https://stripe.com/docs/api?lang=python#usage_records \"\"\" description = None metadata = None stripe_class = stripe . UsageRecord quantity = models . PositiveIntegerField ( help_text = ( \"The quantity of the plan to which the customer should be subscribed.\" ) ) subscription_item = StripeForeignKey ( \"SubscriptionItem\" , on_delete = models . CASCADE , related_name = \"usage_records\" , help_text = \"The subscription item this usage record contains data for.\" , ) timestamp = StripeDateTimeField ( null = True , blank = True , help_text = \"The timestamp for the usage event. This timestamp must be within the current billing period of the subscription of the provided subscription_item.\" , ) action = StripeEnumField ( enum = enums . UsageAction , default = enums . UsageAction . increment , help_text = \"When using increment the specified quantity will be added to the usage at the specified timestamp. The set action will overwrite the usage quantity at that timestamp. If the subscription has billing thresholds, increment is the only allowed value.\" , ) def __str__ ( self ): return f \"Usage for { self . subscription_item } ( { self . action } ) is { self . quantity } \" @classmethod def _api_create ( cls , api_key = djstripe_settings . STRIPE_SECRET_KEY , ** kwargs ): \"\"\" Call the stripe API's create operation for this model. :param api_key: The api key to use for this request. \\ Defaults to djstripe_settings.STRIPE_SECRET_KEY. :type api_key: string \"\"\" if not kwargs . get ( \"id\" ): raise KeyError ( \"SubscriptionItem Object ID is missing\" ) try : SubscriptionItem . objects . get ( id = kwargs [ \"id\" ]) except SubscriptionItem . DoesNotExist : raise usage_stripe_data = stripe . SubscriptionItem . create_usage_record ( api_key = api_key , ** kwargs ) # ! Hack: there is no way to retrieve a UsageRecord object from Stripe, # ! which is why we create and sync it right here cls . sync_from_stripe_data ( usage_stripe_data , api_key = api_key ) return usage_stripe_data @classmethod def create ( cls , ** kwargs ): \"\"\" A wrapper around _api_create() to allow one to create and sync UsageRecord Objects \"\"\" return cls . _api_create ( ** kwargs ) Attributes djstripe . models . billing . UsageRecord . action = StripeEnumField ( enum = enums . UsageAction , default = enums . UsageAction . increment , help_text = 'When using increment the specified quantity will be added to the usage at the specified timestamp. The set action will overwrite the usage quantity at that timestamp. If the subscription has billing thresholds, increment is the only allowed value.' ) class-attribute djstripe . models . billing . UsageRecord . description = None class-attribute djstripe . models . billing . UsageRecord . metadata = None class-attribute djstripe . models . billing . UsageRecord . quantity = models . PositiveIntegerField ( help_text = 'The quantity of the plan to which the customer should be subscribed.' ) class-attribute djstripe . models . billing . UsageRecord . stripe_class = stripe . UsageRecord class-attribute djstripe . models . billing . UsageRecord . subscription_item = StripeForeignKey ( 'SubscriptionItem' , on_delete = models . CASCADE , related_name = 'usage_records' , help_text = 'The subscription item this usage record contains data for.' ) class-attribute djstripe . models . billing . UsageRecord . timestamp = StripeDateTimeField ( null = True , blank = True , help_text = 'The timestamp for the usage event. This timestamp must be within the current billing period of the subscription of the provided subscription_item.' ) class-attribute Functions djstripe . models . billing . UsageRecord . __str__ () Source code in djstripe/models/billing.py 2550 2551 def __str__ ( self ): return f \"Usage for { self . subscription_item } ( { self . action } ) is { self . quantity } \" djstripe . models . billing . UsageRecord . _api_create ( api_key = djstripe_settings . STRIPE_SECRET_KEY , ** kwargs ) classmethod Call the stripe API's create operation for this model. :param api_key: The api key to use for this request. Defaults to djstripe_settings.STRIPE_SECRET_KEY. :type api_key: string Source code in djstripe/models/billing.py 2553 2554 2555 2556 2557 2558 2559 2560 2561 2562 2563 2564 2565 2566 2567 2568 2569 2570 2571 2572 2573 2574 2575 2576 2577 2578 2579 @classmethod def _api_create ( cls , api_key = djstripe_settings . STRIPE_SECRET_KEY , ** kwargs ): \"\"\" Call the stripe API's create operation for this model. :param api_key: The api key to use for this request. \\ Defaults to djstripe_settings.STRIPE_SECRET_KEY. :type api_key: string \"\"\" if not kwargs . get ( \"id\" ): raise KeyError ( \"SubscriptionItem Object ID is missing\" ) try : SubscriptionItem . objects . get ( id = kwargs [ \"id\" ]) except SubscriptionItem . DoesNotExist : raise usage_stripe_data = stripe . SubscriptionItem . create_usage_record ( api_key = api_key , ** kwargs ) # ! Hack: there is no way to retrieve a UsageRecord object from Stripe, # ! which is why we create and sync it right here cls . sync_from_stripe_data ( usage_stripe_data , api_key = api_key ) return usage_stripe_data djstripe . models . billing . UsageRecord . create ( ** kwargs ) classmethod A wrapper around _api_create() to allow one to create and sync UsageRecord Objects Source code in djstripe/models/billing.py 2581 2582 2583 2584 2585 2586 @classmethod def create ( cls , ** kwargs ): \"\"\" A wrapper around _api_create() to allow one to create and sync UsageRecord Objects \"\"\" return cls . _api_create ( ** kwargs ) djstripe.models.billing.UsageRecordSummary Bases: StripeModel Usage record summaries provides usage information that's been summarized from multiple usage records and over a subscription billing period (e.g., 15 usage records in the month of September). Since new usage records can still be added, the returned summary information for the subscription item's ID should be seen as unstable until the subscription billing period ends. Stripe documentation: https://stripe.com/docs/api/usage_records/subscription_item_summary_list?lang=python Source code in djstripe/models/billing.py 2589 2590 2591 2592 2593 2594 2595 2596 2597 2598 2599 2600 2601 2602 2603 2604 2605 2606 2607 2608 2609 2610 2611 2612 2613 2614 2615 2616 2617 2618 2619 2620 2621 2622 2623 2624 2625 2626 2627 2628 2629 2630 2631 2632 2633 2634 2635 2636 2637 2638 2639 2640 2641 2642 2643 2644 2645 2646 2647 2648 2649 2650 2651 2652 2653 2654 2655 2656 2657 2658 2659 2660 2661 2662 2663 2664 2665 2666 2667 2668 2669 2670 2671 2672 2673 2674 class UsageRecordSummary ( StripeModel ): \"\"\" Usage record summaries provides usage information that's been summarized from multiple usage records and over a subscription billing period (e.g., 15 usage records in the month of September). Since new usage records can still be added, the returned summary information for the subscription item's ID should be seen as unstable until the subscription billing period ends. Stripe documentation: https://stripe.com/docs/api/usage_records/subscription_item_summary_list?lang=python \"\"\" stripe_class = stripe . UsageRecordSummary description = None metadata = None invoice = StripeForeignKey ( \"Invoice\" , null = True , blank = True , on_delete = models . CASCADE , related_name = \"usage_record_summaries\" , ) period = JSONField ( null = True , blank = True , help_text = \"Subscription Billing period for the SubscriptionItem\" , ) period_end = StripeDateTimeField ( null = True , blank = True , help_text = \"End of the Subscription Billing period for the SubscriptionItem\" , ) period_start = StripeDateTimeField ( null = True , blank = True , help_text = \"Start of the Subscription Billing period for the SubscriptionItem\" , ) total_usage = models . PositiveIntegerField ( help_text = ( \"The quantity of the plan to which the customer should be subscribed.\" ) ) subscription_item = StripeForeignKey ( \"SubscriptionItem\" , on_delete = models . CASCADE , related_name = \"usage_record_summaries\" , help_text = \"The subscription item this usage record contains data for.\" , ) def __str__ ( self ): return f \"Usage Summary for { self . subscription_item } ( { self . invoice } ) is { self . total_usage } \" @classmethod def _manipulate_stripe_object_hook ( cls , data ): data [ \"period_start\" ] = data [ \"period\" ][ \"start\" ] data [ \"period_end\" ] = data [ \"period\" ][ \"end\" ] return data @classmethod def api_list ( cls , api_key = djstripe_settings . STRIPE_SECRET_KEY , ** kwargs ): \"\"\" Call the stripe API's list operation for this model. :param api_key: The api key to use for this request. \\ Defaults to djstripe_settings.STRIPE_SECRET_KEY. :type api_key: string See Stripe documentation for accepted kwargs for each object. :returns: an iterator over all items in the query \"\"\" if not kwargs . get ( \"id\" ): raise KeyError ( \"SubscriptionItem Object ID is missing\" ) try : SubscriptionItem . objects . get ( id = kwargs [ \"id\" ]) except SubscriptionItem . DoesNotExist : raise return stripe . SubscriptionItem . list_usage_record_summaries ( api_key = api_key , stripe_version = djstripe_settings . STRIPE_API_VERSION , ** kwargs , ) . auto_paging_iter () Attributes djstripe . models . billing . UsageRecordSummary . description = None class-attribute djstripe . models . billing . UsageRecordSummary . invoice = StripeForeignKey ( 'Invoice' , null = True , blank = True , on_delete = models . CASCADE , related_name = 'usage_record_summaries' ) class-attribute djstripe . models . billing . UsageRecordSummary . metadata = None class-attribute djstripe . models . billing . UsageRecordSummary . period = JSONField ( null = True , blank = True , help_text = 'Subscription Billing period for the SubscriptionItem' ) class-attribute djstripe . models . billing . UsageRecordSummary . period_end = StripeDateTimeField ( null = True , blank = True , help_text = 'End of the Subscription Billing period for the SubscriptionItem' ) class-attribute djstripe . models . billing . UsageRecordSummary . period_start = StripeDateTimeField ( null = True , blank = True , help_text = 'Start of the Subscription Billing period for the SubscriptionItem' ) class-attribute djstripe . models . billing . UsageRecordSummary . stripe_class = stripe . UsageRecordSummary class-attribute djstripe . models . billing . UsageRecordSummary . subscription_item = StripeForeignKey ( 'SubscriptionItem' , on_delete = models . CASCADE , related_name = 'usage_record_summaries' , help_text = 'The subscription item this usage record contains data for.' ) class-attribute djstripe . models . billing . UsageRecordSummary . total_usage = models . PositiveIntegerField ( help_text = 'The quantity of the plan to which the customer should be subscribed.' ) class-attribute Functions djstripe . models . billing . UsageRecordSummary . __str__ () Source code in djstripe/models/billing.py 2639 2640 def __str__ ( self ): return f \"Usage Summary for { self . subscription_item } ( { self . invoice } ) is { self . total_usage } \" djstripe . models . billing . UsageRecordSummary . _manipulate_stripe_object_hook ( data ) classmethod Source code in djstripe/models/billing.py 2642 2643 2644 2645 2646 2647 @classmethod def _manipulate_stripe_object_hook ( cls , data ): data [ \"period_start\" ] = data [ \"period\" ][ \"start\" ] data [ \"period_end\" ] = data [ \"period\" ][ \"end\" ] return data djstripe . models . billing . UsageRecordSummary . api_list ( api_key = djstripe_settings . STRIPE_SECRET_KEY , ** kwargs ) classmethod Call the stripe API's list operation for this model. :param api_key: The api key to use for this request. Defaults to djstripe_settings.STRIPE_SECRET_KEY. :type api_key: string See Stripe documentation for accepted kwargs for each object. :returns: an iterator over all items in the query Source code in djstripe/models/billing.py 2649 2650 2651 2652 2653 2654 2655 2656 2657 2658 2659 2660 2661 2662 2663 2664 2665 2666 2667 2668 2669 2670 2671 2672 2673 2674 @classmethod def api_list ( cls , api_key = djstripe_settings . STRIPE_SECRET_KEY , ** kwargs ): \"\"\" Call the stripe API's list operation for this model. :param api_key: The api key to use for this request. \\ Defaults to djstripe_settings.STRIPE_SECRET_KEY. :type api_key: string See Stripe documentation for accepted kwargs for each object. :returns: an iterator over all items in the query \"\"\" if not kwargs . get ( \"id\" ): raise KeyError ( \"SubscriptionItem Object ID is missing\" ) try : SubscriptionItem . objects . get ( id = kwargs [ \"id\" ]) except SubscriptionItem . DoesNotExist : raise return stripe . SubscriptionItem . list_usage_record_summaries ( api_key = api_key , stripe_version = djstripe_settings . STRIPE_API_VERSION , ** kwargs , ) . auto_paging_iter () Functions Connect Attributes Classes djstripe.models.account.Account Bases: StripeModel This is an object representing a Stripe account. You can retrieve it to see properties on the account like its current e-mail address or if the account is enabled yet to make live charges. Stripe documentation: https://stripe.com/docs/api/accounts?lang=python Source code in djstripe/models/account.py 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 class Account ( StripeModel ): \"\"\" This is an object representing a Stripe account. You can retrieve it to see properties on the account like its current e-mail address or if the account is enabled yet to make live charges. Stripe documentation: https://stripe.com/docs/api/accounts?lang=python \"\"\" stripe_class = stripe . Account business_profile = JSONField ( null = True , blank = True , help_text = \"Optional information related to the business.\" ) business_type = StripeEnumField ( enum = enums . BusinessType , default = \"\" , blank = True , help_text = \"The business type.\" ) charges_enabled = models . BooleanField ( help_text = \"Whether the account can create live charges\" ) country = models . CharField ( max_length = 2 , help_text = \"The country of the account\" ) company = JSONField ( null = True , blank = True , help_text = ( \"Information about the company or business. \" \"This field is null unless business_type is set to company.\" ), ) default_currency = StripeCurrencyCodeField ( help_text = \"The currency this account has chosen to use as the default\" ) details_submitted = models . BooleanField ( help_text = ( \"Whether account details have been submitted. \" \"Standard accounts cannot receive payouts before this is true.\" ) ) email = models . CharField ( max_length = 255 , help_text = \"The primary user's email address.\" ) # TODO external_accounts = ... individual = JSONField ( null = True , blank = True , help_text = ( \"Information about the person represented by the account. \" \"This field is null unless business_type is set to individual.\" ), ) payouts_enabled = models . BooleanField ( null = True , help_text = \"Whether Stripe can send payouts to this account\" ) product_description = models . CharField ( max_length = 255 , default = \"\" , blank = True , help_text = \"Internal-only description of the product sold or service provided \" \"by the business. It's used by Stripe for risk and underwriting purposes.\" , ) requirements = JSONField ( null = True , blank = True , help_text = \"Information about the requirements for the account, \" \"including what information needs to be collected, and by when.\" , ) settings = JSONField ( null = True , blank = True , help_text = ( \"Account options for customizing how the account functions within Stripe.\" ), ) type = StripeEnumField ( enum = enums . AccountType , help_text = \"The Stripe account type.\" ) tos_acceptance = JSONField ( null = True , blank = True , help_text = \"Details on the acceptance of the Stripe Services Agreement\" , ) def get_stripe_dashboard_url ( self ) -> str : \"\"\"Get the stripe dashboard url for this object.\"\"\" return ( f \"https://dashboard.stripe.com/ { self . id } /\" f \" { 'test/' if not self . livemode else '' } dashboard\" ) @property def default_api_key ( self ) -> str : return self . get_default_api_key () def get_default_api_key ( self , livemode : bool = None ) -> str : if livemode is None : livemode = self . livemode api_key = APIKey . objects . filter ( djstripe_owner_account = self , type = APIKeyType . secret ) . first () else : api_key = APIKey . objects . filter ( djstripe_owner_account = self , type = APIKeyType . secret , livemode = livemode ) . first () if api_key : return api_key . secret return djstripe_settings . get_default_api_key ( livemode ) @property def business_url ( self ) -> str : \"\"\" The business's publicly available website. \"\"\" if self . business_profile : return self . business_profile . get ( \"url\" , \"\" ) return \"\" @classmethod def get_default_account ( cls , api_key = djstripe_settings . STRIPE_SECRET_KEY ): # As of API version 2020-03-02, there is no permission that can allow # restricted keys to call GET /v1/account if djstripe_settings . STRIPE_SECRET_KEY . startswith ( \"rk_\" ): return None account_data = cls . stripe_class . retrieve ( api_key = api_key , stripe_version = djstripe_settings . STRIPE_API_VERSION ) return cls . _get_or_create_from_stripe_object ( account_data , api_key = api_key )[ 0 ] @classmethod def get_or_retrieve_for_api_key ( cls , api_key : str ): with transaction . atomic (): apikey_instance , _ = APIKey . objects . get_or_create_by_api_key ( api_key ) if not apikey_instance . djstripe_owner_account : apikey_instance . refresh_account () return apikey_instance . djstripe_owner_account def __str__ ( self ): settings = self . settings or {} business_profile = self . business_profile or {} return ( settings . get ( \"dashboard\" , {}) . get ( \"display_name\" ) or business_profile . get ( \"name\" ) or super () . __str__ () ) def api_reject ( self , api_key = None , stripe_account = None , ** kwargs ): \"\"\" Call the stripe API's reject operation for Account model :param api_key: The api key to use for this request. Defaults to djstripe_settings.STRIPE_SECRET_KEY. :type api_key: string :param stripe_account: The optional connected account \\ for which this request is being made. :type stripe_account: string \"\"\" api_key = api_key or self . default_api_key # Prefer passed in stripe_account if set. if not stripe_account : stripe_account = self . _get_stripe_account_id ( api_key ) return self . stripe_class . reject ( self . id , api_key = api_key , stripe_account = stripe_account , stripe_version = djstripe_settings . STRIPE_API_VERSION , ** kwargs , ) @classmethod def _create_from_stripe_object ( cls , data , current_ids = None , pending_relations = None , save = True , stripe_account = None , api_key = djstripe_settings . STRIPE_SECRET_KEY , ): \"\"\" Set the stripe_account to the id of the Account instance being created. This ensures that the foreign-key relations that may exist in stripe are fetched using the appropriate connected account ID. \"\"\" return super () . _create_from_stripe_object ( data = data , current_ids = current_ids , pending_relations = pending_relations , save = save , stripe_account = data [ \"id\" ] if not stripe_account else stripe_account , api_key = api_key , ) # \"Special\" handling of the icon and logo fields # Previously available as properties, they moved to # settings.branding in Stripe 2019-02-19. # Currently, they return a File ID @property def branding_icon ( self ): from ..models.core import File id = self . settings . get ( \"branding\" , {}) . get ( \"icon\" ) return File . objects . filter ( id = id ) . first () if id else None @property def branding_logo ( self ): from ..models.core import File id = self . settings . get ( \"branding\" , {}) . get ( \"logo\" ) return File . objects . filter ( id = id ) . first () if id else None def _attach_objects_post_save_hook ( self , cls , data , pending_relations = None , api_key = djstripe_settings . STRIPE_SECRET_KEY , ): from ..models.core import File super () . _attach_objects_post_save_hook ( cls , data , pending_relations = pending_relations , api_key = api_key ) # set the livemode if not returned by data if \"livemode\" not in data . keys () and self . djstripe_owner_account is not None : # Platform Account if self == self . djstripe_owner_account : self . livemode = None else : # Connected Account _ , self . livemode = get_api_key_details_by_prefix ( api_key ) # save the updates self . save () # Retrieve and save the Files in the settings.branding object. for field in \"icon\" , \"logo\" : file_upload_id = self . settings and self . settings . get ( \"branding\" , {}) . get ( field ) if file_upload_id : try : File . sync_from_stripe_data ( File ( id = file_upload_id ) . api_retrieve ( stripe_account = self . id , api_key = api_key ), api_key = api_key , ) except stripe . error . PermissionError : # No permission to retrieve the data with the key logger . warning ( f \"Cannot retrieve business branding { field } for acct { self . id } with the key.\" ) except stripe . error . InvalidRequestError as e : if \"a similar object exists in\" in str ( e ): # HACK around a Stripe bug. # See #830 and commit c09d25f52bfdcf883e9eec0bf6c25af1771a644a pass else : raise except stripe . error . AuthenticationError : # This may happen if saving an account that has a logo, using # a different API key to the default. # OK, concretely, there is a chicken-and-egg problem here. # But, the logo file object is not a particularly important thing. # Until we have a better solution, just ignore this error. pass Attributes djstripe . models . account . Account . branding_icon property djstripe . models . account . Account . branding_logo property djstripe . models . account . Account . business_profile = JSONField ( null = True , blank = True , help_text = 'Optional information related to the business.' ) class-attribute djstripe . models . account . Account . business_type = StripeEnumField ( enum = enums . BusinessType , default = '' , blank = True , help_text = 'The business type.' ) class-attribute djstripe . models . account . Account . business_url : str property The business's publicly available website. djstripe . models . account . Account . charges_enabled = models . BooleanField ( help_text = 'Whether the account can create live charges' ) class-attribute djstripe . models . account . Account . company = JSONField ( null = True , blank = True , help_text = 'Information about the company or business. This field is null unless business_type is set to company.' ) class-attribute djstripe . models . account . Account . country = models . CharField ( max_length = 2 , help_text = 'The country of the account' ) class-attribute djstripe . models . account . Account . default_api_key : str property djstripe . models . account . Account . default_currency = StripeCurrencyCodeField ( help_text = 'The currency this account has chosen to use as the default' ) class-attribute djstripe . models . account . Account . details_submitted = models . BooleanField ( help_text = 'Whether account details have been submitted. Standard accounts cannot receive payouts before this is true.' ) class-attribute djstripe . models . account . Account . email = models . CharField ( max_length = 255 , help_text = \"The primary user's email address.\" ) class-attribute djstripe . models . account . Account . individual = JSONField ( null = True , blank = True , help_text = 'Information about the person represented by the account. This field is null unless business_type is set to individual.' ) class-attribute djstripe . models . account . Account . payouts_enabled = models . BooleanField ( null = True , help_text = 'Whether Stripe can send payouts to this account' ) class-attribute djstripe . models . account . Account . product_description = models . CharField ( max_length = 255 , default = '' , blank = True , help_text = \"Internal-only description of the product sold or service provided by the business. It's used by Stripe for risk and underwriting purposes.\" ) class-attribute djstripe . models . account . Account . requirements = JSONField ( null = True , blank = True , help_text = 'Information about the requirements for the account, including what information needs to be collected, and by when.' ) class-attribute djstripe . models . account . Account . settings = JSONField ( null = True , blank = True , help_text = 'Account options for customizing how the account functions within Stripe.' ) class-attribute djstripe . models . account . Account . stripe_class = stripe . Account class-attribute djstripe . models . account . Account . tos_acceptance = JSONField ( null = True , blank = True , help_text = 'Details on the acceptance of the Stripe Services Agreement' ) class-attribute djstripe . models . account . Account . type = StripeEnumField ( enum = enums . AccountType , help_text = 'The Stripe account type.' ) class-attribute Functions djstripe . models . account . Account . __str__ () Source code in djstripe/models/account.py 149 150 151 152 153 154 155 156 def __str__ ( self ): settings = self . settings or {} business_profile = self . business_profile or {} return ( settings . get ( \"dashboard\" , {}) . get ( \"display_name\" ) or business_profile . get ( \"name\" ) or super () . __str__ () ) djstripe . models . account . Account . api_reject ( api_key = None , stripe_account = None , ** kwargs ) Call the stripe API's reject operation for Account model :param api_key: The api key to use for this request. Defaults to djstripe_settings.STRIPE_SECRET_KEY. :type api_key: string :param stripe_account: The optional connected account for which this request is being made. :type stripe_account: string Source code in djstripe/models/account.py 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 def api_reject ( self , api_key = None , stripe_account = None , ** kwargs ): \"\"\" Call the stripe API's reject operation for Account model :param api_key: The api key to use for this request. Defaults to djstripe_settings.STRIPE_SECRET_KEY. :type api_key: string :param stripe_account: The optional connected account \\ for which this request is being made. :type stripe_account: string \"\"\" api_key = api_key or self . default_api_key # Prefer passed in stripe_account if set. if not stripe_account : stripe_account = self . _get_stripe_account_id ( api_key ) return self . stripe_class . reject ( self . id , api_key = api_key , stripe_account = stripe_account , stripe_version = djstripe_settings . STRIPE_API_VERSION , ** kwargs , ) djstripe . models . account . Account . get_default_account ( api_key = djstripe_settings . STRIPE_SECRET_KEY ) classmethod Source code in djstripe/models/account.py 127 128 129 130 131 132 133 134 135 136 137 138 @classmethod def get_default_account ( cls , api_key = djstripe_settings . STRIPE_SECRET_KEY ): # As of API version 2020-03-02, there is no permission that can allow # restricted keys to call GET /v1/account if djstripe_settings . STRIPE_SECRET_KEY . startswith ( \"rk_\" ): return None account_data = cls . stripe_class . retrieve ( api_key = api_key , stripe_version = djstripe_settings . STRIPE_API_VERSION ) return cls . _get_or_create_from_stripe_object ( account_data , api_key = api_key )[ 0 ] djstripe . models . account . Account . get_default_api_key ( livemode = None ) Source code in djstripe/models/account.py 103 104 105 106 107 108 109 110 111 112 113 114 115 116 def get_default_api_key ( self , livemode : bool = None ) -> str : if livemode is None : livemode = self . livemode api_key = APIKey . objects . filter ( djstripe_owner_account = self , type = APIKeyType . secret ) . first () else : api_key = APIKey . objects . filter ( djstripe_owner_account = self , type = APIKeyType . secret , livemode = livemode ) . first () if api_key : return api_key . secret return djstripe_settings . get_default_api_key ( livemode ) djstripe . models . account . Account . get_or_retrieve_for_api_key ( api_key ) classmethod Source code in djstripe/models/account.py 140 141 142 143 144 145 146 147 @classmethod def get_or_retrieve_for_api_key ( cls , api_key : str ): with transaction . atomic (): apikey_instance , _ = APIKey . objects . get_or_create_by_api_key ( api_key ) if not apikey_instance . djstripe_owner_account : apikey_instance . refresh_account () return apikey_instance . djstripe_owner_account djstripe . models . account . Account . get_stripe_dashboard_url () Get the stripe dashboard url for this object. Source code in djstripe/models/account.py 92 93 94 95 96 97 def get_stripe_dashboard_url ( self ) -> str : \"\"\"Get the stripe dashboard url for this object.\"\"\" return ( f \"https://dashboard.stripe.com/ { self . id } /\" f \" { 'test/' if not self . livemode else '' } dashboard\" ) Functions Attributes Classes djstripe.models.connect.ApplicationFee Bases: StripeModel When you collect a transaction fee on top of a charge made for your user (using Connect), an ApplicationFee is created in your account. Please note the model field charge exists on the Stripe Connected Account while the application_fee modelfield on Charge model exists on the Platform Account! Stripe documentation: https://stripe.com/docs/api?lang=python#application_fees Source code in djstripe/models/connect.py 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 class ApplicationFee ( StripeModel ): \"\"\" When you collect a transaction fee on top of a charge made for your user (using Connect), an ApplicationFee is created in your account. Please note the model field charge exists on the Stripe Connected Account while the application_fee modelfield on Charge model exists on the Platform Account! Stripe documentation: https://stripe.com/docs/api?lang=python#application_fees \"\"\" stripe_class = stripe . ApplicationFee account = StripeForeignKey ( \"Account\" , on_delete = models . PROTECT , related_name = \"application_fees\" , help_text = \"ID of the Stripe account this fee was taken from.\" , ) amount = StripeQuantumCurrencyAmountField ( help_text = \"Amount earned, in cents.\" ) amount_refunded = StripeQuantumCurrencyAmountField ( help_text = \"Amount in cents refunded (can be less than the amount attribute \" \"on the fee if a partial refund was issued)\" ) # TODO application = ... # balance_transaction exists on the platform account balance_transaction = StripeForeignKey ( \"BalanceTransaction\" , on_delete = models . CASCADE , help_text = \"Balance transaction that describes the impact on your account\" \" balance.\" , ) # charge exists on the Stripe Connected Account and not the Platform Account charge = StripeForeignKey ( \"Charge\" , on_delete = models . CASCADE , help_text = \"The charge that the application fee was taken from.\" , ) currency = StripeCurrencyCodeField () # TODO originating_transaction = ... (refs. both Charge and Transfer) refunded = models . BooleanField ( help_text = ( \"Whether the fee has been fully refunded. If the fee is only \" \"partially refunded, this attribute will still be false.\" ) ) Attributes djstripe . models . connect . ApplicationFee . account = StripeForeignKey ( 'Account' , on_delete = models . PROTECT , related_name = 'application_fees' , help_text = 'ID of the Stripe account this fee was taken from.' ) class-attribute djstripe . models . connect . ApplicationFee . amount = StripeQuantumCurrencyAmountField ( help_text = 'Amount earned, in cents.' ) class-attribute djstripe . models . connect . ApplicationFee . amount_refunded = StripeQuantumCurrencyAmountField ( help_text = 'Amount in cents refunded (can be less than the amount attribute on the fee if a partial refund was issued)' ) class-attribute djstripe . models . connect . ApplicationFee . balance_transaction = StripeForeignKey ( 'BalanceTransaction' , on_delete = models . CASCADE , help_text = 'Balance transaction that describes the impact on your account balance.' ) class-attribute djstripe . models . connect . ApplicationFee . charge = StripeForeignKey ( 'Charge' , on_delete = models . CASCADE , help_text = 'The charge that the application fee was taken from.' ) class-attribute djstripe . models . connect . ApplicationFee . currency = StripeCurrencyCodeField () class-attribute djstripe . models . connect . ApplicationFee . refunded = models . BooleanField ( help_text = 'Whether the fee has been fully refunded. If the fee is only partially refunded, this attribute will still be false.' ) class-attribute djstripe . models . connect . ApplicationFee . stripe_class = stripe . ApplicationFee class-attribute djstripe.models.connect.ApplicationFeeRefund Bases: StripeModel ApplicationFeeRefund objects allow you to refund an ApplicationFee that has previously been created but not yet refunded. Funds will be refunded to the Stripe account from which the fee was originally collected. Stripe documentation: https://stripe.com/docs/api?lang=python#fee_refunds Source code in djstripe/models/connect.py 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 class ApplicationFeeRefund ( StripeModel ): \"\"\" ApplicationFeeRefund objects allow you to refund an ApplicationFee that has previously been created but not yet refunded. Funds will be refunded to the Stripe account from which the fee was originally collected. Stripe documentation: https://stripe.com/docs/api?lang=python#fee_refunds \"\"\" description = None stripe_class = stripe . ApplicationFeeRefund amount = StripeQuantumCurrencyAmountField ( help_text = \"Amount refunded, in cents.\" ) balance_transaction = StripeForeignKey ( \"BalanceTransaction\" , on_delete = models . CASCADE , help_text = \"Balance transaction that describes the impact on your account \" \"balance.\" , ) currency = StripeCurrencyCodeField () fee = StripeForeignKey ( \"ApplicationFee\" , on_delete = models . CASCADE , related_name = \"refunds\" , help_text = \"The application fee that was refunded\" , ) Attributes djstripe . models . connect . ApplicationFeeRefund . amount = StripeQuantumCurrencyAmountField ( help_text = 'Amount refunded, in cents.' ) class-attribute djstripe . models . connect . ApplicationFeeRefund . balance_transaction = StripeForeignKey ( 'BalanceTransaction' , on_delete = models . CASCADE , help_text = 'Balance transaction that describes the impact on your account balance.' ) class-attribute djstripe . models . connect . ApplicationFeeRefund . currency = StripeCurrencyCodeField () class-attribute djstripe . models . connect . ApplicationFeeRefund . description = None class-attribute djstripe . models . connect . ApplicationFeeRefund . fee = StripeForeignKey ( 'ApplicationFee' , on_delete = models . CASCADE , related_name = 'refunds' , help_text = 'The application fee that was refunded' ) class-attribute djstripe . models . connect . ApplicationFeeRefund . stripe_class = stripe . ApplicationFeeRefund class-attribute djstripe.models.connect.CountrySpec Bases: StripeBaseModel Stripe documentation: https://stripe.com/docs/api?lang=python#country_specs Source code in djstripe/models/connect.py 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 class CountrySpec ( StripeBaseModel ): \"\"\" Stripe documentation: https://stripe.com/docs/api?lang=python#country_specs \"\"\" stripe_class = stripe . CountrySpec id = models . CharField ( max_length = 2 , primary_key = True , serialize = True ) default_currency = StripeCurrencyCodeField ( help_text = ( \"The default currency for this country. \" \"This applies to both payment methods and bank accounts.\" ) ) supported_bank_account_currencies = JSONField ( help_text = \"Currencies that can be accepted in the specific country\" \" (for transfers).\" ) supported_payment_currencies = JSONField ( help_text = \"Currencies that can be accepted in the specified country\" \" (for payments).\" ) supported_payment_methods = JSONField ( help_text = \"Payment methods available in the specified country.\" ) supported_transfer_countries = JSONField ( help_text = \"Countries that can accept transfers from the specified country.\" ) verification_fields = JSONField ( help_text = \"Lists the types of verification data needed to keep an account open.\" ) @classmethod def sync_from_stripe_data ( cls , data , api_key = djstripe_settings . STRIPE_SECRET_KEY ) -> \"CountrySpec\" : \"\"\" Syncs this object from the stripe data provided. Foreign keys will also be retrieved and synced recursively. :param data: stripe object :type data: dict :rtype: cls \"\"\" data_id = data [ \"id\" ] supported_fields = ( \"default_currency\" , \"supported_bank_account_currencies\" , \"supported_payment_currencies\" , \"supported_payment_methods\" , \"supported_transfer_countries\" , \"verification_fields\" , ) instance , created = cls . objects . get_or_create ( id = data_id , defaults = { k : data [ k ] for k in supported_fields }, ) return instance def api_retrieve ( self , api_key : str = None , stripe_account = None ): if api_key is None : api_key = djstripe_settings . get_default_api_key ( livemode = None ) return self . stripe_class . retrieve ( id = self . id , api_key = api_key , stripe_version = djstripe_settings . STRIPE_API_VERSION , stripe_account = stripe_account , ) Attributes djstripe . models . connect . CountrySpec . default_currency = StripeCurrencyCodeField ( help_text = 'The default currency for this country. This applies to both payment methods and bank accounts.' ) class-attribute djstripe . models . connect . CountrySpec . id = models . CharField ( max_length = 2 , primary_key = True , serialize = True ) class-attribute djstripe . models . connect . CountrySpec . stripe_class = stripe . CountrySpec class-attribute djstripe . models . connect . CountrySpec . supported_bank_account_currencies = JSONField ( help_text = 'Currencies that can be accepted in the specific country (for transfers).' ) class-attribute djstripe . models . connect . CountrySpec . supported_payment_currencies = JSONField ( help_text = 'Currencies that can be accepted in the specified country (for payments).' ) class-attribute djstripe . models . connect . CountrySpec . supported_payment_methods = JSONField ( help_text = 'Payment methods available in the specified country.' ) class-attribute djstripe . models . connect . CountrySpec . supported_transfer_countries = JSONField ( help_text = 'Countries that can accept transfers from the specified country.' ) class-attribute djstripe . models . connect . CountrySpec . verification_fields = JSONField ( help_text = 'Lists the types of verification data needed to keep an account open.' ) class-attribute Functions djstripe . models . connect . CountrySpec . api_retrieve ( api_key = None , stripe_account = None ) Source code in djstripe/models/connect.py 163 164 165 166 167 168 169 170 171 172 def api_retrieve ( self , api_key : str = None , stripe_account = None ): if api_key is None : api_key = djstripe_settings . get_default_api_key ( livemode = None ) return self . stripe_class . retrieve ( id = self . id , api_key = api_key , stripe_version = djstripe_settings . STRIPE_API_VERSION , stripe_account = stripe_account , ) djstripe . models . connect . CountrySpec . sync_from_stripe_data ( data , api_key = djstripe_settings . STRIPE_SECRET_KEY ) classmethod Syncs this object from the stripe data provided. Foreign keys will also be retrieved and synced recursively. :param data: stripe object :type data: dict :rtype: cls Source code in djstripe/models/connect.py 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 @classmethod def sync_from_stripe_data ( cls , data , api_key = djstripe_settings . STRIPE_SECRET_KEY ) -> \"CountrySpec\" : \"\"\" Syncs this object from the stripe data provided. Foreign keys will also be retrieved and synced recursively. :param data: stripe object :type data: dict :rtype: cls \"\"\" data_id = data [ \"id\" ] supported_fields = ( \"default_currency\" , \"supported_bank_account_currencies\" , \"supported_payment_currencies\" , \"supported_payment_methods\" , \"supported_transfer_countries\" , \"verification_fields\" , ) instance , created = cls . objects . get_or_create ( id = data_id , defaults = { k : data [ k ] for k in supported_fields }, ) return instance djstripe.models.connect.Transfer Bases: StripeModel When Stripe sends you money or you initiate a transfer to a bank account, debit card, or connected Stripe account, a transfer object will be created. Stripe documentation: https://stripe.com/docs/api?lang=python#transfers Source code in djstripe/models/connect.py 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 class Transfer ( StripeModel ): \"\"\" When Stripe sends you money or you initiate a transfer to a bank account, debit card, or connected Stripe account, a transfer object will be created. Stripe documentation: https://stripe.com/docs/api?lang=python#transfers \"\"\" stripe_class = stripe . Transfer expand_fields = [ \"balance_transaction\" ] stripe_dashboard_item_name = \"transfers\" objects = TransferManager () amount = StripeDecimalCurrencyAmountField ( help_text = \"The amount transferred\" ) amount_reversed = StripeDecimalCurrencyAmountField ( null = True , blank = True , help_text = \"The amount (as decimal) reversed (can be less than the amount \" \"attribute on the transfer if a partial reversal was issued).\" , ) balance_transaction = StripeForeignKey ( \"BalanceTransaction\" , on_delete = models . SET_NULL , null = True , blank = True , help_text = \"Balance transaction that describes the impact on your account\" \" balance.\" , ) currency = StripeCurrencyCodeField () destination = StripeIdField ( max_length = 255 , null = True , help_text = \"ID of the bank account, card, or Stripe account the transfer was sent to.\" , ) # todo implement payment model (for some reason py ids are showing up in the charge model) destination_payment = StripeIdField ( null = True , blank = True , help_text = \"If the destination is a Stripe account, this will be the ID of the \" \"payment that the destination account received for the transfer.\" , ) reversed = models . BooleanField ( default = False , help_text = \"Whether or not the transfer has been fully reversed. \" \"If the transfer is only partially reversed, this attribute will still \" \"be false.\" , ) source_transaction = StripeIdField ( null = True , help_text = \"ID of the charge (or other transaction) that was used to fund \" \"the transfer. If null, the transfer was funded from the available balance.\" , ) source_type = StripeEnumField ( enum = enums . LegacySourceType , help_text = \"The source balance from which this transfer came.\" , ) transfer_group = models . CharField ( max_length = 255 , default = \"\" , blank = True , help_text = \"A string that identifies this transaction as part of a group.\" , ) @property def fee ( self ): if self . balance_transaction : return self . balance_transaction . fee def __str__ ( self ): amount = get_friendly_currency_amount ( self . amount , self . currency ) if self . reversed : # Complete Reversal return f \" { amount } Reversed\" elif self . amount_reversed : # Partial Reversal return f \" { amount } Partially Reversed\" # No Reversal return f \" { amount } \" def _attach_objects_post_save_hook ( self , cls , data , api_key = djstripe_settings . STRIPE_SECRET_KEY , pending_relations = None , ): \"\"\" Iterate over reversals on the Transfer object to create and/or sync TransferReversal objects \"\"\" super () . _attach_objects_post_save_hook ( cls , data , api_key = api_key , pending_relations = pending_relations ) # Transfer Reversals exist as a list on the Transfer Object for reversals_data in data . get ( \"reversals\" ) . auto_paging_iter (): TransferReversal . sync_from_stripe_data ( reversals_data , api_key = api_key ) def get_stripe_dashboard_url ( self ) -> str : return ( f \" { self . _get_base_stripe_dashboard_url () } \" f \"connect/ { self . stripe_dashboard_item_name } / { self . id } \" ) Attributes djstripe . models . connect . Transfer . amount = StripeDecimalCurrencyAmountField ( help_text = 'The amount transferred' ) class-attribute djstripe . models . connect . Transfer . amount_reversed = StripeDecimalCurrencyAmountField ( null = True , blank = True , help_text = 'The amount (as decimal) reversed (can be less than the amount attribute on the transfer if a partial reversal was issued).' ) class-attribute djstripe . models . connect . Transfer . balance_transaction = StripeForeignKey ( 'BalanceTransaction' , on_delete = models . SET_NULL , null = True , blank = True , help_text = 'Balance transaction that describes the impact on your account balance.' ) class-attribute djstripe . models . connect . Transfer . currency = StripeCurrencyCodeField () class-attribute djstripe . models . connect . Transfer . destination = StripeIdField ( max_length = 255 , null = True , help_text = 'ID of the bank account, card, or Stripe account the transfer was sent to.' ) class-attribute djstripe . models . connect . Transfer . destination_payment = StripeIdField ( null = True , blank = True , help_text = 'If the destination is a Stripe account, this will be the ID of the payment that the destination account received for the transfer.' ) class-attribute djstripe . models . connect . Transfer . expand_fields = [ 'balance_transaction' ] class-attribute djstripe . models . connect . Transfer . fee property djstripe . models . connect . Transfer . objects = TransferManager () class-attribute djstripe . models . connect . Transfer . reversed = models . BooleanField ( default = False , help_text = 'Whether or not the transfer has been fully reversed. If the transfer is only partially reversed, this attribute will still be false.' ) class-attribute djstripe . models . connect . Transfer . source_transaction = StripeIdField ( null = True , help_text = 'ID of the charge (or other transaction) that was used to fund the transfer. If null, the transfer was funded from the available balance.' ) class-attribute djstripe . models . connect . Transfer . source_type = StripeEnumField ( enum = enums . LegacySourceType , help_text = 'The source balance from which this transfer came.' ) class-attribute djstripe . models . connect . Transfer . stripe_class = stripe . Transfer class-attribute djstripe . models . connect . Transfer . stripe_dashboard_item_name = 'transfers' class-attribute djstripe . models . connect . Transfer . transfer_group = models . CharField ( max_length = 255 , default = '' , blank = True , help_text = 'A string that identifies this transaction as part of a group.' ) class-attribute Functions djstripe . models . connect . Transfer . __str__ () Source code in djstripe/models/connect.py 246 247 248 249 250 251 252 253 254 255 def __str__ ( self ): amount = get_friendly_currency_amount ( self . amount , self . currency ) if self . reversed : # Complete Reversal return f \" { amount } Reversed\" elif self . amount_reversed : # Partial Reversal return f \" { amount } Partially Reversed\" # No Reversal return f \" { amount } \" djstripe . models . connect . Transfer . get_stripe_dashboard_url () Source code in djstripe/models/connect.py 277 278 279 280 281 def get_stripe_dashboard_url ( self ) -> str : return ( f \" { self . _get_base_stripe_dashboard_url () } \" f \"connect/ { self . stripe_dashboard_item_name } / { self . id } \" ) djstripe.models.connect.TransferReversal Bases: StripeModel Stripe documentation: https://stripe.com/docs/api?lang=python#transfer_reversals Source code in djstripe/models/connect.py 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 class TransferReversal ( StripeModel ): \"\"\" Stripe documentation: https://stripe.com/docs/api?lang=python#transfer_reversals \"\"\" expand_fields = [ \"balance_transaction\" , \"transfer\" ] stripe_dashboard_item_name = \"transfer_reversals\" # TransferReversal classmethods are derived from # and attached to the stripe.Transfer class stripe_class = stripe . Transfer amount = StripeQuantumCurrencyAmountField ( help_text = \"Amount, in cents.\" ) balance_transaction = StripeForeignKey ( \"BalanceTransaction\" , on_delete = models . SET_NULL , null = True , blank = True , related_name = \"transfer_reversals\" , help_text = \"Balance transaction that describes the impact on your account \" \"balance.\" , ) currency = StripeCurrencyCodeField () transfer = StripeForeignKey ( \"Transfer\" , on_delete = models . CASCADE , help_text = \"The transfer that was reversed.\" , related_name = \"reversals\" , ) def __str__ ( self ): return str ( self . transfer ) @classmethod def _api_create ( cls , api_key = djstripe_settings . STRIPE_SECRET_KEY , ** kwargs ): \"\"\" Call the stripe API's create operation for this model. :param api_key: The api key to use for this request. \\ Defaults to djstripe_settings.STRIPE_SECRET_KEY. :type api_key: string \"\"\" if not kwargs . get ( \"id\" ): raise KeyError ( \"Transfer Object ID is missing\" ) try : Transfer . objects . get ( id = kwargs [ \"id\" ]) except Transfer . DoesNotExist : raise return stripe . Transfer . create_reversal ( api_key = api_key , stripe_version = djstripe_settings . STRIPE_API_VERSION , ** kwargs , ) def api_retrieve ( self , api_key = None , stripe_account = None ): \"\"\" Call the stripe API's retrieve operation for this model. :param api_key: The api key to use for this request. \\ Defaults to djstripe_settings.STRIPE_SECRET_KEY. :type api_key: string :param stripe_account: The optional connected account \\ for which this request is being made. :type stripe_account: string \"\"\" nested_id = self . id id = self . transfer . id # Prefer passed in stripe_account if set. if not stripe_account : stripe_account = self . _get_stripe_account_id ( api_key ) return stripe . Transfer . retrieve_reversal ( id = id , nested_id = nested_id , api_key = api_key or self . default_api_key , stripe_version = djstripe_settings . STRIPE_API_VERSION , expand = self . expand_fields , stripe_account = stripe_account , ) @classmethod def api_list ( cls , api_key = djstripe_settings . STRIPE_SECRET_KEY , ** kwargs ): \"\"\" Call the stripe API's list operation for this model. :param api_key: The api key to use for this request. \\ Defaults to djstripe_settings.STRIPE_SECRET_KEY. :type api_key: string See Stripe documentation for accepted kwargs for each object. :returns: an iterator over all items in the query \"\"\" return stripe . Transfer . list_reversals ( api_key = api_key , stripe_version = djstripe_settings . STRIPE_API_VERSION , ** kwargs , ) . auto_paging_iter () @classmethod def is_valid_object ( cls , data ): \"\"\" Returns whether the data is a valid object for the class \"\"\" return data and data . get ( \"object\" ) == \"transfer_reversal\" Attributes djstripe . models . connect . TransferReversal . amount = StripeQuantumCurrencyAmountField ( help_text = 'Amount, in cents.' ) class-attribute djstripe . models . connect . TransferReversal . balance_transaction = StripeForeignKey ( 'BalanceTransaction' , on_delete = models . SET_NULL , null = True , blank = True , related_name = 'transfer_reversals' , help_text = 'Balance transaction that describes the impact on your account balance.' ) class-attribute djstripe . models . connect . TransferReversal . currency = StripeCurrencyCodeField () class-attribute djstripe . models . connect . TransferReversal . expand_fields = [ 'balance_transaction' , 'transfer' ] class-attribute djstripe . models . connect . TransferReversal . stripe_class = stripe . Transfer class-attribute djstripe . models . connect . TransferReversal . stripe_dashboard_item_name = 'transfer_reversals' class-attribute djstripe . models . connect . TransferReversal . transfer = StripeForeignKey ( 'Transfer' , on_delete = models . CASCADE , help_text = 'The transfer that was reversed.' , related_name = 'reversals' ) class-attribute Functions djstripe . models . connect . TransferReversal . __str__ () Source code in djstripe/models/connect.py 315 316 def __str__ ( self ): return str ( self . transfer ) djstripe . models . connect . TransferReversal . api_list ( api_key = djstripe_settings . STRIPE_SECRET_KEY , ** kwargs ) classmethod Call the stripe API's list operation for this model. :param api_key: The api key to use for this request. Defaults to djstripe_settings.STRIPE_SECRET_KEY. :type api_key: string See Stripe documentation for accepted kwargs for each object. :returns: an iterator over all items in the query Source code in djstripe/models/connect.py 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 @classmethod def api_list ( cls , api_key = djstripe_settings . STRIPE_SECRET_KEY , ** kwargs ): \"\"\" Call the stripe API's list operation for this model. :param api_key: The api key to use for this request. \\ Defaults to djstripe_settings.STRIPE_SECRET_KEY. :type api_key: string See Stripe documentation for accepted kwargs for each object. :returns: an iterator over all items in the query \"\"\" return stripe . Transfer . list_reversals ( api_key = api_key , stripe_version = djstripe_settings . STRIPE_API_VERSION , ** kwargs , ) . auto_paging_iter () djstripe . models . connect . TransferReversal . api_retrieve ( api_key = None , stripe_account = None ) Call the stripe API's retrieve operation for this model. :param api_key: The api key to use for this request. Defaults to djstripe_settings.STRIPE_SECRET_KEY. :type api_key: string :param stripe_account: The optional connected account for which this request is being made. :type stripe_account: string Source code in djstripe/models/connect.py 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 def api_retrieve ( self , api_key = None , stripe_account = None ): \"\"\" Call the stripe API's retrieve operation for this model. :param api_key: The api key to use for this request. \\ Defaults to djstripe_settings.STRIPE_SECRET_KEY. :type api_key: string :param stripe_account: The optional connected account \\ for which this request is being made. :type stripe_account: string \"\"\" nested_id = self . id id = self . transfer . id # Prefer passed in stripe_account if set. if not stripe_account : stripe_account = self . _get_stripe_account_id ( api_key ) return stripe . Transfer . retrieve_reversal ( id = id , nested_id = nested_id , api_key = api_key or self . default_api_key , stripe_version = djstripe_settings . STRIPE_API_VERSION , expand = self . expand_fields , stripe_account = stripe_account , ) djstripe . models . connect . TransferReversal . is_valid_object ( data ) classmethod Returns whether the data is a valid object for the class Source code in djstripe/models/connect.py 383 384 385 386 387 388 @classmethod def is_valid_object ( cls , data ): \"\"\" Returns whether the data is a valid object for the class \"\"\" return data and data . get ( \"object\" ) == \"transfer_reversal\" Functions Fraud Orders Attributes Classes djstripe.models.orders.Order Bases: StripeModel An Order describes a purchase being made by a customer, including the products & quantities being purchased, the order status, the payment information, and the billing/shipping details. Stripe documentation: https://stripe.com/docs/api/orders_v2/object?lang=python Source code in djstripe/models/orders.py 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 class Order ( StripeModel ): \"\"\" An Order describes a purchase being made by a customer, including the products & quantities being purchased, the order status, the payment information, and the billing/shipping details. Stripe documentation: https://stripe.com/docs/api/orders_v2/object?lang=python \"\"\" stripe_class = stripe . Order expand_fields = [ \"customer\" , \"line_items\" , \"discounts\" , \"total_details.breakdown\" ] stripe_dashboard_item_name = \"orders\" amount_subtotal = StripeQuantumCurrencyAmountField ( help_text = \"Order cost before any discounts or taxes are applied. A positive integer representing the subtotal of the order in the smallest currency unit (e.g., 100 cents to charge $1.00 or 100 to charge \u00a5100, a zero-decimal currency).\" ) amount_total = StripeQuantumCurrencyAmountField ( help_text = \"Total order cost after discounts and taxes are applied. A positive integer representing the cost of the order in the smallest currency unit (e.g., 100 cents to charge $1.00 or 100 to charge \u00a5100, a zero-decimal currency). To submit an order, the total must be either 0 or at least $0.50 USD or equivalent in charge currency.\" ) application = models . CharField ( max_length = 255 , blank = True , help_text = \"ID of the Connect application that created the Order, if any.\" , ) automatic_tax = JSONField ( help_text = \"Settings and latest results for automatic tax lookup for this Order.\" ) billing_details = JSONField ( null = True , blank = True , help_text = \"Customer billing details associated with the order.\" , ) client_secret = models . TextField ( max_length = 5000 , help_text = ( \"The client secret of this PaymentIntent. \" \"Used for client-side retrieval using a publishable key.\" ), ) currency = StripeCurrencyCodeField ( help_text = \"Three-letter ISO currency code, in lowercase. Must be a supported currency.\" ) # not deleting order when customer is deleted, because order may be important for taxation and audit purposes customer = StripeForeignKey ( \"Customer\" , on_delete = models . SET_NULL , null = True , blank = True , help_text = \"The customer which this orders belongs to.\" , ) discounts = JSONField ( null = True , blank = True , help_text = \"The discounts applied to the order.\" , ) ip_address = models . GenericIPAddressField ( null = True , blank = True , help_text = \"A recent IP address of the purchaser used for tax reporting and tax location inference.\" , ) line_items = JSONField ( help_text = \"A list of line items the customer is ordering. Each line item includes information about the product, the quantity, and the resulting cost. There is a maximum of 100 line items.\" , ) payment = JSONField ( help_text = \"Payment information associated with the order. Includes payment status, settings, and a PaymentIntent ID\" , ) payment_intent = StripeForeignKey ( \"PaymentIntent\" , on_delete = models . SET_NULL , null = True , blank = True , help_text = \"ID of the payment intent associated with this order. Null when the order is open.\" , ) shipping_cost = JSONField ( null = True , blank = True , help_text = \"The details of the customer cost of shipping, including the customer chosen ShippingRate.\" , ) shipping_details = JSONField ( null = True , blank = True , help_text = \"Customer shipping information associated with the order.\" , ) status = StripeEnumField ( enum = OrderStatus , help_text = \"The overall status of the order.\" ) tax_details = JSONField ( null = True , blank = True , help_text = \"Tax details about the purchaser for this order.\" , ) total_details = JSONField ( help_text = \"Tax, discount, and shipping details for the computed total amount of this order.\" , ) def __str__ ( self ): template = f \"on { self . created . strftime ( '%m/ %d /%Y' ) } ( { self . status } )\" if self . status in ( OrderStatus . open , OrderStatus . canceled ): return \"Created \" + template elif self . status in ( OrderStatus . submitted , OrderStatus . complete , OrderStatus . processing , ): return \"Placed \" + template return self . id @classmethod def _manipulate_stripe_object_hook ( cls , data ): data [ \"payment_intent\" ] = data [ \"payment\" ][ \"payment_intent\" ] return data def _attach_objects_post_save_hook ( self , cls , data , api_key = djstripe_settings . STRIPE_SECRET_KEY , pending_relations = None , ): super () . _attach_objects_post_save_hook ( cls , data , api_key = api_key , pending_relations = pending_relations ) # sync every discount for discount in self . discounts : Discount . sync_from_stripe_data ( discount , api_key = api_key ) def cancel ( self , api_key = None , stripe_account = None , ** kwargs ): \"\"\" Cancels the order as well as the payment intent if one is attached. :param api_key: The api key to use for this request. \\ Defaults to djstripe_settings.STRIPE_SECRET_KEY. :type api_key: string :param stripe_account: The optional connected account \\ for which this request is being made. :type stripe_account: string \"\"\" api_key = api_key or self . default_api_key # Prefer passed in stripe_account if set. if not stripe_account : stripe_account = self . _get_stripe_account_id ( api_key ) return self . stripe_class . cancel ( self . id , api_key = api_key , stripe_account = stripe_account , stripe_version = djstripe_settings . STRIPE_API_VERSION , ** kwargs , ) def reopen ( self , api_key = None , stripe_account = None , ** kwargs ): \"\"\" Reopens a submitted order. :param api_key: The api key to use for this request. \\ Defaults to djstripe_settings.STRIPE_SECRET_KEY. :type api_key: string :param stripe_account: The optional connected account \\ for which this request is being made. :type stripe_account: string \"\"\" api_key = api_key or self . default_api_key # Prefer passed in stripe_account if set. if not stripe_account : stripe_account = self . _get_stripe_account_id ( api_key ) return self . stripe_class . reopen ( self . id , api_key = api_key , stripe_account = stripe_account , stripe_version = djstripe_settings . STRIPE_API_VERSION , ** kwargs , ) def submit ( self , api_key = None , stripe_account = None , ** kwargs ): \"\"\" Submitting an Order transitions the status to processing and creates a PaymentIntent object so the order can be paid. If the Order has an amount_total of 0, no PaymentIntent object will be created. Once the order is submitted, its contents cannot be changed, unless the reopen method is called. :param api_key: The api key to use for this request. \\ Defaults to djstripe_settings.STRIPE_SECRET_KEY. :type api_key: string :param stripe_account: The optional connected account \\ for which this request is being made. :type stripe_account: string \"\"\" api_key = api_key or self . default_api_key # Prefer passed in stripe_account if set. if not stripe_account : stripe_account = self . _get_stripe_account_id ( api_key ) return self . stripe_class . submit ( self . id , api_key = api_key , stripe_account = stripe_account , stripe_version = djstripe_settings . STRIPE_API_VERSION , ** kwargs , ) Attributes djstripe . models . orders . Order . amount_subtotal = StripeQuantumCurrencyAmountField ( help_text = 'Order cost before any discounts or taxes are applied. A positive integer representing the subtotal of the order in the smallest currency unit (e.g., 100 cents to charge $1.00 or 100 to charge \u00a5100, a zero-decimal currency).' ) class-attribute djstripe . models . orders . Order . amount_total = StripeQuantumCurrencyAmountField ( help_text = 'Total order cost after discounts and taxes are applied. A positive integer representing the cost of the order in the smallest currency unit (e.g., 100 cents to charge $1.00 or 100 to charge \u00a5100, a zero-decimal currency). To submit an order, the total must be either 0 or at least $0.50 USD or equivalent in charge currency.' ) class-attribute djstripe . models . orders . Order . application = models . CharField ( max_length = 255 , blank = True , help_text = 'ID of the Connect application that created the Order, if any.' ) class-attribute djstripe . models . orders . Order . automatic_tax = JSONField ( help_text = 'Settings and latest results for automatic tax lookup for this Order.' ) class-attribute djstripe . models . orders . Order . billing_details = JSONField ( null = True , blank = True , help_text = 'Customer billing details associated with the order.' ) class-attribute djstripe . models . orders . Order . client_secret = models . TextField ( max_length = 5000 , help_text = 'The client secret of this PaymentIntent. Used for client-side retrieval using a publishable key.' ) class-attribute djstripe . models . orders . Order . currency = StripeCurrencyCodeField ( help_text = 'Three-letter ISO currency code, in lowercase. Must be a supported currency.' ) class-attribute djstripe . models . orders . Order . customer = StripeForeignKey ( 'Customer' , on_delete = models . SET_NULL , null = True , blank = True , help_text = 'The customer which this orders belongs to.' ) class-attribute djstripe . models . orders . Order . discounts = JSONField ( null = True , blank = True , help_text = 'The discounts applied to the order.' ) class-attribute djstripe . models . orders . Order . expand_fields = [ 'customer' , 'line_items' , 'discounts' , 'total_details.breakdown' ] class-attribute djstripe . models . orders . Order . ip_address = models . GenericIPAddressField ( null = True , blank = True , help_text = 'A recent IP address of the purchaser used for tax reporting and tax location inference.' ) class-attribute djstripe . models . orders . Order . line_items = JSONField ( help_text = 'A list of line items the customer is ordering. Each line item includes information about the product, the quantity, and the resulting cost. There is a maximum of 100 line items.' ) class-attribute djstripe . models . orders . Order . payment = JSONField ( help_text = 'Payment information associated with the order. Includes payment status, settings, and a PaymentIntent ID' ) class-attribute djstripe . models . orders . Order . payment_intent = StripeForeignKey ( 'PaymentIntent' , on_delete = models . SET_NULL , null = True , blank = True , help_text = 'ID of the payment intent associated with this order. Null when the order is open.' ) class-attribute djstripe . models . orders . Order . shipping_cost = JSONField ( null = True , blank = True , help_text = 'The details of the customer cost of shipping, including the customer chosen ShippingRate.' ) class-attribute djstripe . models . orders . Order . shipping_details = JSONField ( null = True , blank = True , help_text = 'Customer shipping information associated with the order.' ) class-attribute djstripe . models . orders . Order . status = StripeEnumField ( enum = OrderStatus , help_text = 'The overall status of the order.' ) class-attribute djstripe . models . orders . Order . stripe_class = stripe . Order class-attribute djstripe . models . orders . Order . stripe_dashboard_item_name = 'orders' class-attribute djstripe . models . orders . Order . tax_details = JSONField ( null = True , blank = True , help_text = 'Tax details about the purchaser for this order.' ) class-attribute djstripe . models . orders . Order . total_details = JSONField ( help_text = 'Tax, discount, and shipping details for the computed total amount of this order.' ) class-attribute Functions djstripe . models . orders . Order . __str__ () Source code in djstripe/models/orders.py 114 115 116 117 118 119 120 121 122 123 124 def __str__ ( self ): template = f \"on { self . created . strftime ( '%m/ %d /%Y' ) } ( { self . status } )\" if self . status in ( OrderStatus . open , OrderStatus . canceled ): return \"Created \" + template elif self . status in ( OrderStatus . submitted , OrderStatus . complete , OrderStatus . processing , ): return \"Placed \" + template return self . id djstripe . models . orders . Order . cancel ( api_key = None , stripe_account = None , ** kwargs ) Cancels the order as well as the payment intent if one is attached. :param api_key: The api key to use for this request. Defaults to djstripe_settings.STRIPE_SECRET_KEY. :type api_key: string :param stripe_account: The optional connected account for which this request is being made. :type stripe_account: string Source code in djstripe/models/orders.py 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 def cancel ( self , api_key = None , stripe_account = None , ** kwargs ): \"\"\" Cancels the order as well as the payment intent if one is attached. :param api_key: The api key to use for this request. \\ Defaults to djstripe_settings.STRIPE_SECRET_KEY. :type api_key: string :param stripe_account: The optional connected account \\ for which this request is being made. :type stripe_account: string \"\"\" api_key = api_key or self . default_api_key # Prefer passed in stripe_account if set. if not stripe_account : stripe_account = self . _get_stripe_account_id ( api_key ) return self . stripe_class . cancel ( self . id , api_key = api_key , stripe_account = stripe_account , stripe_version = djstripe_settings . STRIPE_API_VERSION , ** kwargs , ) djstripe . models . orders . Order . reopen ( api_key = None , stripe_account = None , ** kwargs ) Reopens a submitted order. :param api_key: The api key to use for this request. Defaults to djstripe_settings.STRIPE_SECRET_KEY. :type api_key: string :param stripe_account: The optional connected account for which this request is being made. :type stripe_account: string Source code in djstripe/models/orders.py 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 def reopen ( self , api_key = None , stripe_account = None , ** kwargs ): \"\"\" Reopens a submitted order. :param api_key: The api key to use for this request. \\ Defaults to djstripe_settings.STRIPE_SECRET_KEY. :type api_key: string :param stripe_account: The optional connected account \\ for which this request is being made. :type stripe_account: string \"\"\" api_key = api_key or self . default_api_key # Prefer passed in stripe_account if set. if not stripe_account : stripe_account = self . _get_stripe_account_id ( api_key ) return self . stripe_class . reopen ( self . id , api_key = api_key , stripe_account = stripe_account , stripe_version = djstripe_settings . STRIPE_API_VERSION , ** kwargs , ) djstripe . models . orders . Order . submit ( api_key = None , stripe_account = None , ** kwargs ) Submitting an Order transitions the status to processing and creates a PaymentIntent object so the order can be paid. If the Order has an amount_total of 0, no PaymentIntent object will be created. Once the order is submitted, its contents cannot be changed, unless the reopen method is called. :param api_key: The api key to use for this request. Defaults to djstripe_settings.STRIPE_SECRET_KEY. :type api_key: string :param stripe_account: The optional connected account for which this request is being made. :type stripe_account: string Source code in djstripe/models/orders.py 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 def submit ( self , api_key = None , stripe_account = None , ** kwargs ): \"\"\" Submitting an Order transitions the status to processing and creates a PaymentIntent object so the order can be paid. If the Order has an amount_total of 0, no PaymentIntent object will be created. Once the order is submitted, its contents cannot be changed, unless the reopen method is called. :param api_key: The api key to use for this request. \\ Defaults to djstripe_settings.STRIPE_SECRET_KEY. :type api_key: string :param stripe_account: The optional connected account \\ for which this request is being made. :type stripe_account: string \"\"\" api_key = api_key or self . default_api_key # Prefer passed in stripe_account if set. if not stripe_account : stripe_account = self . _get_stripe_account_id ( api_key ) return self . stripe_class . submit ( self . id , api_key = api_key , stripe_account = stripe_account , stripe_version = djstripe_settings . STRIPE_API_VERSION , ** kwargs , ) Sigma Classes djstripe.models.sigma.ScheduledQueryRun Bases: StripeModel Stripe documentation: https://stripe.com/docs/api?lang=python#scheduled_queries Source code in djstripe/models/sigma.py 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 class ScheduledQueryRun ( StripeModel ): \"\"\" Stripe documentation: https://stripe.com/docs/api?lang=python#scheduled_queries \"\"\" stripe_class = stripe . sigma . ScheduledQueryRun data_load_time = StripeDateTimeField ( help_text = \"When the query was run, Sigma contained a snapshot of your \" \"Stripe data at this time.\" ) error = JSONField ( null = True , blank = True , help_text = \"If the query run was not succeesful, contains information \" \"about the failure.\" , ) file = StripeForeignKey ( \"file\" , on_delete = models . SET_NULL , null = True , blank = True , help_text = \"The file object representing the results of the query.\" , ) result_available_until = StripeDateTimeField ( help_text = \"Time at which the result expires and is no longer available \" \"for download.\" ) sql = models . TextField ( max_length = 5000 , help_text = \"SQL for the query.\" ) status = StripeEnumField ( enum = enums . ScheduledQueryRunStatus , help_text = \"The query's execution status.\" ) title = models . TextField ( max_length = 5000 , help_text = \"Title of the query.\" ) # TODO Write corresponding test def __str__ ( self ): return f \" { self . title or self . id } ( { self . status } )\" Attributes djstripe . models . sigma . ScheduledQueryRun . data_load_time = StripeDateTimeField ( help_text = 'When the query was run, Sigma contained a snapshot of your Stripe data at this time.' ) class-attribute djstripe . models . sigma . ScheduledQueryRun . error = JSONField ( null = True , blank = True , help_text = 'If the query run was not succeesful, contains information about the failure.' ) class-attribute djstripe . models . sigma . ScheduledQueryRun . file = StripeForeignKey ( 'file' , on_delete = models . SET_NULL , null = True , blank = True , help_text = 'The file object representing the results of the query.' ) class-attribute djstripe . models . sigma . ScheduledQueryRun . result_available_until = StripeDateTimeField ( help_text = 'Time at which the result expires and is no longer available for download.' ) class-attribute djstripe . models . sigma . ScheduledQueryRun . sql = models . TextField ( max_length = 5000 , help_text = 'SQL for the query.' ) class-attribute djstripe . models . sigma . ScheduledQueryRun . status = StripeEnumField ( enum = enums . ScheduledQueryRunStatus , help_text = \"The query's execution status.\" ) class-attribute djstripe . models . sigma . ScheduledQueryRun . stripe_class = stripe . sigma . ScheduledQueryRun class-attribute djstripe . models . sigma . ScheduledQueryRun . title = models . TextField ( max_length = 5000 , help_text = 'Title of the query.' ) class-attribute Functions djstripe . models . sigma . ScheduledQueryRun . __str__ () Source code in djstripe/models/sigma.py 45 46 def __str__ ( self ): return f \" { self . title or self . id } ( { self . status } )\" Webhooks Module for dj-stripe Webhook models Attributes Classes djstripe.models.webhooks.WebhookEndpoint Bases: StripeModel Source code in djstripe/models/webhooks.py 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 class WebhookEndpoint ( StripeModel ): stripe_class = stripe . WebhookEndpoint stripe_dashboard_item_name = \"webhooks\" api_version = models . CharField ( max_length = 64 , blank = True , help_text = \"The API version events are rendered as for this webhook endpoint. Defaults to the configured Stripe API Version.\" , ) enabled_events = JSONField ( help_text = ( \"The list of events to enable for this endpoint. \" \"['*'] indicates that all events are enabled, except those that require explicit selection.\" ) ) secret = models . CharField ( max_length = 256 , blank = True , editable = False , help_text = \"The endpoint's secret, used to generate webhook signatures.\" , ) status = StripeEnumField ( enum = WebhookEndpointStatus , help_text = \"The status of the webhook. It can be enabled or disabled.\" , ) url = models . URLField ( help_text = \"The URL of the webhook endpoint.\" , max_length = 2048 ) application = models . CharField ( max_length = 255 , blank = True , help_text = \"The ID of the associated Connect application.\" , ) djstripe_uuid = models . UUIDField ( null = True , unique = True , default = uuid4 , help_text = \"A UUID specific to dj-stripe generated for the endpoint\" , ) def __str__ ( self ): return self . url or str ( self . djstripe_uuid ) def _attach_objects_hook ( self , cls , data , current_ids = None , api_key = djstripe_settings . STRIPE_SECRET_KEY ): \"\"\" Gets called by this object's create and sync methods just before save. Use this to populate fields before the model is saved. \"\"\" super () . _attach_objects_hook ( cls , data , current_ids = current_ids , api_key = api_key ) self . djstripe_uuid = data . get ( \"metadata\" , {}) . get ( \"djstripe_uuid\" ) Attributes djstripe . models . webhooks . WebhookEndpoint . api_version = models . CharField ( max_length = 64 , blank = True , help_text = 'The API version events are rendered as for this webhook endpoint. Defaults to the configured Stripe API Version.' ) class-attribute djstripe . models . webhooks . WebhookEndpoint . application = models . CharField ( max_length = 255 , blank = True , help_text = 'The ID of the associated Connect application.' ) class-attribute djstripe . models . webhooks . WebhookEndpoint . djstripe_uuid = models . UUIDField ( null = True , unique = True , default = uuid4 , help_text = 'A UUID specific to dj-stripe generated for the endpoint' ) class-attribute djstripe . models . webhooks . WebhookEndpoint . enabled_events = JSONField ( help_text = \"The list of events to enable for this endpoint. ['*'] indicates that all events are enabled, except those that require explicit selection.\" ) class-attribute djstripe . models . webhooks . WebhookEndpoint . secret = models . CharField ( max_length = 256 , blank = True , editable = False , help_text = \"The endpoint's secret, used to generate webhook signatures.\" ) class-attribute djstripe . models . webhooks . WebhookEndpoint . status = StripeEnumField ( enum = WebhookEndpointStatus , help_text = 'The status of the webhook. It can be enabled or disabled.' ) class-attribute djstripe . models . webhooks . WebhookEndpoint . stripe_class = stripe . WebhookEndpoint class-attribute djstripe . models . webhooks . WebhookEndpoint . stripe_dashboard_item_name = 'webhooks' class-attribute djstripe . models . webhooks . WebhookEndpoint . url = models . URLField ( help_text = 'The URL of the webhook endpoint.' , max_length = 2048 ) class-attribute Functions djstripe . models . webhooks . WebhookEndpoint . __str__ () Source code in djstripe/models/webhooks.py 63 64 def __str__ ( self ): return self . url or str ( self . djstripe_uuid ) djstripe.models.webhooks.WebhookEventTrigger Bases: models . Model An instance of a request that reached the server endpoint for Stripe webhooks. Webhook Events are initially UNTRUSTED , as it is possible for any web entity to post any data to our webhook url. Data posted may be valid Stripe information, garbage, or even malicious. The 'valid' flag in this model monitors this. Source code in djstripe/models/webhooks.py 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 class WebhookEventTrigger ( models . Model ): \"\"\" An instance of a request that reached the server endpoint for Stripe webhooks. Webhook Events are initially **UNTRUSTED**, as it is possible for any web entity to post any data to our webhook url. Data posted may be valid Stripe information, garbage, or even malicious. The 'valid' flag in this model monitors this. \"\"\" id = models . BigAutoField ( primary_key = True ) remote_ip = models . GenericIPAddressField ( help_text = \"IP address of the request client.\" ) headers = JSONField () body = models . TextField ( blank = True ) valid = models . BooleanField ( default = False , help_text = \"Whether or not the webhook event has passed validation\" , ) processed = models . BooleanField ( default = False , help_text = \"Whether or not the webhook event has been successfully processed\" , ) exception = models . CharField ( max_length = 128 , blank = True ) traceback = models . TextField ( blank = True , help_text = \"Traceback if an exception was thrown during processing\" ) event = StripeForeignKey ( \"Event\" , on_delete = models . SET_NULL , null = True , blank = True , help_text = \"Event object contained in the (valid) Webhook\" , ) djstripe_version = models . CharField ( max_length = 32 , default = _get_version , # Needs to be a callable, otherwise it's a db default. help_text = \"The version of dj-stripe when the webhook was received\" , ) created = models . DateTimeField ( auto_now_add = True ) updated = models . DateTimeField ( auto_now = True ) stripe_trigger_account = StripeForeignKey ( \"djstripe.Account\" , on_delete = models . CASCADE , to_field = \"id\" , null = True , blank = True , help_text = \"The Stripe Account this object belongs to.\" , ) webhook_endpoint = StripeForeignKey ( \"WebhookEndpoint\" , on_delete = models . SET_NULL , null = True , blank = True , help_text = \"The endpoint this webhook was received on\" , ) def __str__ ( self ): return f \"id= { self . id } , valid= { self . valid } , processed= { self . processed } \" @classmethod def from_request ( cls , request , * , webhook_endpoint : WebhookEndpoint = None ): \"\"\" Create, validate and process a WebhookEventTrigger given a Django request object. The process is three-fold: 1. Create a WebhookEventTrigger object from a Django request. 2. Validate the WebhookEventTrigger as a Stripe event using the API. 3. If valid, process it into an Event object (and child resource). \"\"\" try : body = request . body . decode ( request . encoding or \"utf-8\" ) except Exception : body = \"(error decoding body)\" ip = get_remote_ip ( request ) try : data = json . loads ( body ) except ValueError : data = {} if webhook_endpoint is None : stripe_account = StripeModel . _find_owner_account ( data = data ) secret = djstripe_settings . WEBHOOK_SECRET else : stripe_account = webhook_endpoint . djstripe_owner_account secret = webhook_endpoint . secret obj = cls . objects . create ( headers = dict ( request . headers ), body = body , remote_ip = ip , stripe_trigger_account = stripe_account , webhook_endpoint = webhook_endpoint , ) api_key = ( stripe_account . default_api_key or djstripe_settings . get_default_api_key ( obj . livemode ) ) try : # Validate the webhook first signals . webhook_pre_validate . send ( sender = cls , instance = obj ) obj . valid = obj . validate ( secret = secret , api_key = api_key ) signals . webhook_post_validate . send ( sender = cls , instance = obj , valid = obj . valid ) if obj . valid : signals . webhook_pre_process . send ( sender = cls , instance = obj ) if djstripe_settings . WEBHOOK_EVENT_CALLBACK : # If WEBHOOK_EVENT_CALLBACK, pass it for processing djstripe_settings . WEBHOOK_EVENT_CALLBACK ( obj , api_key = api_key ) else : # Process the item (do not save it, it'll get saved below) obj . process ( save = False , api_key = api_key ) signals . webhook_post_process . send ( sender = cls , instance = obj , api_key = api_key ) except Exception as e : max_length = cls . _meta . get_field ( \"exception\" ) . max_length obj . exception = str ( e )[: max_length ] obj . traceback = format_exc () # Send the exception as the webhook_processing_error signal signals . webhook_processing_error . send ( sender = cls , instance = obj , api_key = api_key , exception = e , data = getattr ( e , \"http_body\" , \"\" ), ) # re-raise the exception so Django sees it raise e finally : obj . save () return obj @cached_property def json_body ( self ): try : return json . loads ( self . body ) except ValueError : return {} @property def is_test_event ( self ): event_id = self . json_body . get ( \"id\" ) return event_id and event_id . endswith ( \"_00000000000000\" ) def verify_signature ( self , secret : str , tolerance : int = djstripe_settings . WEBHOOK_TOLERANCE ) -> bool : if not secret : raise ValueError ( \"Cannot verify event signature without a secret\" ) # HTTP headers are case-insensitive, but we store them as a dict. headers = CaseInsensitiveMapping ( self . headers ) signature = headers . get ( \"stripe-signature\" ) local_cli_signing_secret = headers . get ( \"x-djstripe-webhook-secret\" ) try : # check if the x-djstripe-webhook-secret Custom Header exists if local_cli_signing_secret : # Set Endpoint Signing Secret to the output of Stripe CLI # for signature verification secret = local_cli_signing_secret stripe . WebhookSignature . verify_header ( self . body , signature , secret , tolerance ) except stripe . error . SignatureVerificationError : logger . exception ( \"Failed to verify header\" ) return False else : return True def validate ( self , api_key : str = None , secret : str = djstripe_settings . WEBHOOK_SECRET , tolerance : int = djstripe_settings . WEBHOOK_TOLERANCE , validation_method = djstripe_settings . WEBHOOK_VALIDATION , ): \"\"\" The original contents of the Event message must be confirmed by refetching it and comparing the fetched data with the original data. This function makes an API call to Stripe to redownload the Event data and returns whether or not it matches the WebhookEventTrigger data. \"\"\" local_data = self . json_body if \"id\" not in local_data or \"livemode\" not in local_data : logger . error ( '\"id\" not in json body or \"livemode\" not in json body( %s )' , local_data ) return False if self . is_test_event : logger . info ( \"Test webhook received and discarded: %s \" , local_data ) return False if validation_method is None : # validation disabled warnings . warn ( \"WEBHOOK VALIDATION is disabled.\" ) return True elif validation_method == \"verify_signature\" : return self . verify_signature ( secret = secret ) livemode = local_data [ \"livemode\" ] api_key = api_key or djstripe_settings . get_default_api_key ( livemode ) # Retrieve the event using the api_version specified in itself remote_data = Event . stripe_class . retrieve ( id = local_data [ \"id\" ], api_key = api_key , stripe_version = local_data [ \"api_version\" ], ) return local_data [ \"data\" ] == remote_data [ \"data\" ] def process ( self , save = True , api_key : str = None ): # Reset traceback and exception in case of reprocessing self . exception = \"\" self . traceback = \"\" self . event = Event . process ( self . json_body , api_key = api_key ) self . processed = True if save : self . save () return self . event Attributes djstripe . models . webhooks . WebhookEventTrigger . body = models . TextField ( blank = True ) class-attribute djstripe . models . webhooks . WebhookEventTrigger . created = models . DateTimeField ( auto_now_add = True ) class-attribute djstripe . models . webhooks . WebhookEventTrigger . djstripe_version = models . CharField ( max_length = 32 , default = _get_version , help_text = 'The version of dj-stripe when the webhook was received' ) class-attribute djstripe . models . webhooks . WebhookEventTrigger . event = StripeForeignKey ( 'Event' , on_delete = models . SET_NULL , null = True , blank = True , help_text = 'Event object contained in the (valid) Webhook' ) class-attribute djstripe . models . webhooks . WebhookEventTrigger . exception = models . CharField ( max_length = 128 , blank = True ) class-attribute djstripe . models . webhooks . WebhookEventTrigger . headers = JSONField () class-attribute djstripe . models . webhooks . WebhookEventTrigger . id = models . BigAutoField ( primary_key = True ) class-attribute djstripe . models . webhooks . WebhookEventTrigger . is_test_event property djstripe . models . webhooks . WebhookEventTrigger . processed = models . BooleanField ( default = False , help_text = 'Whether or not the webhook event has been successfully processed' ) class-attribute djstripe . models . webhooks . WebhookEventTrigger . remote_ip = models . GenericIPAddressField ( help_text = 'IP address of the request client.' ) class-attribute djstripe . models . webhooks . WebhookEventTrigger . stripe_trigger_account = StripeForeignKey ( 'djstripe.Account' , on_delete = models . CASCADE , to_field = 'id' , null = True , blank = True , help_text = 'The Stripe Account this object belongs to.' ) class-attribute djstripe . models . webhooks . WebhookEventTrigger . traceback = models . TextField ( blank = True , help_text = 'Traceback if an exception was thrown during processing' ) class-attribute djstripe . models . webhooks . WebhookEventTrigger . updated = models . DateTimeField ( auto_now = True ) class-attribute djstripe . models . webhooks . WebhookEventTrigger . valid = models . BooleanField ( default = False , help_text = 'Whether or not the webhook event has passed validation' ) class-attribute djstripe . models . webhooks . WebhookEventTrigger . webhook_endpoint = StripeForeignKey ( 'WebhookEndpoint' , on_delete = models . SET_NULL , null = True , blank = True , help_text = 'The endpoint this webhook was received on' ) class-attribute Functions djstripe . models . webhooks . WebhookEventTrigger . __str__ () Source code in djstripe/models/webhooks.py 170 171 def __str__ ( self ): return f \"id= { self . id } , valid= { self . valid } , processed= { self . processed } \" djstripe . models . webhooks . WebhookEventTrigger . from_request ( request , * , webhook_endpoint = None ) classmethod Create, validate and process a WebhookEventTrigger given a Django request object. The process is three-fold: 1. Create a WebhookEventTrigger object from a Django request. 2. Validate the WebhookEventTrigger as a Stripe event using the API. 3. If valid, process it into an Event object (and child resource). Source code in djstripe/models/webhooks.py 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 @classmethod def from_request ( cls , request , * , webhook_endpoint : WebhookEndpoint = None ): \"\"\" Create, validate and process a WebhookEventTrigger given a Django request object. The process is three-fold: 1. Create a WebhookEventTrigger object from a Django request. 2. Validate the WebhookEventTrigger as a Stripe event using the API. 3. If valid, process it into an Event object (and child resource). \"\"\" try : body = request . body . decode ( request . encoding or \"utf-8\" ) except Exception : body = \"(error decoding body)\" ip = get_remote_ip ( request ) try : data = json . loads ( body ) except ValueError : data = {} if webhook_endpoint is None : stripe_account = StripeModel . _find_owner_account ( data = data ) secret = djstripe_settings . WEBHOOK_SECRET else : stripe_account = webhook_endpoint . djstripe_owner_account secret = webhook_endpoint . secret obj = cls . objects . create ( headers = dict ( request . headers ), body = body , remote_ip = ip , stripe_trigger_account = stripe_account , webhook_endpoint = webhook_endpoint , ) api_key = ( stripe_account . default_api_key or djstripe_settings . get_default_api_key ( obj . livemode ) ) try : # Validate the webhook first signals . webhook_pre_validate . send ( sender = cls , instance = obj ) obj . valid = obj . validate ( secret = secret , api_key = api_key ) signals . webhook_post_validate . send ( sender = cls , instance = obj , valid = obj . valid ) if obj . valid : signals . webhook_pre_process . send ( sender = cls , instance = obj ) if djstripe_settings . WEBHOOK_EVENT_CALLBACK : # If WEBHOOK_EVENT_CALLBACK, pass it for processing djstripe_settings . WEBHOOK_EVENT_CALLBACK ( obj , api_key = api_key ) else : # Process the item (do not save it, it'll get saved below) obj . process ( save = False , api_key = api_key ) signals . webhook_post_process . send ( sender = cls , instance = obj , api_key = api_key ) except Exception as e : max_length = cls . _meta . get_field ( \"exception\" ) . max_length obj . exception = str ( e )[: max_length ] obj . traceback = format_exc () # Send the exception as the webhook_processing_error signal signals . webhook_processing_error . send ( sender = cls , instance = obj , api_key = api_key , exception = e , data = getattr ( e , \"http_body\" , \"\" ), ) # re-raise the exception so Django sees it raise e finally : obj . save () return obj djstripe . models . webhooks . WebhookEventTrigger . json_body () Source code in djstripe/models/webhooks.py 256 257 258 259 260 261 @cached_property def json_body ( self ): try : return json . loads ( self . body ) except ValueError : return {} djstripe . models . webhooks . WebhookEventTrigger . process ( save = True , api_key = None ) Source code in djstripe/models/webhooks.py 339 340 341 342 343 344 345 346 347 348 349 def process ( self , save = True , api_key : str = None ): # Reset traceback and exception in case of reprocessing self . exception = \"\" self . traceback = \"\" self . event = Event . process ( self . json_body , api_key = api_key ) self . processed = True if save : self . save () return self . event djstripe . models . webhooks . WebhookEventTrigger . validate ( api_key = None , secret = djstripe_settings . WEBHOOK_SECRET , tolerance = djstripe_settings . WEBHOOK_TOLERANCE , validation_method = djstripe_settings . WEBHOOK_VALIDATION ) The original contents of the Event message must be confirmed by refetching it and comparing the fetched data with the original data. This function makes an API call to Stripe to redownload the Event data and returns whether or not it matches the WebhookEventTrigger data. Source code in djstripe/models/webhooks.py 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 def validate ( self , api_key : str = None , secret : str = djstripe_settings . WEBHOOK_SECRET , tolerance : int = djstripe_settings . WEBHOOK_TOLERANCE , validation_method = djstripe_settings . WEBHOOK_VALIDATION , ): \"\"\" The original contents of the Event message must be confirmed by refetching it and comparing the fetched data with the original data. This function makes an API call to Stripe to redownload the Event data and returns whether or not it matches the WebhookEventTrigger data. \"\"\" local_data = self . json_body if \"id\" not in local_data or \"livemode\" not in local_data : logger . error ( '\"id\" not in json body or \"livemode\" not in json body( %s )' , local_data ) return False if self . is_test_event : logger . info ( \"Test webhook received and discarded: %s \" , local_data ) return False if validation_method is None : # validation disabled warnings . warn ( \"WEBHOOK VALIDATION is disabled.\" ) return True elif validation_method == \"verify_signature\" : return self . verify_signature ( secret = secret ) livemode = local_data [ \"livemode\" ] api_key = api_key or djstripe_settings . get_default_api_key ( livemode ) # Retrieve the event using the api_version specified in itself remote_data = Event . stripe_class . retrieve ( id = local_data [ \"id\" ], api_key = api_key , stripe_version = local_data [ \"api_version\" ], ) return local_data [ \"data\" ] == remote_data [ \"data\" ] djstripe . models . webhooks . WebhookEventTrigger . verify_signature ( secret , tolerance = djstripe_settings . WEBHOOK_TOLERANCE ) Source code in djstripe/models/webhooks.py 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 def verify_signature ( self , secret : str , tolerance : int = djstripe_settings . WEBHOOK_TOLERANCE ) -> bool : if not secret : raise ValueError ( \"Cannot verify event signature without a secret\" ) # HTTP headers are case-insensitive, but we store them as a dict. headers = CaseInsensitiveMapping ( self . headers ) signature = headers . get ( \"stripe-signature\" ) local_cli_signing_secret = headers . get ( \"x-djstripe-webhook-secret\" ) try : # check if the x-djstripe-webhook-secret Custom Header exists if local_cli_signing_secret : # Set Endpoint Signing Secret to the output of Stripe CLI # for signature verification secret = local_cli_signing_secret stripe . WebhookSignature . verify_header ( self . body , signature , secret , tolerance ) except stripe . error . SignatureVerificationError : logger . exception ( \"Failed to verify header\" ) return False else : return True Functions djstripe . models . webhooks . get_remote_ip ( request ) Given the HTTPRequest object return the IP Address of the client :param request: client request :type request: HTTPRequest :Returns: the client ip address Source code in djstripe/models/webhooks.py 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 def get_remote_ip ( request ): \"\"\"Given the HTTPRequest object return the IP Address of the client :param request: client request :type request: HTTPRequest :Returns: the client ip address \"\"\" # x-forwarded-for is relevant for django running behind a proxy x_forwarded_for = request . headers . get ( \"x-forwarded-for\" ) if x_forwarded_for : ip = x_forwarded_for . split ( \",\" )[ 0 ] else : ip = request . META . get ( \"REMOTE_ADDR\" ) if not ip : warnings . warn ( \"Could not determine remote IP (missing REMOTE_ADDR). \" \"This is likely an issue with your wsgi/server setup.\" ) ip = \"0.0.0.0\" return ip","title":"Models"},{"location":"reference/models/#models","text":"Models hold the bulk of the functionality included in the dj-stripe package. Each model is tied closely to its corresponding object in the stripe dashboard. Fields that are not implemented for each model have a short reason behind the decision in the docstring for each model.","title":"Models"},{"location":"reference/models/#core-resources","text":"","title":"Core Resources"},{"location":"reference/models/#djstripe.models.core-attributes","text":"","title":"Attributes"},{"location":"reference/models/#djstripe.models.core.FileUpload","text":"","title":"FileUpload"},{"location":"reference/models/#djstripe.models.core-classes","text":"","title":"Classes"},{"location":"reference/models/#djstripe.models.core.BalanceTransaction","text":"Bases: StripeModel A single transaction that updates the Stripe balance. Stripe documentation: https://stripe.com/docs/api?lang=python#balance_transaction_object Source code in djstripe/models/core.py 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 class BalanceTransaction ( StripeModel ): \"\"\" A single transaction that updates the Stripe balance. Stripe documentation: https://stripe.com/docs/api?lang=python#balance_transaction_object \"\"\" stripe_class = stripe . BalanceTransaction amount = StripeQuantumCurrencyAmountField ( help_text = \"Gross amount of the transaction, in cents.\" ) available_on = StripeDateTimeField ( help_text = ( \"The date the transaction's net funds \" \"will become available in the Stripe balance.\" ) ) currency = StripeCurrencyCodeField () exchange_rate = models . DecimalField ( null = True , decimal_places = 6 , max_digits = 8 ) fee = StripeQuantumCurrencyAmountField ( help_text = \"Fee (in cents) paid for this transaction.\" ) fee_details = JSONField () net = StripeQuantumCurrencyAmountField ( help_text = \"Net amount of the transaction, in cents.\" ) source = StripeIdField () reporting_category = StripeEnumField ( enum = enums . BalanceTransactionReportingCategory , help_text = ( \"More information: https://stripe.com/docs/reports/reporting-categories\" ), ) status = StripeEnumField ( enum = enums . BalanceTransactionStatus ) type = StripeEnumField ( enum = enums . BalanceTransactionType ) def __str__ ( self ): amount = get_friendly_currency_amount ( self . amount / 100 , self . currency ) status = enums . BalanceTransactionStatus . humanize ( self . status ) return f \" { amount } ( { status } )\" def get_source_class ( self ): try : return apps . get_model ( \"djstripe\" , self . type ) except LookupError : raise def get_source_instance ( self ): return self . get_source_class () . objects . get ( id = self . source ) def get_stripe_dashboard_url ( self ): return self . get_source_instance () . get_stripe_dashboard_url ()","title":"BalanceTransaction"},{"location":"reference/models/#djstripe.models.core.BalanceTransaction-attributes","text":"","title":"Attributes"},{"location":"reference/models/#djstripe.models.core.BalanceTransaction.amount","text":"","title":"amount"},{"location":"reference/models/#djstripe.models.core.BalanceTransaction.available_on","text":"","title":"available_on"},{"location":"reference/models/#djstripe.models.core.BalanceTransaction.currency","text":"","title":"currency"},{"location":"reference/models/#djstripe.models.core.BalanceTransaction.exchange_rate","text":"","title":"exchange_rate"},{"location":"reference/models/#djstripe.models.core.BalanceTransaction.fee","text":"","title":"fee"},{"location":"reference/models/#djstripe.models.core.BalanceTransaction.fee_details","text":"","title":"fee_details"},{"location":"reference/models/#djstripe.models.core.BalanceTransaction.net","text":"","title":"net"},{"location":"reference/models/#djstripe.models.core.BalanceTransaction.reporting_category","text":"","title":"reporting_category"},{"location":"reference/models/#djstripe.models.core.BalanceTransaction.source","text":"","title":"source"},{"location":"reference/models/#djstripe.models.core.BalanceTransaction.status","text":"","title":"status"},{"location":"reference/models/#djstripe.models.core.BalanceTransaction.stripe_class","text":"","title":"stripe_class"},{"location":"reference/models/#djstripe.models.core.BalanceTransaction.type","text":"","title":"type"},{"location":"reference/models/#djstripe.models.core.BalanceTransaction-functions","text":"","title":"Functions"},{"location":"reference/models/#djstripe.models.core.BalanceTransaction.__str__","text":"Source code in djstripe/models/core.py 90 91 92 93 def __str__ ( self ): amount = get_friendly_currency_amount ( self . amount / 100 , self . currency ) status = enums . BalanceTransactionStatus . humanize ( self . status ) return f \" { amount } ( { status } )\"","title":"__str__()"},{"location":"reference/models/#djstripe.models.core.BalanceTransaction.get_source_class","text":"Source code in djstripe/models/core.py 95 96 97 98 99 def get_source_class ( self ): try : return apps . get_model ( \"djstripe\" , self . type ) except LookupError : raise","title":"get_source_class()"},{"location":"reference/models/#djstripe.models.core.BalanceTransaction.get_source_instance","text":"Source code in djstripe/models/core.py 101 102 def get_source_instance ( self ): return self . get_source_class () . objects . get ( id = self . source )","title":"get_source_instance()"},{"location":"reference/models/#djstripe.models.core.BalanceTransaction.get_stripe_dashboard_url","text":"Source code in djstripe/models/core.py 104 105 def get_stripe_dashboard_url ( self ): return self . get_source_instance () . get_stripe_dashboard_url ()","title":"get_stripe_dashboard_url()"},{"location":"reference/models/#djstripe.models.core.Charge","text":"Bases: StripeModel To charge a credit or a debit card, you create a charge object. You can retrieve and refund individual charges as well as list all charges. Charges are identified by a unique random ID. Stripe documentation: https://stripe.com/docs/api?lang=python#charges Source code in djstripe/models/core.py 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 class Charge ( StripeModel ): \"\"\" To charge a credit or a debit card, you create a charge object. You can retrieve and refund individual charges as well as list all charges. Charges are identified by a unique random ID. Stripe documentation: https://stripe.com/docs/api?lang=python#charges \"\"\" stripe_class = stripe . Charge expand_fields = [ \"balance_transaction\" ] stripe_dashboard_item_name = \"payments\" amount = StripeDecimalCurrencyAmountField ( help_text = \"Amount charged (as decimal).\" ) amount_captured = StripeDecimalCurrencyAmountField ( null = True , help_text = ( \"Amount (as decimal) captured (can be less than the amount attribute \" \"on the charge if a partial capture was issued).\" ), ) amount_refunded = StripeDecimalCurrencyAmountField ( help_text = ( \"Amount (as decimal) refunded (can be less than the amount attribute on \" \"the charge if a partial refund was issued).\" ) ) application = models . CharField ( max_length = 255 , blank = True , help_text = \"ID of the Connect application that created the charge.\" , ) application_fee = StripeForeignKey ( \"ApplicationFee\" , on_delete = models . SET_NULL , null = True , blank = True , related_name = \"fee_for_charge\" , help_text = \"The application fee (if any) for the charge.\" , ) application_fee_amount = StripeDecimalCurrencyAmountField ( null = True , blank = True , help_text = \"The amount (as decimal) of the application fee (if any) \" \"requested for the charge.\" , ) balance_transaction = StripeForeignKey ( \"BalanceTransaction\" , on_delete = models . SET_NULL , null = True , help_text = ( \"The balance transaction that describes the impact of this charge \" \"on your account balance (not including refunds or disputes).\" ), ) billing_details = JSONField ( null = True , help_text = \"Billing information associated with the PaymentMethod at the \" \"time of the transaction.\" , ) calculated_statement_descriptor = models . CharField ( max_length = 22 , default = \"\" , help_text = \"The full statement descriptor that is passed to card networks, \" \"and that is displayed on your customers' credit card and bank statements. \" \"Allows you to see what the statement descriptor looks like after the \" \"static and dynamic portions are combined.\" , ) captured = models . BooleanField ( default = False , help_text = \"If the charge was created without capturing, this boolean \" \"represents whether or not it is still uncaptured or has since been captured.\" , ) currency = StripeCurrencyCodeField ( help_text = \"The currency in which the charge was made.\" ) customer = StripeForeignKey ( \"Customer\" , on_delete = models . SET_NULL , null = True , blank = True , related_name = \"charges\" , help_text = \"The customer associated with this charge.\" , ) dispute = StripeForeignKey ( \"Dispute\" , on_delete = models . SET_NULL , null = True , blank = True , related_name = \"charges\" , help_text = \"Details about the dispute if the charge has been disputed.\" , ) disputed = models . BooleanField ( default = False , help_text = \"Whether the charge has been disputed.\" , ) failure_code = StripeEnumField ( enum = enums . ApiErrorCode , default = \"\" , blank = True , help_text = \"Error code explaining reason for charge failure if available.\" , ) failure_message = models . TextField ( max_length = 5000 , default = \"\" , blank = True , help_text = \"Message to user further explaining reason \" \"for charge failure if available.\" , ) fraud_details = JSONField ( help_text = \"Hash with information on fraud assessments for the charge.\" , null = True , blank = True , ) invoice = StripeForeignKey ( \"Invoice\" , on_delete = models . CASCADE , null = True , related_name = \"charges\" , help_text = \"The invoice this charge is for if one exists.\" , ) # TODO: order (requires Order model) on_behalf_of = StripeForeignKey ( \"Account\" , on_delete = models . CASCADE , null = True , blank = True , related_name = \"charges\" , help_text = \"The account (if any) the charge was made on behalf of \" \"without triggering an automatic transfer.\" , ) outcome = JSONField ( help_text = \"Details about whether or not the payment was accepted, and why.\" , null = True , blank = True , ) paid = models . BooleanField ( default = False , help_text = \"True if the charge succeeded, \" \"or was successfully authorized for later capture, False otherwise.\" , ) payment_intent = StripeForeignKey ( \"PaymentIntent\" , null = True , on_delete = models . SET_NULL , related_name = \"charges\" , help_text = \"PaymentIntent associated with this charge, if one exists.\" , ) payment_method = StripeForeignKey ( \"PaymentMethod\" , null = True , on_delete = models . SET_NULL , related_name = \"charges\" , help_text = \"PaymentMethod used in this charge.\" , ) payment_method_details = JSONField ( help_text = \"Details about the payment method at the time of the transaction.\" , null = True , blank = True , ) receipt_email = models . TextField ( max_length = 800 , # yup, 800. default = \"\" , blank = True , help_text = \"The email address that the receipt for this charge was sent to.\" , ) receipt_number = models . CharField ( max_length = 14 , default = \"\" , blank = True , help_text = \"The transaction number that appears \" \"on email receipts sent for this charge.\" , ) receipt_url = models . TextField ( max_length = 5000 , default = \"\" , blank = True , help_text = \"This is the URL to view the receipt for this charge. \" \"The receipt is kept up-to-date to the latest state of the charge, \" \"including any refunds. If the charge is for an Invoice, \" \"the receipt will be stylized as an Invoice receipt.\" , ) refunded = models . BooleanField ( default = False , help_text = \"Whether or not the charge has been fully refunded. \" \"If the charge is only partially refunded, \" \"this attribute will still be false.\" , ) # TODO: review (requires Review model) shipping = JSONField ( null = True , blank = True , help_text = \"Shipping information for the charge\" ) source = PaymentMethodForeignKey ( on_delete = models . SET_NULL , null = True , blank = True , related_name = \"charges\" , help_text = \"The source used for this charge.\" , ) source_transfer = StripeForeignKey ( \"Transfer\" , null = True , blank = True , on_delete = models . CASCADE , help_text = \"The transfer which created this charge. Only present if the \" \"charge came from another Stripe account.\" , related_name = \"+\" , ) statement_descriptor = models . CharField ( max_length = 22 , null = True , blank = True , help_text = \"For card charges, use statement_descriptor_suffix instead. \" \"Otherwise, you can use this value as the complete description of a \" \"charge on your customers' statements. Must contain at least one letter, \" \"maximum 22 characters.\" , ) statement_descriptor_suffix = models . CharField ( max_length = 22 , null = True , blank = True , help_text = \"Provides information about the charge that customers see on \" \"their statements. Concatenated with the prefix (shortened descriptor) \" \"or statement descriptor that's set on the account to form the \" \"complete statement descriptor. \" \"Maximum 22 characters for the concatenated descriptor.\" , ) status = StripeEnumField ( enum = enums . ChargeStatus , help_text = \"The status of the payment.\" ) transfer = StripeForeignKey ( \"Transfer\" , on_delete = models . CASCADE , null = True , blank = True , help_text = ( \"The transfer to the `destination` account (only applicable if \" \"the charge was created using the `destination` parameter).\" ), ) transfer_data = JSONField ( null = True , blank = True , help_text = \"An optional dictionary including the account to automatically \" \"transfer to as part of a destination charge.\" , ) transfer_group = models . CharField ( max_length = 255 , null = True , blank = True , help_text = \"A string that identifies this transaction as part of a group.\" , ) objects = ChargeManager () def __str__ ( self ): amount = get_friendly_currency_amount ( self . amount , self . currency ) return f \" { amount } ( { self . human_readable_status } )\" @property def fee ( self ): if self . balance_transaction : return self . balance_transaction . fee @property def human_readable_status ( self ) -> str : if not self . captured : return \"Uncaptured\" elif self . disputed : return \"Disputed\" elif self . refunded : return \"Refunded\" return enums . ChargeStatus . humanize ( self . status ) @property def fraudulent ( self ) -> bool : return ( self . fraud_details and list ( self . fraud_details . values ())[ 0 ] == \"fraudulent\" ) def _calculate_refund_amount ( self , amount : Optional [ Decimal ]) -> int : \"\"\" Returns the amount that can be refunded (in cents) \"\"\" eligible_to_refund = self . amount - ( self . amount_refunded or 0 ) amount_to_refund = ( min ( eligible_to_refund , amount ) if amount else eligible_to_refund ) return int ( amount_to_refund * 100 ) def refund ( self , amount : Decimal = None , reason : str = None , api_key : str = None , stripe_account : str = None , ) -> \"Refund\" : \"\"\" Initiate a refund. Returns the refund object. :param amount: A positive decimal amount representing how much of this charge to refund. If amount is not provided, then this will be a full refund. Can only refund up to the unrefunded amount remaining of the charge. :param reason: String indicating the reason for the refund. If set, possible values are ``duplicate``, ``fraudulent``, and ``requested_by_customer``. Specifying ``fraudulent`` as the reason when you believe the charge to be fraudulent will help Stripe improve their fraud detection algorithms. \"\"\" # Prefer passed in stripe_account if set. if not stripe_account : stripe_account = self . _get_stripe_account_id ( api_key ) refund_obj = Refund . _api_create ( charge = self . id , amount = self . _calculate_refund_amount ( amount = amount ), reason = reason , api_key = api_key or self . default_api_key , stripe_account = stripe_account , ) return Refund . sync_from_stripe_data ( refund_obj , api_key = api_key or self . default_api_key , stripe_version = djstripe_settings . STRIPE_API_VERSION , ) def capture ( self , ** kwargs ) -> \"Charge\" : \"\"\" Capture the payment of an existing, uncaptured, charge. This is the second half of the two-step payment flow, where first you created a charge with the capture option set to False. See https://stripe.com/docs/api#capture_charge \"\"\" captured_charge = self . api_retrieve () . capture ( ** kwargs ) return self . __class__ . sync_from_stripe_data ( captured_charge , api_key = self . default_api_key ) def _attach_objects_post_save_hook ( self , cls , data , pending_relations = None , api_key = djstripe_settings . STRIPE_SECRET_KEY , ): super () . _attach_objects_post_save_hook ( cls , data , pending_relations = pending_relations , api_key = api_key ) cls . _stripe_object_to_refunds ( target_cls = Refund , data = data , charge = self , api_key = api_key )","title":"Charge"},{"location":"reference/models/#djstripe.models.core.Charge-attributes","text":"","title":"Attributes"},{"location":"reference/models/#djstripe.models.core.Charge.amount","text":"","title":"amount"},{"location":"reference/models/#djstripe.models.core.Charge.amount_captured","text":"","title":"amount_captured"},{"location":"reference/models/#djstripe.models.core.Charge.amount_refunded","text":"","title":"amount_refunded"},{"location":"reference/models/#djstripe.models.core.Charge.application","text":"","title":"application"},{"location":"reference/models/#djstripe.models.core.Charge.application_fee","text":"","title":"application_fee"},{"location":"reference/models/#djstripe.models.core.Charge.application_fee_amount","text":"","title":"application_fee_amount"},{"location":"reference/models/#djstripe.models.core.Charge.balance_transaction","text":"","title":"balance_transaction"},{"location":"reference/models/#djstripe.models.core.Charge.billing_details","text":"","title":"billing_details"},{"location":"reference/models/#djstripe.models.core.Charge.calculated_statement_descriptor","text":"","title":"calculated_statement_descriptor"},{"location":"reference/models/#djstripe.models.core.Charge.captured","text":"","title":"captured"},{"location":"reference/models/#djstripe.models.core.Charge.currency","text":"","title":"currency"},{"location":"reference/models/#djstripe.models.core.Charge.customer","text":"","title":"customer"},{"location":"reference/models/#djstripe.models.core.Charge.dispute","text":"","title":"dispute"},{"location":"reference/models/#djstripe.models.core.Charge.disputed","text":"","title":"disputed"},{"location":"reference/models/#djstripe.models.core.Charge.expand_fields","text":"","title":"expand_fields"},{"location":"reference/models/#djstripe.models.core.Charge.failure_code","text":"","title":"failure_code"},{"location":"reference/models/#djstripe.models.core.Charge.failure_message","text":"","title":"failure_message"},{"location":"reference/models/#djstripe.models.core.Charge.fee","text":"","title":"fee"},{"location":"reference/models/#djstripe.models.core.Charge.fraud_details","text":"","title":"fraud_details"},{"location":"reference/models/#djstripe.models.core.Charge.fraudulent","text":"","title":"fraudulent"},{"location":"reference/models/#djstripe.models.core.Charge.human_readable_status","text":"","title":"human_readable_status"},{"location":"reference/models/#djstripe.models.core.Charge.invoice","text":"","title":"invoice"},{"location":"reference/models/#djstripe.models.core.Charge.objects","text":"","title":"objects"},{"location":"reference/models/#djstripe.models.core.Charge.on_behalf_of","text":"","title":"on_behalf_of"},{"location":"reference/models/#djstripe.models.core.Charge.outcome","text":"","title":"outcome"},{"location":"reference/models/#djstripe.models.core.Charge.paid","text":"","title":"paid"},{"location":"reference/models/#djstripe.models.core.Charge.payment_intent","text":"","title":"payment_intent"},{"location":"reference/models/#djstripe.models.core.Charge.payment_method","text":"","title":"payment_method"},{"location":"reference/models/#djstripe.models.core.Charge.payment_method_details","text":"","title":"payment_method_details"},{"location":"reference/models/#djstripe.models.core.Charge.receipt_email","text":"","title":"receipt_email"},{"location":"reference/models/#djstripe.models.core.Charge.receipt_number","text":"","title":"receipt_number"},{"location":"reference/models/#djstripe.models.core.Charge.receipt_url","text":"","title":"receipt_url"},{"location":"reference/models/#djstripe.models.core.Charge.refunded","text":"","title":"refunded"},{"location":"reference/models/#djstripe.models.core.Charge.shipping","text":"","title":"shipping"},{"location":"reference/models/#djstripe.models.core.Charge.source","text":"","title":"source"},{"location":"reference/models/#djstripe.models.core.Charge.source_transfer","text":"","title":"source_transfer"},{"location":"reference/models/#djstripe.models.core.Charge.statement_descriptor","text":"","title":"statement_descriptor"},{"location":"reference/models/#djstripe.models.core.Charge.statement_descriptor_suffix","text":"","title":"statement_descriptor_suffix"},{"location":"reference/models/#djstripe.models.core.Charge.status","text":"","title":"status"},{"location":"reference/models/#djstripe.models.core.Charge.stripe_class","text":"","title":"stripe_class"},{"location":"reference/models/#djstripe.models.core.Charge.stripe_dashboard_item_name","text":"","title":"stripe_dashboard_item_name"},{"location":"reference/models/#djstripe.models.core.Charge.transfer","text":"","title":"transfer"},{"location":"reference/models/#djstripe.models.core.Charge.transfer_data","text":"","title":"transfer_data"},{"location":"reference/models/#djstripe.models.core.Charge.transfer_group","text":"","title":"transfer_group"},{"location":"reference/models/#djstripe.models.core.Charge-functions","text":"","title":"Functions"},{"location":"reference/models/#djstripe.models.core.Charge.__str__","text":"Source code in djstripe/models/core.py 364 365 366 def __str__ ( self ): amount = get_friendly_currency_amount ( self . amount , self . currency ) return f \" { amount } ( { self . human_readable_status } )\"","title":"__str__()"},{"location":"reference/models/#djstripe.models.core.Charge.capture","text":"Capture the payment of an existing, uncaptured, charge. This is the second half of the two-step payment flow, where first you created a charge with the capture option set to False. See https://stripe.com/docs/api#capture_charge Source code in djstripe/models/core.py 437 438 439 440 441 442 443 444 445 446 447 448 449 def capture ( self , ** kwargs ) -> \"Charge\" : \"\"\" Capture the payment of an existing, uncaptured, charge. This is the second half of the two-step payment flow, where first you created a charge with the capture option set to False. See https://stripe.com/docs/api#capture_charge \"\"\" captured_charge = self . api_retrieve () . capture ( ** kwargs ) return self . __class__ . sync_from_stripe_data ( captured_charge , api_key = self . default_api_key )","title":"capture()"},{"location":"reference/models/#djstripe.models.core.Charge.refund","text":"Initiate a refund. Returns the refund object. :param amount: A positive decimal amount representing how much of this charge to refund. If amount is not provided, then this will be a full refund. Can only refund up to the unrefunded amount remaining of the charge. :param reason: String indicating the reason for the refund. If set, possible values are duplicate , fraudulent , and requested_by_customer . Specifying fraudulent as the reason when you believe the charge to be fraudulent will help Stripe improve their fraud detection algorithms. Source code in djstripe/models/core.py 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 def refund ( self , amount : Decimal = None , reason : str = None , api_key : str = None , stripe_account : str = None , ) -> \"Refund\" : \"\"\" Initiate a refund. Returns the refund object. :param amount: A positive decimal amount representing how much of this charge to refund. If amount is not provided, then this will be a full refund. Can only refund up to the unrefunded amount remaining of the charge. :param reason: String indicating the reason for the refund. If set, possible values are ``duplicate``, ``fraudulent``, and ``requested_by_customer``. Specifying ``fraudulent`` as the reason when you believe the charge to be fraudulent will help Stripe improve their fraud detection algorithms. \"\"\" # Prefer passed in stripe_account if set. if not stripe_account : stripe_account = self . _get_stripe_account_id ( api_key ) refund_obj = Refund . _api_create ( charge = self . id , amount = self . _calculate_refund_amount ( amount = amount ), reason = reason , api_key = api_key or self . default_api_key , stripe_account = stripe_account , ) return Refund . sync_from_stripe_data ( refund_obj , api_key = api_key or self . default_api_key , stripe_version = djstripe_settings . STRIPE_API_VERSION , )","title":"refund()"},{"location":"reference/models/#djstripe.models.core.Customer","text":"Bases: StripeModel Customer objects allow you to perform recurring charges and track multiple charges that are associated with the same customer. Stripe documentation: https://stripe.com/docs/api?lang=python#customers Source code in djstripe/models/core.py 637 638 639 640 641 642 643 644 645 646 647 648 649 650 651 652 653 654 655 656 657 658 659 660 661 662 663 664 665 666 667 668 669 670 671 672 673 674 675 676 677 678 679 680 681 682 683 684 685 686 687 688 689 690 691 692 693 694 695 696 697 698 699 700 701 702 703 704 705 706 707 708 709 710 711 712 713 714 715 716 717 718 719 720 721 722 723 724 725 726 727 728 729 730 731 732 733 734 735 736 737 738 739 740 741 742 743 744 745 746 747 748 749 750 751 752 753 754 755 756 757 758 759 760 761 762 763 764 765 766 767 768 769 770 771 772 773 774 775 776 777 778 779 780 781 782 783 784 785 786 787 788 789 790 791 792 793 794 795 796 797 798 799 800 801 802 803 804 805 806 807 808 809 810 811 812 813 814 815 816 817 818 819 820 821 822 823 824 825 826 827 828 829 830 831 832 833 834 835 836 837 838 839 840 841 842 843 844 845 846 847 848 849 850 851 852 853 854 855 856 857 858 859 860 861 862 863 864 865 866 867 868 869 870 871 872 873 874 875 876 877 878 879 880 881 882 883 884 885 886 887 888 889 890 891 892 893 894 895 896 897 898 899 900 901 902 903 904 905 906 907 908 909 910 911 912 913 914 915 916 917 918 919 920 921 922 923 924 925 926 927 928 929 930 931 932 933 934 935 936 937 938 939 940 941 942 943 944 945 946 947 948 949 950 951 952 953 954 955 956 957 958 959 960 961 962 963 964 965 966 967 968 969 970 971 972 973 974 975 976 977 978 979 980 981 982 983 984 985 986 987 988 989 990 991 992 993 994 995 996 997 998 999 1000 1001 1002 1003 1004 1005 1006 1007 1008 1009 1010 1011 1012 1013 1014 1015 1016 1017 1018 1019 1020 1021 1022 1023 1024 1025 1026 1027 1028 1029 1030 1031 1032 1033 1034 1035 1036 1037 1038 1039 1040 1041 1042 1043 1044 1045 1046 1047 1048 1049 1050 1051 1052 1053 1054 1055 1056 1057 1058 1059 1060 1061 1062 1063 1064 1065 1066 1067 1068 1069 1070 1071 1072 1073 1074 1075 1076 1077 1078 1079 1080 1081 1082 1083 1084 1085 1086 1087 1088 1089 1090 1091 1092 1093 1094 1095 1096 1097 1098 1099 1100 1101 1102 1103 1104 1105 1106 1107 1108 1109 1110 1111 1112 1113 1114 1115 1116 1117 1118 1119 1120 1121 1122 1123 1124 1125 1126 1127 1128 1129 1130 1131 1132 1133 1134 1135 1136 1137 1138 1139 1140 1141 1142 1143 1144 1145 1146 1147 1148 1149 1150 1151 1152 1153 1154 1155 1156 1157 1158 1159 1160 1161 1162 1163 1164 1165 1166 1167 1168 1169 1170 1171 1172 1173 1174 1175 1176 1177 1178 1179 1180 1181 1182 1183 1184 1185 1186 1187 1188 1189 1190 1191 1192 1193 1194 1195 1196 1197 1198 1199 1200 1201 1202 1203 1204 1205 1206 1207 1208 1209 1210 1211 1212 1213 1214 1215 1216 1217 1218 1219 1220 1221 1222 1223 1224 1225 1226 1227 1228 1229 1230 1231 1232 1233 1234 1235 1236 1237 1238 1239 1240 1241 1242 1243 1244 1245 1246 1247 1248 1249 1250 1251 1252 1253 1254 1255 1256 1257 1258 1259 1260 1261 1262 1263 1264 1265 1266 1267 1268 1269 1270 1271 1272 1273 1274 1275 1276 1277 1278 1279 1280 1281 1282 1283 1284 1285 1286 1287 1288 1289 1290 1291 1292 1293 1294 1295 1296 1297 1298 1299 1300 1301 1302 1303 1304 1305 1306 1307 1308 1309 1310 1311 1312 1313 1314 1315 1316 1317 1318 1319 1320 1321 1322 1323 1324 1325 1326 1327 1328 1329 1330 1331 1332 1333 1334 1335 1336 1337 1338 1339 1340 1341 1342 1343 1344 1345 1346 1347 1348 1349 1350 1351 1352 1353 1354 1355 1356 1357 1358 1359 1360 1361 1362 1363 1364 1365 1366 1367 1368 1369 1370 1371 1372 1373 1374 1375 1376 1377 1378 1379 1380 1381 1382 1383 1384 1385 1386 1387 1388 1389 1390 1391 1392 1393 class Customer ( StripeModel ): \"\"\" Customer objects allow you to perform recurring charges and track multiple charges that are associated with the same customer. Stripe documentation: https://stripe.com/docs/api?lang=python#customers \"\"\" stripe_class = stripe . Customer expand_fields = [ \"default_source\" , \"sources\" ] stripe_dashboard_item_name = \"customers\" address = JSONField ( null = True , blank = True , help_text = \"The customer's address.\" ) balance = StripeQuantumCurrencyAmountField ( null = True , blank = True , default = 0 , help_text = ( \"Current balance (in cents), if any, being stored on the customer's \" \"account. \" \"If negative, the customer has credit to apply to the next invoice. \" \"If positive, the customer has an amount owed that will be added to the \" \"next invoice. The balance does not refer to any unpaid invoices; it \" \"solely takes into account amounts that have yet to be successfully \" \"applied to any invoice. This balance is only taken into account for \" \"recurring billing purposes (i.e., subscriptions, invoices, invoice items).\" ), ) currency = StripeCurrencyCodeField ( blank = True , default = \"\" , help_text = \"The currency the customer can be charged in for \" \"recurring billing purposes\" , ) default_source = PaymentMethodForeignKey ( on_delete = models . SET_NULL , null = True , blank = True , related_name = \"customers\" ) delinquent = models . BooleanField ( null = True , blank = True , default = False , help_text = \"Whether or not the latest charge for the customer's \" \"latest invoice has failed.\" , ) # Stripe API returns deleted customers like so: # { # \"id\": \"cus_KX439W5dKrpi22\", # \"object\": \"customer\", # \"deleted\": true, # } deleted = models . BooleanField ( default = False , null = True , blank = True , help_text = \"Whether the Customer instance has been deleted upstream in Stripe or not.\" , ) # <discount> coupon = models . ForeignKey ( \"Coupon\" , null = True , blank = True , on_delete = models . SET_NULL ) coupon_start = StripeDateTimeField ( null = True , blank = True , editable = False , help_text = \"If a coupon is present, the date at which it was applied.\" , ) coupon_end = StripeDateTimeField ( null = True , blank = True , editable = False , help_text = \"If a coupon is present and has a limited duration, \" \"the date that the discount will end.\" , ) # </discount> discount = JSONField ( null = True , blank = True , help_text = \"Describes the current discount active on the customer, if there is one.\" , ) email = models . TextField ( max_length = 5000 , default = \"\" , blank = True ) invoice_prefix = models . CharField ( default = \"\" , blank = True , max_length = 255 , help_text = ( \"The prefix for the customer used to generate unique invoice numbers.\" ), ) invoice_settings = JSONField ( null = True , blank = True , help_text = \"The customer's default invoice settings.\" ) # default_payment_method is actually nested inside invoice_settings # this field is a convenience to provide the foreign key default_payment_method = StripeForeignKey ( \"PaymentMethod\" , null = True , blank = True , on_delete = models . SET_NULL , related_name = \"+\" , help_text = \"default payment method used for subscriptions and invoices \" \"for the customer.\" , ) name = models . TextField ( max_length = 5000 , default = \"\" , blank = True , help_text = \"The customer's full name or business name.\" , ) phone = models . TextField ( max_length = 5000 , default = \"\" , blank = True , help_text = \"The customer's phone number.\" , ) preferred_locales = JSONField ( null = True , blank = True , help_text = ( \"The customer's preferred locales (languages), ordered by preference.\" ), ) shipping = JSONField ( null = True , blank = True , help_text = \"Shipping information associated with the customer.\" , ) tax_exempt = StripeEnumField ( enum = enums . CustomerTaxExempt , default = \"\" , help_text = \"Describes the customer's tax exemption status. When set to reverse, \" 'invoice and receipt PDFs include the text \"Reverse charge\".' , ) # dj-stripe fields subscriber = models . ForeignKey ( djstripe_settings . get_subscriber_model_string (), blank = True , null = True , on_delete = models . SET_NULL , related_name = \"djstripe_customers\" , ) date_purged = models . DateTimeField ( null = True , editable = False ) class Meta ( StripeModel . Meta ): unique_together = ( \"subscriber\" , \"livemode\" , \"djstripe_owner_account\" ) def __str__ ( self ): if self . subscriber : return str ( self . subscriber ) return self . name or self . description or self . id @classmethod def _manipulate_stripe_object_hook ( cls , data ): # stripe adds a deleted attribute if the Customer has been deleted upstream if data . get ( \"deleted\" ): logger . warning ( f \"This customer ( { data . get ( 'id' ) } ) has been deleted upstream, in Stripe\" ) else : # set \"deleted\" key to False (default) data [ \"deleted\" ] = False discount = data . get ( \"discount\" ) if discount : data [ \"coupon_start\" ] = discount [ \"start\" ] data [ \"coupon_end\" ] = discount [ \"end\" ] # Populate the object id for our default_payment_method field (or set it None) data [ \"default_payment_method\" ] = data . get ( \"invoice_settings\" , {}) . get ( \"default_payment_method\" ) return data @classmethod def get_or_create ( cls , subscriber , livemode = djstripe_settings . STRIPE_LIVE_MODE , stripe_account = None , ): \"\"\" Get or create a dj-stripe customer. :param subscriber: The subscriber model instance for which to get or create a customer. :type subscriber: User :param livemode: Whether to get the subscriber in live or test mode. :type livemode: bool \"\"\" try : return cls . objects . get ( subscriber = subscriber , livemode = livemode ), False except cls . DoesNotExist : action = f \"create: { subscriber . pk } \" idempotency_key = djstripe_settings . get_idempotency_key ( \"customer\" , action , livemode ) return ( cls . create ( subscriber , idempotency_key = idempotency_key , stripe_account = stripe_account , ), True , ) @classmethod def create ( cls , subscriber , idempotency_key = None , stripe_account = None ): metadata = {} subscriber_key = djstripe_settings . SUBSCRIBER_CUSTOMER_KEY if subscriber_key not in ( \"\" , None ): metadata [ subscriber_key ] = subscriber . pk stripe_customer = cls . _api_create ( email = subscriber . email , idempotency_key = idempotency_key , metadata = metadata , stripe_account = stripe_account , ) customer , created = cls . objects . get_or_create ( id = stripe_customer [ \"id\" ], defaults = { \"subscriber\" : subscriber , \"livemode\" : stripe_customer [ \"livemode\" ], \"balance\" : stripe_customer . get ( \"balance\" , 0 ), \"delinquent\" : stripe_customer . get ( \"delinquent\" , False ), }, ) return customer @property def credits ( self ): \"\"\" The customer is considered to have credits if their balance is below 0. \"\"\" return abs ( min ( self . balance , 0 )) @property def customer_payment_methods ( self ): \"\"\" An iterable of all of the customer's payment methods (sources, then legacy cards) \"\"\" for source in self . sources . iterator (): yield source for card in self . legacy_cards . iterator (): yield card @property def pending_charges ( self ): \"\"\" The customer is considered to have pending charges if their balance is above 0. \"\"\" return max ( self . balance , 0 ) def subscribe ( self , * , items = None , price = None , plan = None , ** kwargs ): \"\"\" Subscribes this customer to all the prices or plans in the items dict (Recommended). :param items: A list of up to 20 subscription items, each with an attached price :type list: :param items: A dictionary of Plan (or Plan ID) or Price (or Price ID) :type dict: The price or plan to which to subscribe the customer. :param price: The price to which to subscribe the customer. :type price: Price or string (price ID) :param plan: The plan to which to subscribe the customer. :type plan: Plan or string (plan ID) \"\"\" from .billing import Subscription if ( items and price ) or ( items and plan ) or ( price and plan ): raise TypeError ( \"Please define only one of items, price or plan arguments.\" ) if items is None : _items = [{ \"price\" : price }] else : _items = [] for item in items : price = item . get ( \"price\" , \"\" ) plan = item . get ( \"plan\" , \"\" ) price , kwargs = _sanitise_price ( price , plan , ** kwargs ) if \"price\" in item : _items . append ({ \"price\" : price }) if \"plan\" in item : _items . append ({ \"plan\" : price }) stripe_subscription = Subscription . _api_create ( items = _items , customer = self . id , ** kwargs ) api_key = kwargs . get ( \"api_key\" ) or self . default_api_key return Subscription . sync_from_stripe_data ( stripe_subscription , api_key = api_key ) def charge ( self , amount : Decimal , * , application_fee : Decimal = None , source : Union [ str , StripeModel ] = None , ** kwargs , ) -> Charge : \"\"\" Creates a charge for this customer. :param amount: The amount to charge. :type amount: Decimal. Precision is 2; anything more will be ignored. :param source: The source to use for this charge. Must be a source attributed to this customer. If None, the customer's default source is used. Can be either the id of the source or the source object itself. :type source: string, Source \"\"\" if not isinstance ( amount , Decimal ): raise ValueError ( \"You must supply a decimal value representing dollars.\" ) # Convert Source to id if source and isinstance ( source , StripeModel ): source = source . id stripe_charge = Charge . _api_create ( customer = self . id , amount = int ( amount * 100 ), # Convert dollars into cents application_fee = int ( application_fee * 100 ) if application_fee else None , # Convert dollars into cents source = source , ** kwargs , ) api_key = kwargs . get ( \"api_key\" ) or self . default_api_key return Charge . sync_from_stripe_data ( stripe_charge , api_key = api_key ) def add_invoice_item ( self , amount , currency , description = None , discountable = None , invoice = None , metadata = None , subscription = None , ): \"\"\" Adds an arbitrary charge or credit to the customer's upcoming invoice. Different than creating a charge. Charges are separate bills that get processed immediately. Invoice items are appended to the customer's next invoice. This is extremely useful when adding surcharges to subscriptions. :param amount: The amount to charge. :type amount: Decimal. Precision is 2; anything more will be ignored. :param currency: 3-letter ISO code for currency :type currency: string :param description: An arbitrary string. :type description: string :param discountable: Controls whether discounts apply to this invoice item. Defaults to False for prorations or negative invoice items, and True for all other invoice items. :type discountable: boolean :param invoice: An existing invoice to add this invoice item to. When left blank, the invoice item will be added to the next upcoming \\ scheduled invoice. \\ Use this when adding invoice items in response to an \\ ``invoice.created`` webhook. You cannot add an invoice \\ item to an invoice that has already been paid, attempted or closed. :type invoice: Invoice or string (invoice ID) :param metadata: A set of key/value pairs useful for storing additional information. :type metadata: dict :param subscription: A subscription to add this invoice item to. When left blank, the invoice item will be be added to the next upcoming \\ scheduled invoice. When set, scheduled invoices for subscriptions other \\ than the specified subscription will ignore the invoice item. \\ Use this when you want to express that an invoice item has been accrued \\ within the context of a particular subscription. :type subscription: Subscription or string (subscription ID) .. Notes: .. if you're using ``Customer.add_invoice_item()`` instead of .. ``Customer.add_invoice_item()``, ``invoice`` and ``subscriptions`` .. can only be strings \"\"\" from .billing import InvoiceItem if not isinstance ( amount , Decimal ): raise ValueError ( \"You must supply a decimal value representing dollars.\" ) # Convert Invoice to id if invoice is not None and isinstance ( invoice , StripeModel ): invoice = invoice . id # Convert Subscription to id if subscription is not None and isinstance ( subscription , StripeModel ): subscription = subscription . id stripe_invoiceitem = InvoiceItem . _api_create ( amount = int ( amount * 100 ), # Convert dollars into cents currency = currency , customer = self . id , description = description , discountable = discountable , invoice = invoice , metadata = metadata , subscription = subscription , ) return InvoiceItem . sync_from_stripe_data ( stripe_invoiceitem , api_key = self . default_api_key ) def add_card ( self , source , set_default = True ): \"\"\" Adds a card to this customer's account. :param source: Either a token, like the ones returned by our Stripe.js, or a dictionary containing a user's credit card details. Stripe will automatically validate the card. :type source: string, dict :param set_default: Whether or not to set the source as the customer's default source :type set_default: boolean \"\"\" from .payment_methods import DjstripePaymentMethod stripe_customer = self . api_retrieve () new_stripe_payment_method = stripe_customer . sources . create ( source = source ) if set_default : stripe_customer . default_source = new_stripe_payment_method [ \"id\" ] stripe_customer . save () new_payment_method = DjstripePaymentMethod . from_stripe_object ( new_stripe_payment_method ) # Change the default source if set_default : self . default_source = new_payment_method self . save () return new_payment_method . resolve () def add_payment_method ( self , payment_method , set_default = True ): \"\"\" Adds an already existing payment method to this customer's account :param payment_method: PaymentMethod to be attached to the customer :type payment_method: str, PaymentMethod :param set_default: If true, this will be set as the default_payment_method :type set_default: bool :rtype: PaymentMethod \"\"\" from .payment_methods import PaymentMethod stripe_customer = self . api_retrieve () payment_method = PaymentMethod . attach ( payment_method , stripe_customer ) if set_default : stripe_customer [ \"invoice_settings\" ][ \"default_payment_method\" ] = payment_method . id stripe_customer . save () # Refresh self from the stripe customer, this should have two effects: # 1) sets self.default_payment_method (we rely on logic in # Customer._manipulate_stripe_object_hook to do this) # 2) updates self.invoice_settings.default_payment_methods self . sync_from_stripe_data ( stripe_customer , api_key = self . default_api_key ) self . refresh_from_db () return payment_method def purge ( self ): \"\"\"Customers are soft deleted as deleted customers are still accessible by the Stripe API and sync for all RelatedModels would fail\"\"\" try : self . _api_delete () except InvalidRequestError as exc : if \"No such customer:\" in str ( exc ): # The exception was thrown because the stripe customer was already # deleted on the stripe side, ignore the exception pass else : # The exception was raised for another reason, re-raise it raise # toggle the deleted flag on Customer to indicate it has been # deleted upstream in Stripe self . deleted = True if self . subscriber : # Delete the idempotency key used by Customer.create() # So re-creating a customer for this subscriber before the key expires # doesn't return the older Customer data idempotency_key_action = f \"customer:create: { self . subscriber . pk } \" IdempotencyKey . objects . filter ( action = idempotency_key_action ) . delete () self . subscriber = None # Remove sources self . default_source = None for source in self . legacy_cards . all (): source . remove () for source in self . sources . all (): source . detach () self . date_purged = timezone . now () self . save () def _get_valid_subscriptions ( self ): \"\"\"Get a list of this customer's valid subscriptions.\"\"\" return [ subscription for subscription in self . subscriptions . all () if subscription . is_valid () ] def is_subscribed_to ( self , product : Union [ Product , str ]) -> bool : \"\"\" Checks to see if this customer has an active subscription to the given product. :param product: The product for which to check for an active subscription. :type product: Product or string (product ID) :returns: True if there exists an active subscription, False otherwise. \"\"\" if isinstance ( product , StripeModel ): product = product . id for subscription in self . _get_valid_subscriptions (): for item in subscription . items . all (): if item . price and item . price . product . id == product : return True return False def has_any_active_subscription ( self ): \"\"\" Checks to see if this customer has an active subscription to any plan. :returns: True if there exists an active subscription, False otherwise. \"\"\" return len ( self . _get_valid_subscriptions ()) != 0 @property def active_subscriptions ( self ): \"\"\" Returns active subscriptions (subscriptions with an active status that end in the future). \"\"\" return self . subscriptions . filter ( status = enums . SubscriptionStatus . active , current_period_end__gt = timezone . now (), ) @property def valid_subscriptions ( self ): \"\"\" Returns this customer's valid subscriptions (subscriptions that aren't canceled or incomplete_expired). \"\"\" return self . subscriptions . exclude ( status__in = [ enums . SubscriptionStatus . canceled , enums . SubscriptionStatus . incomplete_expired , ] ) @property def subscription ( self ): \"\"\" Shortcut to get this customer's subscription. :returns: None if the customer has no subscriptions, the subscription if the customer has a subscription. :raises MultipleSubscriptionException: Raised if the customer has multiple subscriptions. In this case, use ``Customer.subscriptions`` instead. \"\"\" subscriptions = self . valid_subscriptions if subscriptions . count () > 1 : raise MultipleSubscriptionException ( \"This customer has multiple subscriptions. Use Customer.subscriptions \" \"to access them.\" ) else : return subscriptions . first () def send_invoice ( self ): \"\"\" Pay and send the customer's latest invoice. :returns: True if an invoice was able to be created and paid, False otherwise (typically if there was nothing to invoice). \"\"\" from .billing import Invoice try : invoice = Invoice . _api_create ( customer = self . id ) invoice . pay () return True except InvalidRequestError : # TODO: Check this for a more # specific error message. return False # There was nothing to invoice def retry_unpaid_invoices ( self ): \"\"\"Attempt to retry collecting payment on the customer's unpaid invoices.\"\"\" self . _sync_invoices () for invoice in self . invoices . filter ( auto_advance = True ) . exclude ( status = \"paid\" ): try : invoice . retry () # Always retry unpaid invoices except InvalidRequestError as exc : if str ( exc ) != \"Invoice is already paid\" : raise def add_coupon ( self , coupon , idempotency_key = None ): \"\"\" Add a coupon to a Customer. The coupon can be a Coupon object, or a valid Stripe Coupon ID. \"\"\" if isinstance ( coupon , StripeModel ): coupon = coupon . id stripe_customer = self . api_retrieve () stripe_customer [ \"coupon\" ] = coupon stripe_customer . save ( idempotency_key = idempotency_key ) return self . __class__ . sync_from_stripe_data ( stripe_customer , api_key = self . default_api_key ) def upcoming_invoice ( self , ** kwargs ): \"\"\"Gets the upcoming preview invoice (singular) for this customer. See `Invoice.upcoming() <#djstripe.Invoice.upcoming>`__. The ``customer`` argument to the ``upcoming()`` call is automatically set by this method. \"\"\" from .billing import Invoice kwargs [ \"customer\" ] = self return Invoice . upcoming ( ** kwargs ) def _attach_objects_post_save_hook ( self , cls , data , pending_relations = None , api_key = djstripe_settings . STRIPE_SECRET_KEY , ): from .billing import Coupon from .payment_methods import DjstripePaymentMethod super () . _attach_objects_post_save_hook ( cls , data , pending_relations = pending_relations , api_key = api_key ) save = False customer_sources = data . get ( \"sources\" ) sources = {} if customer_sources : # Have to create sources before we handle the default_source # We save all of them in the `sources` dict, so that we can find them # by id when we look at the default_source (we need the source type). for source in customer_sources [ \"data\" ]: obj , _ = DjstripePaymentMethod . _get_or_create_source ( source , source [ \"object\" ], api_key = api_key ) sources [ source [ \"id\" ]] = obj discount = data . get ( \"discount\" ) if discount : coupon , _created = Coupon . _get_or_create_from_stripe_object ( discount , \"coupon\" , api_key = api_key ) if coupon and coupon != self . coupon : self . coupon = coupon save = True elif self . coupon : self . coupon = None save = True if save : self . save () def _attach_objects_hook ( self , cls , data , current_ids = None , api_key = djstripe_settings . STRIPE_SECRET_KEY ): # When we save a customer to Stripe, we add a reference to its Django PK # in the `django_account` key. If we find that, we re-attach that PK. subscriber_key = djstripe_settings . SUBSCRIBER_CUSTOMER_KEY if subscriber_key in ( \"\" , None ): # Disabled. Nothing else to do. return subscriber_id = data . get ( \"metadata\" , {}) . get ( subscriber_key ) if subscriber_id : cls = djstripe_settings . get_subscriber_model () try : # We have to perform a get(), instead of just attaching the PK # blindly as the object may have been deleted or not exist. # Attempting to save that would cause an IntegrityError. self . subscriber = cls . objects . get ( pk = subscriber_id ) except ( cls . DoesNotExist , ValueError ): logger . warning ( \"Could not find subscriber %r matching customer %r \" , subscriber_id , self . id , ) self . subscriber = None # SYNC methods should be dropped in favor of the master sync infrastructure proposed def _sync_invoices ( self , ** kwargs ): from .billing import Invoice api_key = kwargs . get ( \"api_key\" ) or self . default_api_key for stripe_invoice in Invoice . api_list ( customer = self . id , ** kwargs ): Invoice . sync_from_stripe_data ( stripe_invoice , api_key = api_key ) def _sync_charges ( self , ** kwargs ): api_key = kwargs . get ( \"api_key\" ) or self . default_api_key for stripe_charge in Charge . api_list ( customer = self . id , ** kwargs ): Charge . sync_from_stripe_data ( stripe_charge , api_key = api_key ) def _sync_cards ( self , ** kwargs ): from .payment_methods import Card api_key = kwargs . get ( \"api_key\" ) or self . default_api_key for stripe_card in Card . api_list ( customer = self , ** kwargs ): Card . sync_from_stripe_data ( stripe_card , api_key = api_key ) def _sync_subscriptions ( self , ** kwargs ): from .billing import Subscription api_key = kwargs . get ( \"api_key\" ) or self . default_api_key for stripe_subscription in Subscription . api_list ( customer = self . id , status = \"all\" , ** kwargs ): Subscription . sync_from_stripe_data ( stripe_subscription , api_key = api_key )","title":"Customer"},{"location":"reference/models/#djstripe.models.core.Customer-attributes","text":"","title":"Attributes"},{"location":"reference/models/#djstripe.models.core.Customer.active_subscriptions","text":"Returns active subscriptions (subscriptions with an active status that end in the future).","title":"active_subscriptions"},{"location":"reference/models/#djstripe.models.core.Customer.address","text":"","title":"address"},{"location":"reference/models/#djstripe.models.core.Customer.balance","text":"","title":"balance"},{"location":"reference/models/#djstripe.models.core.Customer.coupon","text":"","title":"coupon"},{"location":"reference/models/#djstripe.models.core.Customer.coupon_end","text":"","title":"coupon_end"},{"location":"reference/models/#djstripe.models.core.Customer.coupon_start","text":"","title":"coupon_start"},{"location":"reference/models/#djstripe.models.core.Customer.credits","text":"The customer is considered to have credits if their balance is below 0.","title":"credits"},{"location":"reference/models/#djstripe.models.core.Customer.currency","text":"","title":"currency"},{"location":"reference/models/#djstripe.models.core.Customer.customer_payment_methods","text":"An iterable of all of the customer's payment methods (sources, then legacy cards)","title":"customer_payment_methods"},{"location":"reference/models/#djstripe.models.core.Customer.date_purged","text":"","title":"date_purged"},{"location":"reference/models/#djstripe.models.core.Customer.default_payment_method","text":"","title":"default_payment_method"},{"location":"reference/models/#djstripe.models.core.Customer.default_source","text":"","title":"default_source"},{"location":"reference/models/#djstripe.models.core.Customer.deleted","text":"","title":"deleted"},{"location":"reference/models/#djstripe.models.core.Customer.delinquent","text":"","title":"delinquent"},{"location":"reference/models/#djstripe.models.core.Customer.discount","text":"","title":"discount"},{"location":"reference/models/#djstripe.models.core.Customer.email","text":"","title":"email"},{"location":"reference/models/#djstripe.models.core.Customer.expand_fields","text":"","title":"expand_fields"},{"location":"reference/models/#djstripe.models.core.Customer.invoice_prefix","text":"","title":"invoice_prefix"},{"location":"reference/models/#djstripe.models.core.Customer.invoice_settings","text":"","title":"invoice_settings"},{"location":"reference/models/#djstripe.models.core.Customer.name","text":"","title":"name"},{"location":"reference/models/#djstripe.models.core.Customer.pending_charges","text":"The customer is considered to have pending charges if their balance is above 0.","title":"pending_charges"},{"location":"reference/models/#djstripe.models.core.Customer.phone","text":"","title":"phone"},{"location":"reference/models/#djstripe.models.core.Customer.preferred_locales","text":"","title":"preferred_locales"},{"location":"reference/models/#djstripe.models.core.Customer.shipping","text":"","title":"shipping"},{"location":"reference/models/#djstripe.models.core.Customer.stripe_class","text":"","title":"stripe_class"},{"location":"reference/models/#djstripe.models.core.Customer.stripe_dashboard_item_name","text":"","title":"stripe_dashboard_item_name"},{"location":"reference/models/#djstripe.models.core.Customer.subscriber","text":"","title":"subscriber"},{"location":"reference/models/#djstripe.models.core.Customer.subscription","text":"Shortcut to get this customer's subscription. :returns: None if the customer has no subscriptions, the subscription if the customer has a subscription. :raises MultipleSubscriptionException: Raised if the customer has multiple subscriptions. In this case, use Customer.subscriptions instead.","title":"subscription"},{"location":"reference/models/#djstripe.models.core.Customer.tax_exempt","text":"","title":"tax_exempt"},{"location":"reference/models/#djstripe.models.core.Customer.valid_subscriptions","text":"Returns this customer's valid subscriptions (subscriptions that aren't canceled or incomplete_expired).","title":"valid_subscriptions"},{"location":"reference/models/#djstripe.models.core.Customer-classes","text":"","title":"Classes"},{"location":"reference/models/#djstripe.models.core.Customer.Meta","text":"Bases: StripeModel . Meta Source code in djstripe/models/core.py 781 782 class Meta ( StripeModel . Meta ): unique_together = ( \"subscriber\" , \"livemode\" , \"djstripe_owner_account\" )","title":"Meta"},{"location":"reference/models/#djstripe.models.core.Customer.Meta-attributes","text":"djstripe . models . core . Customer . Meta . unique_together = ( 'subscriber' , 'livemode' , 'djstripe_owner_account' ) class-attribute","title":"Attributes"},{"location":"reference/models/#djstripe.models.core.Customer-functions","text":"","title":"Functions"},{"location":"reference/models/#djstripe.models.core.Customer.__str__","text":"Source code in djstripe/models/core.py 784 785 786 787 788 def __str__ ( self ): if self . subscriber : return str ( self . subscriber ) return self . name or self . description or self . id","title":"__str__()"},{"location":"reference/models/#djstripe.models.core.Customer.add_card","text":"Adds a card to this customer's account. :param source: Either a token, like the ones returned by our Stripe.js, or a dictionary containing a user's credit card details. Stripe will automatically validate the card. :type source: string, dict :param set_default: Whether or not to set the source as the customer's default source :type set_default: boolean Source code in djstripe/models/core.py 1056 1057 1058 1059 1060 1061 1062 1063 1064 1065 1066 1067 1068 1069 1070 1071 1072 1073 1074 1075 1076 1077 1078 1079 1080 1081 1082 1083 1084 1085 1086 1087 def add_card ( self , source , set_default = True ): \"\"\" Adds a card to this customer's account. :param source: Either a token, like the ones returned by our Stripe.js, or a dictionary containing a user's credit card details. Stripe will automatically validate the card. :type source: string, dict :param set_default: Whether or not to set the source as the customer's default source :type set_default: boolean \"\"\" from .payment_methods import DjstripePaymentMethod stripe_customer = self . api_retrieve () new_stripe_payment_method = stripe_customer . sources . create ( source = source ) if set_default : stripe_customer . default_source = new_stripe_payment_method [ \"id\" ] stripe_customer . save () new_payment_method = DjstripePaymentMethod . from_stripe_object ( new_stripe_payment_method ) # Change the default source if set_default : self . default_source = new_payment_method self . save () return new_payment_method . resolve ()","title":"add_card()"},{"location":"reference/models/#djstripe.models.core.Customer.add_coupon","text":"Add a coupon to a Customer. The coupon can be a Coupon object, or a valid Stripe Coupon ID. Source code in djstripe/models/core.py 1268 1269 1270 1271 1272 1273 1274 1275 1276 1277 1278 1279 1280 1281 1282 def add_coupon ( self , coupon , idempotency_key = None ): \"\"\" Add a coupon to a Customer. The coupon can be a Coupon object, or a valid Stripe Coupon ID. \"\"\" if isinstance ( coupon , StripeModel ): coupon = coupon . id stripe_customer = self . api_retrieve () stripe_customer [ \"coupon\" ] = coupon stripe_customer . save ( idempotency_key = idempotency_key ) return self . __class__ . sync_from_stripe_data ( stripe_customer , api_key = self . default_api_key )","title":"add_coupon()"},{"location":"reference/models/#djstripe.models.core.Customer.add_invoice_item","text":"Adds an arbitrary charge or credit to the customer's upcoming invoice. Different than creating a charge. Charges are separate bills that get processed immediately. Invoice items are appended to the customer's next invoice. This is extremely useful when adding surcharges to subscriptions. :param amount: The amount to charge. :type amount: Decimal. Precision is 2; anything more will be ignored. :param currency: 3-letter ISO code for currency :type currency: string :param description: An arbitrary string. :type description: string :param discountable: Controls whether discounts apply to this invoice item. Defaults to False for prorations or negative invoice items, and True for all other invoice items. :type discountable: boolean :param invoice: An existing invoice to add this invoice item to. When left blank, the invoice item will be added to the next upcoming scheduled invoice. Use this when adding invoice items in response to an invoice.created webhook. You cannot add an invoice item to an invoice that has already been paid, attempted or closed. :type invoice: Invoice or string (invoice ID) :param metadata: A set of key/value pairs useful for storing additional information. :type metadata: dict :param subscription: A subscription to add this invoice item to. When left blank, the invoice item will be be added to the next upcoming scheduled invoice. When set, scheduled invoices for subscriptions other than the specified subscription will ignore the invoice item. Use this when you want to express that an invoice item has been accrued within the context of a particular subscription. :type subscription: Subscription or string (subscription ID) .. Notes: .. if you're using Customer.add_invoice_item() instead of .. Customer.add_invoice_item() , invoice and subscriptions .. can only be strings Source code in djstripe/models/core.py 979 980 981 982 983 984 985 986 987 988 989 990 991 992 993 994 995 996 997 998 999 1000 1001 1002 1003 1004 1005 1006 1007 1008 1009 1010 1011 1012 1013 1014 1015 1016 1017 1018 1019 1020 1021 1022 1023 1024 1025 1026 1027 1028 1029 1030 1031 1032 1033 1034 1035 1036 1037 1038 1039 1040 1041 1042 1043 1044 1045 1046 1047 1048 1049 1050 1051 1052 1053 1054 def add_invoice_item ( self , amount , currency , description = None , discountable = None , invoice = None , metadata = None , subscription = None , ): \"\"\" Adds an arbitrary charge or credit to the customer's upcoming invoice. Different than creating a charge. Charges are separate bills that get processed immediately. Invoice items are appended to the customer's next invoice. This is extremely useful when adding surcharges to subscriptions. :param amount: The amount to charge. :type amount: Decimal. Precision is 2; anything more will be ignored. :param currency: 3-letter ISO code for currency :type currency: string :param description: An arbitrary string. :type description: string :param discountable: Controls whether discounts apply to this invoice item. Defaults to False for prorations or negative invoice items, and True for all other invoice items. :type discountable: boolean :param invoice: An existing invoice to add this invoice item to. When left blank, the invoice item will be added to the next upcoming \\ scheduled invoice. \\ Use this when adding invoice items in response to an \\ ``invoice.created`` webhook. You cannot add an invoice \\ item to an invoice that has already been paid, attempted or closed. :type invoice: Invoice or string (invoice ID) :param metadata: A set of key/value pairs useful for storing additional information. :type metadata: dict :param subscription: A subscription to add this invoice item to. When left blank, the invoice item will be be added to the next upcoming \\ scheduled invoice. When set, scheduled invoices for subscriptions other \\ than the specified subscription will ignore the invoice item. \\ Use this when you want to express that an invoice item has been accrued \\ within the context of a particular subscription. :type subscription: Subscription or string (subscription ID) .. Notes: .. if you're using ``Customer.add_invoice_item()`` instead of .. ``Customer.add_invoice_item()``, ``invoice`` and ``subscriptions`` .. can only be strings \"\"\" from .billing import InvoiceItem if not isinstance ( amount , Decimal ): raise ValueError ( \"You must supply a decimal value representing dollars.\" ) # Convert Invoice to id if invoice is not None and isinstance ( invoice , StripeModel ): invoice = invoice . id # Convert Subscription to id if subscription is not None and isinstance ( subscription , StripeModel ): subscription = subscription . id stripe_invoiceitem = InvoiceItem . _api_create ( amount = int ( amount * 100 ), # Convert dollars into cents currency = currency , customer = self . id , description = description , discountable = discountable , invoice = invoice , metadata = metadata , subscription = subscription , ) return InvoiceItem . sync_from_stripe_data ( stripe_invoiceitem , api_key = self . default_api_key )","title":"add_invoice_item()"},{"location":"reference/models/#djstripe.models.core.Customer.add_payment_method","text":"Adds an already existing payment method to this customer's account :param payment_method: PaymentMethod to be attached to the customer :type payment_method: str, PaymentMethod :param set_default: If true, this will be set as the default_payment_method :type set_default: bool :rtype: PaymentMethod Source code in djstripe/models/core.py 1089 1090 1091 1092 1093 1094 1095 1096 1097 1098 1099 1100 1101 1102 1103 1104 1105 1106 1107 1108 1109 1110 1111 1112 1113 1114 1115 1116 1117 def add_payment_method ( self , payment_method , set_default = True ): \"\"\" Adds an already existing payment method to this customer's account :param payment_method: PaymentMethod to be attached to the customer :type payment_method: str, PaymentMethod :param set_default: If true, this will be set as the default_payment_method :type set_default: bool :rtype: PaymentMethod \"\"\" from .payment_methods import PaymentMethod stripe_customer = self . api_retrieve () payment_method = PaymentMethod . attach ( payment_method , stripe_customer ) if set_default : stripe_customer [ \"invoice_settings\" ][ \"default_payment_method\" ] = payment_method . id stripe_customer . save () # Refresh self from the stripe customer, this should have two effects: # 1) sets self.default_payment_method (we rely on logic in # Customer._manipulate_stripe_object_hook to do this) # 2) updates self.invoice_settings.default_payment_methods self . sync_from_stripe_data ( stripe_customer , api_key = self . default_api_key ) self . refresh_from_db () return payment_method","title":"add_payment_method()"},{"location":"reference/models/#djstripe.models.core.Customer.charge","text":"Creates a charge for this customer. :param amount: The amount to charge. :type amount: Decimal. Precision is 2; anything more will be ignored. :param source: The source to use for this charge. Must be a source attributed to this customer. If None, the customer's default source is used. Can be either the id of the source or the source object itself. :type source: string, Source Source code in djstripe/models/core.py 939 940 941 942 943 944 945 946 947 948 949 950 951 952 953 954 955 956 957 958 959 960 961 962 963 964 965 966 967 968 969 970 971 972 973 974 975 976 977 def charge ( self , amount : Decimal , * , application_fee : Decimal = None , source : Union [ str , StripeModel ] = None , ** kwargs , ) -> Charge : \"\"\" Creates a charge for this customer. :param amount: The amount to charge. :type amount: Decimal. Precision is 2; anything more will be ignored. :param source: The source to use for this charge. Must be a source attributed to this customer. If None, the customer's default source is used. Can be either the id of the source or the source object itself. :type source: string, Source \"\"\" if not isinstance ( amount , Decimal ): raise ValueError ( \"You must supply a decimal value representing dollars.\" ) # Convert Source to id if source and isinstance ( source , StripeModel ): source = source . id stripe_charge = Charge . _api_create ( customer = self . id , amount = int ( amount * 100 ), # Convert dollars into cents application_fee = int ( application_fee * 100 ) if application_fee else None , # Convert dollars into cents source = source , ** kwargs , ) api_key = kwargs . get ( \"api_key\" ) or self . default_api_key return Charge . sync_from_stripe_data ( stripe_charge , api_key = api_key )","title":"charge()"},{"location":"reference/models/#djstripe.models.core.Customer.create","text":"Source code in djstripe/models/core.py 848 849 850 851 852 853 854 855 856 857 858 859 860 861 862 863 864 865 866 867 868 869 870 871 @classmethod def create ( cls , subscriber , idempotency_key = None , stripe_account = None ): metadata = {} subscriber_key = djstripe_settings . SUBSCRIBER_CUSTOMER_KEY if subscriber_key not in ( \"\" , None ): metadata [ subscriber_key ] = subscriber . pk stripe_customer = cls . _api_create ( email = subscriber . email , idempotency_key = idempotency_key , metadata = metadata , stripe_account = stripe_account , ) customer , created = cls . objects . get_or_create ( id = stripe_customer [ \"id\" ], defaults = { \"subscriber\" : subscriber , \"livemode\" : stripe_customer [ \"livemode\" ], \"balance\" : stripe_customer . get ( \"balance\" , 0 ), \"delinquent\" : stripe_customer . get ( \"delinquent\" , False ), }, ) return customer","title":"create()"},{"location":"reference/models/#djstripe.models.core.Customer.get_or_create","text":"Get or create a dj-stripe customer. :param subscriber: The subscriber model instance for which to get or create a customer. :type subscriber: User :param livemode: Whether to get the subscriber in live or test mode. :type livemode: bool Source code in djstripe/models/core.py 814 815 816 817 818 819 820 821 822 823 824 825 826 827 828 829 830 831 832 833 834 835 836 837 838 839 840 841 842 843 844 845 846 @classmethod def get_or_create ( cls , subscriber , livemode = djstripe_settings . STRIPE_LIVE_MODE , stripe_account = None , ): \"\"\" Get or create a dj-stripe customer. :param subscriber: The subscriber model instance for which to get or create a customer. :type subscriber: User :param livemode: Whether to get the subscriber in live or test mode. :type livemode: bool \"\"\" try : return cls . objects . get ( subscriber = subscriber , livemode = livemode ), False except cls . DoesNotExist : action = f \"create: { subscriber . pk } \" idempotency_key = djstripe_settings . get_idempotency_key ( \"customer\" , action , livemode ) return ( cls . create ( subscriber , idempotency_key = idempotency_key , stripe_account = stripe_account , ), True , )","title":"get_or_create()"},{"location":"reference/models/#djstripe.models.core.Customer.has_any_active_subscription","text":"Checks to see if this customer has an active subscription to any plan. :returns: True if there exists an active subscription, False otherwise. Source code in djstripe/models/core.py 1185 1186 1187 1188 1189 1190 1191 1192 def has_any_active_subscription ( self ): \"\"\" Checks to see if this customer has an active subscription to any plan. :returns: True if there exists an active subscription, False otherwise. \"\"\" return len ( self . _get_valid_subscriptions ()) != 0","title":"has_any_active_subscription()"},{"location":"reference/models/#djstripe.models.core.Customer.is_subscribed_to","text":"Checks to see if this customer has an active subscription to the given product. :param product: The product for which to check for an active subscription. :type product: Product or string (product ID) :returns: True if there exists an active subscription, False otherwise. Source code in djstripe/models/core.py 1166 1167 1168 1169 1170 1171 1172 1173 1174 1175 1176 1177 1178 1179 1180 1181 1182 1183 def is_subscribed_to ( self , product : Union [ Product , str ]) -> bool : \"\"\" Checks to see if this customer has an active subscription to the given product. :param product: The product for which to check for an active subscription. :type product: Product or string (product ID) :returns: True if there exists an active subscription, False otherwise. \"\"\" if isinstance ( product , StripeModel ): product = product . id for subscription in self . _get_valid_subscriptions (): for item in subscription . items . all (): if item . price and item . price . product . id == product : return True return False","title":"is_subscribed_to()"},{"location":"reference/models/#djstripe.models.core.Customer.purge","text":"Customers are soft deleted as deleted customers are still accessible by the Stripe API and sync for all RelatedModels would fail Source code in djstripe/models/core.py 1119 1120 1121 1122 1123 1124 1125 1126 1127 1128 1129 1130 1131 1132 1133 1134 1135 1136 1137 1138 1139 1140 1141 1142 1143 1144 1145 1146 1147 1148 1149 1150 1151 1152 1153 1154 1155 def purge ( self ): \"\"\"Customers are soft deleted as deleted customers are still accessible by the Stripe API and sync for all RelatedModels would fail\"\"\" try : self . _api_delete () except InvalidRequestError as exc : if \"No such customer:\" in str ( exc ): # The exception was thrown because the stripe customer was already # deleted on the stripe side, ignore the exception pass else : # The exception was raised for another reason, re-raise it raise # toggle the deleted flag on Customer to indicate it has been # deleted upstream in Stripe self . deleted = True if self . subscriber : # Delete the idempotency key used by Customer.create() # So re-creating a customer for this subscriber before the key expires # doesn't return the older Customer data idempotency_key_action = f \"customer:create: { self . subscriber . pk } \" IdempotencyKey . objects . filter ( action = idempotency_key_action ) . delete () self . subscriber = None # Remove sources self . default_source = None for source in self . legacy_cards . all (): source . remove () for source in self . sources . all (): source . detach () self . date_purged = timezone . now () self . save ()","title":"purge()"},{"location":"reference/models/#djstripe.models.core.Customer.retry_unpaid_invoices","text":"Attempt to retry collecting payment on the customer's unpaid invoices. Source code in djstripe/models/core.py 1257 1258 1259 1260 1261 1262 1263 1264 1265 1266 def retry_unpaid_invoices ( self ): \"\"\"Attempt to retry collecting payment on the customer's unpaid invoices.\"\"\" self . _sync_invoices () for invoice in self . invoices . filter ( auto_advance = True ) . exclude ( status = \"paid\" ): try : invoice . retry () # Always retry unpaid invoices except InvalidRequestError as exc : if str ( exc ) != \"Invoice is already paid\" : raise","title":"retry_unpaid_invoices()"},{"location":"reference/models/#djstripe.models.core.Customer.send_invoice","text":"Pay and send the customer's latest invoice. :returns: True if an invoice was able to be created and paid, False otherwise (typically if there was nothing to invoice). Source code in djstripe/models/core.py 1240 1241 1242 1243 1244 1245 1246 1247 1248 1249 1250 1251 1252 1253 1254 1255 def send_invoice ( self ): \"\"\" Pay and send the customer's latest invoice. :returns: True if an invoice was able to be created and paid, False otherwise (typically if there was nothing to invoice). \"\"\" from .billing import Invoice try : invoice = Invoice . _api_create ( customer = self . id ) invoice . pay () return True except InvalidRequestError : # TODO: Check this for a more # specific error message. return False # There was nothing to invoice","title":"send_invoice()"},{"location":"reference/models/#djstripe.models.core.Customer.subscribe","text":"Subscribes this customer to all the prices or plans in the items dict (Recommended). :param items: A list of up to 20 subscription items, each with an attached price :type list: :param items: A dictionary of Plan (or Plan ID) or Price (or Price ID) :type dict: The price or plan to which to subscribe the customer. :param price: The price to which to subscribe the customer. :type price: Price or string (price ID) :param plan: The plan to which to subscribe the customer. :type plan: Plan or string (plan ID) Source code in djstripe/models/core.py 899 900 901 902 903 904 905 906 907 908 909 910 911 912 913 914 915 916 917 918 919 920 921 922 923 924 925 926 927 928 929 930 931 932 933 934 935 936 937 def subscribe ( self , * , items = None , price = None , plan = None , ** kwargs ): \"\"\" Subscribes this customer to all the prices or plans in the items dict (Recommended). :param items: A list of up to 20 subscription items, each with an attached price :type list: :param items: A dictionary of Plan (or Plan ID) or Price (or Price ID) :type dict: The price or plan to which to subscribe the customer. :param price: The price to which to subscribe the customer. :type price: Price or string (price ID) :param plan: The plan to which to subscribe the customer. :type plan: Plan or string (plan ID) \"\"\" from .billing import Subscription if ( items and price ) or ( items and plan ) or ( price and plan ): raise TypeError ( \"Please define only one of items, price or plan arguments.\" ) if items is None : _items = [{ \"price\" : price }] else : _items = [] for item in items : price = item . get ( \"price\" , \"\" ) plan = item . get ( \"plan\" , \"\" ) price , kwargs = _sanitise_price ( price , plan , ** kwargs ) if \"price\" in item : _items . append ({ \"price\" : price }) if \"plan\" in item : _items . append ({ \"plan\" : price }) stripe_subscription = Subscription . _api_create ( items = _items , customer = self . id , ** kwargs ) api_key = kwargs . get ( \"api_key\" ) or self . default_api_key return Subscription . sync_from_stripe_data ( stripe_subscription , api_key = api_key )","title":"subscribe()"},{"location":"reference/models/#djstripe.models.core.Customer.upcoming_invoice","text":"Gets the upcoming preview invoice (singular) for this customer. See Invoice.upcoming() <#djstripe.Invoice.upcoming> __. The customer argument to the upcoming() call is automatically set by this method. Source code in djstripe/models/core.py 1284 1285 1286 1287 1288 1289 1290 1291 1292 1293 1294 1295 def upcoming_invoice ( self , ** kwargs ): \"\"\"Gets the upcoming preview invoice (singular) for this customer. See `Invoice.upcoming() <#djstripe.Invoice.upcoming>`__. The ``customer`` argument to the ``upcoming()`` call is automatically set by this method. \"\"\" from .billing import Invoice kwargs [ \"customer\" ] = self return Invoice . upcoming ( ** kwargs )","title":"upcoming_invoice()"},{"location":"reference/models/#djstripe.models.core.Dispute","text":"Bases: StripeModel A dispute occurs when a customer questions your charge with their card issuer. When this happens, you're given the opportunity to respond to the dispute with evidence that shows that the charge is legitimate Stripe documentation: https://stripe.com/docs/api?lang=python#disputes Source code in djstripe/models/core.py 1396 1397 1398 1399 1400 1401 1402 1403 1404 1405 1406 1407 1408 1409 1410 1411 1412 1413 1414 1415 1416 1417 1418 1419 1420 1421 1422 1423 1424 1425 1426 1427 1428 1429 1430 1431 1432 1433 1434 1435 1436 1437 1438 1439 1440 1441 1442 1443 1444 1445 1446 1447 1448 1449 1450 1451 1452 1453 1454 1455 1456 1457 1458 1459 1460 1461 1462 1463 1464 1465 1466 1467 1468 1469 1470 1471 1472 1473 1474 1475 1476 1477 1478 1479 1480 1481 1482 1483 1484 1485 1486 1487 1488 1489 1490 1491 1492 1493 1494 1495 1496 1497 1498 1499 1500 1501 1502 1503 1504 1505 1506 1507 1508 1509 1510 1511 1512 class Dispute ( StripeModel ): \"\"\" A dispute occurs when a customer questions your charge with their card issuer. When this happens, you're given the opportunity to respond to the dispute with evidence that shows that the charge is legitimate Stripe documentation: https://stripe.com/docs/api?lang=python#disputes \"\"\" stripe_class = stripe . Dispute stripe_dashboard_item_name = \"payments\" amount = StripeQuantumCurrencyAmountField ( help_text = ( \"Disputed amount (in cents). Usually the amount of the charge, \" \"but can differ \" \"(usually because of currency fluctuation or because only part of \" \"the order is disputed).\" ) ) balance_transaction = StripeForeignKey ( \"BalanceTransaction\" , null = True , on_delete = models . CASCADE , related_name = \"disputes\" , help_text = \"Balance transaction that describes the impact on your \" \"account balance.\" , ) balance_transactions = JSONField ( default = list , help_text = \"List of 0, 1 or 2 Balance Transactions that show funds withdrawn and reinstated to your Stripe account as a result of this dispute.\" , ) # charge is nullable to avoid infinite sync as Charge model has a dispute field as well charge = StripeForeignKey ( \"Charge\" , null = True , on_delete = models . CASCADE , related_name = \"disputes\" , help_text = \"The charge that was disputed\" , ) currency = StripeCurrencyCodeField () evidence = JSONField ( help_text = \"Evidence provided to respond to a dispute.\" ) evidence_details = JSONField ( help_text = \"Information about the evidence submission.\" ) is_charge_refundable = models . BooleanField ( help_text = ( \"If true, it is still possible to refund the disputed payment. \" \"Once the payment has been fully refunded, no further funds will \" \"be withdrawn from your Stripe account as a result of this dispute.\" ) ) payment_intent = StripeForeignKey ( \"PaymentIntent\" , null = True , on_delete = models . CASCADE , related_name = \"disputes\" , help_text = \"The PaymentIntent that was disputed\" , ) reason = StripeEnumField ( enum = enums . DisputeReason ) status = StripeEnumField ( enum = enums . DisputeStatus ) def __str__ ( self ): amount = get_friendly_currency_amount ( self . amount / 100 , self . currency ) status = enums . DisputeStatus . humanize ( self . status ) return f \" { amount } ( { status } ) \" def get_stripe_dashboard_url ( self ) -> str : \"\"\"Get the stripe dashboard url for this object.\"\"\" return ( f \" { self . _get_base_stripe_dashboard_url () } \" f \" { self . stripe_dashboard_item_name } / { self . payment_intent . id } \" ) def _attach_objects_post_save_hook ( self , cls , data , pending_relations = None , api_key = djstripe_settings . STRIPE_SECRET_KEY , ): super () . _attach_objects_post_save_hook ( cls , data , pending_relations = pending_relations , api_key = api_key ) # Retrieve and save files from the dispute.evidence object. # todo find a better way of retrieving and syncing File Type fields from Dispute object for field in ( \"cancellation_policy\" , \"customer_communication\" , \"customer_signature\" , \"duplicate_charge_documentation\" , \"receipt\" , \"refund_policy\" , \"service_documentation\" , \"shipping_documentation\" , \"uncategorized_file\" , ): file_upload_id = self . evidence . get ( field , None ) if file_upload_id : try : File . sync_from_stripe_data ( File ( id = file_upload_id ) . api_retrieve ( api_key = api_key ), api_key = api_key , ) except stripe . error . PermissionError : # No permission to retrieve the data with the key # Log a warning message logger . warning ( \"No permission to retrieve the File Evidence Object.\" ) except stripe . error . InvalidRequestError : raise # iterate and sync every balance transaction for stripe_balance_transaction in self . balance_transactions : BalanceTransaction . sync_from_stripe_data ( stripe_balance_transaction , api_key = api_key )","title":"Dispute"},{"location":"reference/models/#djstripe.models.core.Dispute-attributes","text":"","title":"Attributes"},{"location":"reference/models/#djstripe.models.core.Dispute.amount","text":"","title":"amount"},{"location":"reference/models/#djstripe.models.core.Dispute.balance_transaction","text":"","title":"balance_transaction"},{"location":"reference/models/#djstripe.models.core.Dispute.balance_transactions","text":"","title":"balance_transactions"},{"location":"reference/models/#djstripe.models.core.Dispute.charge","text":"","title":"charge"},{"location":"reference/models/#djstripe.models.core.Dispute.currency","text":"","title":"currency"},{"location":"reference/models/#djstripe.models.core.Dispute.evidence","text":"","title":"evidence"},{"location":"reference/models/#djstripe.models.core.Dispute.evidence_details","text":"","title":"evidence_details"},{"location":"reference/models/#djstripe.models.core.Dispute.is_charge_refundable","text":"","title":"is_charge_refundable"},{"location":"reference/models/#djstripe.models.core.Dispute.payment_intent","text":"","title":"payment_intent"},{"location":"reference/models/#djstripe.models.core.Dispute.reason","text":"","title":"reason"},{"location":"reference/models/#djstripe.models.core.Dispute.status","text":"","title":"status"},{"location":"reference/models/#djstripe.models.core.Dispute.stripe_class","text":"","title":"stripe_class"},{"location":"reference/models/#djstripe.models.core.Dispute.stripe_dashboard_item_name","text":"","title":"stripe_dashboard_item_name"},{"location":"reference/models/#djstripe.models.core.Dispute-functions","text":"","title":"Functions"},{"location":"reference/models/#djstripe.models.core.Dispute.__str__","text":"Source code in djstripe/models/core.py 1456 1457 1458 1459 def __str__ ( self ): amount = get_friendly_currency_amount ( self . amount / 100 , self . currency ) status = enums . DisputeStatus . humanize ( self . status ) return f \" { amount } ( { status } ) \"","title":"__str__()"},{"location":"reference/models/#djstripe.models.core.Dispute.get_stripe_dashboard_url","text":"Get the stripe dashboard url for this object. Source code in djstripe/models/core.py 1461 1462 1463 1464 1465 1466 def get_stripe_dashboard_url ( self ) -> str : \"\"\"Get the stripe dashboard url for this object.\"\"\" return ( f \" { self . _get_base_stripe_dashboard_url () } \" f \" { self . stripe_dashboard_item_name } / { self . payment_intent . id } \" )","title":"get_stripe_dashboard_url()"},{"location":"reference/models/#djstripe.models.core.Event","text":"Bases: StripeModel Events are Stripe's way of letting you know when something interesting happens in your account. When an interesting event occurs, a new Event object is created and POSTed to the configured webhook URL if the Event type matches. Stripe documentation: https://stripe.com/docs/api/events?lang=python Source code in djstripe/models/core.py 1515 1516 1517 1518 1519 1520 1521 1522 1523 1524 1525 1526 1527 1528 1529 1530 1531 1532 1533 1534 1535 1536 1537 1538 1539 1540 1541 1542 1543 1544 1545 1546 1547 1548 1549 1550 1551 1552 1553 1554 1555 1556 1557 1558 1559 1560 1561 1562 1563 1564 1565 1566 1567 1568 1569 1570 1571 1572 1573 1574 1575 1576 1577 1578 1579 1580 1581 1582 1583 1584 1585 1586 1587 1588 1589 1590 1591 1592 1593 1594 1595 1596 1597 1598 1599 1600 1601 1602 1603 1604 1605 1606 1607 1608 1609 1610 1611 1612 1613 1614 1615 1616 1617 1618 1619 1620 1621 1622 1623 1624 1625 1626 1627 1628 1629 1630 class Event ( StripeModel ): \"\"\" Events are Stripe's way of letting you know when something interesting happens in your account. When an interesting event occurs, a new Event object is created and POSTed to the configured webhook URL if the Event type matches. Stripe documentation: https://stripe.com/docs/api/events?lang=python \"\"\" stripe_class = stripe . Event stripe_dashboard_item_name = \"events\" api_version = models . CharField ( max_length = 64 , blank = True , help_text = \"the API version at which the event data was \" \"rendered. Blank for old entries only, all new entries will have this value\" , ) data = JSONField ( help_text = \"data received at webhook. data should be considered to be garbage \" \"until validity check is run and valid flag is set\" ) request_id = models . CharField ( max_length = 50 , help_text = \"Information about the request that triggered this event, \" \"for traceability purposes. If empty string then this is an old entry \" \"without that data. If Null then this is not an old entry, but a Stripe \" \"'automated' event with no associated request.\" , default = \"\" , blank = True , ) idempotency_key = models . TextField ( default = \"\" , blank = True ) type = models . CharField ( max_length = 250 , help_text = \"Stripe's event description code\" ) def __str__ ( self ): return f \"type= { self . type } , id= { self . id } \" def _attach_objects_hook ( self , cls , data , current_ids = None , api_key = djstripe_settings . STRIPE_SECRET_KEY ): if self . api_version is None : # as of api version 2017-02-14, the account.application.deauthorized # event sends None as api_version. # If we receive that, store an empty string instead. # Remove this hack if this gets fixed upstream. self . api_version = \"\" request_obj = data . get ( \"request\" , None ) if isinstance ( request_obj , dict ): # Format as of 2017-05-25 self . request_id = request_obj . get ( \"id\" ) or \"\" self . idempotency_key = request_obj . get ( \"idempotency_key\" ) or \"\" else : # Format before 2017-05-25 self . request_id = request_obj or \"\" @classmethod def process ( cls , data , api_key = djstripe_settings . STRIPE_SECRET_KEY ): qs = cls . objects . filter ( id = data [ \"id\" ]) if qs . exists (): return qs . first () # Rollback any DB operations in the case of failure so # we will retry creating and processing the event the # next time the webhook fires. with transaction . atomic (): # process the event and create an Event Object ret = cls . _create_from_stripe_object ( data , api_key = api_key ) ret . invoke_webhook_handlers () return ret def invoke_webhook_handlers ( self ): \"\"\" Invokes any webhook handlers that have been registered for this event based on event type or event sub-type. See event handlers registered in the ``djstripe.event_handlers`` module (or handlers registered in djstripe plugins or contrib packages). \"\"\" webhooks . call_handlers ( event = self ) signal = WEBHOOK_SIGNALS . get ( self . type ) if signal : return signal . send ( sender = Event , event = self ) @cached_property def parts ( self ): \"\"\"Gets the event category/verb as a list of parts.\"\"\" return str ( self . type ) . split ( \".\" ) @cached_property def category ( self ): \"\"\"Gets the event category string (e.g. 'customer').\"\"\" return self . parts [ 0 ] @cached_property def verb ( self ): \"\"\"Gets the event past-tense verb string (e.g. 'updated').\"\"\" return \".\" . join ( self . parts [ 1 :]) @property def customer ( self ): data = self . data [ \"object\" ] if data [ \"object\" ] == \"customer\" : customer_id = get_id_from_stripe_data ( data . get ( \"id\" )) else : customer_id = get_id_from_stripe_data ( data . get ( \"customer\" )) if customer_id : return Customer . _get_or_retrieve ( id = customer_id , stripe_account = getattr ( self . djstripe_owner_account , \"id\" , None ), api_key = self . default_api_key , )","title":"Event"},{"location":"reference/models/#djstripe.models.core.Event-attributes","text":"","title":"Attributes"},{"location":"reference/models/#djstripe.models.core.Event.api_version","text":"","title":"api_version"},{"location":"reference/models/#djstripe.models.core.Event.customer","text":"","title":"customer"},{"location":"reference/models/#djstripe.models.core.Event.data","text":"","title":"data"},{"location":"reference/models/#djstripe.models.core.Event.idempotency_key","text":"","title":"idempotency_key"},{"location":"reference/models/#djstripe.models.core.Event.request_id","text":"","title":"request_id"},{"location":"reference/models/#djstripe.models.core.Event.stripe_class","text":"","title":"stripe_class"},{"location":"reference/models/#djstripe.models.core.Event.stripe_dashboard_item_name","text":"","title":"stripe_dashboard_item_name"},{"location":"reference/models/#djstripe.models.core.Event.type","text":"","title":"type"},{"location":"reference/models/#djstripe.models.core.Event-functions","text":"","title":"Functions"},{"location":"reference/models/#djstripe.models.core.Event.__str__","text":"Source code in djstripe/models/core.py 1550 1551 def __str__ ( self ): return f \"type= { self . type } , id= { self . id } \"","title":"__str__()"},{"location":"reference/models/#djstripe.models.core.Event.category","text":"Gets the event category string (e.g. 'customer'). Source code in djstripe/models/core.py 1607 1608 1609 1610 @cached_property def category ( self ): \"\"\"Gets the event category string (e.g. 'customer').\"\"\" return self . parts [ 0 ]","title":"category()"},{"location":"reference/models/#djstripe.models.core.Event.invoke_webhook_handlers","text":"Invokes any webhook handlers that have been registered for this event based on event type or event sub-type. See event handlers registered in the djstripe.event_handlers module (or handlers registered in djstripe plugins or contrib packages). Source code in djstripe/models/core.py 1587 1588 1589 1590 1591 1592 1593 1594 1595 1596 1597 1598 1599 1600 def invoke_webhook_handlers ( self ): \"\"\" Invokes any webhook handlers that have been registered for this event based on event type or event sub-type. See event handlers registered in the ``djstripe.event_handlers`` module (or handlers registered in djstripe plugins or contrib packages). \"\"\" webhooks . call_handlers ( event = self ) signal = WEBHOOK_SIGNALS . get ( self . type ) if signal : return signal . send ( sender = Event , event = self )","title":"invoke_webhook_handlers()"},{"location":"reference/models/#djstripe.models.core.Event.parts","text":"Gets the event category/verb as a list of parts. Source code in djstripe/models/core.py 1602 1603 1604 1605 @cached_property def parts ( self ): \"\"\"Gets the event category/verb as a list of parts.\"\"\" return str ( self . type ) . split ( \".\" )","title":"parts()"},{"location":"reference/models/#djstripe.models.core.Event.process","text":"Source code in djstripe/models/core.py 1572 1573 1574 1575 1576 1577 1578 1579 1580 1581 1582 1583 1584 1585 @classmethod def process ( cls , data , api_key = djstripe_settings . STRIPE_SECRET_KEY ): qs = cls . objects . filter ( id = data [ \"id\" ]) if qs . exists (): return qs . first () # Rollback any DB operations in the case of failure so # we will retry creating and processing the event the # next time the webhook fires. with transaction . atomic (): # process the event and create an Event Object ret = cls . _create_from_stripe_object ( data , api_key = api_key ) ret . invoke_webhook_handlers () return ret","title":"process()"},{"location":"reference/models/#djstripe.models.core.Event.verb","text":"Gets the event past-tense verb string (e.g. 'updated'). Source code in djstripe/models/core.py 1612 1613 1614 1615 @cached_property def verb ( self ): \"\"\"Gets the event past-tense verb string (e.g. 'updated').\"\"\" return \".\" . join ( self . parts [ 1 :])","title":"verb()"},{"location":"reference/models/#djstripe.models.core.File","text":"Bases: StripeModel This is an object representing a file hosted on Stripe's servers. The file may have been uploaded by yourself using the create file request (for example, when uploading dispute evidence) or it may have been created by Stripe (for example, the results of a Sigma scheduled query). Stripe documentation: https://stripe.com/docs/api/files?lang=python Source code in djstripe/models/core.py 1633 1634 1635 1636 1637 1638 1639 1640 1641 1642 1643 1644 1645 1646 1647 1648 1649 1650 1651 1652 1653 1654 1655 1656 1657 1658 1659 1660 1661 1662 1663 1664 1665 1666 class File ( StripeModel ): \"\"\" This is an object representing a file hosted on Stripe's servers. The file may have been uploaded by yourself using the create file request (for example, when uploading dispute evidence) or it may have been created by Stripe (for example, the results of a Sigma scheduled query). Stripe documentation: https://stripe.com/docs/api/files?lang=python \"\"\" stripe_class = stripe . File filename = models . CharField ( max_length = 255 , help_text = \"A filename for the file, suitable for saving to a filesystem.\" , ) purpose = StripeEnumField ( enum = enums . FilePurpose , help_text = \"The purpose of the uploaded file.\" ) size = models . IntegerField ( help_text = \"The size in bytes of the file upload object.\" ) type = StripeEnumField ( enum = enums . FileType , help_text = \"The type of the file returned.\" ) url = models . CharField ( max_length = 200 , help_text = \"A read-only URL where the uploaded file can be accessed.\" , ) @classmethod def is_valid_object ( cls , data ): return data and data . get ( \"object\" ) in ( \"file\" , \"file_upload\" ) def __str__ ( self ): return f \" { self . filename } , { enums . FilePurpose . humanize ( self . purpose ) } \"","title":"File"},{"location":"reference/models/#djstripe.models.core.File-attributes","text":"","title":"Attributes"},{"location":"reference/models/#djstripe.models.core.File.filename","text":"","title":"filename"},{"location":"reference/models/#djstripe.models.core.File.purpose","text":"","title":"purpose"},{"location":"reference/models/#djstripe.models.core.File.size","text":"","title":"size"},{"location":"reference/models/#djstripe.models.core.File.stripe_class","text":"","title":"stripe_class"},{"location":"reference/models/#djstripe.models.core.File.type","text":"","title":"type"},{"location":"reference/models/#djstripe.models.core.File.url","text":"","title":"url"},{"location":"reference/models/#djstripe.models.core.File-functions","text":"","title":"Functions"},{"location":"reference/models/#djstripe.models.core.File.__str__","text":"Source code in djstripe/models/core.py 1665 1666 def __str__ ( self ): return f \" { self . filename } , { enums . FilePurpose . humanize ( self . purpose ) } \"","title":"__str__()"},{"location":"reference/models/#djstripe.models.core.File.is_valid_object","text":"Source code in djstripe/models/core.py 1661 1662 1663 @classmethod def is_valid_object ( cls , data ): return data and data . get ( \"object\" ) in ( \"file\" , \"file_upload\" )","title":"is_valid_object()"},{"location":"reference/models/#djstripe.models.core.FileLink","text":"Bases: StripeModel To share the contents of a File object with non-Stripe users, you can create a FileLink. FileLinks contain a URL that can be used to retrieve the contents of the file without authentication. Stripe documentation: https://stripe.com/docs/api/file_links?lang=python Source code in djstripe/models/core.py 1675 1676 1677 1678 1679 1680 1681 1682 1683 1684 1685 1686 1687 1688 1689 1690 1691 1692 1693 class FileLink ( StripeModel ): \"\"\" To share the contents of a File object with non-Stripe users, you can create a FileLink. FileLinks contain a URL that can be used to retrieve the contents of the file without authentication. Stripe documentation: https://stripe.com/docs/api/file_links?lang=python \"\"\" stripe_class = stripe . FileLink expires_at = StripeDateTimeField ( null = True , blank = True , help_text = \"Time at which the link expires.\" ) file = StripeForeignKey ( \"File\" , on_delete = models . CASCADE ) url = models . URLField ( help_text = \"The publicly accessible URL to download the file.\" ) def __str__ ( self ): return f \" { self . file . filename } , { self . url } \"","title":"FileLink"},{"location":"reference/models/#djstripe.models.core.FileLink-attributes","text":"","title":"Attributes"},{"location":"reference/models/#djstripe.models.core.FileLink.expires_at","text":"","title":"expires_at"},{"location":"reference/models/#djstripe.models.core.FileLink.file","text":"","title":"file"},{"location":"reference/models/#djstripe.models.core.FileLink.stripe_class","text":"","title":"stripe_class"},{"location":"reference/models/#djstripe.models.core.FileLink.url","text":"","title":"url"},{"location":"reference/models/#djstripe.models.core.FileLink-functions","text":"","title":"Functions"},{"location":"reference/models/#djstripe.models.core.FileLink.__str__","text":"Source code in djstripe/models/core.py 1692 1693 def __str__ ( self ): return f \" { self . file . filename } , { self . url } \"","title":"__str__()"},{"location":"reference/models/#djstripe.models.core.Mandate","text":"Bases: StripeModel A Mandate is a record of the permission a customer has given you to debit their payment method. https://stripe.com/docs/api/mandates Source code in djstripe/models/core.py 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 class Mandate ( StripeModel ): \"\"\" A Mandate is a record of the permission a customer has given you to debit their payment method. https://stripe.com/docs/api/mandates \"\"\" stripe_class = stripe . Mandate customer_acceptance = JSONField ( help_text = \"Details about the customer's acceptance of the mandate.\" ) payment_method = StripeForeignKey ( \"paymentmethod\" , on_delete = models . CASCADE ) payment_method_details = JSONField ( help_text = \"Additional mandate information specific to the payment method type.\" ) status = StripeEnumField ( enum = enums . MandateStatus , help_text = \"The status of the mandate, which indicates whether it can be used to initiate a payment.\" , ) type = StripeEnumField ( enum = enums . MandateType , help_text = \"The status of the mandate, which indicates whether it can be used to initiate a payment.\" , ) multi_use = JSONField ( null = True , blank = True , help_text = \"If this is a `multi_use` mandate, this hash contains details about the mandate.\" , ) single_use = JSONField ( null = True , blank = True , help_text = \"If this is a `single_use` mandate, this hash contains details about the mandate.\" , )","title":"Mandate"},{"location":"reference/models/#djstripe.models.core.Mandate-attributes","text":"","title":"Attributes"},{"location":"reference/models/#djstripe.models.core.Mandate.customer_acceptance","text":"","title":"customer_acceptance"},{"location":"reference/models/#djstripe.models.core.Mandate.multi_use","text":"","title":"multi_use"},{"location":"reference/models/#djstripe.models.core.Mandate.payment_method","text":"","title":"payment_method"},{"location":"reference/models/#djstripe.models.core.Mandate.payment_method_details","text":"","title":"payment_method_details"},{"location":"reference/models/#djstripe.models.core.Mandate.single_use","text":"","title":"single_use"},{"location":"reference/models/#djstripe.models.core.Mandate.status","text":"","title":"status"},{"location":"reference/models/#djstripe.models.core.Mandate.stripe_class","text":"","title":"stripe_class"},{"location":"reference/models/#djstripe.models.core.Mandate.type","text":"","title":"type"},{"location":"reference/models/#djstripe.models.core.PaymentIntent","text":"Bases: StripeModel A PaymentIntent guides you through the process of collecting a payment from your customer. We recommend that you create exactly one PaymentIntent for each order or customer session in your system. You can reference the PaymentIntent later to see the history of payment attempts for a particular session. A PaymentIntent transitions through multiple statuses throughout its lifetime as it interfaces with Stripe.js to perform authentication flows and ultimately creates at most one successful charge. Stripe documentation: https://stripe.com/docs/api?lang=python#payment_intents Source code in djstripe/models/core.py 1696 1697 1698 1699 1700 1701 1702 1703 1704 1705 1706 1707 1708 1709 1710 1711 1712 1713 1714 1715 1716 1717 1718 1719 1720 1721 1722 1723 1724 1725 1726 1727 1728 1729 1730 1731 1732 1733 1734 1735 1736 1737 1738 1739 1740 1741 1742 1743 1744 1745 1746 1747 1748 1749 1750 1751 1752 1753 1754 1755 1756 1757 1758 1759 1760 1761 1762 1763 1764 1765 1766 1767 1768 1769 1770 1771 1772 1773 1774 1775 1776 1777 1778 1779 1780 1781 1782 1783 1784 1785 1786 1787 1788 1789 1790 1791 1792 1793 1794 1795 1796 1797 1798 1799 1800 1801 1802 1803 1804 1805 1806 1807 1808 1809 1810 1811 1812 1813 1814 1815 1816 1817 1818 1819 1820 1821 1822 1823 1824 1825 1826 1827 1828 1829 1830 1831 1832 1833 1834 1835 1836 1837 1838 1839 1840 1841 1842 1843 1844 1845 1846 1847 1848 1849 1850 1851 1852 1853 1854 1855 1856 1857 1858 1859 1860 1861 1862 1863 1864 1865 1866 1867 1868 1869 1870 1871 1872 1873 1874 1875 1876 1877 1878 1879 1880 1881 1882 1883 1884 1885 1886 1887 1888 1889 1890 1891 1892 1893 1894 1895 1896 1897 1898 1899 1900 1901 1902 1903 1904 1905 1906 1907 1908 1909 1910 1911 1912 1913 1914 1915 1916 1917 1918 1919 1920 1921 1922 1923 1924 1925 1926 1927 1928 1929 1930 1931 1932 1933 1934 class PaymentIntent ( StripeModel ): \"\"\" A PaymentIntent guides you through the process of collecting a payment from your customer. We recommend that you create exactly one PaymentIntent for each order or customer session in your system. You can reference the PaymentIntent later to see the history of payment attempts for a particular session. A PaymentIntent transitions through multiple statuses throughout its lifetime as it interfaces with Stripe.js to perform authentication flows and ultimately creates at most one successful charge. Stripe documentation: https://stripe.com/docs/api?lang=python#payment_intents \"\"\" stripe_class = stripe . PaymentIntent stripe_dashboard_item_name = \"payments\" amount = StripeQuantumCurrencyAmountField ( help_text = \"Amount (in cents) intended to be collected by this PaymentIntent.\" ) amount_capturable = StripeQuantumCurrencyAmountField ( help_text = \"Amount (in cents) that can be captured from this PaymentIntent.\" ) amount_received = StripeQuantumCurrencyAmountField ( help_text = \"Amount (in cents) that was collected by this PaymentIntent.\" ) # application # application_fee_amount canceled_at = StripeDateTimeField ( null = True , blank = True , default = None , help_text = ( \"Populated when status is canceled, this is the time at which the \" \"PaymentIntent was canceled. Measured in seconds since the Unix epoch.\" ), ) cancellation_reason = StripeEnumField ( enum = enums . PaymentIntentCancellationReason , blank = True , help_text = ( \"Reason for cancellation of this PaymentIntent, either user-provided \" \"(duplicate, fraudulent, requested_by_customer, or abandoned) or \" \"generated by Stripe internally (failed_invoice, void_invoice, \" \"or automatic).\" ), ) capture_method = StripeEnumField ( enum = enums . CaptureMethod , help_text = \"Capture method of this PaymentIntent, one of automatic or manual.\" , ) client_secret = models . TextField ( max_length = 5000 , help_text = ( \"The client secret of this PaymentIntent. \" \"Used for client-side retrieval using a publishable key.\" ), ) confirmation_method = StripeEnumField ( enum = enums . ConfirmationMethod , help_text = ( \"Confirmation method of this PaymentIntent, one of manual or automatic.\" ), ) currency = StripeCurrencyCodeField () customer = StripeForeignKey ( \"Customer\" , null = True , on_delete = models . CASCADE , help_text = \"Customer this PaymentIntent is for if one exists.\" , ) description = models . TextField ( max_length = 1000 , default = \"\" , blank = True , help_text = ( \"An arbitrary string attached to the object. \" \"Often useful for displaying to users.\" ), ) last_payment_error = JSONField ( null = True , blank = True , help_text = ( \"The payment error encountered in the previous PaymentIntent confirmation.\" ), ) next_action = JSONField ( null = True , blank = True , help_text = ( \"If present, this property tells you what actions you need to take \" \"in order for your customer to fulfill a payment using the provided source.\" ), ) on_behalf_of = StripeForeignKey ( \"Account\" , on_delete = models . CASCADE , null = True , blank = True , help_text = \"The account (if any) for which the funds of the \" \"PaymentIntent are intended.\" , related_name = \"payment_intents\" , ) payment_method = StripeForeignKey ( \"PaymentMethod\" , on_delete = models . SET_NULL , null = True , blank = True , help_text = \"Payment method used in this PaymentIntent.\" , ) payment_method_types = JSONField ( help_text = ( \"The list of payment method types (e.g. card) that this \" \"PaymentIntent is allowed to use.\" ) ) receipt_email = models . CharField ( blank = True , max_length = 255 , help_text = ( \"Email address that the receipt for the resulting payment will be sent to.\" ), ) # TODO: Add `review` field after we add Review model. setup_future_usage = StripeEnumField ( enum = enums . IntentUsage , null = True , blank = True , help_text = ( \"Indicates that you intend to make future payments with this \" \"PaymentIntent's payment method. \" \"If present, the payment method used with this PaymentIntent can \" \"be attached to a Customer, even after the transaction completes. \" \"Use `on_session` if you intend to only reuse the payment method \" \"when your customer is present in your checkout flow. Use `off_session` \" \"if your customer may or may not be in your checkout flow. \" \"Stripe uses `setup_future_usage` to dynamically optimize \" \"your payment flow and comply with regional legislation and network rules. \" \"For example, if your customer is impacted by SCA, using `off_session` \" \"will ensure that they are authenticated while processing this \" \"PaymentIntent. You will then be able to make later off-session payments \" \"for this customer.\" ), ) shipping = JSONField ( null = True , blank = True , help_text = \"Shipping information for this PaymentIntent.\" ) statement_descriptor = models . CharField ( max_length = 22 , blank = True , help_text = ( \"For non-card charges, you can use this value as the complete description \" \"that appears on your customers' statements. Must contain at least one \" \"letter, maximum 22 characters.\" ), ) status = StripeEnumField ( enum = enums . PaymentIntentStatus , help_text = ( \"Status of this PaymentIntent, one of requires_payment_method, \" \"requires_confirmation, requires_action, processing, requires_capture, \" \"canceled, or succeeded. \" \"You can read more about PaymentIntent statuses here.\" ), ) transfer_data = JSONField ( null = True , blank = True , help_text = ( \"The data with which to automatically create a Transfer when the payment \" \"is finalized. \" \"See the PaymentIntents Connect usage guide for details.\" ), ) transfer_group = models . CharField ( blank = True , max_length = 255 , help_text = ( \"A string that identifies the resulting payment as part of a group. \" \"See the PaymentIntents Connect usage guide for details.\" ), ) def __str__ ( self ): account = self . on_behalf_of customer = self . customer amount = get_friendly_currency_amount ( self . amount / 100 , self . currency ) status = enums . PaymentIntentStatus . humanize ( self . status ) if account and customer : return f \" { amount } ( { status } ) for { account } by { customer } \" if account : return f \" { amount } for { account } . { status } \" if customer : return f \" { amount } by { customer } . { status } \" return f \" { amount } ( { status } )\" def update ( self , api_key = None , ** kwargs ): \"\"\" Call the stripe API's modify operation for this model :param api_key: The api key to use for this request. Defaults to djstripe_settings.STRIPE_SECRET_KEY. :type api_key: string \"\"\" api_key = api_key or self . default_api_key response = self . api_retrieve ( api_key = api_key ) return response . modify ( response . stripe_id , api_key = api_key , ** kwargs ) def _api_cancel ( self , api_key = None , ** kwargs ): \"\"\" Call the stripe API's cancel operation for this model :param api_key: The api key to use for this request. Defaults to djstripe_settings.STRIPE_SECRET_KEY. :type api_key: string \"\"\" api_key = api_key or self . default_api_key return self . api_retrieve ( api_key = api_key ) . cancel ( ** kwargs ) def _api_confirm ( self , api_key = None , ** kwargs ): \"\"\" Call the stripe API's confirm operation for this model. Confirm that your customer intends to pay with current or provided payment method. Upon confirmation, the PaymentIntent will attempt to initiate a payment. :param api_key: The api key to use for this request. Defaults to djstripe_settings.STRIPE_SECRET_KEY. :type api_key: string \"\"\" api_key = api_key or self . default_api_key return self . api_retrieve ( api_key = api_key ) . confirm ( ** kwargs )","title":"PaymentIntent"},{"location":"reference/models/#djstripe.models.core.PaymentIntent-attributes","text":"","title":"Attributes"},{"location":"reference/models/#djstripe.models.core.PaymentIntent.amount","text":"","title":"amount"},{"location":"reference/models/#djstripe.models.core.PaymentIntent.amount_capturable","text":"","title":"amount_capturable"},{"location":"reference/models/#djstripe.models.core.PaymentIntent.amount_received","text":"","title":"amount_received"},{"location":"reference/models/#djstripe.models.core.PaymentIntent.canceled_at","text":"","title":"canceled_at"},{"location":"reference/models/#djstripe.models.core.PaymentIntent.cancellation_reason","text":"","title":"cancellation_reason"},{"location":"reference/models/#djstripe.models.core.PaymentIntent.capture_method","text":"","title":"capture_method"},{"location":"reference/models/#djstripe.models.core.PaymentIntent.client_secret","text":"","title":"client_secret"},{"location":"reference/models/#djstripe.models.core.PaymentIntent.confirmation_method","text":"","title":"confirmation_method"},{"location":"reference/models/#djstripe.models.core.PaymentIntent.currency","text":"","title":"currency"},{"location":"reference/models/#djstripe.models.core.PaymentIntent.customer","text":"","title":"customer"},{"location":"reference/models/#djstripe.models.core.PaymentIntent.description","text":"","title":"description"},{"location":"reference/models/#djstripe.models.core.PaymentIntent.last_payment_error","text":"","title":"last_payment_error"},{"location":"reference/models/#djstripe.models.core.PaymentIntent.next_action","text":"","title":"next_action"},{"location":"reference/models/#djstripe.models.core.PaymentIntent.on_behalf_of","text":"","title":"on_behalf_of"},{"location":"reference/models/#djstripe.models.core.PaymentIntent.payment_method","text":"","title":"payment_method"},{"location":"reference/models/#djstripe.models.core.PaymentIntent.payment_method_types","text":"","title":"payment_method_types"},{"location":"reference/models/#djstripe.models.core.PaymentIntent.receipt_email","text":"","title":"receipt_email"},{"location":"reference/models/#djstripe.models.core.PaymentIntent.setup_future_usage","text":"","title":"setup_future_usage"},{"location":"reference/models/#djstripe.models.core.PaymentIntent.shipping","text":"","title":"shipping"},{"location":"reference/models/#djstripe.models.core.PaymentIntent.statement_descriptor","text":"","title":"statement_descriptor"},{"location":"reference/models/#djstripe.models.core.PaymentIntent.status","text":"","title":"status"},{"location":"reference/models/#djstripe.models.core.PaymentIntent.stripe_class","text":"","title":"stripe_class"},{"location":"reference/models/#djstripe.models.core.PaymentIntent.stripe_dashboard_item_name","text":"","title":"stripe_dashboard_item_name"},{"location":"reference/models/#djstripe.models.core.PaymentIntent.transfer_data","text":"","title":"transfer_data"},{"location":"reference/models/#djstripe.models.core.PaymentIntent.transfer_group","text":"","title":"transfer_group"},{"location":"reference/models/#djstripe.models.core.PaymentIntent-functions","text":"","title":"Functions"},{"location":"reference/models/#djstripe.models.core.PaymentIntent.__str__","text":"Source code in djstripe/models/core.py 1881 1882 1883 1884 1885 1886 1887 1888 1889 1890 1891 1892 1893 1894 def __str__ ( self ): account = self . on_behalf_of customer = self . customer amount = get_friendly_currency_amount ( self . amount / 100 , self . currency ) status = enums . PaymentIntentStatus . humanize ( self . status ) if account and customer : return f \" { amount } ( { status } ) for { account } by { customer } \" if account : return f \" { amount } for { account } . { status } \" if customer : return f \" { amount } by { customer } . { status } \" return f \" { amount } ( { status } )\"","title":"__str__()"},{"location":"reference/models/#djstripe.models.core.PaymentIntent.update","text":"Call the stripe API's modify operation for this model :param api_key: The api key to use for this request. Defaults to djstripe_settings.STRIPE_SECRET_KEY. :type api_key: string Source code in djstripe/models/core.py 1896 1897 1898 1899 1900 1901 1902 1903 1904 1905 1906 def update ( self , api_key = None , ** kwargs ): \"\"\" Call the stripe API's modify operation for this model :param api_key: The api key to use for this request. Defaults to djstripe_settings.STRIPE_SECRET_KEY. :type api_key: string \"\"\" api_key = api_key or self . default_api_key response = self . api_retrieve ( api_key = api_key ) return response . modify ( response . stripe_id , api_key = api_key , ** kwargs )","title":"update()"},{"location":"reference/models/#djstripe.models.core.Payout","text":"Bases: StripeModel A Payout object is created when you receive funds from Stripe, or when you initiate a payout to either a bank account or debit card of a connected Stripe account. Stripe documentation: https://stripe.com/docs/api?lang=python#payouts Source code in djstripe/models/core.py 2051 2052 2053 2054 2055 2056 2057 2058 2059 2060 2061 2062 2063 2064 2065 2066 2067 2068 2069 2070 2071 2072 2073 2074 2075 2076 2077 2078 2079 2080 2081 2082 2083 2084 2085 2086 2087 2088 2089 2090 2091 2092 2093 2094 2095 2096 2097 2098 2099 2100 2101 2102 2103 2104 2105 2106 2107 2108 2109 2110 2111 2112 2113 2114 2115 2116 2117 2118 2119 2120 2121 2122 2123 2124 2125 2126 2127 2128 2129 2130 2131 2132 2133 2134 2135 2136 2137 2138 2139 2140 2141 2142 2143 2144 2145 2146 2147 2148 2149 2150 2151 2152 2153 2154 2155 2156 2157 2158 2159 2160 2161 2162 class Payout ( StripeModel ): \"\"\" A Payout object is created when you receive funds from Stripe, or when you initiate a payout to either a bank account or debit card of a connected Stripe account. Stripe documentation: https://stripe.com/docs/api?lang=python#payouts \"\"\" expand_fields = [ \"destination\" ] stripe_class = stripe . Payout stripe_dashboard_item_name = \"payouts\" amount = StripeDecimalCurrencyAmountField ( help_text = \"Amount (as decimal) to be transferred to your bank account or \" \"debit card.\" ) arrival_date = StripeDateTimeField ( help_text = ( \"Date the payout is expected to arrive in the bank. \" \"This factors in delays like weekends or bank holidays.\" ) ) automatic = models . BooleanField ( help_text = ( \"`true` if the payout was created by an automated payout schedule, \" \"and `false` if it was requested manually.\" ) ) balance_transaction = StripeForeignKey ( \"BalanceTransaction\" , on_delete = models . SET_NULL , null = True , help_text = \"Balance transaction that describes the impact on your \" \"account balance.\" , ) currency = StripeCurrencyCodeField () destination = PaymentMethodForeignKey ( on_delete = models . PROTECT , null = True , help_text = \"Bank account or card the payout was sent to.\" , ) failure_balance_transaction = StripeForeignKey ( \"BalanceTransaction\" , on_delete = models . SET_NULL , related_name = \"failure_payouts\" , null = True , blank = True , help_text = ( \"If the payout failed or was canceled, this will be the balance \" \"transaction that reversed the initial balance transaction, and \" \"puts the funds from the failed payout back in your balance.\" ), ) failure_code = StripeEnumField ( enum = enums . PayoutFailureCode , default = \"\" , blank = True , help_text = ( \"Error code explaining reason for transfer failure if available. \" \"See https://stripe.com/docs/api?lang=python#transfer_failures.\" ), ) failure_message = models . TextField ( default = \"\" , blank = True , help_text = ( \"Message to user further explaining reason for \" \"payout failure if available.\" ), ) method = StripeEnumField ( max_length = 8 , enum = enums . PayoutMethod , help_text = ( \"The method used to send this payout. \" \"`instant` is only supported for payouts to debit cards.\" ), ) # TODO: `original_payout` impl as OneToOne, with `reversed_by` reverse relation # original_payout = StripeForeignKey( # \"Payout\", # on_delete=models.SET_NULL, # null=True, # blank=True, # help_text=\"If the payout reverses another, this is the original payout.\", # ) source_type = StripeEnumField ( enum = enums . PayoutSourceType , help_text = \"The source balance this payout came from.\" , ) statement_descriptor = models . CharField ( max_length = 255 , default = \"\" , blank = True , help_text = \"Extra information about a payout to be displayed \" \"on the user's bank statement.\" , ) status = StripeEnumField ( enum = enums . PayoutStatus , help_text = ( \"Current status of the payout. \" \"A payout will be `pending` until it is submitted to the bank, \" \"at which point it becomes `in_transit`. \" \"It will then change to paid if the transaction goes through. \" \"If it does not go through successfully, \" \"its status will change to `failed` or `canceled`.\" ), ) type = StripeEnumField ( enum = enums . PayoutType ) def __str__ ( self ): return f \" { self . amount } ( { enums . PayoutStatus . humanize ( self . status ) } )\"","title":"Payout"},{"location":"reference/models/#djstripe.models.core.Payout-attributes","text":"","title":"Attributes"},{"location":"reference/models/#djstripe.models.core.Payout.amount","text":"","title":"amount"},{"location":"reference/models/#djstripe.models.core.Payout.arrival_date","text":"","title":"arrival_date"},{"location":"reference/models/#djstripe.models.core.Payout.automatic","text":"","title":"automatic"},{"location":"reference/models/#djstripe.models.core.Payout.balance_transaction","text":"","title":"balance_transaction"},{"location":"reference/models/#djstripe.models.core.Payout.currency","text":"","title":"currency"},{"location":"reference/models/#djstripe.models.core.Payout.destination","text":"","title":"destination"},{"location":"reference/models/#djstripe.models.core.Payout.expand_fields","text":"","title":"expand_fields"},{"location":"reference/models/#djstripe.models.core.Payout.failure_balance_transaction","text":"","title":"failure_balance_transaction"},{"location":"reference/models/#djstripe.models.core.Payout.failure_code","text":"","title":"failure_code"},{"location":"reference/models/#djstripe.models.core.Payout.failure_message","text":"","title":"failure_message"},{"location":"reference/models/#djstripe.models.core.Payout.method","text":"","title":"method"},{"location":"reference/models/#djstripe.models.core.Payout.source_type","text":"","title":"source_type"},{"location":"reference/models/#djstripe.models.core.Payout.statement_descriptor","text":"","title":"statement_descriptor"},{"location":"reference/models/#djstripe.models.core.Payout.status","text":"","title":"status"},{"location":"reference/models/#djstripe.models.core.Payout.stripe_class","text":"","title":"stripe_class"},{"location":"reference/models/#djstripe.models.core.Payout.stripe_dashboard_item_name","text":"","title":"stripe_dashboard_item_name"},{"location":"reference/models/#djstripe.models.core.Payout.type","text":"","title":"type"},{"location":"reference/models/#djstripe.models.core.Payout-functions","text":"","title":"Functions"},{"location":"reference/models/#djstripe.models.core.Payout.__str__","text":"Source code in djstripe/models/core.py 2161 2162 def __str__ ( self ): return f \" { self . amount } ( { enums . PayoutStatus . humanize ( self . status ) } )\"","title":"__str__()"},{"location":"reference/models/#djstripe.models.core.Price","text":"Bases: StripeModel Prices define the unit cost, currency, and (optional) billing cycle for both recurring and one-time purchases of products. Price and Plan objects are the same, but use a different representation. Creating a recurring Price in Stripe also makes a Plan available, and vice versa. This is not the case for a Price with interval=one_time. Price objects are a more recent API representation, support more features and its usage is encouraged instead of Plan objects. Stripe documentation: - https://stripe.com/docs/api/prices - https://stripe.com/docs/billing/prices-guide Source code in djstripe/models/core.py 2165 2166 2167 2168 2169 2170 2171 2172 2173 2174 2175 2176 2177 2178 2179 2180 2181 2182 2183 2184 2185 2186 2187 2188 2189 2190 2191 2192 2193 2194 2195 2196 2197 2198 2199 2200 2201 2202 2203 2204 2205 2206 2207 2208 2209 2210 2211 2212 2213 2214 2215 2216 2217 2218 2219 2220 2221 2222 2223 2224 2225 2226 2227 2228 2229 2230 2231 2232 2233 2234 2235 2236 2237 2238 2239 2240 2241 2242 2243 2244 2245 2246 2247 2248 2249 2250 2251 2252 2253 2254 2255 2256 2257 2258 2259 2260 2261 2262 2263 2264 2265 2266 2267 2268 2269 2270 2271 2272 2273 2274 2275 2276 2277 2278 2279 2280 2281 2282 2283 2284 2285 2286 2287 2288 2289 2290 2291 2292 2293 2294 2295 2296 2297 2298 2299 2300 2301 2302 2303 2304 2305 2306 2307 2308 2309 2310 2311 2312 2313 2314 2315 2316 2317 2318 2319 2320 2321 2322 2323 2324 2325 2326 2327 2328 2329 2330 2331 2332 2333 2334 2335 2336 2337 2338 2339 2340 2341 2342 2343 2344 2345 2346 2347 2348 2349 2350 2351 2352 2353 2354 2355 2356 2357 2358 2359 2360 2361 2362 2363 2364 2365 2366 class Price ( StripeModel ): \"\"\" Prices define the unit cost, currency, and (optional) billing cycle for both recurring and one-time purchases of products. Price and Plan objects are the same, but use a different representation. Creating a recurring Price in Stripe also makes a Plan available, and vice versa. This is not the case for a Price with interval=one_time. Price objects are a more recent API representation, support more features and its usage is encouraged instead of Plan objects. Stripe documentation: - https://stripe.com/docs/api/prices - https://stripe.com/docs/billing/prices-guide \"\"\" stripe_class = stripe . Price expand_fields = [ \"product\" , \"tiers\" ] stripe_dashboard_item_name = \"prices\" active = models . BooleanField ( help_text = \"Whether the price can be used for new purchases.\" ) currency = StripeCurrencyCodeField () nickname = models . CharField ( max_length = 250 , blank = True , help_text = \"A brief description of the plan, hidden from customers.\" , ) product = StripeForeignKey ( \"Product\" , on_delete = models . CASCADE , related_name = \"prices\" , help_text = \"The product this price is associated with.\" , ) recurring = JSONField ( default = None , blank = True , null = True , help_text = ( \"The recurring components of a price such as `interval` and `usage_type`.\" ), ) type = StripeEnumField ( enum = enums . PriceType , help_text = ( \"Whether the price is for a one-time purchase or a recurring \" \"(subscription) purchase.\" ), ) unit_amount = StripeQuantumCurrencyAmountField ( null = True , blank = True , help_text = ( \"The unit amount in cents to be charged, represented as a whole \" \"integer if possible. Null if a sub-cent precision is required.\" ), ) unit_amount_decimal = StripeDecimalCurrencyAmountField ( null = True , blank = True , max_digits = 19 , decimal_places = 12 , help_text = ( \"The unit amount in cents to be charged, represented as a decimal \" \"string with at most 12 decimal places.\" ), ) # More attributes\u2026 billing_scheme = StripeEnumField ( enum = enums . BillingScheme , blank = True , help_text = ( \"Describes how to compute the price per period. \" \"Either `per_unit` or `tiered`. \" \"`per_unit` indicates that the fixed amount (specified in `unit_amount` \" \"or `unit_amount_decimal`) will be charged per unit in `quantity` \" \"(for prices with `usage_type=licensed`), or per unit of total \" \"usage (for prices with `usage_type=metered`). \" \"`tiered` indicates that the unit pricing will be computed using \" \"a tiering strategy as defined using the `tiers` and `tiers_mode` \" \"attributes.\" ), ) lookup_key = models . CharField ( max_length = 250 , null = True , blank = True , help_text = \"A lookup key used to retrieve prices dynamically from a \" \"static string.\" , ) tiers = JSONField ( null = True , blank = True , help_text = ( \"Each element represents a pricing tier. \" \"This parameter requires `billing_scheme` to be set to `tiered`.\" ), ) tiers_mode = StripeEnumField ( enum = enums . PriceTiersMode , null = True , blank = True , help_text = ( \"Defines if the tiering price should be `graduated` or `volume` based. \" \"In `volume`-based tiering, the maximum quantity within a period \" \"determines the per unit price, in `graduated` tiering pricing can \" \"successively change as the quantity grows.\" ), ) transform_quantity = JSONField ( null = True , blank = True , help_text = ( \"Apply a transformation to the reported usage or set quantity \" \"before computing the amount billed. Cannot be combined with `tiers`.\" ), ) class Meta ( object ): ordering = [ \"unit_amount\" ] @classmethod def get_or_create ( cls , ** kwargs ): \"\"\"Get or create a Price.\"\"\" try : return cls . objects . get ( id = kwargs [ \"id\" ]), False except cls . DoesNotExist : return cls . create ( ** kwargs ), True @classmethod def create ( cls , ** kwargs ): # A few minor things are changed in the api-version of the create call api_kwargs = dict ( kwargs ) if api_kwargs [ \"unit_amount\" ]: api_kwargs [ \"unit_amount\" ] = int ( api_kwargs [ \"unit_amount\" ] * 100 ) if isinstance ( api_kwargs . get ( \"product\" ), StripeModel ): api_kwargs [ \"product\" ] = api_kwargs [ \"product\" ] . id stripe_price = cls . _api_create ( ** api_kwargs ) api_key = api_kwargs . get ( \"api_key\" ) or djstripe_settings . STRIPE_SECRET_KEY price = cls . sync_from_stripe_data ( stripe_price , api_key = api_key ) return price def __str__ ( self ): return f \" { self . human_readable_price } for { self . product . name } \" @property def human_readable_price ( self ): if self . billing_scheme == \"per_unit\" : unit_amount = ( self . unit_amount or 0 ) / 100 amount = get_friendly_currency_amount ( unit_amount , self . currency ) else : # tiered billing scheme tier_1 = self . tiers [ 0 ] formatted_unit_amount_tier_1 = get_friendly_currency_amount ( ( tier_1 [ \"unit_amount\" ] or 0 ) / 100 , self . currency ) amount = f \"Starts at { formatted_unit_amount_tier_1 } per unit\" # stripe shows flat fee even if it is set to 0.00 flat_amount_tier_1 = tier_1 [ \"flat_amount\" ] if flat_amount_tier_1 is not None : formatted_flat_amount_tier_1 = get_friendly_currency_amount ( flat_amount_tier_1 / 100 , self . currency ) amount = f \" { amount } + { formatted_flat_amount_tier_1 } \" format_args = { \"amount\" : amount } if self . recurring : interval_count = self . recurring [ \"interval_count\" ] if interval_count == 1 : interval = { \"day\" : _ ( \"day\" ), \"week\" : _ ( \"week\" ), \"month\" : _ ( \"month\" ), \"year\" : _ ( \"year\" ), }[ self . recurring [ \"interval\" ]] template = _ ( \" {amount} / {interval} \" ) format_args [ \"interval\" ] = interval else : interval = { \"day\" : _ ( \"days\" ), \"week\" : _ ( \"weeks\" ), \"month\" : _ ( \"months\" ), \"year\" : _ ( \"years\" ), }[ self . recurring [ \"interval\" ]] template = _ ( \" {amount} / every {interval_count} {interval} \" ) format_args [ \"interval\" ] = interval format_args [ \"interval_count\" ] = interval_count else : template = _ ( \" {amount} (one time)\" ) return format_lazy ( template , ** format_args )","title":"Price"},{"location":"reference/models/#djstripe.models.core.Price-attributes","text":"","title":"Attributes"},{"location":"reference/models/#djstripe.models.core.Price.active","text":"","title":"active"},{"location":"reference/models/#djstripe.models.core.Price.billing_scheme","text":"","title":"billing_scheme"},{"location":"reference/models/#djstripe.models.core.Price.currency","text":"","title":"currency"},{"location":"reference/models/#djstripe.models.core.Price.expand_fields","text":"","title":"expand_fields"},{"location":"reference/models/#djstripe.models.core.Price.human_readable_price","text":"","title":"human_readable_price"},{"location":"reference/models/#djstripe.models.core.Price.lookup_key","text":"","title":"lookup_key"},{"location":"reference/models/#djstripe.models.core.Price.nickname","text":"","title":"nickname"},{"location":"reference/models/#djstripe.models.core.Price.product","text":"","title":"product"},{"location":"reference/models/#djstripe.models.core.Price.recurring","text":"","title":"recurring"},{"location":"reference/models/#djstripe.models.core.Price.stripe_class","text":"","title":"stripe_class"},{"location":"reference/models/#djstripe.models.core.Price.stripe_dashboard_item_name","text":"","title":"stripe_dashboard_item_name"},{"location":"reference/models/#djstripe.models.core.Price.tiers","text":"","title":"tiers"},{"location":"reference/models/#djstripe.models.core.Price.tiers_mode","text":"","title":"tiers_mode"},{"location":"reference/models/#djstripe.models.core.Price.transform_quantity","text":"","title":"transform_quantity"},{"location":"reference/models/#djstripe.models.core.Price.type","text":"","title":"type"},{"location":"reference/models/#djstripe.models.core.Price.unit_amount","text":"","title":"unit_amount"},{"location":"reference/models/#djstripe.models.core.Price.unit_amount_decimal","text":"","title":"unit_amount_decimal"},{"location":"reference/models/#djstripe.models.core.Price-classes","text":"","title":"Classes"},{"location":"reference/models/#djstripe.models.core.Price.Meta","text":"Bases: object Source code in djstripe/models/core.py 2286 2287 class Meta ( object ): ordering = [ \"unit_amount\" ]","title":"Meta"},{"location":"reference/models/#djstripe.models.core.Price.Meta-attributes","text":"djstripe . models . core . Price . Meta . ordering = [ 'unit_amount' ] class-attribute","title":"Attributes"},{"location":"reference/models/#djstripe.models.core.Price-functions","text":"","title":"Functions"},{"location":"reference/models/#djstripe.models.core.Price.__str__","text":"Source code in djstripe/models/core.py 2315 2316 def __str__ ( self ): return f \" { self . human_readable_price } for { self . product . name } \"","title":"__str__()"},{"location":"reference/models/#djstripe.models.core.Price.create","text":"Source code in djstripe/models/core.py 2298 2299 2300 2301 2302 2303 2304 2305 2306 2307 2308 2309 2310 2311 2312 2313 @classmethod def create ( cls , ** kwargs ): # A few minor things are changed in the api-version of the create call api_kwargs = dict ( kwargs ) if api_kwargs [ \"unit_amount\" ]: api_kwargs [ \"unit_amount\" ] = int ( api_kwargs [ \"unit_amount\" ] * 100 ) if isinstance ( api_kwargs . get ( \"product\" ), StripeModel ): api_kwargs [ \"product\" ] = api_kwargs [ \"product\" ] . id stripe_price = cls . _api_create ( ** api_kwargs ) api_key = api_kwargs . get ( \"api_key\" ) or djstripe_settings . STRIPE_SECRET_KEY price = cls . sync_from_stripe_data ( stripe_price , api_key = api_key ) return price","title":"create()"},{"location":"reference/models/#djstripe.models.core.Price.get_or_create","text":"Get or create a Price. Source code in djstripe/models/core.py 2289 2290 2291 2292 2293 2294 2295 2296 @classmethod def get_or_create ( cls , ** kwargs ): \"\"\"Get or create a Price.\"\"\" try : return cls . objects . get ( id = kwargs [ \"id\" ]), False except cls . DoesNotExist : return cls . create ( ** kwargs ), True","title":"get_or_create()"},{"location":"reference/models/#djstripe.models.core.Product","text":"Bases: StripeModel Products describe the specific goods or services you offer to your customers. For example, you might offer a Standard and Premium version of your goods or service; each version would be a separate Product. They can be used in conjunction with Prices to configure pricing in Payment Links, Checkout, and Subscriptions. Stripe documentation: https://stripe.com/docs/api?lang=python#products Source code in djstripe/models/core.py 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 class Product ( StripeModel ): \"\"\" Products describe the specific goods or services you offer to your customers. For example, you might offer a Standard and Premium version of your goods or service; each version would be a separate Product. They can be used in conjunction with Prices to configure pricing in Payment Links, Checkout, and Subscriptions. Stripe documentation: https://stripe.com/docs/api?lang=python#products \"\"\" stripe_class = stripe . Product stripe_dashboard_item_name = \"products\" # Fields applicable to both `good` and `service` name = models . TextField ( max_length = 5000 , help_text = ( \"The product's name, meant to be displayable to the customer. \" \"Applicable to both `service` and `good` types.\" ), ) default_price = StripeForeignKey ( \"Price\" , on_delete = models . SET_NULL , null = True , blank = True , related_name = \"products\" , help_text = \"The default price this product is associated with.\" , ) type = StripeEnumField ( enum = enums . ProductType , help_text = ( \"The type of the product. The product is either of type `good`, which is \" \"eligible for use with Orders and SKUs, or `service`, which is eligible \" \"for use with Subscriptions and Plans.\" ), ) # Fields applicable to `good` only active = models . BooleanField ( null = True , help_text = ( \"Whether the product is currently available for purchase. \" \"Only applicable to products of `type=good`.\" ), ) attributes = JSONField ( null = True , blank = True , help_text = ( \"A list of up to 5 attributes that each SKU can provide values for \" '(e.g., `[\"color\", \"size\"]`). Only applicable to products of `type=good`.' ), ) caption = models . TextField ( default = \"\" , blank = True , max_length = 5000 , help_text = ( \"A short one-line description of the product, meant to be displayable\" \"to the customer. Only applicable to products of `type=good`.\" ), ) deactivate_on = JSONField ( null = True , blank = True , help_text = ( \"An array of connect application identifiers that cannot purchase \" \"this product. Only applicable to products of `type=good`.\" ), ) images = JSONField ( null = True , blank = True , help_text = ( \"A list of up to 8 URLs of images for this product, meant to be \" \"displayable to the customer. Only applicable to products of `type=good`.\" ), ) package_dimensions = JSONField ( null = True , blank = True , help_text = ( \"The dimensions of this product for shipping purposes. \" \"A SKU associated with this product can override this value by having its \" \"own `package_dimensions`. Only applicable to products of `type=good`.\" ), ) shippable = models . BooleanField ( null = True , blank = True , help_text = ( \"Whether this product is a shipped good. \" \"Only applicable to products of `type=good`.\" ), ) url = models . CharField ( max_length = 799 , null = True , blank = True , help_text = ( \"A URL of a publicly-accessible webpage for this product. \" \"Only applicable to products of `type=good`.\" ), ) # Fields available to `service` only statement_descriptor = models . CharField ( max_length = 22 , default = \"\" , blank = True , help_text = ( \"Extra information about a product which will appear on your customer's \" \"credit card statement. In the case that multiple products are billed at \" \"once, the first statement descriptor will be used. \" \"Only available on products of type=`service`.\" ), ) unit_label = models . CharField ( max_length = 12 , default = \"\" , blank = True ) def __str__ ( self ): # 1 product can have 1 or more than 1 related price price_qs = self . prices . all () price_count = price_qs . count () if price_count > 1 : return f \" { self . name } ( { price_count } prices)\" elif price_count == 1 : return f \" { self . name } ( { price_qs [ 0 ] . human_readable_price } )\" else : return self . name","title":"Product"},{"location":"reference/models/#djstripe.models.core.Product-attributes","text":"","title":"Attributes"},{"location":"reference/models/#djstripe.models.core.Product.active","text":"","title":"active"},{"location":"reference/models/#djstripe.models.core.Product.attributes","text":"","title":"attributes"},{"location":"reference/models/#djstripe.models.core.Product.caption","text":"","title":"caption"},{"location":"reference/models/#djstripe.models.core.Product.deactivate_on","text":"","title":"deactivate_on"},{"location":"reference/models/#djstripe.models.core.Product.default_price","text":"","title":"default_price"},{"location":"reference/models/#djstripe.models.core.Product.images","text":"","title":"images"},{"location":"reference/models/#djstripe.models.core.Product.name","text":"","title":"name"},{"location":"reference/models/#djstripe.models.core.Product.package_dimensions","text":"","title":"package_dimensions"},{"location":"reference/models/#djstripe.models.core.Product.shippable","text":"","title":"shippable"},{"location":"reference/models/#djstripe.models.core.Product.statement_descriptor","text":"","title":"statement_descriptor"},{"location":"reference/models/#djstripe.models.core.Product.stripe_class","text":"","title":"stripe_class"},{"location":"reference/models/#djstripe.models.core.Product.stripe_dashboard_item_name","text":"","title":"stripe_dashboard_item_name"},{"location":"reference/models/#djstripe.models.core.Product.type","text":"","title":"type"},{"location":"reference/models/#djstripe.models.core.Product.unit_label","text":"","title":"unit_label"},{"location":"reference/models/#djstripe.models.core.Product.url","text":"","title":"url"},{"location":"reference/models/#djstripe.models.core.Product-functions","text":"","title":"Functions"},{"location":"reference/models/#djstripe.models.core.Product.__str__","text":"Source code in djstripe/models/core.py 624 625 626 627 628 629 630 631 632 633 634 def __str__ ( self ): # 1 product can have 1 or more than 1 related price price_qs = self . prices . all () price_count = price_qs . count () if price_count > 1 : return f \" { self . name } ( { price_count } prices)\" elif price_count == 1 : return f \" { self . name } ( { price_qs [ 0 ] . human_readable_price } )\" else : return self . name","title":"__str__()"},{"location":"reference/models/#djstripe.models.core.Refund","text":"Bases: StripeModel Refund objects allow you to refund a charge that has previously been created but not yet refunded. Funds will be refunded to the credit or debit card that was originally charged. Stripe documentation: https://stripe.com/docs/api?lang=python#refund_object Source code in djstripe/models/core.py 2369 2370 2371 2372 2373 2374 2375 2376 2377 2378 2379 2380 2381 2382 2383 2384 2385 2386 2387 2388 2389 2390 2391 2392 2393 2394 2395 2396 2397 2398 2399 2400 2401 2402 2403 2404 2405 2406 2407 2408 2409 2410 2411 2412 2413 2414 2415 2416 2417 2418 2419 2420 2421 2422 2423 2424 2425 2426 2427 2428 2429 2430 2431 2432 2433 2434 2435 class Refund ( StripeModel ): \"\"\" Refund objects allow you to refund a charge that has previously been created but not yet refunded. Funds will be refunded to the credit or debit card that was originally charged. Stripe documentation: https://stripe.com/docs/api?lang=python#refund_object \"\"\" stripe_class = stripe . Refund amount = StripeQuantumCurrencyAmountField ( help_text = \"Amount, in cents.\" ) balance_transaction = StripeForeignKey ( \"BalanceTransaction\" , on_delete = models . SET_NULL , null = True , help_text = \"Balance transaction that describes the impact on your account \" \"balance.\" , ) charge = StripeForeignKey ( \"Charge\" , on_delete = models . CASCADE , related_name = \"refunds\" , help_text = \"The charge that was refunded\" , ) currency = StripeCurrencyCodeField () failure_balance_transaction = StripeForeignKey ( \"BalanceTransaction\" , on_delete = models . SET_NULL , related_name = \"failure_refunds\" , null = True , blank = True , help_text = \"If the refund failed, this balance transaction describes the \" \"adjustment made on your account balance that reverses the initial \" \"balance transaction.\" , ) failure_reason = StripeEnumField ( enum = enums . RefundFailureReason , default = \"\" , blank = True , help_text = \"If the refund failed, the reason for refund failure if known.\" , ) reason = StripeEnumField ( enum = enums . RefundReason , blank = True , default = \"\" , help_text = \"Reason for the refund.\" , ) receipt_number = models . CharField ( max_length = 9 , default = \"\" , blank = True , help_text = \"The transaction number that appears on email receipts sent \" \"for this charge.\" , ) status = StripeEnumField ( blank = True , enum = enums . RefundStatus , help_text = \"Status of the refund.\" ) # todo implement source_transfer_reversal and transfer_reversal def get_stripe_dashboard_url ( self ): return self . charge . get_stripe_dashboard_url () def __str__ ( self ): amount = get_friendly_currency_amount ( self . amount / 100 , self . currency ) status = enums . RefundStatus . humanize ( self . status ) return f \" { amount } ( { status } )\"","title":"Refund"},{"location":"reference/models/#djstripe.models.core.Refund-attributes","text":"","title":"Attributes"},{"location":"reference/models/#djstripe.models.core.Refund.amount","text":"","title":"amount"},{"location":"reference/models/#djstripe.models.core.Refund.balance_transaction","text":"","title":"balance_transaction"},{"location":"reference/models/#djstripe.models.core.Refund.charge","text":"","title":"charge"},{"location":"reference/models/#djstripe.models.core.Refund.currency","text":"","title":"currency"},{"location":"reference/models/#djstripe.models.core.Refund.failure_balance_transaction","text":"","title":"failure_balance_transaction"},{"location":"reference/models/#djstripe.models.core.Refund.failure_reason","text":"","title":"failure_reason"},{"location":"reference/models/#djstripe.models.core.Refund.reason","text":"","title":"reason"},{"location":"reference/models/#djstripe.models.core.Refund.receipt_number","text":"","title":"receipt_number"},{"location":"reference/models/#djstripe.models.core.Refund.status","text":"","title":"status"},{"location":"reference/models/#djstripe.models.core.Refund.stripe_class","text":"","title":"stripe_class"},{"location":"reference/models/#djstripe.models.core.Refund-functions","text":"","title":"Functions"},{"location":"reference/models/#djstripe.models.core.Refund.__str__","text":"Source code in djstripe/models/core.py 2432 2433 2434 2435 def __str__ ( self ): amount = get_friendly_currency_amount ( self . amount / 100 , self . currency ) status = enums . RefundStatus . humanize ( self . status ) return f \" { amount } ( { status } )\"","title":"__str__()"},{"location":"reference/models/#djstripe.models.core.Refund.get_stripe_dashboard_url","text":"Source code in djstripe/models/core.py 2429 2430 def get_stripe_dashboard_url ( self ): return self . charge . get_stripe_dashboard_url ()","title":"get_stripe_dashboard_url()"},{"location":"reference/models/#djstripe.models.core.SetupIntent","text":"Bases: StripeModel A SetupIntent guides you through the process of setting up a customer's payment credentials for future payments. For example, you could use a SetupIntent to set up your customer's card without immediately collecting a payment. Later, you can use PaymentIntents to drive the payment flow. NOTE: You should not maintain long-lived, unconfirmed SetupIntents. For security purposes, SetupIntents older than 24 hours may no longer be valid. Stripe documentation: https://stripe.com/docs/api?lang=python#setup_intents Source code in djstripe/models/core.py 1937 1938 1939 1940 1941 1942 1943 1944 1945 1946 1947 1948 1949 1950 1951 1952 1953 1954 1955 1956 1957 1958 1959 1960 1961 1962 1963 1964 1965 1966 1967 1968 1969 1970 1971 1972 1973 1974 1975 1976 1977 1978 1979 1980 1981 1982 1983 1984 1985 1986 1987 1988 1989 1990 1991 1992 1993 1994 1995 1996 1997 1998 1999 2000 2001 2002 2003 2004 2005 2006 2007 2008 2009 2010 2011 2012 2013 2014 2015 2016 2017 2018 2019 2020 2021 2022 2023 2024 2025 2026 2027 2028 2029 2030 2031 2032 2033 2034 2035 2036 2037 2038 2039 2040 2041 2042 2043 2044 2045 2046 2047 class SetupIntent ( StripeModel ): \"\"\" A SetupIntent guides you through the process of setting up a customer's payment credentials for future payments. For example, you could use a SetupIntent to set up your customer's card without immediately collecting a payment. Later, you can use PaymentIntents to drive the payment flow. NOTE: You should not maintain long-lived, unconfirmed SetupIntents. For security purposes, SetupIntents older than 24 hours may no longer be valid. Stripe documentation: https://stripe.com/docs/api?lang=python#setup_intents \"\"\" stripe_class = stripe . SetupIntent application = models . CharField ( max_length = 255 , blank = True , help_text = \"ID of the Connect application that created the SetupIntent.\" , ) cancellation_reason = StripeEnumField ( enum = enums . SetupIntentCancellationReason , blank = True , help_text = ( \"Reason for cancellation of this SetupIntent, one of abandoned, \" \"requested_by_customer, or duplicate\" ), ) client_secret = models . TextField ( max_length = 5000 , blank = True , help_text = ( \"The client secret of this SetupIntent. \" \"Used for client-side retrieval using a publishable key.\" ), ) customer = StripeForeignKey ( \"Customer\" , null = True , blank = True , on_delete = models . SET_NULL , help_text = \"Customer this SetupIntent belongs to, if one exists.\" , ) last_setup_error = JSONField ( null = True , blank = True , help_text = \"The error encountered in the previous SetupIntent confirmation.\" , ) next_action = JSONField ( null = True , blank = True , help_text = ( \"If present, this property tells you what actions you need to take in\" \"order for your customer to continue payment setup.\" ), ) on_behalf_of = StripeForeignKey ( \"Account\" , on_delete = models . SET_NULL , null = True , blank = True , help_text = \"The account (if any) for which the setup is intended.\" , related_name = \"setup_intents\" , ) payment_method = StripeForeignKey ( \"PaymentMethod\" , on_delete = models . SET_NULL , null = True , blank = True , help_text = \"Payment method used in this PaymentIntent.\" , ) payment_method_types = JSONField ( help_text = ( \"The list of payment method types (e.g. card) that this PaymentIntent is \" \"allowed to use.\" ) ) status = StripeEnumField ( enum = enums . SetupIntentStatus , help_text = ( \"Status of this SetupIntent, one of requires_payment_method, \" \"requires_confirmation, requires_action, processing, \" \"canceled, or succeeded.\" ), ) usage = StripeEnumField ( enum = enums . IntentUsage , default = enums . IntentUsage . off_session , help_text = ( \"Indicates how the payment method is intended to be used in the future.\" ), ) def __str__ ( self ): account = self . on_behalf_of customer = self . customer if account and customer : return ( f \" { self . payment_method } ( { enums . SetupIntentStatus . humanize ( self . status ) } ) \" f \"for { account } \" f \"by { customer } \" ) if account : return f \" { self . payment_method } for { account } . { enums . SetupIntentStatus . humanize ( self . status ) } \" if customer : return f \" { self . payment_method } by { customer } . { enums . SetupIntentStatus . humanize ( self . status ) } \" return ( f \" { self . payment_method } ( { enums . SetupIntentStatus . humanize ( self . status ) } )\" )","title":"SetupIntent"},{"location":"reference/models/#djstripe.models.core.SetupIntent-attributes","text":"","title":"Attributes"},{"location":"reference/models/#djstripe.models.core.SetupIntent.application","text":"","title":"application"},{"location":"reference/models/#djstripe.models.core.SetupIntent.cancellation_reason","text":"","title":"cancellation_reason"},{"location":"reference/models/#djstripe.models.core.SetupIntent.client_secret","text":"","title":"client_secret"},{"location":"reference/models/#djstripe.models.core.SetupIntent.customer","text":"","title":"customer"},{"location":"reference/models/#djstripe.models.core.SetupIntent.last_setup_error","text":"","title":"last_setup_error"},{"location":"reference/models/#djstripe.models.core.SetupIntent.next_action","text":"","title":"next_action"},{"location":"reference/models/#djstripe.models.core.SetupIntent.on_behalf_of","text":"","title":"on_behalf_of"},{"location":"reference/models/#djstripe.models.core.SetupIntent.payment_method","text":"","title":"payment_method"},{"location":"reference/models/#djstripe.models.core.SetupIntent.payment_method_types","text":"","title":"payment_method_types"},{"location":"reference/models/#djstripe.models.core.SetupIntent.status","text":"","title":"status"},{"location":"reference/models/#djstripe.models.core.SetupIntent.stripe_class","text":"","title":"stripe_class"},{"location":"reference/models/#djstripe.models.core.SetupIntent.usage","text":"","title":"usage"},{"location":"reference/models/#djstripe.models.core.SetupIntent-functions","text":"","title":"Functions"},{"location":"reference/models/#djstripe.models.core.SetupIntent.__str__","text":"Source code in djstripe/models/core.py 2030 2031 2032 2033 2034 2035 2036 2037 2038 2039 2040 2041 2042 2043 2044 2045 2046 2047 def __str__ ( self ): account = self . on_behalf_of customer = self . customer if account and customer : return ( f \" { self . payment_method } ( { enums . SetupIntentStatus . humanize ( self . status ) } ) \" f \"for { account } \" f \"by { customer } \" ) if account : return f \" { self . payment_method } for { account } . { enums . SetupIntentStatus . humanize ( self . status ) } \" if customer : return f \" { self . payment_method } by { customer } . { enums . SetupIntentStatus . humanize ( self . status ) } \" return ( f \" { self . payment_method } ( { enums . SetupIntentStatus . humanize ( self . status ) } )\" )","title":"__str__()"},{"location":"reference/models/#djstripe.models.core-functions","text":"","title":"Functions"},{"location":"reference/models/#payment-methods","text":"","title":"Payment Methods"},{"location":"reference/models/#djstripe.models.payment_methods-attributes","text":"","title":"Attributes"},{"location":"reference/models/#djstripe.models.payment_methods-classes","text":"","title":"Classes"},{"location":"reference/models/#djstripe.models.payment_methods.BankAccount","text":"Bases: LegacySourceMixin , StripeModel These bank accounts are payment methods on Customer objects. On the other hand External Accounts are transfer destinations on Account objects for Custom accounts. They can be bank accounts or debit cards as well. Stripe documentation:https://stripe.com/docs/api/customer_bank_accounts Source code in djstripe/models/payment_methods.py 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 class BankAccount ( LegacySourceMixin , StripeModel ): \"\"\" These bank accounts are payment methods on Customer objects. On the other hand External Accounts are transfer destinations on Account objects for Custom accounts. They can be bank accounts or debit cards as well. Stripe documentation:https://stripe.com/docs/api/customer_bank_accounts \"\"\" stripe_class = stripe . BankAccount account = StripeForeignKey ( \"Account\" , on_delete = models . PROTECT , null = True , blank = True , related_name = \"bank_accounts\" , help_text = \"The external account the charge was made on behalf of. Null here indicates \" \"that this value was never set.\" , ) account_holder_name = models . TextField ( max_length = 5000 , blank = True , help_text = \"The name of the person or business that owns the bank account.\" , ) account_holder_type = StripeEnumField ( enum = enums . BankAccountHolderType , help_text = \"The type of entity that holds the account.\" , ) bank_name = models . CharField ( max_length = 255 , help_text = \"Name of the bank associated with the routing number \" \"(e.g., `WELLS FARGO`).\" , ) country = models . CharField ( max_length = 2 , help_text = \"Two-letter ISO code representing the country the bank account \" \"is located in.\" , ) currency = StripeCurrencyCodeField () customer = StripeForeignKey ( \"Customer\" , on_delete = models . SET_NULL , null = True , related_name = \"bank_account\" ) default_for_currency = models . BooleanField ( null = True , help_text = \"Whether this external account (BankAccount) is the default account for \" \"its currency.\" , ) fingerprint = models . CharField ( max_length = 16 , help_text = ( \"Uniquely identifies this particular bank account. \" \"You can use this attribute to check whether two bank accounts are \" \"the same.\" ), ) last4 = models . CharField ( max_length = 4 ) routing_number = models . CharField ( max_length = 255 , help_text = \"The routing transit number for the bank account.\" ) status = StripeEnumField ( enum = enums . BankAccountStatus ) def __str__ ( self ): default = False # prefer to show it by customer format if present if self . customer : default_source = self . customer . default_source default_payment_method = self . customer . default_payment_method if ( default_payment_method and self . id == default_payment_method . id ) or ( default_source and self . id == default_source . id ): # current card is the default payment method or source default = True customer_template = f \" { self . bank_name } { self . routing_number } ( { self . human_readable_status } ) { 'Default' if default else '' } { self . currency } \" return customer_template default = getattr ( self , \"default_for_currency\" , False ) account_template = f \" { self . bank_name } { self . currency } { 'Default' if default else '' } { self . routing_number } { self . last4 } \" return account_template @property def human_readable_status ( self ): if self . status == \"new\" : return \"Pending Verification\" return enums . BankAccountStatus . humanize ( self . status ) def api_retrieve ( self , ** kwargs ): if not self . customer and not self . account : raise ImpossibleAPIRequest ( \"Can't retrieve a bank account without a customer or account object.\" \" This may happen if not all accounts or customer objects are in the db.\" ' Please run \"python manage.py djstripe_sync_models Account Customer\" as a potential fix.' ) return super () . api_retrieve ( ** kwargs )","title":"BankAccount"},{"location":"reference/models/#djstripe.models.payment_methods.BankAccount-attributes","text":"","title":"Attributes"},{"location":"reference/models/#djstripe.models.payment_methods.BankAccount.account","text":"","title":"account"},{"location":"reference/models/#djstripe.models.payment_methods.BankAccount.account_holder_name","text":"","title":"account_holder_name"},{"location":"reference/models/#djstripe.models.payment_methods.BankAccount.account_holder_type","text":"","title":"account_holder_type"},{"location":"reference/models/#djstripe.models.payment_methods.BankAccount.bank_name","text":"","title":"bank_name"},{"location":"reference/models/#djstripe.models.payment_methods.BankAccount.country","text":"","title":"country"},{"location":"reference/models/#djstripe.models.payment_methods.BankAccount.currency","text":"","title":"currency"},{"location":"reference/models/#djstripe.models.payment_methods.BankAccount.customer","text":"","title":"customer"},{"location":"reference/models/#djstripe.models.payment_methods.BankAccount.default_for_currency","text":"","title":"default_for_currency"},{"location":"reference/models/#djstripe.models.payment_methods.BankAccount.fingerprint","text":"","title":"fingerprint"},{"location":"reference/models/#djstripe.models.payment_methods.BankAccount.human_readable_status","text":"","title":"human_readable_status"},{"location":"reference/models/#djstripe.models.payment_methods.BankAccount.last4","text":"","title":"last4"},{"location":"reference/models/#djstripe.models.payment_methods.BankAccount.routing_number","text":"","title":"routing_number"},{"location":"reference/models/#djstripe.models.payment_methods.BankAccount.status","text":"","title":"status"},{"location":"reference/models/#djstripe.models.payment_methods.BankAccount.stripe_class","text":"","title":"stripe_class"},{"location":"reference/models/#djstripe.models.payment_methods.BankAccount-functions","text":"","title":"Functions"},{"location":"reference/models/#djstripe.models.payment_methods.BankAccount.__str__","text":"Source code in djstripe/models/payment_methods.py 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 def __str__ ( self ): default = False # prefer to show it by customer format if present if self . customer : default_source = self . customer . default_source default_payment_method = self . customer . default_payment_method if ( default_payment_method and self . id == default_payment_method . id ) or ( default_source and self . id == default_source . id ): # current card is the default payment method or source default = True customer_template = f \" { self . bank_name } { self . routing_number } ( { self . human_readable_status } ) { 'Default' if default else '' } { self . currency } \" return customer_template default = getattr ( self , \"default_for_currency\" , False ) account_template = f \" { self . bank_name } { self . currency } { 'Default' if default else '' } { self . routing_number } { self . last4 } \" return account_template","title":"__str__()"},{"location":"reference/models/#djstripe.models.payment_methods.BankAccount.api_retrieve","text":"Source code in djstripe/models/payment_methods.py 452 453 454 455 456 457 458 459 460 def api_retrieve ( self , ** kwargs ): if not self . customer and not self . account : raise ImpossibleAPIRequest ( \"Can't retrieve a bank account without a customer or account object.\" \" This may happen if not all accounts or customer objects are in the db.\" ' Please run \"python manage.py djstripe_sync_models Account Customer\" as a potential fix.' ) return super () . api_retrieve ( ** kwargs )","title":"api_retrieve()"},{"location":"reference/models/#djstripe.models.payment_methods.Card","text":"Bases: LegacySourceMixin , StripeModel You can store multiple cards on a customer in order to charge the customer later. This is a legacy model which only applies to the \"v2\" Stripe API (eg. Checkout.js). You should strive to use the Stripe \"v3\" API (eg. Stripe Elements). Also see: https://stripe.com/docs/stripe-js/elements/migrating When using Elements, you will not be using Card objects. Instead, you will use Source objects. A Source object of type \"card\" is equivalent to a Card object. However, Card objects cannot be converted into Source objects by Stripe at this time. Stripe documentation: https://stripe.com/docs/api?lang=python#cards Source code in djstripe/models/payment_methods.py 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 class Card ( LegacySourceMixin , StripeModel ): \"\"\" You can store multiple cards on a customer in order to charge the customer later. This is a legacy model which only applies to the \"v2\" Stripe API (eg. Checkout.js). You should strive to use the Stripe \"v3\" API (eg. Stripe Elements). Also see: https://stripe.com/docs/stripe-js/elements/migrating When using Elements, you will not be using Card objects. Instead, you will use Source objects. A Source object of type \"card\" is equivalent to a Card object. However, Card objects cannot be converted into Source objects by Stripe at this time. Stripe documentation: https://stripe.com/docs/api?lang=python#cards \"\"\" stripe_class = stripe . Card # Stripe Custom Connected Accounts can have cards as \"Payout Sources\" account = StripeForeignKey ( \"Account\" , on_delete = models . PROTECT , null = True , blank = True , related_name = \"cards\" , help_text = \"The external account the charge was made on behalf of. Null here indicates \" \"that this value was never set.\" , ) address_city = models . TextField ( max_length = 5000 , blank = True , default = \"\" , help_text = \"City/District/Suburb/Town/Village.\" , ) address_country = models . TextField ( max_length = 5000 , blank = True , default = \"\" , help_text = \"Billing address country.\" ) address_line1 = models . TextField ( max_length = 5000 , blank = True , default = \"\" , help_text = \"Street address/PO Box/Company name.\" , ) address_line1_check = StripeEnumField ( enum = enums . CardCheckResult , blank = True , default = \"\" , help_text = \"If `address_line1` was provided, results of the check.\" , ) address_line2 = models . TextField ( max_length = 5000 , blank = True , default = \"\" , help_text = \"Apartment/Suite/Unit/Building.\" , ) address_state = models . TextField ( max_length = 5000 , blank = True , default = \"\" , help_text = \"State/County/Province/Region.\" , ) address_zip = models . TextField ( max_length = 5000 , blank = True , default = \"\" , help_text = \"ZIP or postal code.\" ) address_zip_check = StripeEnumField ( enum = enums . CardCheckResult , blank = True , default = \"\" , help_text = \"If `address_zip` was provided, results of the check.\" , ) brand = StripeEnumField ( enum = enums . CardBrand , help_text = \"Card brand.\" ) country = models . CharField ( max_length = 2 , default = \"\" , blank = True , help_text = \"Two-letter ISO code representing the country of the card.\" , ) customer = StripeForeignKey ( \"Customer\" , on_delete = models . SET_NULL , null = True , related_name = \"legacy_cards\" ) cvc_check = StripeEnumField ( enum = enums . CardCheckResult , default = \"\" , blank = True , help_text = \"If a CVC was provided, results of the check.\" , ) default_for_currency = models . BooleanField ( null = True , help_text = \"Whether this external account (Card) is the default account for \" \"its currency.\" , ) dynamic_last4 = models . CharField ( max_length = 4 , default = \"\" , blank = True , help_text = \"(For tokenized numbers only.) The last four digits of the device \" \"account number.\" , ) exp_month = models . IntegerField ( help_text = \"Card expiration month.\" ) exp_year = models . IntegerField ( help_text = \"Card expiration year.\" ) fingerprint = models . CharField ( default = \"\" , blank = True , max_length = 16 , help_text = \"Uniquely identifies this particular card number.\" , ) funding = StripeEnumField ( enum = enums . CardFundingType , help_text = \"Card funding type.\" ) last4 = models . CharField ( max_length = 4 , help_text = \"Last four digits of Card number.\" ) name = models . TextField ( max_length = 5000 , default = \"\" , blank = True , help_text = \"Cardholder name.\" ) tokenization_method = StripeEnumField ( enum = enums . CardTokenizationMethod , default = \"\" , blank = True , help_text = \"If the card number is tokenized, this is the method that was used.\" , ) def __str__ ( self ): default = False # prefer to show it by customer format if present if self . customer : default_source = self . customer . default_source default_payment_method = self . customer . default_payment_method if ( default_payment_method and self . id == default_payment_method . id ) or ( default_source and self . id == default_source . id ): # current card is the default payment method or source default = True customer_template = f \" { enums . CardBrand . humanize ( self . brand ) } { self . last4 } { 'Default' if default else '' } Expires { self . exp_month } { self . exp_year } \" return customer_template elif self . account : default = getattr ( self , \"default_for_currency\" , False ) account_template = f \" { enums . CardBrand . humanize ( self . brand ) } { self . account . default_currency } { 'Default' if default else '' } { self . last4 } \" return account_template return self . id or \"\" @classmethod def create_token ( cls , number : str , exp_month : int , exp_year : int , cvc : str , api_key : str = djstripe_settings . STRIPE_SECRET_KEY , ** kwargs , ) -> stripe . Token : \"\"\" Creates a single use token that wraps the details of a credit card. This token can be used in place of a credit card dictionary with any API method. These tokens can only be used once: by creating a new charge object, or attaching them to a customer. (Source: https://stripe.com/docs/api?lang=python#create_card_token) :param number: The card number without any separators (no spaces) :param exp_month: The card's expiration month. (two digits) :param exp_year: The card's expiration year. (four digits) :param cvc: Card security code. :param api_key: The API key to use \"\"\" card = { \"number\" : number , \"exp_month\" : exp_month , \"exp_year\" : exp_year , \"cvc\" : cvc , } card . update ( kwargs ) return stripe . Token . create ( api_key = api_key , card = card )","title":"Card"},{"location":"reference/models/#djstripe.models.payment_methods.Card-attributes","text":"","title":"Attributes"},{"location":"reference/models/#djstripe.models.payment_methods.Card.account","text":"","title":"account"},{"location":"reference/models/#djstripe.models.payment_methods.Card.address_city","text":"","title":"address_city"},{"location":"reference/models/#djstripe.models.payment_methods.Card.address_country","text":"","title":"address_country"},{"location":"reference/models/#djstripe.models.payment_methods.Card.address_line1","text":"","title":"address_line1"},{"location":"reference/models/#djstripe.models.payment_methods.Card.address_line1_check","text":"","title":"address_line1_check"},{"location":"reference/models/#djstripe.models.payment_methods.Card.address_line2","text":"","title":"address_line2"},{"location":"reference/models/#djstripe.models.payment_methods.Card.address_state","text":"","title":"address_state"},{"location":"reference/models/#djstripe.models.payment_methods.Card.address_zip","text":"","title":"address_zip"},{"location":"reference/models/#djstripe.models.payment_methods.Card.address_zip_check","text":"","title":"address_zip_check"},{"location":"reference/models/#djstripe.models.payment_methods.Card.brand","text":"","title":"brand"},{"location":"reference/models/#djstripe.models.payment_methods.Card.country","text":"","title":"country"},{"location":"reference/models/#djstripe.models.payment_methods.Card.customer","text":"","title":"customer"},{"location":"reference/models/#djstripe.models.payment_methods.Card.cvc_check","text":"","title":"cvc_check"},{"location":"reference/models/#djstripe.models.payment_methods.Card.default_for_currency","text":"","title":"default_for_currency"},{"location":"reference/models/#djstripe.models.payment_methods.Card.dynamic_last4","text":"","title":"dynamic_last4"},{"location":"reference/models/#djstripe.models.payment_methods.Card.exp_month","text":"","title":"exp_month"},{"location":"reference/models/#djstripe.models.payment_methods.Card.exp_year","text":"","title":"exp_year"},{"location":"reference/models/#djstripe.models.payment_methods.Card.fingerprint","text":"","title":"fingerprint"},{"location":"reference/models/#djstripe.models.payment_methods.Card.funding","text":"","title":"funding"},{"location":"reference/models/#djstripe.models.payment_methods.Card.last4","text":"","title":"last4"},{"location":"reference/models/#djstripe.models.payment_methods.Card.name","text":"","title":"name"},{"location":"reference/models/#djstripe.models.payment_methods.Card.stripe_class","text":"","title":"stripe_class"},{"location":"reference/models/#djstripe.models.payment_methods.Card.tokenization_method","text":"","title":"tokenization_method"},{"location":"reference/models/#djstripe.models.payment_methods.Card-functions","text":"","title":"Functions"},{"location":"reference/models/#djstripe.models.payment_methods.Card.__str__","text":"Source code in djstripe/models/payment_methods.py 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 def __str__ ( self ): default = False # prefer to show it by customer format if present if self . customer : default_source = self . customer . default_source default_payment_method = self . customer . default_payment_method if ( default_payment_method and self . id == default_payment_method . id ) or ( default_source and self . id == default_source . id ): # current card is the default payment method or source default = True customer_template = f \" { enums . CardBrand . humanize ( self . brand ) } { self . last4 } { 'Default' if default else '' } Expires { self . exp_month } { self . exp_year } \" return customer_template elif self . account : default = getattr ( self , \"default_for_currency\" , False ) account_template = f \" { enums . CardBrand . humanize ( self . brand ) } { self . account . default_currency } { 'Default' if default else '' } { self . last4 } \" return account_template return self . id or \"\"","title":"__str__()"},{"location":"reference/models/#djstripe.models.payment_methods.Card.create_token","text":"Creates a single use token that wraps the details of a credit card. This token can be used in place of a credit card dictionary with any API method. These tokens can only be used once: by creating a new charge object, or attaching them to a customer. (Source: https://stripe.com/docs/api?lang=python#create_card_token) :param number: The card number without any separators (no spaces) :param exp_month: The card's expiration month. (two digits) :param exp_year: The card's expiration year. (four digits) :param cvc: Card security code. :param api_key: The API key to use Source code in djstripe/models/payment_methods.py 604 605 606 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 @classmethod def create_token ( cls , number : str , exp_month : int , exp_year : int , cvc : str , api_key : str = djstripe_settings . STRIPE_SECRET_KEY , ** kwargs , ) -> stripe . Token : \"\"\" Creates a single use token that wraps the details of a credit card. This token can be used in place of a credit card dictionary with any API method. These tokens can only be used once: by creating a new charge object, or attaching them to a customer. (Source: https://stripe.com/docs/api?lang=python#create_card_token) :param number: The card number without any separators (no spaces) :param exp_month: The card's expiration month. (two digits) :param exp_year: The card's expiration year. (four digits) :param cvc: Card security code. :param api_key: The API key to use \"\"\" card = { \"number\" : number , \"exp_month\" : exp_month , \"exp_year\" : exp_year , \"cvc\" : cvc , } card . update ( kwargs ) return stripe . Token . create ( api_key = api_key , card = card )","title":"create_token()"},{"location":"reference/models/#djstripe.models.payment_methods.PaymentMethod","text":"Bases: StripeModel PaymentMethod objects represent your customer's payment instruments. You can use them with PaymentIntents to collect payments or save them to Customer objects to store instrument details for future payments. Stripe documentation: https://stripe.com/docs/api?lang=python#payment_methods Source code in djstripe/models/payment_methods.py 797 798 799 800 801 802 803 804 805 806 807 808 809 810 811 812 813 814 815 816 817 818 819 820 821 822 823 824 825 826 827 828 829 830 831 832 833 834 835 836 837 838 839 840 841 842 843 844 845 846 847 848 849 850 851 852 853 854 855 856 857 858 859 860 861 862 863 864 865 866 867 868 869 870 871 872 873 874 875 876 877 878 879 880 881 882 883 884 885 886 887 888 889 890 891 892 893 894 895 896 897 898 899 900 901 902 903 904 905 906 907 908 909 910 911 912 913 914 915 916 917 918 919 920 921 922 923 924 925 926 927 928 929 930 931 932 933 934 935 936 937 938 939 940 941 942 943 944 945 946 947 948 949 950 951 952 953 954 955 956 957 958 959 960 961 962 963 964 965 966 967 968 969 970 971 972 973 974 975 976 977 978 979 980 981 982 983 984 985 986 987 988 989 990 991 992 993 994 995 996 997 998 999 1000 1001 1002 1003 1004 1005 1006 1007 1008 1009 1010 1011 1012 1013 1014 1015 1016 1017 1018 1019 1020 1021 1022 1023 1024 1025 1026 1027 1028 1029 1030 1031 1032 1033 1034 1035 1036 1037 1038 1039 1040 1041 1042 1043 1044 1045 1046 1047 1048 1049 1050 1051 1052 1053 1054 1055 1056 1057 1058 1059 1060 1061 1062 1063 1064 1065 1066 1067 1068 1069 1070 1071 1072 1073 1074 1075 1076 1077 1078 class PaymentMethod ( StripeModel ): \"\"\" PaymentMethod objects represent your customer's payment instruments. You can use them with PaymentIntents to collect payments or save them to Customer objects to store instrument details for future payments. Stripe documentation: https://stripe.com/docs/api?lang=python#payment_methods \"\"\" stripe_class = stripe . PaymentMethod description = None billing_details = JSONField ( help_text = ( \"Billing information associated with the PaymentMethod that may be used or \" \"required by particular types of payment methods.\" ) ) customer = StripeForeignKey ( \"Customer\" , on_delete = models . SET_NULL , null = True , blank = True , related_name = \"payment_methods\" , help_text = ( \"Customer to which this PaymentMethod is saved. \" \"This will not be set when the PaymentMethod has \" \"not been saved to a Customer.\" ), ) type = StripeEnumField ( enum = enums . PaymentMethodType , help_text = \"The type of the PaymentMethod.\" , ) acss_debit = JSONField ( null = True , blank = True , help_text = \"Additional information for payment methods of type `acss_debit`\" , ) affirm = JSONField ( null = True , blank = True , help_text = \"Additional information for payment methods of type `affirm`\" , ) afterpay_clearpay = JSONField ( null = True , blank = True , help_text = \"Additional information for payment methods of type `afterpay_clearpay`\" , ) alipay = JSONField ( null = True , blank = True , help_text = \"Additional information for payment methods of type `alipay`\" , ) au_becs_debit = JSONField ( null = True , blank = True , help_text = \"Additional information for payment methods of type `au_becs_debit`\" , ) bacs_debit = JSONField ( null = True , blank = True , help_text = \"Additional information for payment methods of type `bacs_debit`\" , ) bancontact = JSONField ( null = True , blank = True , help_text = \"Additional information for payment methods of type `bancontact`\" , ) blik = JSONField ( null = True , blank = True , help_text = \"Additional information for payment methods of type `blik`\" , ) boleto = JSONField ( null = True , blank = True , help_text = \"Additional information for payment methods of type `boleto`\" , ) card = JSONField ( null = True , blank = True , help_text = \"Additional information for payment methods of type `card`\" , ) card_present = JSONField ( null = True , blank = True , help_text = \"Additional information for payment methods of type `card_present`\" , ) customer_balance = JSONField ( null = True , blank = True , help_text = \"Additional information for payment methods of type `customer_balance`\" , ) eps = JSONField ( null = True , blank = True , help_text = \"Additional information for payment methods of type `eps`\" , ) fpx = JSONField ( null = True , blank = True , help_text = \"Additional information for payment methods of type `fpx`\" , ) giropay = JSONField ( null = True , blank = True , help_text = \"Additional information for payment methods of type `giropay`\" , ) grabpay = JSONField ( null = True , blank = True , help_text = \"Additional information for payment methods of type `grabpay`\" , ) ideal = JSONField ( null = True , blank = True , help_text = \"Additional information for payment methods of type `ideal`\" , ) interac_present = JSONField ( null = True , blank = True , help_text = ( \"Additional information for payment methods of type `interac_present`\" ), ) klarna = JSONField ( null = True , blank = True , help_text = \"Additional information for payment methods of type `klarna`\" , ) konbini = JSONField ( null = True , blank = True , help_text = \"Additional information for payment methods of type `konbini`\" , ) link = JSONField ( null = True , blank = True , help_text = \"Additional information for payment methods of type `link`\" , ) oxxo = JSONField ( null = True , blank = True , help_text = \"Additional information for payment methods of type `oxxo`\" , ) p24 = JSONField ( null = True , blank = True , help_text = \"Additional information for payment methods of type `p24`\" , ) paynow = JSONField ( null = True , blank = True , help_text = \"Additional information for payment methods of type `paynow`\" , ) pix = JSONField ( null = True , blank = True , help_text = \"Additional information for payment methods of type `pix`\" , ) promptpay = JSONField ( null = True , blank = True , help_text = \"Additional information for payment methods of type `promptpay`\" , ) sepa_debit = JSONField ( null = True , blank = True , help_text = \"Additional information for payment methods of type `sepa_debit`\" , ) sofort = JSONField ( null = True , blank = True , help_text = \"Additional information for payment methods of type `sofort`\" , ) us_bank_account = JSONField ( null = True , blank = True , help_text = \"Additional information for payment methods of type `us_bank_account`\" , ) wechat_pay = JSONField ( null = True , blank = True , help_text = \"Additional information for payment methods of type `wechat_pay`\" , ) def __str__ ( self ): if self . customer : return f \" { enums . PaymentMethodType . humanize ( self . type ) } for { self . customer } \" return f \" { enums . PaymentMethodType . humanize ( self . type ) } is not associated with any customer\" def get_stripe_dashboard_url ( self ) -> str : if self . customer : return self . customer . get_stripe_dashboard_url () return \"\" def _attach_objects_hook ( self , cls , data , api_key = djstripe_settings . STRIPE_SECRET_KEY , current_ids = None ): customer = None # \"customer\" key could be like \"cus_6lsBvm5rJ0zyHc\" or {\"id\": \"cus_6lsBvm5rJ0zyHc\"} customer_id = get_id_from_stripe_data ( data . get ( \"customer\" )) if current_ids is None or customer_id not in current_ids : customer = cls . _stripe_object_to_customer ( target_cls = Customer , data = data , current_ids = current_ids , api_key = api_key ) if customer : self . customer = customer else : self . customer = None @classmethod def attach ( cls , payment_method : Union [ str , \"PaymentMethod\" ], customer : Union [ str , Customer ], api_key : str = djstripe_settings . STRIPE_SECRET_KEY , ) -> \"PaymentMethod\" : \"\"\" Attach a payment method to a customer \"\"\" if isinstance ( payment_method , StripeModel ): payment_method = payment_method . id if isinstance ( customer , StripeModel ): customer = customer . id extra_kwargs = {} if not isinstance ( payment_method , stripe . PaymentMethod ): # send api_key if we're not passing in a Stripe object # avoids \"Received unknown parameter: api_key\" since api uses the # key cached in the Stripe object extra_kwargs = { \"api_key\" : api_key } stripe_payment_method = stripe . PaymentMethod . attach ( payment_method , customer = customer , ** extra_kwargs ) return cls . sync_from_stripe_data ( stripe_payment_method , api_key = api_key ) def detach ( self ): \"\"\" Detach the payment method from its customer. :return: Returns true if the payment method was newly detached, \\ false if it was already detached :rtype: bool \"\"\" # Find customers that use this customers = Customer . objects . filter ( default_payment_method = self ) . all () changed = True # special handling is needed for legacy \"card\"-type PaymentMethods, # since detaching them deletes them within Stripe. # see https://github.com/dj-stripe/dj-stripe/pull/967 is_legacy_card = self . id . startswith ( \"card_\" ) try : self . sync_from_stripe_data ( self . api_retrieve () . detach ()) # resync customer to update .default_payment_method and # .invoice_settings.default_payment_method for customer in customers : Customer . sync_from_stripe_data ( customer . api_retrieve ()) except ( InvalidRequestError ,): # The source was already detached. Resyncing. if self . pk and not is_legacy_card : self . sync_from_stripe_data ( self . api_retrieve ()) changed = False if self . pk : if is_legacy_card : self . delete () else : self . refresh_from_db () return changed","title":"PaymentMethod"},{"location":"reference/models/#djstripe.models.payment_methods.PaymentMethod-attributes","text":"","title":"Attributes"},{"location":"reference/models/#djstripe.models.payment_methods.PaymentMethod.acss_debit","text":"","title":"acss_debit"},{"location":"reference/models/#djstripe.models.payment_methods.PaymentMethod.affirm","text":"","title":"affirm"},{"location":"reference/models/#djstripe.models.payment_methods.PaymentMethod.afterpay_clearpay","text":"","title":"afterpay_clearpay"},{"location":"reference/models/#djstripe.models.payment_methods.PaymentMethod.alipay","text":"","title":"alipay"},{"location":"reference/models/#djstripe.models.payment_methods.PaymentMethod.au_becs_debit","text":"","title":"au_becs_debit"},{"location":"reference/models/#djstripe.models.payment_methods.PaymentMethod.bacs_debit","text":"","title":"bacs_debit"},{"location":"reference/models/#djstripe.models.payment_methods.PaymentMethod.bancontact","text":"","title":"bancontact"},{"location":"reference/models/#djstripe.models.payment_methods.PaymentMethod.billing_details","text":"","title":"billing_details"},{"location":"reference/models/#djstripe.models.payment_methods.PaymentMethod.blik","text":"","title":"blik"},{"location":"reference/models/#djstripe.models.payment_methods.PaymentMethod.boleto","text":"","title":"boleto"},{"location":"reference/models/#djstripe.models.payment_methods.PaymentMethod.card","text":"","title":"card"},{"location":"reference/models/#djstripe.models.payment_methods.PaymentMethod.card_present","text":"","title":"card_present"},{"location":"reference/models/#djstripe.models.payment_methods.PaymentMethod.customer","text":"","title":"customer"},{"location":"reference/models/#djstripe.models.payment_methods.PaymentMethod.customer_balance","text":"","title":"customer_balance"},{"location":"reference/models/#djstripe.models.payment_methods.PaymentMethod.description","text":"","title":"description"},{"location":"reference/models/#djstripe.models.payment_methods.PaymentMethod.eps","text":"","title":"eps"},{"location":"reference/models/#djstripe.models.payment_methods.PaymentMethod.fpx","text":"","title":"fpx"},{"location":"reference/models/#djstripe.models.payment_methods.PaymentMethod.giropay","text":"","title":"giropay"},{"location":"reference/models/#djstripe.models.payment_methods.PaymentMethod.grabpay","text":"","title":"grabpay"},{"location":"reference/models/#djstripe.models.payment_methods.PaymentMethod.ideal","text":"","title":"ideal"},{"location":"reference/models/#djstripe.models.payment_methods.PaymentMethod.interac_present","text":"","title":"interac_present"},{"location":"reference/models/#djstripe.models.payment_methods.PaymentMethod.klarna","text":"","title":"klarna"},{"location":"reference/models/#djstripe.models.payment_methods.PaymentMethod.konbini","text":"","title":"konbini"},{"location":"reference/models/#djstripe.models.payment_methods.PaymentMethod.link","text":"","title":"link"},{"location":"reference/models/#djstripe.models.payment_methods.PaymentMethod.oxxo","text":"","title":"oxxo"},{"location":"reference/models/#djstripe.models.payment_methods.PaymentMethod.p24","text":"","title":"p24"},{"location":"reference/models/#djstripe.models.payment_methods.PaymentMethod.paynow","text":"","title":"paynow"},{"location":"reference/models/#djstripe.models.payment_methods.PaymentMethod.pix","text":"","title":"pix"},{"location":"reference/models/#djstripe.models.payment_methods.PaymentMethod.promptpay","text":"","title":"promptpay"},{"location":"reference/models/#djstripe.models.payment_methods.PaymentMethod.sepa_debit","text":"","title":"sepa_debit"},{"location":"reference/models/#djstripe.models.payment_methods.PaymentMethod.sofort","text":"","title":"sofort"},{"location":"reference/models/#djstripe.models.payment_methods.PaymentMethod.stripe_class","text":"","title":"stripe_class"},{"location":"reference/models/#djstripe.models.payment_methods.PaymentMethod.type","text":"","title":"type"},{"location":"reference/models/#djstripe.models.payment_methods.PaymentMethod.us_bank_account","text":"","title":"us_bank_account"},{"location":"reference/models/#djstripe.models.payment_methods.PaymentMethod.wechat_pay","text":"","title":"wechat_pay"},{"location":"reference/models/#djstripe.models.payment_methods.PaymentMethod-functions","text":"","title":"Functions"},{"location":"reference/models/#djstripe.models.payment_methods.PaymentMethod.__str__","text":"Source code in djstripe/models/payment_methods.py 984 985 986 987 def __str__ ( self ): if self . customer : return f \" { enums . PaymentMethodType . humanize ( self . type ) } for { self . customer } \" return f \" { enums . PaymentMethodType . humanize ( self . type ) } is not associated with any customer\"","title":"__str__()"},{"location":"reference/models/#djstripe.models.payment_methods.PaymentMethod._attach_objects_hook","text":"Source code in djstripe/models/payment_methods.py 994 995 996 997 998 999 1000 1001 1002 1003 1004 1005 1006 1007 1008 1009 def _attach_objects_hook ( self , cls , data , api_key = djstripe_settings . STRIPE_SECRET_KEY , current_ids = None ): customer = None # \"customer\" key could be like \"cus_6lsBvm5rJ0zyHc\" or {\"id\": \"cus_6lsBvm5rJ0zyHc\"} customer_id = get_id_from_stripe_data ( data . get ( \"customer\" )) if current_ids is None or customer_id not in current_ids : customer = cls . _stripe_object_to_customer ( target_cls = Customer , data = data , current_ids = current_ids , api_key = api_key ) if customer : self . customer = customer else : self . customer = None","title":"_attach_objects_hook()"},{"location":"reference/models/#djstripe.models.payment_methods.PaymentMethod.attach","text":"Attach a payment method to a customer Source code in djstripe/models/payment_methods.py 1011 1012 1013 1014 1015 1016 1017 1018 1019 1020 1021 1022 1023 1024 1025 1026 1027 1028 1029 1030 1031 1032 1033 1034 1035 1036 1037 1038 @classmethod def attach ( cls , payment_method : Union [ str , \"PaymentMethod\" ], customer : Union [ str , Customer ], api_key : str = djstripe_settings . STRIPE_SECRET_KEY , ) -> \"PaymentMethod\" : \"\"\" Attach a payment method to a customer \"\"\" if isinstance ( payment_method , StripeModel ): payment_method = payment_method . id if isinstance ( customer , StripeModel ): customer = customer . id extra_kwargs = {} if not isinstance ( payment_method , stripe . PaymentMethod ): # send api_key if we're not passing in a Stripe object # avoids \"Received unknown parameter: api_key\" since api uses the # key cached in the Stripe object extra_kwargs = { \"api_key\" : api_key } stripe_payment_method = stripe . PaymentMethod . attach ( payment_method , customer = customer , ** extra_kwargs ) return cls . sync_from_stripe_data ( stripe_payment_method , api_key = api_key )","title":"attach()"},{"location":"reference/models/#djstripe.models.payment_methods.PaymentMethod.detach","text":"Detach the payment method from its customer. :return: Returns true if the payment method was newly detached, false if it was already detached :rtype: bool Source code in djstripe/models/payment_methods.py 1040 1041 1042 1043 1044 1045 1046 1047 1048 1049 1050 1051 1052 1053 1054 1055 1056 1057 1058 1059 1060 1061 1062 1063 1064 1065 1066 1067 1068 1069 1070 1071 1072 1073 1074 1075 1076 1077 1078 def detach ( self ): \"\"\" Detach the payment method from its customer. :return: Returns true if the payment method was newly detached, \\ false if it was already detached :rtype: bool \"\"\" # Find customers that use this customers = Customer . objects . filter ( default_payment_method = self ) . all () changed = True # special handling is needed for legacy \"card\"-type PaymentMethods, # since detaching them deletes them within Stripe. # see https://github.com/dj-stripe/dj-stripe/pull/967 is_legacy_card = self . id . startswith ( \"card_\" ) try : self . sync_from_stripe_data ( self . api_retrieve () . detach ()) # resync customer to update .default_payment_method and # .invoice_settings.default_payment_method for customer in customers : Customer . sync_from_stripe_data ( customer . api_retrieve ()) except ( InvalidRequestError ,): # The source was already detached. Resyncing. if self . pk and not is_legacy_card : self . sync_from_stripe_data ( self . api_retrieve ()) changed = False if self . pk : if is_legacy_card : self . delete () else : self . refresh_from_db () return changed","title":"detach()"},{"location":"reference/models/#djstripe.models.payment_methods.PaymentMethod.get_stripe_dashboard_url","text":"Source code in djstripe/models/payment_methods.py 989 990 991 992 def get_stripe_dashboard_url ( self ) -> str : if self . customer : return self . customer . get_stripe_dashboard_url () return \"\"","title":"get_stripe_dashboard_url()"},{"location":"reference/models/#djstripe.models.payment_methods.Source","text":"Bases: StripeModel Source objects allow you to accept a variety of payment methods. They represent a customer's payment instrument, and can be used with the Stripe API just like a Card object: once chargeable, they can be charged, or can be attached to customers. Stripe documentation: https://stripe.com/docs/api?lang=python#sources Source code in djstripe/models/payment_methods.py 639 640 641 642 643 644 645 646 647 648 649 650 651 652 653 654 655 656 657 658 659 660 661 662 663 664 665 666 667 668 669 670 671 672 673 674 675 676 677 678 679 680 681 682 683 684 685 686 687 688 689 690 691 692 693 694 695 696 697 698 699 700 701 702 703 704 705 706 707 708 709 710 711 712 713 714 715 716 717 718 719 720 721 722 723 724 725 726 727 728 729 730 731 732 733 734 735 736 737 738 739 740 741 742 743 744 745 746 747 748 749 750 751 752 753 754 755 756 757 758 759 760 761 762 763 764 765 766 767 768 769 770 771 772 773 774 775 776 777 778 779 780 781 782 783 784 785 786 787 788 789 790 791 792 793 794 class Source ( StripeModel ): \"\"\" Source objects allow you to accept a variety of payment methods. They represent a customer's payment instrument, and can be used with the Stripe API just like a Card object: once chargeable, they can be charged, or can be attached to customers. Stripe documentation: https://stripe.com/docs/api?lang=python#sources \"\"\" amount = StripeDecimalCurrencyAmountField ( null = True , blank = True , help_text = ( \"Amount (as decimal) associated with the source. \" \"This is the amount for which the source will be chargeable once ready. \" \"Required for `single_use` sources.\" ), ) client_secret = models . CharField ( max_length = 255 , help_text = ( \"The client secret of the source. \" \"Used for client-side retrieval using a publishable key.\" ), ) currency = StripeCurrencyCodeField ( default = \"\" , blank = True ) flow = StripeEnumField ( enum = enums . SourceFlow , help_text = \"The authentication flow of the source.\" ) owner = JSONField ( help_text = ( \"Information about the owner of the payment instrument that may be \" \"used or required by particular source types.\" ) ) statement_descriptor = models . CharField ( max_length = 255 , default = \"\" , blank = True , help_text = \"Extra information about a source. This will appear on your \" \"customer's statement every time you charge the source.\" , ) status = StripeEnumField ( enum = enums . SourceStatus , help_text = \"The status of the source. Only `chargeable` sources can be used \" \"to create a charge.\" , ) type = StripeEnumField ( enum = enums . SourceType , help_text = \"The type of the source.\" ) usage = StripeEnumField ( enum = enums . SourceUsage , help_text = \"Whether this source should be reusable or not. \" \"Some source types may or may not be reusable by construction, \" \"while other may leave the option at creation.\" , ) # Flows code_verification = JSONField ( null = True , blank = True , help_text = \"Information related to the code verification flow. \" \"Present if the source is authenticated by a verification code \" \"(`flow` is `code_verification`).\" , ) receiver = JSONField ( null = True , blank = True , help_text = \"Information related to the receiver flow. \" \"Present if the source is a receiver (`flow` is `receiver`).\" , ) redirect = JSONField ( null = True , blank = True , help_text = \"Information related to the redirect flow. \" \"Present if the source is authenticated by a redirect (`flow` is `redirect`).\" , ) source_data = JSONField ( help_text = \"The data corresponding to the source type.\" ) customer = StripeForeignKey ( \"Customer\" , on_delete = models . SET_NULL , null = True , blank = True , related_name = \"sources\" , ) stripe_class = stripe . Source stripe_dashboard_item_name = \"sources\" def __str__ ( self ): return f \" { self . type } { self . id } \" @classmethod def _manipulate_stripe_object_hook ( cls , data ): # The source_data dict is an alias of all the source types data [ \"source_data\" ] = data [ data [ \"type\" ]] return data def _attach_objects_hook ( self , cls , data , api_key = djstripe_settings . STRIPE_SECRET_KEY , current_ids = None ): customer = None # \"customer\" key could be like \"cus_6lsBvm5rJ0zyHc\" or {\"id\": \"cus_6lsBvm5rJ0zyHc\"} customer_id = get_id_from_stripe_data ( data . get ( \"customer\" )) if current_ids is None or customer_id not in current_ids : customer = cls . _stripe_object_to_customer ( target_cls = Customer , data = data , current_ids = current_ids , api_key = api_key ) if customer : self . customer = customer else : self . customer = None def detach ( self ) -> bool : \"\"\" Detach the source from its customer. \"\"\" # First, wipe default source on all customers that use this. Customer . objects . filter ( default_source = self . id ) . update ( default_source = None ) api_key = self . default_api_key try : # TODO - we could use the return value of sync_from_stripe_data # or call its internals - self._sync/_attach_objects_hook etc here # to update `self` at this point? self . sync_from_stripe_data ( self . api_retrieve ( api_key = api_key ) . detach (), api_key = api_key ) return True except InvalidRequestError : # The source was already detached. Resyncing. self . sync_from_stripe_data ( self . api_retrieve ( api_key = self . default_api_key ), api_key = self . default_api_key , ) return False @classmethod def api_list ( cls , api_key = djstripe_settings . STRIPE_SECRET_KEY , ** kwargs ): \"\"\" Call the stripe API's list operation for this model. :param api_key: The api key to use for this request. \\ Defaults to djstripe_settings.STRIPE_SECRET_KEY. :type api_key: string See Stripe documentation for accepted kwargs for each object. :returns: an iterator over all items in the query \"\"\" return Customer . stripe_class . list_sources ( object = \"source\" , api_key = api_key , stripe_version = djstripe_settings . STRIPE_API_VERSION , ** kwargs , ) . auto_paging_iter ()","title":"Source"},{"location":"reference/models/#djstripe.models.payment_methods.Source-attributes","text":"","title":"Attributes"},{"location":"reference/models/#djstripe.models.payment_methods.Source.amount","text":"","title":"amount"},{"location":"reference/models/#djstripe.models.payment_methods.Source.client_secret","text":"","title":"client_secret"},{"location":"reference/models/#djstripe.models.payment_methods.Source.code_verification","text":"","title":"code_verification"},{"location":"reference/models/#djstripe.models.payment_methods.Source.currency","text":"","title":"currency"},{"location":"reference/models/#djstripe.models.payment_methods.Source.customer","text":"","title":"customer"},{"location":"reference/models/#djstripe.models.payment_methods.Source.flow","text":"","title":"flow"},{"location":"reference/models/#djstripe.models.payment_methods.Source.owner","text":"","title":"owner"},{"location":"reference/models/#djstripe.models.payment_methods.Source.receiver","text":"","title":"receiver"},{"location":"reference/models/#djstripe.models.payment_methods.Source.redirect","text":"","title":"redirect"},{"location":"reference/models/#djstripe.models.payment_methods.Source.source_data","text":"","title":"source_data"},{"location":"reference/models/#djstripe.models.payment_methods.Source.statement_descriptor","text":"","title":"statement_descriptor"},{"location":"reference/models/#djstripe.models.payment_methods.Source.status","text":"","title":"status"},{"location":"reference/models/#djstripe.models.payment_methods.Source.stripe_class","text":"","title":"stripe_class"},{"location":"reference/models/#djstripe.models.payment_methods.Source.stripe_dashboard_item_name","text":"","title":"stripe_dashboard_item_name"},{"location":"reference/models/#djstripe.models.payment_methods.Source.type","text":"","title":"type"},{"location":"reference/models/#djstripe.models.payment_methods.Source.usage","text":"","title":"usage"},{"location":"reference/models/#djstripe.models.payment_methods.Source-functions","text":"","title":"Functions"},{"location":"reference/models/#djstripe.models.payment_methods.Source.__str__","text":"Source code in djstripe/models/payment_methods.py 729 730 def __str__ ( self ): return f \" { self . type } { self . id } \"","title":"__str__()"},{"location":"reference/models/#djstripe.models.payment_methods.Source._attach_objects_hook","text":"Source code in djstripe/models/payment_methods.py 738 739 740 741 742 743 744 745 746 747 748 749 750 751 752 753 def _attach_objects_hook ( self , cls , data , api_key = djstripe_settings . STRIPE_SECRET_KEY , current_ids = None ): customer = None # \"customer\" key could be like \"cus_6lsBvm5rJ0zyHc\" or {\"id\": \"cus_6lsBvm5rJ0zyHc\"} customer_id = get_id_from_stripe_data ( data . get ( \"customer\" )) if current_ids is None or customer_id not in current_ids : customer = cls . _stripe_object_to_customer ( target_cls = Customer , data = data , current_ids = current_ids , api_key = api_key ) if customer : self . customer = customer else : self . customer = None","title":"_attach_objects_hook()"},{"location":"reference/models/#djstripe.models.payment_methods.Source._manipulate_stripe_object_hook","text":"Source code in djstripe/models/payment_methods.py 732 733 734 735 736 @classmethod def _manipulate_stripe_object_hook ( cls , data ): # The source_data dict is an alias of all the source types data [ \"source_data\" ] = data [ data [ \"type\" ]] return data","title":"_manipulate_stripe_object_hook()"},{"location":"reference/models/#djstripe.models.payment_methods.Source.api_list","text":"Call the stripe API's list operation for this model. :param api_key: The api key to use for this request. Defaults to djstripe_settings.STRIPE_SECRET_KEY. :type api_key: string See Stripe documentation for accepted kwargs for each object. :returns: an iterator over all items in the query Source code in djstripe/models/payment_methods.py 779 780 781 782 783 784 785 786 787 788 789 790 791 792 793 794 @classmethod def api_list ( cls , api_key = djstripe_settings . STRIPE_SECRET_KEY , ** kwargs ): \"\"\" Call the stripe API's list operation for this model. :param api_key: The api key to use for this request. \\ Defaults to djstripe_settings.STRIPE_SECRET_KEY. :type api_key: string See Stripe documentation for accepted kwargs for each object. :returns: an iterator over all items in the query \"\"\" return Customer . stripe_class . list_sources ( object = \"source\" , api_key = api_key , stripe_version = djstripe_settings . STRIPE_API_VERSION , ** kwargs , ) . auto_paging_iter ()","title":"api_list()"},{"location":"reference/models/#djstripe.models.payment_methods.Source.detach","text":"Detach the source from its customer. Source code in djstripe/models/payment_methods.py 755 756 757 758 759 760 761 762 763 764 765 766 767 768 769 770 771 772 773 774 775 776 777 def detach ( self ) -> bool : \"\"\" Detach the source from its customer. \"\"\" # First, wipe default source on all customers that use this. Customer . objects . filter ( default_source = self . id ) . update ( default_source = None ) api_key = self . default_api_key try : # TODO - we could use the return value of sync_from_stripe_data # or call its internals - self._sync/_attach_objects_hook etc here # to update `self` at this point? self . sync_from_stripe_data ( self . api_retrieve ( api_key = api_key ) . detach (), api_key = api_key ) return True except InvalidRequestError : # The source was already detached. Resyncing. self . sync_from_stripe_data ( self . api_retrieve ( api_key = self . default_api_key ), api_key = self . default_api_key , ) return False","title":"detach()"},{"location":"reference/models/#djstripe.models.payment_methods-functions","text":"","title":"Functions"},{"location":"reference/models/#billing","text":"","title":"Billing"},{"location":"reference/models/#djstripe.models.billing-attributes","text":"","title":"Attributes"},{"location":"reference/models/#djstripe.models.billing.logger","text":"","title":"logger"},{"location":"reference/models/#djstripe.models.billing-classes","text":"","title":"Classes"},{"location":"reference/models/#djstripe.models.billing.Coupon","text":"Bases: StripeModel A coupon contains information about a percent-off or amount-off discount you might want to apply to a customer. Coupons may be applied to invoices or orders. Coupons do not work with conventional one-off charges. Stripe documentation: https://stripe.com/docs/api/coupons?lang=python Source code in djstripe/models/billing.py 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 class Coupon ( StripeModel ): \"\"\" A coupon contains information about a percent-off or amount-off discount you might want to apply to a customer. Coupons may be applied to invoices or orders. Coupons do not work with conventional one-off charges. Stripe documentation: https://stripe.com/docs/api/coupons?lang=python \"\"\" stripe_class = stripe . Coupon expand_fields = [ \"applies_to\" ] stripe_dashboard_item_name = \"coupons\" id = StripeIdField ( max_length = 500 ) applies_to = JSONField ( null = True , blank = True , help_text = \"Contains information about what this coupon applies to.\" , ) amount_off = StripeDecimalCurrencyAmountField ( null = True , blank = True , help_text = \"Amount (as decimal) that will be taken off the subtotal of any \" \"invoices for this customer.\" , ) currency = StripeCurrencyCodeField ( null = True , blank = True ) duration = StripeEnumField ( enum = enums . CouponDuration , help_text = ( \"Describes how long a customer who applies this coupon \" \"will get the discount.\" ), default = enums . CouponDuration . once , ) duration_in_months = models . PositiveIntegerField ( null = True , blank = True , help_text = \"If `duration` is `repeating`, the number of months \" \"the coupon applies.\" , ) max_redemptions = models . PositiveIntegerField ( null = True , blank = True , help_text = \"Maximum number of times this coupon can be redeemed, in total, \" \"before it is no longer valid.\" , ) name = models . TextField ( max_length = 5000 , default = \"\" , blank = True , help_text = ( \"Name of the coupon displayed to customers on for instance invoices \" \"or receipts.\" ), ) percent_off = StripePercentField ( null = True , blank = True , help_text = ( \"Percent that will be taken off the subtotal of any invoices for \" \"this customer for the duration of the coupon. \" \"For example, a coupon with percent_off of 50 will make a \" \"$100 invoice $50 instead.\" ), ) redeem_by = StripeDateTimeField ( null = True , blank = True , help_text = \"Date after which the coupon can no longer be redeemed. \" \"Max 5 years in the future.\" , ) times_redeemed = models . PositiveIntegerField ( editable = False , default = 0 , help_text = \"Number of times this coupon has been applied to a customer.\" , ) # valid = models.BooleanField(editable=False) class Meta ( StripeModel . Meta ): unique_together = ( \"id\" , \"livemode\" ) def __str__ ( self ): if self . name : return self . name return self . human_readable @property def human_readable_amount ( self ): if self . percent_off : amount = f \" { self . percent_off } %\" elif self . currency : amount = get_friendly_currency_amount ( self . amount_off or 0 , self . currency ) else : amount = \"(invalid amount)\" return f \" { amount } off\" @property def human_readable ( self ): if self . duration == enums . CouponDuration . repeating : if self . duration_in_months == 1 : duration = \"for 1 month\" else : duration = f \"for { self . duration_in_months } months\" else : duration = self . duration return f \" { self . human_readable_amount } { duration } \"","title":"Coupon"},{"location":"reference/models/#djstripe.models.billing.Coupon-attributes","text":"","title":"Attributes"},{"location":"reference/models/#djstripe.models.billing.Coupon.amount_off","text":"","title":"amount_off"},{"location":"reference/models/#djstripe.models.billing.Coupon.applies_to","text":"","title":"applies_to"},{"location":"reference/models/#djstripe.models.billing.Coupon.currency","text":"","title":"currency"},{"location":"reference/models/#djstripe.models.billing.Coupon.duration","text":"","title":"duration"},{"location":"reference/models/#djstripe.models.billing.Coupon.duration_in_months","text":"","title":"duration_in_months"},{"location":"reference/models/#djstripe.models.billing.Coupon.expand_fields","text":"","title":"expand_fields"},{"location":"reference/models/#djstripe.models.billing.Coupon.human_readable","text":"","title":"human_readable"},{"location":"reference/models/#djstripe.models.billing.Coupon.human_readable_amount","text":"","title":"human_readable_amount"},{"location":"reference/models/#djstripe.models.billing.Coupon.id","text":"","title":"id"},{"location":"reference/models/#djstripe.models.billing.Coupon.max_redemptions","text":"","title":"max_redemptions"},{"location":"reference/models/#djstripe.models.billing.Coupon.name","text":"","title":"name"},{"location":"reference/models/#djstripe.models.billing.Coupon.percent_off","text":"","title":"percent_off"},{"location":"reference/models/#djstripe.models.billing.Coupon.redeem_by","text":"","title":"redeem_by"},{"location":"reference/models/#djstripe.models.billing.Coupon.stripe_class","text":"","title":"stripe_class"},{"location":"reference/models/#djstripe.models.billing.Coupon.stripe_dashboard_item_name","text":"","title":"stripe_dashboard_item_name"},{"location":"reference/models/#djstripe.models.billing.Coupon.times_redeemed","text":"","title":"times_redeemed"},{"location":"reference/models/#djstripe.models.billing.Coupon-classes","text":"","title":"Classes"},{"location":"reference/models/#djstripe.models.billing.Coupon.Meta","text":"Bases: StripeModel . Meta Source code in djstripe/models/billing.py 172 173 class Meta ( StripeModel . Meta ): unique_together = ( \"id\" , \"livemode\" )","title":"Meta"},{"location":"reference/models/#djstripe.models.billing.Coupon.Meta-attributes","text":"djstripe . models . billing . Coupon . Meta . unique_together = ( 'id' , 'livemode' ) class-attribute","title":"Attributes"},{"location":"reference/models/#djstripe.models.billing.Coupon-functions","text":"","title":"Functions"},{"location":"reference/models/#djstripe.models.billing.Coupon.__str__","text":"Source code in djstripe/models/billing.py 175 176 177 178 def __str__ ( self ): if self . name : return self . name return self . human_readable","title":"__str__()"},{"location":"reference/models/#djstripe.models.billing.Discount","text":"Bases: StripeModel A discount represents the actual application of a coupon or promotion code. It contains information about when the discount began, when it will end, and what it is applied to. Stripe documentation: https://stripe.com/docs/api/discounts Source code in djstripe/models/billing.py 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 class Discount ( StripeModel ): \"\"\" A discount represents the actual application of a coupon or promotion code. It contains information about when the discount began, when it will end, and what it is applied to. Stripe documentation: https://stripe.com/docs/api/discounts \"\"\" expand_fields = [ \"customer\" ] stripe_class = None checkout_session = StripeForeignKey ( \"Session\" , null = True , blank = True , on_delete = models . CASCADE , help_text = \"The Checkout session that this coupon is applied to, if it is applied to a particular session in payment mode. Will not be present for subscription mode.\" , ) coupon = JSONField ( null = True , blank = True , help_text = \"Hash describing the coupon applied to create this discount.\" , ) customer = StripeForeignKey ( \"Customer\" , null = True , blank = True , on_delete = models . CASCADE , help_text = \"The ID of the customer associated with this discount.\" , related_name = \"customer_discounts\" , ) end = StripeDateTimeField ( null = True , blank = True , help_text = ( \"If the coupon has a duration of repeating, the date that this discount will end. If the coupon has a duration of once or forever, this attribute will be null.\" ), ) invoice = StripeForeignKey ( \"Invoice\" , null = True , blank = True , on_delete = models . CASCADE , help_text = \"The invoice that the discount\u2019s coupon was applied to, if it was applied directly to a particular invoice.\" , related_name = \"invoice_discounts\" , ) invoice_item = InvoiceOrLineItemForeignKey ( null = True , blank = True , on_delete = models . CASCADE , help_text = \"The invoice item id (or invoice line item id for invoice line items of type=\u2018subscription\u2019) that the discount\u2019s coupon was applied to, if it was applied directly to a particular invoice item or invoice line item.\" , ) promotion_code = models . CharField ( max_length = 255 , blank = True , help_text = \"The promotion code applied to create this discount.\" , ) start = StripeDateTimeField ( null = True , blank = True , help_text = ( \"Date that the coupon was applied.\" ), ) subscription = StripeForeignKey ( \"subscription\" , null = True , blank = True , on_delete = models . CASCADE , help_text = \"The subscription that this coupon is applied to, if it is applied to a particular subscription.\" , related_name = \"subscription_discounts\" , ) @classmethod def is_valid_object ( cls , data ): \"\"\" Returns whether the data is a valid object for the class \"\"\" return \"object\" in data and data [ \"object\" ] == \"discount\"","title":"Discount"},{"location":"reference/models/#djstripe.models.billing.Discount-attributes","text":"","title":"Attributes"},{"location":"reference/models/#djstripe.models.billing.Discount.checkout_session","text":"","title":"checkout_session"},{"location":"reference/models/#djstripe.models.billing.Discount.coupon","text":"","title":"coupon"},{"location":"reference/models/#djstripe.models.billing.Discount.customer","text":"","title":"customer"},{"location":"reference/models/#djstripe.models.billing.Discount.end","text":"","title":"end"},{"location":"reference/models/#djstripe.models.billing.Discount.expand_fields","text":"","title":"expand_fields"},{"location":"reference/models/#djstripe.models.billing.Discount.invoice","text":"","title":"invoice"},{"location":"reference/models/#djstripe.models.billing.Discount.invoice_item","text":"","title":"invoice_item"},{"location":"reference/models/#djstripe.models.billing.Discount.promotion_code","text":"","title":"promotion_code"},{"location":"reference/models/#djstripe.models.billing.Discount.start","text":"","title":"start"},{"location":"reference/models/#djstripe.models.billing.Discount.stripe_class","text":"","title":"stripe_class"},{"location":"reference/models/#djstripe.models.billing.Discount.subscription","text":"","title":"subscription"},{"location":"reference/models/#djstripe.models.billing.Discount-functions","text":"","title":"Functions"},{"location":"reference/models/#djstripe.models.billing.Discount.is_valid_object","text":"Returns whether the data is a valid object for the class Source code in djstripe/models/billing.py 274 275 276 277 278 279 @classmethod def is_valid_object ( cls , data ): \"\"\" Returns whether the data is a valid object for the class \"\"\" return \"object\" in data and data [ \"object\" ] == \"discount\"","title":"is_valid_object()"},{"location":"reference/models/#djstripe.models.billing.Invoice","text":"Bases: BaseInvoice Invoices are statements of what a customer owes for a particular billing period, including subscriptions, invoice items, and any automatic proration adjustments if necessary. Once an invoice is created, payment is automatically attempted. Note that the payment, while automatic, does not happen exactly at the time of invoice creation. If you have configured webhooks, the invoice will wait until one hour after the last webhook is successfully sent (or the last webhook times out after failing). Any customer credit on the account is applied before determining how much is due for that invoice (the amount that will be actually charged). If the amount due for the invoice is less than 50 cents (the minimum for a charge), we add the amount to the customer's running account balance to be added to the next invoice. If this amount is negative, it will act as a credit to offset the next invoice. Note that the customer account balance does not include unpaid invoices; it only includes balances that need to be taken into account when calculating the amount due for the next invoice. Stripe documentation: https://stripe.com/docs/api?lang=python#invoices Source code in djstripe/models/billing.py 780 781 782 783 784 785 786 787 788 789 790 791 792 793 794 795 796 797 798 799 800 801 802 803 804 805 806 807 808 809 810 811 812 813 814 815 816 817 818 819 820 821 822 823 824 825 826 827 828 829 830 831 832 833 834 835 836 837 838 839 840 841 842 843 844 845 846 847 848 849 850 class Invoice ( BaseInvoice ): \"\"\" Invoices are statements of what a customer owes for a particular billing period, including subscriptions, invoice items, and any automatic proration adjustments if necessary. Once an invoice is created, payment is automatically attempted. Note that the payment, while automatic, does not happen exactly at the time of invoice creation. If you have configured webhooks, the invoice will wait until one hour after the last webhook is successfully sent (or the last webhook times out after failing). Any customer credit on the account is applied before determining how much is due for that invoice (the amount that will be actually charged). If the amount due for the invoice is less than 50 cents (the minimum for a charge), we add the amount to the customer's running account balance to be added to the next invoice. If this amount is negative, it will act as a credit to offset the next invoice. Note that the customer account balance does not include unpaid invoices; it only includes balances that need to be taken into account when calculating the amount due for the next invoice. Stripe documentation: https://stripe.com/docs/api?lang=python#invoices \"\"\" default_source = PaymentMethodForeignKey ( on_delete = models . SET_NULL , null = True , blank = True , related_name = \"invoices\" , help_text = \"The default payment source for the invoice. \" \"It must belong to the customer associated with the invoice and be \" \"in a chargeable state. If not set, defaults to the subscription's \" \"default source, if any, or to the customer's default source.\" , ) # Note: # Most fields are defined on BaseInvoice so they're shared with UpcomingInvoice. # ManyToManyFields are an exception, since UpcomingInvoice doesn't exist in the db. default_tax_rates = models . ManyToManyField ( \"TaxRate\" , # explicitly specify the joining table name as though the joining model # was defined with through=\"DjstripeInvoiceDefaultTaxRate\" db_table = \"djstripe_djstripeinvoicedefaulttaxrate\" , related_name = \"+\" , blank = True , help_text = \"The tax rates applied to this invoice, if any.\" , ) def _attach_objects_post_save_hook ( self , cls , data , api_key = djstripe_settings . STRIPE_SECRET_KEY , pending_relations = None , ): super () . _attach_objects_post_save_hook ( cls , data , api_key = api_key , pending_relations = pending_relations ) self . default_tax_rates . set ( cls . _stripe_object_to_default_tax_rates ( target_cls = TaxRate , data = data , api_key = api_key ) ) cls . _stripe_object_set_total_tax_amounts ( target_cls = DjstripeInvoiceTotalTaxAmount , data = data , instance = self , api_key = api_key , )","title":"Invoice"},{"location":"reference/models/#djstripe.models.billing.Invoice-attributes","text":"","title":"Attributes"},{"location":"reference/models/#djstripe.models.billing.Invoice.default_source","text":"","title":"default_source"},{"location":"reference/models/#djstripe.models.billing.Invoice.default_tax_rates","text":"","title":"default_tax_rates"},{"location":"reference/models/#djstripe.models.billing.Invoice-functions","text":"","title":"Functions"},{"location":"reference/models/#djstripe.models.billing.Invoice._attach_objects_post_save_hook","text":"Source code in djstripe/models/billing.py 828 829 830 831 832 833 834 835 836 837 838 839 840 841 842 843 844 845 846 847 848 849 850 def _attach_objects_post_save_hook ( self , cls , data , api_key = djstripe_settings . STRIPE_SECRET_KEY , pending_relations = None , ): super () . _attach_objects_post_save_hook ( cls , data , api_key = api_key , pending_relations = pending_relations ) self . default_tax_rates . set ( cls . _stripe_object_to_default_tax_rates ( target_cls = TaxRate , data = data , api_key = api_key ) ) cls . _stripe_object_set_total_tax_amounts ( target_cls = DjstripeInvoiceTotalTaxAmount , data = data , instance = self , api_key = api_key , )","title":"_attach_objects_post_save_hook()"},{"location":"reference/models/#djstripe.models.billing.InvoiceItem","text":"Bases: StripeModel Sometimes you want to add a charge or credit to a customer but only actually charge the customer's card at the end of a regular billing cycle. This is useful for combining several charges to minimize per-transaction fees or having Stripe tabulate your usage-based billing totals. Stripe documentation: https://stripe.com/docs/api?lang=python#invoiceitems Source code in djstripe/models/billing.py 995 996 997 998 999 1000 1001 1002 1003 1004 1005 1006 1007 1008 1009 1010 1011 1012 1013 1014 1015 1016 1017 1018 1019 1020 1021 1022 1023 1024 1025 1026 1027 1028 1029 1030 1031 1032 1033 1034 1035 1036 1037 1038 1039 1040 1041 1042 1043 1044 1045 1046 1047 1048 1049 1050 1051 1052 1053 1054 1055 1056 1057 1058 1059 1060 1061 1062 1063 1064 1065 1066 1067 1068 1069 1070 1071 1072 1073 1074 1075 1076 1077 1078 1079 1080 1081 1082 1083 1084 1085 1086 1087 1088 1089 1090 1091 1092 1093 1094 1095 1096 1097 1098 1099 1100 1101 1102 1103 1104 1105 1106 1107 1108 1109 1110 1111 1112 1113 1114 1115 1116 1117 1118 1119 1120 1121 1122 1123 1124 1125 1126 1127 1128 1129 1130 1131 1132 1133 1134 1135 1136 1137 1138 1139 1140 1141 1142 1143 1144 1145 1146 1147 class InvoiceItem ( StripeModel ): \"\"\" Sometimes you want to add a charge or credit to a customer but only actually charge the customer's card at the end of a regular billing cycle. This is useful for combining several charges to minimize per-transaction fees or having Stripe tabulate your usage-based billing totals. Stripe documentation: https://stripe.com/docs/api?lang=python#invoiceitems \"\"\" stripe_class = stripe . InvoiceItem expand_fields = [ \"discounts\" ] amount = StripeDecimalCurrencyAmountField ( help_text = \"Amount invoiced (as decimal).\" ) currency = StripeCurrencyCodeField () customer = StripeForeignKey ( \"Customer\" , on_delete = models . CASCADE , related_name = \"invoiceitems\" , help_text = \"The customer associated with this invoiceitem.\" , ) date = StripeDateTimeField ( help_text = \"The date on the invoiceitem.\" ) discountable = models . BooleanField ( default = False , help_text = \"If True, discounts will apply to this invoice item. \" \"Always False for prorations.\" , ) discounts = JSONField ( null = True , blank = True , help_text = \"The discounts which apply to the invoice item. Item discounts are applied before invoice discounts.\" , ) invoice = StripeForeignKey ( \"Invoice\" , on_delete = models . CASCADE , null = True , related_name = \"invoiceitems\" , help_text = \"The invoice to which this invoiceitem is attached.\" , ) period = JSONField () period_end = StripeDateTimeField ( help_text = \"Might be the date when this invoiceitem's invoice was sent.\" ) period_start = StripeDateTimeField ( help_text = \"Might be the date when this invoiceitem was added to the invoice\" ) plan = models . ForeignKey ( \"Plan\" , null = True , on_delete = models . SET_NULL , help_text = \"If the invoice item is a proration, the plan of the subscription \" \"for which the proration was computed.\" , ) price = models . ForeignKey ( \"Price\" , null = True , related_name = \"invoiceitems\" , on_delete = models . SET_NULL , help_text = \"If the invoice item is a proration, the price of the subscription \" \"for which the proration was computed.\" , ) proration = models . BooleanField ( default = False , help_text = \"Whether or not the invoice item was created automatically as a \" \"proration adjustment when the customer switched plans.\" , ) quantity = models . IntegerField ( null = True , blank = True , help_text = \"If the invoice item is a proration, the quantity of the \" \"subscription for which the proration was computed.\" , ) subscription = StripeForeignKey ( \"Subscription\" , null = True , related_name = \"invoiceitems\" , on_delete = models . SET_NULL , help_text = \"The subscription that this invoice item has been created for, \" \"if any.\" , ) # XXX: subscription_item tax_rates = models . ManyToManyField ( \"TaxRate\" , # explicitly specify the joining table name as though the joining model # was defined with through=\"DjstripeInvoiceItemTaxRate\" db_table = \"djstripe_djstripeinvoiceitemtaxrate\" , related_name = \"+\" , blank = True , help_text = \"The tax rates which apply to this invoice item. When set, \" \"the default_tax_rates on the invoice do not apply to this \" \"invoice item.\" , ) unit_amount = StripeQuantumCurrencyAmountField ( null = True , blank = True , help_text = \"Unit amount (in the `currency` specified) of the invoice item.\" , ) unit_amount_decimal = StripeDecimalCurrencyAmountField ( null = True , blank = True , max_digits = 19 , decimal_places = 12 , help_text = ( \"Same as `unit_amount`, but contains a decimal value with \" \"at most 12 decimal places.\" ), ) @classmethod def _manipulate_stripe_object_hook ( cls , data ): data [ \"period_start\" ] = data [ \"period\" ][ \"start\" ] data [ \"period_end\" ] = data [ \"period\" ][ \"end\" ] return data def _attach_objects_post_save_hook ( self , cls , data , api_key = djstripe_settings . STRIPE_SECRET_KEY , pending_relations = None , ): super () . _attach_objects_post_save_hook ( cls , data , api_key = api_key , pending_relations = pending_relations ) if self . pk : # only call .set() on saved instance (ie don't on items of UpcomingInvoice) self . tax_rates . set ( cls . _stripe_object_to_tax_rates ( target_cls = TaxRate , data = data , api_key = api_key ) ) # sync every discount for discount in self . discounts : Discount . sync_from_stripe_data ( discount , api_key = api_key ) def __str__ ( self ): return self . description def get_stripe_dashboard_url ( self ): return self . invoice . get_stripe_dashboard_url () def api_retrieve ( self , * args , ** kwargs ): if \"-il_\" in self . id : warnings . warn ( f \"Attempting to retrieve InvoiceItem with id= { self . id !r} \" \" will most likely fail. \" \"Run manage.py djstripe_update_invoiceitem_ids if this is a problem.\" ) return super () . api_retrieve ( * args , ** kwargs )","title":"InvoiceItem"},{"location":"reference/models/#djstripe.models.billing.InvoiceItem-attributes","text":"","title":"Attributes"},{"location":"reference/models/#djstripe.models.billing.InvoiceItem.amount","text":"","title":"amount"},{"location":"reference/models/#djstripe.models.billing.InvoiceItem.currency","text":"","title":"currency"},{"location":"reference/models/#djstripe.models.billing.InvoiceItem.customer","text":"","title":"customer"},{"location":"reference/models/#djstripe.models.billing.InvoiceItem.date","text":"","title":"date"},{"location":"reference/models/#djstripe.models.billing.InvoiceItem.discountable","text":"","title":"discountable"},{"location":"reference/models/#djstripe.models.billing.InvoiceItem.discounts","text":"","title":"discounts"},{"location":"reference/models/#djstripe.models.billing.InvoiceItem.expand_fields","text":"","title":"expand_fields"},{"location":"reference/models/#djstripe.models.billing.InvoiceItem.invoice","text":"","title":"invoice"},{"location":"reference/models/#djstripe.models.billing.InvoiceItem.period","text":"","title":"period"},{"location":"reference/models/#djstripe.models.billing.InvoiceItem.period_end","text":"","title":"period_end"},{"location":"reference/models/#djstripe.models.billing.InvoiceItem.period_start","text":"","title":"period_start"},{"location":"reference/models/#djstripe.models.billing.InvoiceItem.plan","text":"","title":"plan"},{"location":"reference/models/#djstripe.models.billing.InvoiceItem.price","text":"","title":"price"},{"location":"reference/models/#djstripe.models.billing.InvoiceItem.proration","text":"","title":"proration"},{"location":"reference/models/#djstripe.models.billing.InvoiceItem.quantity","text":"","title":"quantity"},{"location":"reference/models/#djstripe.models.billing.InvoiceItem.stripe_class","text":"","title":"stripe_class"},{"location":"reference/models/#djstripe.models.billing.InvoiceItem.subscription","text":"","title":"subscription"},{"location":"reference/models/#djstripe.models.billing.InvoiceItem.tax_rates","text":"","title":"tax_rates"},{"location":"reference/models/#djstripe.models.billing.InvoiceItem.unit_amount","text":"","title":"unit_amount"},{"location":"reference/models/#djstripe.models.billing.InvoiceItem.unit_amount_decimal","text":"","title":"unit_amount_decimal"},{"location":"reference/models/#djstripe.models.billing.InvoiceItem-functions","text":"","title":"Functions"},{"location":"reference/models/#djstripe.models.billing.InvoiceItem.__str__","text":"Source code in djstripe/models/billing.py 1133 1134 def __str__ ( self ): return self . description","title":"__str__()"},{"location":"reference/models/#djstripe.models.billing.InvoiceItem._attach_objects_post_save_hook","text":"Source code in djstripe/models/billing.py 1110 1111 1112 1113 1114 1115 1116 1117 1118 1119 1120 1121 1122 1123 1124 1125 1126 1127 1128 1129 1130 1131 def _attach_objects_post_save_hook ( self , cls , data , api_key = djstripe_settings . STRIPE_SECRET_KEY , pending_relations = None , ): super () . _attach_objects_post_save_hook ( cls , data , api_key = api_key , pending_relations = pending_relations ) if self . pk : # only call .set() on saved instance (ie don't on items of UpcomingInvoice) self . tax_rates . set ( cls . _stripe_object_to_tax_rates ( target_cls = TaxRate , data = data , api_key = api_key ) ) # sync every discount for discount in self . discounts : Discount . sync_from_stripe_data ( discount , api_key = api_key )","title":"_attach_objects_post_save_hook()"},{"location":"reference/models/#djstripe.models.billing.InvoiceItem._manipulate_stripe_object_hook","text":"Source code in djstripe/models/billing.py 1103 1104 1105 1106 1107 1108 @classmethod def _manipulate_stripe_object_hook ( cls , data ): data [ \"period_start\" ] = data [ \"period\" ][ \"start\" ] data [ \"period_end\" ] = data [ \"period\" ][ \"end\" ] return data","title":"_manipulate_stripe_object_hook()"},{"location":"reference/models/#djstripe.models.billing.InvoiceItem.api_retrieve","text":"Source code in djstripe/models/billing.py 1139 1140 1141 1142 1143 1144 1145 1146 1147 def api_retrieve ( self , * args , ** kwargs ): if \"-il_\" in self . id : warnings . warn ( f \"Attempting to retrieve InvoiceItem with id= { self . id !r} \" \" will most likely fail. \" \"Run manage.py djstripe_update_invoiceitem_ids if this is a problem.\" ) return super () . api_retrieve ( * args , ** kwargs )","title":"api_retrieve()"},{"location":"reference/models/#djstripe.models.billing.InvoiceItem.get_stripe_dashboard_url","text":"Source code in djstripe/models/billing.py 1136 1137 def get_stripe_dashboard_url ( self ): return self . invoice . get_stripe_dashboard_url ()","title":"get_stripe_dashboard_url()"},{"location":"reference/models/#djstripe.models.billing.InvoiceOrLineItem","text":"Bases: models . Model An Internal Model that abstracts InvoiceItem and lineItem objects Contains two fields: id and type : - id is the id of the Stripe object. - type can be line_item , invoice_item or unsupported Source code in djstripe/models/billing.py 1295 1296 1297 1298 1299 1300 1301 1302 1303 1304 1305 1306 1307 1308 1309 1310 1311 1312 1313 1314 1315 1316 1317 1318 1319 1320 1321 1322 1323 1324 1325 1326 1327 1328 1329 1330 1331 1332 1333 1334 1335 1336 1337 1338 1339 1340 1341 1342 1343 1344 1345 1346 1347 1348 1349 1350 1351 1352 1353 class InvoiceOrLineItem ( models . Model ): \"\"\"An Internal Model that abstracts InvoiceItem and lineItem objects Contains two fields: `id` and `type`: - `id` is the id of the Stripe object. - `type` can be `line_item`, `invoice_item` or `unsupported` \"\"\" id = models . CharField ( max_length = 255 , primary_key = True ) type = StripeEnumField ( enum = enums . InvoiceorLineItemType , help_text = \"Indicates whether the underlying model is LineItem or InvoiceItem. Can be one of: 'invoice_item', 'line_item' or 'unsupported'\" , ) @classmethod def _model_type ( cls , id_ ): if id_ . startswith ( \"ii\" ): return InvoiceItem , \"invoice_item\" elif id_ . startswith ( \"il\" ): return LineItem , \"line_item\" raise ValueError ( f \"Unknown object type with id: { id_ } \" ) @classmethod def _get_or_create_from_stripe_object ( cls , data , field_name = \"id\" , refetch = True , current_ids = None , pending_relations = None , save = True , stripe_account = None , api_key = djstripe_settings . STRIPE_SECRET_KEY , ): raw_field_data = data . get ( field_name ) id_ = get_id_from_stripe_data ( raw_field_data ) try : object_cls , object_type = cls . _model_type ( id_ ) except ValueError : # This may happen if we have object types we don't know about. # Let's not make dj-stripe entirely unusable if that happens. logger . warning ( f \"Unknown Object. Could not sync object with id: { id_ } \" ) return cls . objects . get_or_create ( id = id_ , defaults = { \"type\" : \"unsupported\" }) # call model's _get_or_create_from_stripe_object to ensure # that object exists before getting or creating its InvoiceorLineItem mapping object_cls . _get_or_create_from_stripe_object ( data , field_name , refetch = refetch , current_ids = current_ids , pending_relations = pending_relations , stripe_account = stripe_account , api_key = api_key , ) return cls . objects . get_or_create ( id = id_ , defaults = { \"type\" : object_type })","title":"InvoiceOrLineItem"},{"location":"reference/models/#djstripe.models.billing.InvoiceOrLineItem-attributes","text":"","title":"Attributes"},{"location":"reference/models/#djstripe.models.billing.InvoiceOrLineItem.id","text":"","title":"id"},{"location":"reference/models/#djstripe.models.billing.InvoiceOrLineItem.type","text":"","title":"type"},{"location":"reference/models/#djstripe.models.billing.InvoiceOrLineItem-functions","text":"","title":"Functions"},{"location":"reference/models/#djstripe.models.billing.InvoiceOrLineItem._get_or_create_from_stripe_object","text":"Source code in djstripe/models/billing.py 1318 1319 1320 1321 1322 1323 1324 1325 1326 1327 1328 1329 1330 1331 1332 1333 1334 1335 1336 1337 1338 1339 1340 1341 1342 1343 1344 1345 1346 1347 1348 1349 1350 1351 1352 1353 @classmethod def _get_or_create_from_stripe_object ( cls , data , field_name = \"id\" , refetch = True , current_ids = None , pending_relations = None , save = True , stripe_account = None , api_key = djstripe_settings . STRIPE_SECRET_KEY , ): raw_field_data = data . get ( field_name ) id_ = get_id_from_stripe_data ( raw_field_data ) try : object_cls , object_type = cls . _model_type ( id_ ) except ValueError : # This may happen if we have object types we don't know about. # Let's not make dj-stripe entirely unusable if that happens. logger . warning ( f \"Unknown Object. Could not sync object with id: { id_ } \" ) return cls . objects . get_or_create ( id = id_ , defaults = { \"type\" : \"unsupported\" }) # call model's _get_or_create_from_stripe_object to ensure # that object exists before getting or creating its InvoiceorLineItem mapping object_cls . _get_or_create_from_stripe_object ( data , field_name , refetch = refetch , current_ids = current_ids , pending_relations = pending_relations , stripe_account = stripe_account , api_key = api_key , ) return cls . objects . get_or_create ( id = id_ , defaults = { \"type\" : object_type })","title":"_get_or_create_from_stripe_object()"},{"location":"reference/models/#djstripe.models.billing.InvoiceOrLineItem._model_type","text":"Source code in djstripe/models/billing.py 1310 1311 1312 1313 1314 1315 1316 @classmethod def _model_type ( cls , id_ ): if id_ . startswith ( \"ii\" ): return InvoiceItem , \"invoice_item\" elif id_ . startswith ( \"il\" ): return LineItem , \"line_item\" raise ValueError ( f \"Unknown object type with id: { id_ } \" )","title":"_model_type()"},{"location":"reference/models/#djstripe.models.billing.LineItem","text":"Bases: StripeModel The individual line items that make up the invoice. Stripe documentation: https://stripe.com/docs/api/invoices/line_item Source code in djstripe/models/billing.py 1150 1151 1152 1153 1154 1155 1156 1157 1158 1159 1160 1161 1162 1163 1164 1165 1166 1167 1168 1169 1170 1171 1172 1173 1174 1175 1176 1177 1178 1179 1180 1181 1182 1183 1184 1185 1186 1187 1188 1189 1190 1191 1192 1193 1194 1195 1196 1197 1198 1199 1200 1201 1202 1203 1204 1205 1206 1207 1208 1209 1210 1211 1212 1213 1214 1215 1216 1217 1218 1219 1220 1221 1222 1223 1224 1225 1226 1227 1228 1229 1230 1231 1232 1233 1234 1235 1236 1237 1238 1239 1240 1241 1242 1243 1244 1245 1246 1247 1248 1249 1250 1251 1252 1253 1254 1255 1256 1257 1258 1259 1260 1261 1262 1263 1264 1265 1266 1267 1268 1269 1270 1271 1272 1273 1274 1275 1276 1277 1278 1279 1280 1281 1282 1283 1284 1285 1286 1287 1288 1289 1290 1291 1292 class LineItem ( StripeModel ): \"\"\" The individual line items that make up the invoice. Stripe documentation: https://stripe.com/docs/api/invoices/line_item \"\"\" stripe_class = stripe . InvoiceLineItem expand_fields = [ \"discounts\" ] amount = StripeQuantumCurrencyAmountField ( help_text = \"The amount, in cents.\" ) amount_excluding_tax = StripeQuantumCurrencyAmountField ( help_text = \"The integer amount in cents representing the amount for this line item, excluding all tax and discounts.\" ) currency = StripeCurrencyCodeField () discount_amounts = JSONField ( null = True , blank = True , help_text = \"The amount of discount calculated per discount for this line item.\" , ) discountable = models . BooleanField ( default = False , help_text = \"If True, discounts will apply to this line item. \" \"Always False for prorations.\" , ) discounts = JSONField ( null = True , blank = True , help_text = \"The discounts applied to the invoice line item. Line item discounts are applied before invoice discounts.\" , ) invoice_item = StripeForeignKey ( \"InvoiceItem\" , null = True , blank = True , on_delete = models . CASCADE , help_text = \"The ID of the invoice item associated with this line item if any.\" , ) period = JSONField ( help_text = \"The period this line_item covers. For subscription line items, this is the subscription period. For prorations, this starts when the proration was calculated, and ends at the period end of the subscription. For invoice items, this is the time at which the invoice item was created or the period of the item.\" ) period_end = StripeDateTimeField ( help_text = \"The end of the period, which must be greater than or equal to the start.\" ) period_start = StripeDateTimeField ( help_text = \"The start of the period.\" ) price = JSONField ( help_text = \"The price of the line item.\" , ) proration = models . BooleanField ( default = False , help_text = \"Whether or not the invoice item was created automatically as a \" \"proration adjustment when the customer switched plans.\" , ) proration_details = JSONField ( help_text = \"Additional details for proration line items\" ) subscription = StripeForeignKey ( \"Subscription\" , null = True , blank = True , on_delete = models . CASCADE , help_text = \"The subscription that the invoice item pertains to, if any.\" , ) subscription_item = StripeForeignKey ( \"SubscriptionItem\" , null = True , blank = True , on_delete = models . CASCADE , help_text = \"The subscription item that generated this invoice item. Left empty if the line item is not an explicit result of a subscription.\" , ) tax_amounts = JSONField ( null = True , blank = True , help_text = \"The amount of tax calculated per tax rate for this line item\" , ) tax_rates = JSONField ( null = True , blank = True , help_text = \"The tax rates which apply to the line item.\" ) type = StripeEnumField ( enum = enums . LineItem ) unit_amount_excluding_tax = StripeDecimalCurrencyAmountField ( null = True , blank = True , help_text = ( \"The amount in cents representing the unit amount for this line item, excluding all tax and discounts.\" ), ) quantity = models . IntegerField ( null = True , blank = True , help_text = \"The quantity of the subscription, if the line item is a subscription or a proration.\" , ) @classmethod def _manipulate_stripe_object_hook ( cls , data ): data [ \"period_start\" ] = data [ \"period\" ][ \"start\" ] data [ \"period_end\" ] = data [ \"period\" ][ \"end\" ] return data def _attach_objects_post_save_hook ( self , cls , data , api_key = djstripe_settings . STRIPE_SECRET_KEY , pending_relations = None , ): super () . _attach_objects_post_save_hook ( cls , data , api_key = api_key , pending_relations = pending_relations ) # sync every discount for discount in self . discounts : Discount . sync_from_stripe_data ( discount , api_key = api_key ) @classmethod def api_list ( cls , api_key = djstripe_settings . STRIPE_SECRET_KEY , ** kwargs ): \"\"\" Call the stripe API's list operation for this model. Note that we only iterate and sync the LineItem associated with the passed in Invoice. Upcoming invoices are virtual and are not saved and hence their line items are also not retrieved and synced :param api_key: The api key to use for this request. \\ Defaults to djstripe_settings.STRIPE_SECRET_KEY. :type api_key: string See Stripe documentation for accepted kwargs for each object. :returns: an iterator over all items in the query \"\"\" # get current invoice if any invoice_id = kwargs . pop ( \"id\" ) # get expand parameter that needs to be passed to invoice.lines.list call expand_fields = kwargs . pop ( \"expand\" ) invoice = Invoice . stripe_class . retrieve ( invoice_id , api_key = api_key , ** kwargs ) # iterate over all the line items on the current invoice return invoice . lines . list ( api_key = api_key , expand = expand_fields , ** kwargs ) . auto_paging_iter ()","title":"LineItem"},{"location":"reference/models/#djstripe.models.billing.LineItem-attributes","text":"","title":"Attributes"},{"location":"reference/models/#djstripe.models.billing.LineItem.amount","text":"","title":"amount"},{"location":"reference/models/#djstripe.models.billing.LineItem.amount_excluding_tax","text":"","title":"amount_excluding_tax"},{"location":"reference/models/#djstripe.models.billing.LineItem.currency","text":"","title":"currency"},{"location":"reference/models/#djstripe.models.billing.LineItem.discount_amounts","text":"","title":"discount_amounts"},{"location":"reference/models/#djstripe.models.billing.LineItem.discountable","text":"","title":"discountable"},{"location":"reference/models/#djstripe.models.billing.LineItem.discounts","text":"","title":"discounts"},{"location":"reference/models/#djstripe.models.billing.LineItem.expand_fields","text":"","title":"expand_fields"},{"location":"reference/models/#djstripe.models.billing.LineItem.invoice_item","text":"","title":"invoice_item"},{"location":"reference/models/#djstripe.models.billing.LineItem.period","text":"","title":"period"},{"location":"reference/models/#djstripe.models.billing.LineItem.period_end","text":"","title":"period_end"},{"location":"reference/models/#djstripe.models.billing.LineItem.period_start","text":"","title":"period_start"},{"location":"reference/models/#djstripe.models.billing.LineItem.price","text":"","title":"price"},{"location":"reference/models/#djstripe.models.billing.LineItem.proration","text":"","title":"proration"},{"location":"reference/models/#djstripe.models.billing.LineItem.proration_details","text":"","title":"proration_details"},{"location":"reference/models/#djstripe.models.billing.LineItem.quantity","text":"","title":"quantity"},{"location":"reference/models/#djstripe.models.billing.LineItem.stripe_class","text":"","title":"stripe_class"},{"location":"reference/models/#djstripe.models.billing.LineItem.subscription","text":"","title":"subscription"},{"location":"reference/models/#djstripe.models.billing.LineItem.subscription_item","text":"","title":"subscription_item"},{"location":"reference/models/#djstripe.models.billing.LineItem.tax_amounts","text":"","title":"tax_amounts"},{"location":"reference/models/#djstripe.models.billing.LineItem.tax_rates","text":"","title":"tax_rates"},{"location":"reference/models/#djstripe.models.billing.LineItem.type","text":"","title":"type"},{"location":"reference/models/#djstripe.models.billing.LineItem.unit_amount_excluding_tax","text":"","title":"unit_amount_excluding_tax"},{"location":"reference/models/#djstripe.models.billing.LineItem-functions","text":"","title":"Functions"},{"location":"reference/models/#djstripe.models.billing.LineItem._attach_objects_post_save_hook","text":"Source code in djstripe/models/billing.py 1248 1249 1250 1251 1252 1253 1254 1255 1256 1257 1258 1259 1260 1261 def _attach_objects_post_save_hook ( self , cls , data , api_key = djstripe_settings . STRIPE_SECRET_KEY , pending_relations = None , ): super () . _attach_objects_post_save_hook ( cls , data , api_key = api_key , pending_relations = pending_relations ) # sync every discount for discount in self . discounts : Discount . sync_from_stripe_data ( discount , api_key = api_key )","title":"_attach_objects_post_save_hook()"},{"location":"reference/models/#djstripe.models.billing.LineItem._manipulate_stripe_object_hook","text":"Source code in djstripe/models/billing.py 1241 1242 1243 1244 1245 1246 @classmethod def _manipulate_stripe_object_hook ( cls , data ): data [ \"period_start\" ] = data [ \"period\" ][ \"start\" ] data [ \"period_end\" ] = data [ \"period\" ][ \"end\" ] return data","title":"_manipulate_stripe_object_hook()"},{"location":"reference/models/#djstripe.models.billing.LineItem.api_list","text":"Call the stripe API's list operation for this model. Note that we only iterate and sync the LineItem associated with the passed in Invoice. Upcoming invoices are virtual and are not saved and hence their line items are also not retrieved and synced :param api_key: The api key to use for this request. Defaults to djstripe_settings.STRIPE_SECRET_KEY. :type api_key: string See Stripe documentation for accepted kwargs for each object. :returns: an iterator over all items in the query Source code in djstripe/models/billing.py 1263 1264 1265 1266 1267 1268 1269 1270 1271 1272 1273 1274 1275 1276 1277 1278 1279 1280 1281 1282 1283 1284 1285 1286 1287 1288 1289 1290 1291 1292 @classmethod def api_list ( cls , api_key = djstripe_settings . STRIPE_SECRET_KEY , ** kwargs ): \"\"\" Call the stripe API's list operation for this model. Note that we only iterate and sync the LineItem associated with the passed in Invoice. Upcoming invoices are virtual and are not saved and hence their line items are also not retrieved and synced :param api_key: The api key to use for this request. \\ Defaults to djstripe_settings.STRIPE_SECRET_KEY. :type api_key: string See Stripe documentation for accepted kwargs for each object. :returns: an iterator over all items in the query \"\"\" # get current invoice if any invoice_id = kwargs . pop ( \"id\" ) # get expand parameter that needs to be passed to invoice.lines.list call expand_fields = kwargs . pop ( \"expand\" ) invoice = Invoice . stripe_class . retrieve ( invoice_id , api_key = api_key , ** kwargs ) # iterate over all the line items on the current invoice return invoice . lines . list ( api_key = api_key , expand = expand_fields , ** kwargs ) . auto_paging_iter ()","title":"api_list()"},{"location":"reference/models/#djstripe.models.billing.Plan","text":"Bases: StripeModel A subscription plan contains the pricing information for different products and feature levels on your site. Stripe documentation: https://stripe.com/docs/api/plans?lang=python NOTE: The Stripe Plans API has been deprecated in favor of the Prices API. You may want to upgrade to use the Price model instead of the Plan model. Source code in djstripe/models/billing.py 1356 1357 1358 1359 1360 1361 1362 1363 1364 1365 1366 1367 1368 1369 1370 1371 1372 1373 1374 1375 1376 1377 1378 1379 1380 1381 1382 1383 1384 1385 1386 1387 1388 1389 1390 1391 1392 1393 1394 1395 1396 1397 1398 1399 1400 1401 1402 1403 1404 1405 1406 1407 1408 1409 1410 1411 1412 1413 1414 1415 1416 1417 1418 1419 1420 1421 1422 1423 1424 1425 1426 1427 1428 1429 1430 1431 1432 1433 1434 1435 1436 1437 1438 1439 1440 1441 1442 1443 1444 1445 1446 1447 1448 1449 1450 1451 1452 1453 1454 1455 1456 1457 1458 1459 1460 1461 1462 1463 1464 1465 1466 1467 1468 1469 1470 1471 1472 1473 1474 1475 1476 1477 1478 1479 1480 1481 1482 1483 1484 1485 1486 1487 1488 1489 1490 1491 1492 1493 1494 1495 1496 1497 1498 1499 1500 1501 1502 1503 1504 1505 1506 1507 1508 1509 1510 1511 1512 1513 1514 1515 1516 1517 1518 1519 1520 1521 1522 1523 1524 1525 1526 1527 1528 1529 1530 1531 1532 1533 1534 1535 1536 1537 1538 1539 1540 1541 1542 1543 1544 1545 1546 1547 1548 1549 1550 1551 1552 1553 1554 1555 1556 1557 1558 1559 1560 1561 1562 1563 1564 1565 1566 1567 1568 1569 1570 class Plan ( StripeModel ): \"\"\" A subscription plan contains the pricing information for different products and feature levels on your site. Stripe documentation: https://stripe.com/docs/api/plans?lang=python NOTE: The Stripe Plans API has been deprecated in favor of the Prices API. You may want to upgrade to use the Price model instead of the Plan model. \"\"\" stripe_class = stripe . Plan expand_fields = [ \"product\" , \"tiers\" ] stripe_dashboard_item_name = \"plans\" active = models . BooleanField ( help_text = \"Whether the plan can be used for new purchases.\" ) aggregate_usage = StripeEnumField ( enum = enums . PlanAggregateUsage , default = \"\" , blank = True , help_text = ( \"Specifies a usage aggregation strategy for plans of usage_type=metered. \" \"Allowed values are `sum` for summing up all usage during a period, \" \"`last_during_period` for picking the last usage record reported within a \" \"period, `last_ever` for picking the last usage record ever (across period \" \"bounds) or max which picks the usage record with the maximum reported \" \"usage during a period. Defaults to `sum`.\" ), ) amount = StripeDecimalCurrencyAmountField ( null = True , blank = True , help_text = \"Amount (as decimal) to be charged on the interval specified.\" , ) amount_decimal = StripeDecimalCurrencyAmountField ( null = True , blank = True , max_digits = 19 , decimal_places = 12 , help_text = ( \"The unit amount in cents to be charged, represented as a decimal \" \"string with at most 12 decimal places.\" ), ) billing_scheme = StripeEnumField ( enum = enums . BillingScheme , default = \"\" , blank = True , help_text = ( \"Describes how to compute the price per period. \" \"Either `per_unit` or `tiered`. \" \"`per_unit` indicates that the fixed amount (specified in amount) \" \"will be charged per unit in quantity \" \"(for plans with `usage_type=licensed`), or per unit of total \" \"usage (for plans with `usage_type=metered`). \" \"`tiered` indicates that the unit pricing will be computed using \" \"a tiering strategy as defined using the tiers and tiers_mode attributes.\" ), ) currency = StripeCurrencyCodeField () interval = StripeEnumField ( enum = enums . PlanInterval , help_text = \"The frequency with which a subscription should be billed.\" , ) interval_count = models . PositiveIntegerField ( null = True , blank = True , help_text = ( \"The number of intervals (specified in the interval property) \" \"between each subscription billing.\" ), ) nickname = models . TextField ( max_length = 5000 , default = \"\" , blank = True , help_text = \"A brief description of the plan, hidden from customers.\" , ) product = StripeForeignKey ( \"Product\" , on_delete = models . SET_NULL , null = True , blank = True , help_text = \"The product whose pricing this plan determines.\" , ) tiers = JSONField ( null = True , blank = True , help_text = ( \"Each element represents a pricing tier. \" \"This parameter requires `billing_scheme` to be set to `tiered`.\" ), ) tiers_mode = StripeEnumField ( enum = enums . PriceTiersMode , null = True , blank = True , help_text = ( \"Defines if the tiering price should be `graduated` or `volume` based. \" \"In `volume`-based tiering, the maximum quantity within a period \" \"determines the per unit price, in `graduated` tiering pricing can \" \"successively change as the quantity grows.\" ), ) transform_usage = JSONField ( null = True , blank = True , help_text = ( \"Apply a transformation to the reported usage or set quantity \" \"before computing the billed price. Cannot be combined with `tiers`.\" ), ) trial_period_days = models . IntegerField ( null = True , blank = True , help_text = ( \"Number of trial period days granted when subscribing a customer \" \"to this plan. Null if the plan has no trial period.\" ), ) usage_type = StripeEnumField ( enum = enums . PriceUsageType , default = enums . PriceUsageType . licensed , help_text = ( \"Configures how the quantity per period should be determined, \" \"can be either `metered` or `licensed`. `licensed` will automatically \" \"bill the `quantity` set for a plan when adding it to a subscription, \" \"`metered` will aggregate the total usage based on usage records. \" \"Defaults to `licensed`.\" ), ) class Meta ( object ): ordering = [ \"amount\" ] @classmethod def get_or_create ( cls , ** kwargs ): \"\"\"Get or create a Plan.\"\"\" try : return cls . objects . get ( id = kwargs [ \"id\" ]), False except cls . DoesNotExist : return cls . create ( ** kwargs ), True @classmethod def create ( cls , ** kwargs ): # A few minor things are changed in the api-version of the create call api_kwargs = dict ( kwargs ) api_kwargs [ \"amount\" ] = int ( api_kwargs [ \"amount\" ] * 100 ) if isinstance ( api_kwargs . get ( \"product\" ), StripeModel ): api_kwargs [ \"product\" ] = api_kwargs [ \"product\" ] . id stripe_plan = cls . _api_create ( ** api_kwargs ) api_key = api_kwargs . get ( \"api_key\" ) or djstripe_settings . STRIPE_SECRET_KEY plan = cls . sync_from_stripe_data ( stripe_plan , api_key = api_key ) return plan def __str__ ( self ): if self . product and self . product . name : return f \" { self . human_readable_price } for { self . product . name } \" return self . human_readable_price @property def amount_in_cents ( self ): return int ( self . amount * 100 ) @property def human_readable_price ( self ) -> str : if self . billing_scheme == \"per_unit\" : unit_amount = self . amount amount = get_friendly_currency_amount ( unit_amount , self . currency ) else : # tiered billing scheme tier_1 = self . tiers [ 0 ] flat_amount_tier_1 = tier_1 [ \"flat_amount\" ] formatted_unit_amount_tier_1 = get_friendly_currency_amount ( ( tier_1 [ \"unit_amount\" ] or 0 ) / 100 , self . currency ) amount = f \"Starts at { formatted_unit_amount_tier_1 } per unit\" # stripe shows flat fee even if it is set to 0.00 if flat_amount_tier_1 is not None : formatted_flat_amount_tier_1 = get_friendly_currency_amount ( flat_amount_tier_1 / 100 , self . currency ) amount = f \" { amount } + { formatted_flat_amount_tier_1 } \" format_args = { \"amount\" : amount } interval_count = self . interval_count if interval_count == 1 : interval = { \"day\" : _ ( \"day\" ), \"week\" : _ ( \"week\" ), \"month\" : _ ( \"month\" ), \"year\" : _ ( \"year\" ), }[ self . interval ] template = _ ( \" {amount} / {interval} \" ) format_args [ \"interval\" ] = interval else : interval = { \"day\" : _ ( \"days\" ), \"week\" : _ ( \"weeks\" ), \"month\" : _ ( \"months\" ), \"year\" : _ ( \"years\" ), }[ self . interval ] template = _ ( \" {amount} / every {interval_count} {interval} \" ) format_args [ \"interval\" ] = interval format_args [ \"interval_count\" ] = interval_count return str ( format_lazy ( template , ** format_args ))","title":"Plan"},{"location":"reference/models/#djstripe.models.billing.Plan-attributes","text":"","title":"Attributes"},{"location":"reference/models/#djstripe.models.billing.Plan.active","text":"","title":"active"},{"location":"reference/models/#djstripe.models.billing.Plan.aggregate_usage","text":"","title":"aggregate_usage"},{"location":"reference/models/#djstripe.models.billing.Plan.amount","text":"","title":"amount"},{"location":"reference/models/#djstripe.models.billing.Plan.amount_decimal","text":"","title":"amount_decimal"},{"location":"reference/models/#djstripe.models.billing.Plan.amount_in_cents","text":"","title":"amount_in_cents"},{"location":"reference/models/#djstripe.models.billing.Plan.billing_scheme","text":"","title":"billing_scheme"},{"location":"reference/models/#djstripe.models.billing.Plan.currency","text":"","title":"currency"},{"location":"reference/models/#djstripe.models.billing.Plan.expand_fields","text":"","title":"expand_fields"},{"location":"reference/models/#djstripe.models.billing.Plan.human_readable_price","text":"","title":"human_readable_price"},{"location":"reference/models/#djstripe.models.billing.Plan.interval","text":"","title":"interval"},{"location":"reference/models/#djstripe.models.billing.Plan.interval_count","text":"","title":"interval_count"},{"location":"reference/models/#djstripe.models.billing.Plan.nickname","text":"","title":"nickname"},{"location":"reference/models/#djstripe.models.billing.Plan.product","text":"","title":"product"},{"location":"reference/models/#djstripe.models.billing.Plan.stripe_class","text":"","title":"stripe_class"},{"location":"reference/models/#djstripe.models.billing.Plan.stripe_dashboard_item_name","text":"","title":"stripe_dashboard_item_name"},{"location":"reference/models/#djstripe.models.billing.Plan.tiers","text":"","title":"tiers"},{"location":"reference/models/#djstripe.models.billing.Plan.tiers_mode","text":"","title":"tiers_mode"},{"location":"reference/models/#djstripe.models.billing.Plan.transform_usage","text":"","title":"transform_usage"},{"location":"reference/models/#djstripe.models.billing.Plan.trial_period_days","text":"","title":"trial_period_days"},{"location":"reference/models/#djstripe.models.billing.Plan.usage_type","text":"","title":"usage_type"},{"location":"reference/models/#djstripe.models.billing.Plan-classes","text":"","title":"Classes"},{"location":"reference/models/#djstripe.models.billing.Plan.Meta","text":"Bases: object Source code in djstripe/models/billing.py 1490 1491 class Meta ( object ): ordering = [ \"amount\" ]","title":"Meta"},{"location":"reference/models/#djstripe.models.billing.Plan.Meta-attributes","text":"djstripe . models . billing . Plan . Meta . ordering = [ 'amount' ] class-attribute","title":"Attributes"},{"location":"reference/models/#djstripe.models.billing.Plan-functions","text":"","title":"Functions"},{"location":"reference/models/#djstripe.models.billing.Plan.__str__","text":"Source code in djstripe/models/billing.py 1517 1518 1519 1520 def __str__ ( self ): if self . product and self . product . name : return f \" { self . human_readable_price } for { self . product . name } \" return self . human_readable_price","title":"__str__()"},{"location":"reference/models/#djstripe.models.billing.Plan.create","text":"Source code in djstripe/models/billing.py 1502 1503 1504 1505 1506 1507 1508 1509 1510 1511 1512 1513 1514 1515 @classmethod def create ( cls , ** kwargs ): # A few minor things are changed in the api-version of the create call api_kwargs = dict ( kwargs ) api_kwargs [ \"amount\" ] = int ( api_kwargs [ \"amount\" ] * 100 ) if isinstance ( api_kwargs . get ( \"product\" ), StripeModel ): api_kwargs [ \"product\" ] = api_kwargs [ \"product\" ] . id stripe_plan = cls . _api_create ( ** api_kwargs ) api_key = api_kwargs . get ( \"api_key\" ) or djstripe_settings . STRIPE_SECRET_KEY plan = cls . sync_from_stripe_data ( stripe_plan , api_key = api_key ) return plan","title":"create()"},{"location":"reference/models/#djstripe.models.billing.Plan.get_or_create","text":"Get or create a Plan. Source code in djstripe/models/billing.py 1493 1494 1495 1496 1497 1498 1499 1500 @classmethod def get_or_create ( cls , ** kwargs ): \"\"\"Get or create a Plan.\"\"\" try : return cls . objects . get ( id = kwargs [ \"id\" ]), False except cls . DoesNotExist : return cls . create ( ** kwargs ), True","title":"get_or_create()"},{"location":"reference/models/#djstripe.models.billing.ShippingRate","text":"Bases: StripeModel Shipping rates describe the price of shipping presented to your customers and can be applied to Checkout Sessions to collect shipping costs. Stripe documentation: https://stripe.com/docs/api/shipping_rates Source code in djstripe/models/billing.py 2263 2264 2265 2266 2267 2268 2269 2270 2271 2272 2273 2274 2275 2276 2277 2278 2279 2280 2281 2282 2283 2284 2285 2286 2287 2288 2289 2290 2291 2292 2293 2294 2295 2296 2297 2298 2299 2300 2301 2302 2303 2304 2305 2306 2307 2308 2309 2310 2311 2312 2313 2314 2315 2316 2317 2318 2319 2320 2321 2322 2323 2324 2325 class ShippingRate ( StripeModel ): \"\"\" Shipping rates describe the price of shipping presented to your customers and can be applied to Checkout Sessions to collect shipping costs. Stripe documentation: https://stripe.com/docs/api/shipping_rates \"\"\" stripe_class = stripe . ShippingRate stripe_dashboard_item_name = \"shipping-rates\" description = None active = models . BooleanField ( default = True , help_text = \"Whether the shipping rate can be used for new purchases. Defaults to true\" , ) display_name = models . CharField ( max_length = 50 , default = \"\" , blank = True , help_text = \"The name of the shipping rate, meant to be displayable to the customer. This will appear on CheckoutSessions.\" , ) fixed_amount = JSONField ( help_text = \"Describes a fixed amount to charge for shipping. Must be present if type is fixed_amount\" , ) type = StripeEnumField ( enum = enums . ShippingRateType , default = enums . ShippingRateType . fixed_amount , help_text = _ ( \"The type of calculation to use on the shipping rate. Can only be fixed_amount for now.\" ), ) delivery_estimate = JSONField ( null = True , blank = True , help_text = \"The estimated range for how long shipping will take, meant to be displayable to the customer. This will appear on CheckoutSessions.\" , ) tax_behavior = StripeEnumField ( enum = enums . ShippingRateTaxBehavior , help_text = _ ( \"Specifies whether the rate is considered inclusive of taxes or exclusive of taxes.\" ), ) tax_code = StripeForeignKey ( \"TaxCode\" , null = True , blank = True , on_delete = models . CASCADE , help_text = \"The shipping tax code\" , ) class Meta ( StripeModel . Meta ): verbose_name = \"Shipping Rate\" def __str__ ( self ): amount = get_friendly_currency_amount ( self . fixed_amount . get ( \"amount\" ) / 100 , self . fixed_amount . get ( \"currency\" ) ) if self . active : return f \" { self . display_name } - { amount } (Active)\" else : return f \" { self . display_name } - { amount } (Archived)\"","title":"ShippingRate"},{"location":"reference/models/#djstripe.models.billing.ShippingRate-attributes","text":"","title":"Attributes"},{"location":"reference/models/#djstripe.models.billing.ShippingRate.active","text":"","title":"active"},{"location":"reference/models/#djstripe.models.billing.ShippingRate.delivery_estimate","text":"","title":"delivery_estimate"},{"location":"reference/models/#djstripe.models.billing.ShippingRate.description","text":"","title":"description"},{"location":"reference/models/#djstripe.models.billing.ShippingRate.display_name","text":"","title":"display_name"},{"location":"reference/models/#djstripe.models.billing.ShippingRate.fixed_amount","text":"","title":"fixed_amount"},{"location":"reference/models/#djstripe.models.billing.ShippingRate.stripe_class","text":"","title":"stripe_class"},{"location":"reference/models/#djstripe.models.billing.ShippingRate.stripe_dashboard_item_name","text":"","title":"stripe_dashboard_item_name"},{"location":"reference/models/#djstripe.models.billing.ShippingRate.tax_behavior","text":"","title":"tax_behavior"},{"location":"reference/models/#djstripe.models.billing.ShippingRate.tax_code","text":"","title":"tax_code"},{"location":"reference/models/#djstripe.models.billing.ShippingRate.type","text":"","title":"type"},{"location":"reference/models/#djstripe.models.billing.ShippingRate-classes","text":"","title":"Classes"},{"location":"reference/models/#djstripe.models.billing.ShippingRate.Meta","text":"Bases: StripeModel . Meta Source code in djstripe/models/billing.py 2315 2316 class Meta ( StripeModel . Meta ): verbose_name = \"Shipping Rate\"","title":"Meta"},{"location":"reference/models/#djstripe.models.billing.ShippingRate.Meta-attributes","text":"djstripe . models . billing . ShippingRate . Meta . verbose_name = 'Shipping Rate' class-attribute","title":"Attributes"},{"location":"reference/models/#djstripe.models.billing.ShippingRate-functions","text":"","title":"Functions"},{"location":"reference/models/#djstripe.models.billing.ShippingRate.__str__","text":"Source code in djstripe/models/billing.py 2318 2319 2320 2321 2322 2323 2324 2325 def __str__ ( self ): amount = get_friendly_currency_amount ( self . fixed_amount . get ( \"amount\" ) / 100 , self . fixed_amount . get ( \"currency\" ) ) if self . active : return f \" { self . display_name } - { amount } (Active)\" else : return f \" { self . display_name } - { amount } (Archived)\"","title":"__str__()"},{"location":"reference/models/#djstripe.models.billing.Subscription","text":"Bases: StripeModel Subscriptions allow you to charge a customer's card on a recurring basis. A subscription ties a customer to a particular plan you've created. A subscription still in its trial period is trialing and moves to active when the trial period is over. When payment to renew the subscription fails, the subscription becomes past_due . After Stripe has exhausted all payment retry attempts, the subscription ends up with a status of either canceled or unpaid depending on your retry settings. Note that when a subscription has a status of unpaid , no subsequent invoices will be attempted (invoices will be created, but then immediately automatically closed. Additionally, updating customer card details will not lead to Stripe retrying the latest invoice.). After receiving updated card details from a customer, you may choose to reopen and pay their closed invoices. Stripe documentation: https://stripe.com/docs/api?lang=python#subscriptions Source code in djstripe/models/billing.py 1573 1574 1575 1576 1577 1578 1579 1580 1581 1582 1583 1584 1585 1586 1587 1588 1589 1590 1591 1592 1593 1594 1595 1596 1597 1598 1599 1600 1601 1602 1603 1604 1605 1606 1607 1608 1609 1610 1611 1612 1613 1614 1615 1616 1617 1618 1619 1620 1621 1622 1623 1624 1625 1626 1627 1628 1629 1630 1631 1632 1633 1634 1635 1636 1637 1638 1639 1640 1641 1642 1643 1644 1645 1646 1647 1648 1649 1650 1651 1652 1653 1654 1655 1656 1657 1658 1659 1660 1661 1662 1663 1664 1665 1666 1667 1668 1669 1670 1671 1672 1673 1674 1675 1676 1677 1678 1679 1680 1681 1682 1683 1684 1685 1686 1687 1688 1689 1690 1691 1692 1693 1694 1695 1696 1697 1698 1699 1700 1701 1702 1703 1704 1705 1706 1707 1708 1709 1710 1711 1712 1713 1714 1715 1716 1717 1718 1719 1720 1721 1722 1723 1724 1725 1726 1727 1728 1729 1730 1731 1732 1733 1734 1735 1736 1737 1738 1739 1740 1741 1742 1743 1744 1745 1746 1747 1748 1749 1750 1751 1752 1753 1754 1755 1756 1757 1758 1759 1760 1761 1762 1763 1764 1765 1766 1767 1768 1769 1770 1771 1772 1773 1774 1775 1776 1777 1778 1779 1780 1781 1782 1783 1784 1785 1786 1787 1788 1789 1790 1791 1792 1793 1794 1795 1796 1797 1798 1799 1800 1801 1802 1803 1804 1805 1806 1807 1808 1809 1810 1811 1812 1813 1814 1815 1816 1817 1818 1819 1820 1821 1822 1823 1824 1825 1826 1827 1828 1829 1830 1831 1832 1833 1834 1835 1836 1837 1838 1839 1840 1841 1842 1843 1844 1845 1846 1847 1848 1849 1850 1851 1852 1853 1854 1855 1856 1857 1858 1859 1860 1861 1862 1863 1864 1865 1866 1867 1868 1869 1870 1871 1872 1873 1874 1875 1876 1877 1878 1879 1880 1881 1882 1883 1884 1885 1886 1887 1888 1889 1890 1891 1892 1893 1894 1895 1896 1897 1898 1899 1900 1901 1902 1903 1904 1905 1906 1907 1908 1909 1910 1911 1912 1913 1914 1915 1916 1917 1918 1919 1920 1921 1922 1923 1924 1925 1926 1927 1928 1929 1930 1931 1932 1933 1934 1935 1936 1937 1938 1939 1940 1941 1942 1943 1944 1945 1946 1947 1948 1949 1950 1951 1952 1953 1954 1955 1956 1957 1958 1959 1960 1961 1962 1963 1964 1965 1966 1967 1968 1969 1970 1971 1972 1973 1974 1975 1976 1977 1978 1979 1980 1981 1982 1983 1984 1985 1986 1987 1988 1989 1990 1991 1992 1993 1994 1995 1996 1997 1998 1999 2000 2001 2002 2003 2004 2005 2006 2007 2008 2009 2010 2011 2012 2013 2014 2015 2016 2017 2018 2019 2020 2021 2022 class Subscription ( StripeModel ): \"\"\" Subscriptions allow you to charge a customer's card on a recurring basis. A subscription ties a customer to a particular plan you've created. A subscription still in its trial period is ``trialing`` and moves to ``active`` when the trial period is over. When payment to renew the subscription fails, the subscription becomes ``past_due``. After Stripe has exhausted all payment retry attempts, the subscription ends up with a status of either ``canceled`` or ``unpaid`` depending on your retry settings. Note that when a subscription has a status of ``unpaid``, no subsequent invoices will be attempted (invoices will be created, but then immediately automatically closed. Additionally, updating customer card details will not lead to Stripe retrying the latest invoice.). After receiving updated card details from a customer, you may choose to reopen and pay their closed invoices. Stripe documentation: https://stripe.com/docs/api?lang=python#subscriptions \"\"\" stripe_class = stripe . Subscription stripe_dashboard_item_name = \"subscriptions\" application_fee_percent = StripePercentField ( null = True , blank = True , help_text = \"A positive decimal that represents the fee percentage of the \" \"subscription invoice amount that will be transferred to the application \" \"owner's Stripe account each billing period.\" , ) billing_cycle_anchor = StripeDateTimeField ( null = True , blank = True , help_text = ( \"Determines the date of the first full invoice, and, for plans \" \"with `month` or `year` intervals, the day of the month for subsequent \" \"invoices.\" ), ) billing_thresholds = JSONField ( null = True , blank = True , help_text = \"Define thresholds at which an invoice will be sent, and the \" \"subscription advanced to a new billing period.\" , ) cancel_at = StripeDateTimeField ( null = True , blank = True , help_text = \"A date in the future at which the subscription will automatically \" \"get canceled.\" , ) cancel_at_period_end = models . BooleanField ( default = False , help_text = \"If the subscription has been canceled with the ``at_period_end`` \" \"flag set to true, ``cancel_at_period_end`` on the subscription will be true. \" \"You can use this attribute to determine whether a subscription that has a \" \"status of active is scheduled to be canceled at the end of the \" \"current period.\" , ) canceled_at = StripeDateTimeField ( null = True , blank = True , help_text = \"If the subscription has been canceled, the date of that \" \"cancellation. If the subscription was canceled with ``cancel_at_period_end``, \" \"canceled_at will still reflect the date of the initial cancellation request, \" \"not the end of the subscription period when the subscription is automatically \" \"moved to a canceled state.\" , ) collection_method = StripeEnumField ( enum = enums . InvoiceCollectionMethod , help_text = \"Either `charge_automatically`, or `send_invoice`. When charging \" \"automatically, Stripe will attempt to pay this subscription at the end of the \" \"cycle using the default source attached to the customer. \" \"When sending an invoice, Stripe will email your customer an invoice with \" \"payment instructions.\" , ) current_period_end = StripeDateTimeField ( help_text = \"End of the current period for which the subscription has been \" \"invoiced. At the end of this period, a new invoice will be created.\" ) current_period_start = StripeDateTimeField ( help_text = \"Start of the current period for which the subscription has \" \"been invoiced.\" ) customer = StripeForeignKey ( \"Customer\" , on_delete = models . CASCADE , related_name = \"subscriptions\" , help_text = \"The customer associated with this subscription.\" , ) days_until_due = models . IntegerField ( null = True , blank = True , help_text = \"Number of days a customer has to pay invoices generated by this \" \"subscription. This value will be `null` for subscriptions where \" \"`billing=charge_automatically`.\" , ) default_payment_method = StripeForeignKey ( \"PaymentMethod\" , null = True , blank = True , on_delete = models . SET_NULL , related_name = \"+\" , help_text = \"The default payment method for the subscription. \" \"It must belong to the customer associated with the subscription. \" \"If not set, invoices will use the default payment method in the \" \"customer's invoice settings.\" , ) default_source = PaymentMethodForeignKey ( on_delete = models . SET_NULL , null = True , blank = True , related_name = \"subscriptions\" , help_text = \"The default payment source for the subscription. \" \"It must belong to the customer associated with the subscription \" \"and be in a chargeable state. If not set, defaults to the customer's \" \"default source.\" , ) default_tax_rates = models . ManyToManyField ( \"TaxRate\" , # explicitly specify the joining table name as though the joining model # was defined with through=\"DjstripeSubscriptionDefaultTaxRate\" db_table = \"djstripe_djstripesubscriptiondefaulttaxrate\" , related_name = \"+\" , blank = True , help_text = \"The tax rates that will apply to any subscription item \" \"that does not have tax_rates set. Invoices created will have their \" \"default_tax_rates populated from the subscription.\" , ) discount = JSONField ( null = True , blank = True , help_text = \"Describes the current discount applied to this subscription, if there is one. When billing, a discount applied to a subscription overrides a discount applied on a customer-wide basis.\" , ) ended_at = StripeDateTimeField ( null = True , blank = True , help_text = \"If the subscription has ended (either because it was canceled or \" \"because the customer was switched to a subscription to a new plan), \" \"the date the subscription ended.\" , ) latest_invoice = StripeForeignKey ( \"Invoice\" , null = True , blank = True , related_name = \"+\" , on_delete = models . SET_NULL , help_text = \"The most recent invoice this subscription has generated.\" , ) next_pending_invoice_item_invoice = StripeDateTimeField ( null = True , blank = True , help_text = \"Specifies the approximate timestamp on which any pending \" \"invoice items will be billed according to the schedule provided at \" \"pending_invoice_item_interval.\" , ) pause_collection = JSONField ( null = True , blank = True , help_text = \"If specified, payment collection for this subscription will be paused.\" , ) pending_invoice_item_interval = JSONField ( null = True , blank = True , help_text = \"Specifies an interval for how often to bill for any \" \"pending invoice items. It is analogous to calling Create an invoice \" \"for the given subscription at the specified interval.\" , ) pending_setup_intent = StripeForeignKey ( \"SetupIntent\" , null = True , blank = True , on_delete = models . CASCADE , related_name = \"setup_intents\" , help_text = \"We can use this SetupIntent to collect user authentication \" \"when creating a subscription without immediate payment or updating a \" \"subscription's payment method, allowing you to \" \"optimize for off-session payments.\" , ) pending_update = JSONField ( null = True , blank = True , help_text = \"If specified, pending updates that will be applied to the \" \"subscription once the latest_invoice has been paid.\" , ) plan = models . ForeignKey ( \"Plan\" , null = True , blank = True , on_delete = models . CASCADE , related_name = \"subscriptions\" , help_text = \"The plan associated with this subscription. This value will be \" \"`null` for multi-plan subscriptions\" , ) proration_behavior = StripeEnumField ( enum = enums . SubscriptionProrationBehavior , help_text = \"Determines how to handle prorations when the billing cycle changes (e.g., when switching plans, resetting billing_cycle_anchor=now, or starting a trial), or if an item\u2019s quantity changes\" , default = enums . SubscriptionProrationBehavior . create_prorations , blank = True , ) proration_date = StripeDateTimeField ( null = True , blank = True , help_text = \"If set, the proration will be calculated as though the subscription was updated at the given time. This can be used to apply exactly the same proration that was previewed with upcoming invoice endpoint. It can also be used to implement custom proration logic, such as prorating by day instead of by second, by providing the time that you wish to use for proration calculations\" , ) quantity = models . IntegerField ( null = True , blank = True , help_text = \"The quantity applied to this subscription. This value will be \" \"`null` for multi-plan subscriptions\" , ) schedule = models . ForeignKey ( \"SubscriptionSchedule\" , null = True , blank = True , on_delete = models . CASCADE , related_name = \"subscriptions\" , help_text = \"The schedule associated with this subscription.\" , ) start_date = StripeDateTimeField ( null = True , blank = True , help_text = \"Date when the subscription was first created. The date \" \"might differ from the created date due to backdating.\" , ) status = StripeEnumField ( enum = enums . SubscriptionStatus , help_text = \"The status of this subscription.\" ) trial_end = StripeDateTimeField ( null = True , blank = True , help_text = \"If the subscription has a trial, the end of that trial.\" , ) trial_start = StripeDateTimeField ( null = True , blank = True , help_text = \"If the subscription has a trial, the beginning of that trial.\" , ) objects = SubscriptionManager () @classmethod def api_list ( cls , api_key = djstripe_settings . STRIPE_SECRET_KEY , ** kwargs ): \"\"\" Call the stripe API's list operation for this model. :param api_key: The api key to use for this request. \\ Defaults to djstripe_settings.STRIPE_SECRET_KEY. :type api_key: string See Stripe documentation for accepted kwargs for each object. :returns: an iterator over all items in the query \"\"\" if not kwargs . get ( \"status\" ): # special case: https://stripe.com/docs/api/subscriptions/list#list_subscriptions-status # See Issue: https://github.com/dj-stripe/dj-stripe/issues/1763 kwargs [ \"status\" ] = \"all\" return super () . api_list ( api_key = api_key , ** kwargs ) def update ( self , plan : Union [ StripeModel , str ] = None , ** kwargs ): \"\"\" See `Customer.subscribe() <#djstripe.models.Customer.subscribe>`__ :param plan: The plan to which to subscribe the customer. :type plan: Plan or string (plan ID) .. important:: Updating a subscription by changing the plan or quantity \\ creates a new ``Subscription`` in \\ Stripe (and dj-stripe). \"\"\" # Convert Plan to id if plan is not None and isinstance ( plan , StripeModel ): plan = plan . id stripe_subscription = self . _api_update ( plan = plan , ** kwargs ) api_key = kwargs . get ( \"api_key\" ) or self . default_api_key return Subscription . sync_from_stripe_data ( stripe_subscription , api_key = api_key ) def extend ( self , delta ): \"\"\" Extends this subscription by the provided delta. :param delta: The timedelta by which to extend this subscription. :type delta: timedelta \"\"\" if delta . total_seconds () < 0 : raise ValueError ( \"delta must be a positive timedelta.\" ) if self . trial_end is not None and self . trial_end > timezone . now (): period_end = self . trial_end else : period_end = self . current_period_end period_end += delta return self . update ( proration_behavior = \"none\" , trial_end = period_end ) def cancel ( self , at_period_end : bool = False , ** kwargs ): \"\"\" Cancels this subscription. If you set the at_period_end parameter to true, the subscription will remain active until the end of the period, at which point it will be canceled and not renewed. By default, the subscription is terminated immediately. In either case, the customer will not be charged again for the subscription. Note, however, that any pending invoice items or metered usage will still be charged at the end of the period unless manually deleted. Depending on how `proration_behavior` is set, any pending prorations will also be left in place and collected at the end of the period. However, if the subscription is set to cancel immediately, you can pass the `prorate` and `invoice_now` flags in `kwargs` to configure how the pending metered usage is invoiced and how proration must work. By default, all unpaid invoices for the customer will be closed upon subscription cancellation. We do this in order to prevent unexpected payment retries once the customer has canceled a subscription. However, you can reopen the invoices manually after subscription cancellation to have us proceed with automatic retries, or you could even re-attempt payment yourself on all unpaid invoices before allowing the customer to cancel the subscription at all. :param at_period_end: A flag that if set to true will delay the cancellation \\ of the subscription until the end of the current period. Default is False. :type at_period_end: boolean .. important:: If a subscription is canceled during a trial period, \\ the ``at_period_end`` flag will be overridden to False so that the trial ends \\ immediately and the customer's card isn't charged. \"\"\" # If plan has trial days and customer cancels before # trial period ends, then end subscription now, # i.e. at_period_end=False if self . trial_end and self . trial_end > timezone . now (): at_period_end = False if at_period_end : stripe_subscription = self . _api_update ( cancel_at_period_end = True ) else : try : stripe_subscription = self . _api_delete ( ** kwargs ) except InvalidRequestError as exc : if \"No such subscription:\" in str ( exc ): # cancel() works by deleting the subscription. The object still # exists in Stripe however, and can still be retrieved. # If the subscription was already canceled (status=canceled), # that api_retrieve() call will fail with \"No such subscription\". # However, this may also happen if the subscription legitimately # does not exist, in which case the following line will re-raise. stripe_subscription = self . api_retrieve () else : raise return Subscription . sync_from_stripe_data ( stripe_subscription , api_key = self . default_api_key ) def reactivate ( self ): \"\"\" Reactivates this subscription. If a customer's subscription is canceled with ``at_period_end`` set to True and it has not yet reached the end of the billing period, it can be reactivated. Subscriptions canceled immediately cannot be reactivated. (Source: https://stripe.com/docs/billing/subscriptions/cancel) .. warning:: Reactivating a fully canceled Subscription will fail silently. \\ Be sure to check the returned Subscription's status. \"\"\" stripe_subscription = self . api_retrieve () stripe_subscription . plan = self . plan . id stripe_subscription . cancel_at_period_end = False return Subscription . sync_from_stripe_data ( stripe_subscription . save ()) def is_period_current ( self ): \"\"\" Returns True if this subscription's period is current, false otherwise. \"\"\" return self . current_period_end > timezone . now () or ( self . trial_end and self . trial_end > timezone . now () ) def is_status_current ( self ): \"\"\" Returns True if this subscription's status is current (active or trialing), false otherwise. \"\"\" return self . status in [ \"trialing\" , \"active\" ] def is_status_temporarily_current ( self ): \"\"\" A status is temporarily current when the subscription is canceled with the ``at_period_end`` flag. The subscription is still active, but is technically canceled and we're just waiting for it to run out. You could use this method to give customers limited service after they've canceled. For example, a video on demand service could only allow customers to download their libraries and do nothing else when their subscription is temporarily current. \"\"\" return ( self . canceled_at and self . cancel_at_period_end and timezone . now () < self . current_period_end ) def is_valid ( self ): \"\"\" Returns True if this subscription's status and period are current, false otherwise. \"\"\" if not self . is_status_current (): return False if not self . is_period_current (): return False return True def _attach_objects_post_save_hook ( self , cls , data , api_key = djstripe_settings . STRIPE_SECRET_KEY , pending_relations = None , ): super () . _attach_objects_post_save_hook ( cls , data , api_key = api_key , pending_relations = pending_relations ) cls . _stripe_object_to_subscription_items ( target_cls = SubscriptionItem , data = data , subscription = self , api_key = api_key ) self . default_tax_rates . set ( cls . _stripe_object_to_default_tax_rates ( target_cls = TaxRate , data = data , api_key = api_key ) )","title":"Subscription"},{"location":"reference/models/#djstripe.models.billing.Subscription-attributes","text":"","title":"Attributes"},{"location":"reference/models/#djstripe.models.billing.Subscription.application_fee_percent","text":"","title":"application_fee_percent"},{"location":"reference/models/#djstripe.models.billing.Subscription.billing_cycle_anchor","text":"","title":"billing_cycle_anchor"},{"location":"reference/models/#djstripe.models.billing.Subscription.billing_thresholds","text":"","title":"billing_thresholds"},{"location":"reference/models/#djstripe.models.billing.Subscription.cancel_at","text":"","title":"cancel_at"},{"location":"reference/models/#djstripe.models.billing.Subscription.cancel_at_period_end","text":"","title":"cancel_at_period_end"},{"location":"reference/models/#djstripe.models.billing.Subscription.canceled_at","text":"","title":"canceled_at"},{"location":"reference/models/#djstripe.models.billing.Subscription.collection_method","text":"","title":"collection_method"},{"location":"reference/models/#djstripe.models.billing.Subscription.current_period_end","text":"","title":"current_period_end"},{"location":"reference/models/#djstripe.models.billing.Subscription.current_period_start","text":"","title":"current_period_start"},{"location":"reference/models/#djstripe.models.billing.Subscription.customer","text":"","title":"customer"},{"location":"reference/models/#djstripe.models.billing.Subscription.days_until_due","text":"","title":"days_until_due"},{"location":"reference/models/#djstripe.models.billing.Subscription.default_payment_method","text":"","title":"default_payment_method"},{"location":"reference/models/#djstripe.models.billing.Subscription.default_source","text":"","title":"default_source"},{"location":"reference/models/#djstripe.models.billing.Subscription.default_tax_rates","text":"","title":"default_tax_rates"},{"location":"reference/models/#djstripe.models.billing.Subscription.discount","text":"","title":"discount"},{"location":"reference/models/#djstripe.models.billing.Subscription.ended_at","text":"","title":"ended_at"},{"location":"reference/models/#djstripe.models.billing.Subscription.latest_invoice","text":"","title":"latest_invoice"},{"location":"reference/models/#djstripe.models.billing.Subscription.next_pending_invoice_item_invoice","text":"","title":"next_pending_invoice_item_invoice"},{"location":"reference/models/#djstripe.models.billing.Subscription.objects","text":"","title":"objects"},{"location":"reference/models/#djstripe.models.billing.Subscription.pause_collection","text":"","title":"pause_collection"},{"location":"reference/models/#djstripe.models.billing.Subscription.pending_invoice_item_interval","text":"","title":"pending_invoice_item_interval"},{"location":"reference/models/#djstripe.models.billing.Subscription.pending_setup_intent","text":"","title":"pending_setup_intent"},{"location":"reference/models/#djstripe.models.billing.Subscription.pending_update","text":"","title":"pending_update"},{"location":"reference/models/#djstripe.models.billing.Subscription.plan","text":"","title":"plan"},{"location":"reference/models/#djstripe.models.billing.Subscription.proration_behavior","text":"","title":"proration_behavior"},{"location":"reference/models/#djstripe.models.billing.Subscription.proration_date","text":"","title":"proration_date"},{"location":"reference/models/#djstripe.models.billing.Subscription.quantity","text":"","title":"quantity"},{"location":"reference/models/#djstripe.models.billing.Subscription.schedule","text":"","title":"schedule"},{"location":"reference/models/#djstripe.models.billing.Subscription.start_date","text":"","title":"start_date"},{"location":"reference/models/#djstripe.models.billing.Subscription.status","text":"","title":"status"},{"location":"reference/models/#djstripe.models.billing.Subscription.stripe_class","text":"","title":"stripe_class"},{"location":"reference/models/#djstripe.models.billing.Subscription.stripe_dashboard_item_name","text":"","title":"stripe_dashboard_item_name"},{"location":"reference/models/#djstripe.models.billing.Subscription.trial_end","text":"","title":"trial_end"},{"location":"reference/models/#djstripe.models.billing.Subscription.trial_start","text":"","title":"trial_start"},{"location":"reference/models/#djstripe.models.billing.Subscription-functions","text":"","title":"Functions"},{"location":"reference/models/#djstripe.models.billing.Subscription._attach_objects_post_save_hook","text":"Source code in djstripe/models/billing.py 2003 2004 2005 2006 2007 2008 2009 2010 2011 2012 2013 2014 2015 2016 2017 2018 2019 2020 2021 2022 def _attach_objects_post_save_hook ( self , cls , data , api_key = djstripe_settings . STRIPE_SECRET_KEY , pending_relations = None , ): super () . _attach_objects_post_save_hook ( cls , data , api_key = api_key , pending_relations = pending_relations ) cls . _stripe_object_to_subscription_items ( target_cls = SubscriptionItem , data = data , subscription = self , api_key = api_key ) self . default_tax_rates . set ( cls . _stripe_object_to_default_tax_rates ( target_cls = TaxRate , data = data , api_key = api_key ) )","title":"_attach_objects_post_save_hook()"},{"location":"reference/models/#djstripe.models.billing.Subscription.api_list","text":"Call the stripe API's list operation for this model. :param api_key: The api key to use for this request. Defaults to djstripe_settings.STRIPE_SECRET_KEY. :type api_key: string See Stripe documentation for accepted kwargs for each object. :returns: an iterator over all items in the query Source code in djstripe/models/billing.py 1818 1819 1820 1821 1822 1823 1824 1825 1826 1827 1828 1829 1830 1831 1832 @classmethod def api_list ( cls , api_key = djstripe_settings . STRIPE_SECRET_KEY , ** kwargs ): \"\"\" Call the stripe API's list operation for this model. :param api_key: The api key to use for this request. \\ Defaults to djstripe_settings.STRIPE_SECRET_KEY. :type api_key: string See Stripe documentation for accepted kwargs for each object. :returns: an iterator over all items in the query \"\"\" if not kwargs . get ( \"status\" ): # special case: https://stripe.com/docs/api/subscriptions/list#list_subscriptions-status # See Issue: https://github.com/dj-stripe/dj-stripe/issues/1763 kwargs [ \"status\" ] = \"all\" return super () . api_list ( api_key = api_key , ** kwargs )","title":"api_list()"},{"location":"reference/models/#djstripe.models.billing.Subscription.cancel","text":"Cancels this subscription. If you set the at_period_end parameter to true, the subscription will remain active until the end of the period, at which point it will be canceled and not renewed. By default, the subscription is terminated immediately. In either case, the customer will not be charged again for the subscription. Note, however, that any pending invoice items or metered usage will still be charged at the end of the period unless manually deleted. Depending on how proration_behavior is set, any pending prorations will also be left in place and collected at the end of the period. However, if the subscription is set to cancel immediately, you can pass the prorate and invoice_now flags in kwargs to configure how the pending metered usage is invoiced and how proration must work. By default, all unpaid invoices for the customer will be closed upon subscription cancellation. We do this in order to prevent unexpected payment retries once the customer has canceled a subscription. However, you can reopen the invoices manually after subscription cancellation to have us proceed with automatic retries, or you could even re-attempt payment yourself on all unpaid invoices before allowing the customer to cancel the subscription at all. :param at_period_end: A flag that if set to true will delay the cancellation of the subscription until the end of the current period. Default is False. :type at_period_end: boolean .. important:: If a subscription is canceled during a trial period, the at_period_end flag will be overridden to False so that the trial ends immediately and the customer's card isn't charged. Source code in djstripe/models/billing.py 1875 1876 1877 1878 1879 1880 1881 1882 1883 1884 1885 1886 1887 1888 1889 1890 1891 1892 1893 1894 1895 1896 1897 1898 1899 1900 1901 1902 1903 1904 1905 1906 1907 1908 1909 1910 1911 1912 1913 1914 1915 1916 1917 1918 1919 1920 1921 1922 1923 1924 1925 1926 1927 1928 1929 1930 1931 1932 1933 def cancel ( self , at_period_end : bool = False , ** kwargs ): \"\"\" Cancels this subscription. If you set the at_period_end parameter to true, the subscription will remain active until the end of the period, at which point it will be canceled and not renewed. By default, the subscription is terminated immediately. In either case, the customer will not be charged again for the subscription. Note, however, that any pending invoice items or metered usage will still be charged at the end of the period unless manually deleted. Depending on how `proration_behavior` is set, any pending prorations will also be left in place and collected at the end of the period. However, if the subscription is set to cancel immediately, you can pass the `prorate` and `invoice_now` flags in `kwargs` to configure how the pending metered usage is invoiced and how proration must work. By default, all unpaid invoices for the customer will be closed upon subscription cancellation. We do this in order to prevent unexpected payment retries once the customer has canceled a subscription. However, you can reopen the invoices manually after subscription cancellation to have us proceed with automatic retries, or you could even re-attempt payment yourself on all unpaid invoices before allowing the customer to cancel the subscription at all. :param at_period_end: A flag that if set to true will delay the cancellation \\ of the subscription until the end of the current period. Default is False. :type at_period_end: boolean .. important:: If a subscription is canceled during a trial period, \\ the ``at_period_end`` flag will be overridden to False so that the trial ends \\ immediately and the customer's card isn't charged. \"\"\" # If plan has trial days and customer cancels before # trial period ends, then end subscription now, # i.e. at_period_end=False if self . trial_end and self . trial_end > timezone . now (): at_period_end = False if at_period_end : stripe_subscription = self . _api_update ( cancel_at_period_end = True ) else : try : stripe_subscription = self . _api_delete ( ** kwargs ) except InvalidRequestError as exc : if \"No such subscription:\" in str ( exc ): # cancel() works by deleting the subscription. The object still # exists in Stripe however, and can still be retrieved. # If the subscription was already canceled (status=canceled), # that api_retrieve() call will fail with \"No such subscription\". # However, this may also happen if the subscription legitimately # does not exist, in which case the following line will re-raise. stripe_subscription = self . api_retrieve () else : raise return Subscription . sync_from_stripe_data ( stripe_subscription , api_key = self . default_api_key )","title":"cancel()"},{"location":"reference/models/#djstripe.models.billing.Subscription.extend","text":"Extends this subscription by the provided delta. :param delta: The timedelta by which to extend this subscription. :type delta: timedelta Source code in djstripe/models/billing.py 1855 1856 1857 1858 1859 1860 1861 1862 1863 1864 1865 1866 1867 1868 1869 1870 1871 1872 1873 def extend ( self , delta ): \"\"\" Extends this subscription by the provided delta. :param delta: The timedelta by which to extend this subscription. :type delta: timedelta \"\"\" if delta . total_seconds () < 0 : raise ValueError ( \"delta must be a positive timedelta.\" ) if self . trial_end is not None and self . trial_end > timezone . now (): period_end = self . trial_end else : period_end = self . current_period_end period_end += delta return self . update ( proration_behavior = \"none\" , trial_end = period_end )","title":"extend()"},{"location":"reference/models/#djstripe.models.billing.Subscription.is_period_current","text":"Returns True if this subscription's period is current, false otherwise. Source code in djstripe/models/billing.py 1953 1954 1955 1956 1957 1958 1959 1960 def is_period_current ( self ): \"\"\" Returns True if this subscription's period is current, false otherwise. \"\"\" return self . current_period_end > timezone . now () or ( self . trial_end and self . trial_end > timezone . now () )","title":"is_period_current()"},{"location":"reference/models/#djstripe.models.billing.Subscription.is_status_current","text":"Returns True if this subscription's status is current (active or trialing), false otherwise. Source code in djstripe/models/billing.py 1962 1963 1964 1965 1966 1967 1968 def is_status_current ( self ): \"\"\" Returns True if this subscription's status is current (active or trialing), false otherwise. \"\"\" return self . status in [ \"trialing\" , \"active\" ]","title":"is_status_current()"},{"location":"reference/models/#djstripe.models.billing.Subscription.is_status_temporarily_current","text":"A status is temporarily current when the subscription is canceled with the at_period_end flag. The subscription is still active, but is technically canceled and we're just waiting for it to run out. You could use this method to give customers limited service after they've canceled. For example, a video on demand service could only allow customers to download their libraries and do nothing else when their subscription is temporarily current. Source code in djstripe/models/billing.py 1970 1971 1972 1973 1974 1975 1976 1977 1978 1979 1980 1981 1982 1983 1984 1985 1986 1987 def is_status_temporarily_current ( self ): \"\"\" A status is temporarily current when the subscription is canceled with the ``at_period_end`` flag. The subscription is still active, but is technically canceled and we're just waiting for it to run out. You could use this method to give customers limited service after they've canceled. For example, a video on demand service could only allow customers to download their libraries and do nothing else when their subscription is temporarily current. \"\"\" return ( self . canceled_at and self . cancel_at_period_end and timezone . now () < self . current_period_end )","title":"is_status_temporarily_current()"},{"location":"reference/models/#djstripe.models.billing.Subscription.is_valid","text":"Returns True if this subscription's status and period are current, false otherwise. Source code in djstripe/models/billing.py 1989 1990 1991 1992 1993 1994 1995 1996 1997 1998 1999 2000 2001 def is_valid ( self ): \"\"\" Returns True if this subscription's status and period are current, false otherwise. \"\"\" if not self . is_status_current (): return False if not self . is_period_current (): return False return True","title":"is_valid()"},{"location":"reference/models/#djstripe.models.billing.Subscription.reactivate","text":"Reactivates this subscription. If a customer's subscription is canceled with at_period_end set to True and it has not yet reached the end of the billing period, it can be reactivated. Subscriptions canceled immediately cannot be reactivated. (Source: https://stripe.com/docs/billing/subscriptions/cancel) .. warning:: Reactivating a fully canceled Subscription will fail silently. Be sure to check the returned Subscription's status. Source code in djstripe/models/billing.py 1935 1936 1937 1938 1939 1940 1941 1942 1943 1944 1945 1946 1947 1948 1949 1950 1951 def reactivate ( self ): \"\"\" Reactivates this subscription. If a customer's subscription is canceled with ``at_period_end`` set to True and it has not yet reached the end of the billing period, it can be reactivated. Subscriptions canceled immediately cannot be reactivated. (Source: https://stripe.com/docs/billing/subscriptions/cancel) .. warning:: Reactivating a fully canceled Subscription will fail silently. \\ Be sure to check the returned Subscription's status. \"\"\" stripe_subscription = self . api_retrieve () stripe_subscription . plan = self . plan . id stripe_subscription . cancel_at_period_end = False return Subscription . sync_from_stripe_data ( stripe_subscription . save ())","title":"reactivate()"},{"location":"reference/models/#djstripe.models.billing.Subscription.update","text":"See Customer.subscribe() <#djstripe.models.Customer.subscribe> __ :param plan: The plan to which to subscribe the customer. :type plan: Plan or string (plan ID) .. important:: Updating a subscription by changing the plan or quantity creates a new Subscription in Stripe (and dj-stripe). Source code in djstripe/models/billing.py 1834 1835 1836 1837 1838 1839 1840 1841 1842 1843 1844 1845 1846 1847 1848 1849 1850 1851 1852 1853 def update ( self , plan : Union [ StripeModel , str ] = None , ** kwargs ): \"\"\" See `Customer.subscribe() <#djstripe.models.Customer.subscribe>`__ :param plan: The plan to which to subscribe the customer. :type plan: Plan or string (plan ID) .. important:: Updating a subscription by changing the plan or quantity \\ creates a new ``Subscription`` in \\ Stripe (and dj-stripe). \"\"\" # Convert Plan to id if plan is not None and isinstance ( plan , StripeModel ): plan = plan . id stripe_subscription = self . _api_update ( plan = plan , ** kwargs ) api_key = kwargs . get ( \"api_key\" ) or self . default_api_key return Subscription . sync_from_stripe_data ( stripe_subscription , api_key = api_key )","title":"update()"},{"location":"reference/models/#djstripe.models.billing.SubscriptionItem","text":"Bases: StripeModel Subscription items allow you to create customer subscriptions with more than one plan, making it easy to represent complex billing relationships. Stripe documentation: https://stripe.com/docs/api?lang=python#subscription_items Source code in djstripe/models/billing.py 2025 2026 2027 2028 2029 2030 2031 2032 2033 2034 2035 2036 2037 2038 2039 2040 2041 2042 2043 2044 2045 2046 2047 2048 2049 2050 2051 2052 2053 2054 2055 2056 2057 2058 2059 2060 2061 2062 2063 2064 2065 2066 2067 2068 2069 2070 2071 2072 2073 2074 2075 2076 2077 2078 2079 2080 2081 2082 2083 2084 2085 2086 2087 2088 2089 2090 2091 2092 2093 2094 2095 2096 2097 2098 2099 2100 2101 2102 2103 2104 2105 2106 class SubscriptionItem ( StripeModel ): \"\"\" Subscription items allow you to create customer subscriptions with more than one plan, making it easy to represent complex billing relationships. Stripe documentation: https://stripe.com/docs/api?lang=python#subscription_items \"\"\" stripe_class = stripe . SubscriptionItem billing_thresholds = JSONField ( null = True , blank = True , help_text = \"Define thresholds at which an invoice will be sent, and the \" \"related subscription advanced to a new billing period.\" , ) plan = models . ForeignKey ( \"Plan\" , on_delete = models . CASCADE , related_name = \"subscription_items\" , help_text = \"The plan the customer is subscribed to.\" , ) price = models . ForeignKey ( \"Price\" , null = True , blank = True , on_delete = models . CASCADE , related_name = \"subscription_items\" , help_text = \"The price the customer is subscribed to.\" , ) proration_behavior = StripeEnumField ( enum = enums . SubscriptionProrationBehavior , help_text = \"Determines how to handle prorations when the billing cycle changes (e.g., when switching plans, resetting billing_cycle_anchor=now, or starting a trial), or if an item\u2019s quantity changes\" , default = enums . SubscriptionProrationBehavior . create_prorations , blank = True , ) proration_date = StripeDateTimeField ( null = True , blank = True , help_text = \"If set, the proration will be calculated as though the subscription was updated at the given time. This can be used to apply exactly the same proration that was previewed with upcoming invoice endpoint. It can also be used to implement custom proration logic, such as prorating by day instead of by second, by providing the time that you wish to use for proration calculations\" , ) quantity = models . PositiveIntegerField ( null = True , blank = True , help_text = ( \"The quantity of the plan to which the customer should be subscribed.\" ), ) subscription = StripeForeignKey ( \"Subscription\" , on_delete = models . CASCADE , related_name = \"items\" , help_text = \"The subscription this subscription item belongs to.\" , ) tax_rates = models . ManyToManyField ( \"TaxRate\" , # explicitly specify the joining table name as though the joining model # was defined with through=\"DjstripeSubscriptionItemTaxRate\" db_table = \"djstripe_djstripesubscriptionitemtaxrate\" , related_name = \"+\" , blank = True , help_text = \"The tax rates which apply to this subscription_item. When set, \" \"the default_tax_rates on the subscription do not apply to this \" \"subscription_item.\" , ) def _attach_objects_post_save_hook ( self , cls , data , api_key = djstripe_settings . STRIPE_SECRET_KEY , pending_relations = None , ): super () . _attach_objects_post_save_hook ( cls , data , api_key = api_key , pending_relations = pending_relations ) self . tax_rates . set ( cls . _stripe_object_to_tax_rates ( target_cls = TaxRate , data = data , api_key = api_key ) )","title":"SubscriptionItem"},{"location":"reference/models/#djstripe.models.billing.SubscriptionItem-attributes","text":"","title":"Attributes"},{"location":"reference/models/#djstripe.models.billing.SubscriptionItem.billing_thresholds","text":"","title":"billing_thresholds"},{"location":"reference/models/#djstripe.models.billing.SubscriptionItem.plan","text":"","title":"plan"},{"location":"reference/models/#djstripe.models.billing.SubscriptionItem.price","text":"","title":"price"},{"location":"reference/models/#djstripe.models.billing.SubscriptionItem.proration_behavior","text":"","title":"proration_behavior"},{"location":"reference/models/#djstripe.models.billing.SubscriptionItem.proration_date","text":"","title":"proration_date"},{"location":"reference/models/#djstripe.models.billing.SubscriptionItem.quantity","text":"","title":"quantity"},{"location":"reference/models/#djstripe.models.billing.SubscriptionItem.stripe_class","text":"","title":"stripe_class"},{"location":"reference/models/#djstripe.models.billing.SubscriptionItem.subscription","text":"","title":"subscription"},{"location":"reference/models/#djstripe.models.billing.SubscriptionItem.tax_rates","text":"","title":"tax_rates"},{"location":"reference/models/#djstripe.models.billing.SubscriptionItem-functions","text":"","title":"Functions"},{"location":"reference/models/#djstripe.models.billing.SubscriptionItem._attach_objects_post_save_hook","text":"Source code in djstripe/models/billing.py 2091 2092 2093 2094 2095 2096 2097 2098 2099 2100 2101 2102 2103 2104 2105 2106 def _attach_objects_post_save_hook ( self , cls , data , api_key = djstripe_settings . STRIPE_SECRET_KEY , pending_relations = None , ): super () . _attach_objects_post_save_hook ( cls , data , api_key = api_key , pending_relations = pending_relations ) self . tax_rates . set ( cls . _stripe_object_to_tax_rates ( target_cls = TaxRate , data = data , api_key = api_key ) )","title":"_attach_objects_post_save_hook()"},{"location":"reference/models/#djstripe.models.billing.SubscriptionSchedule","text":"Bases: StripeModel Subscription schedules allow you to create and manage the lifecycle of a subscription by predefining expected changes. Stripe documentation: https://stripe.com/docs/api/subscription_schedules?lang=python Source code in djstripe/models/billing.py 2109 2110 2111 2112 2113 2114 2115 2116 2117 2118 2119 2120 2121 2122 2123 2124 2125 2126 2127 2128 2129 2130 2131 2132 2133 2134 2135 2136 2137 2138 2139 2140 2141 2142 2143 2144 2145 2146 2147 2148 2149 2150 2151 2152 2153 2154 2155 2156 2157 2158 2159 2160 2161 2162 2163 2164 2165 2166 2167 2168 2169 2170 2171 2172 2173 2174 2175 2176 2177 2178 2179 2180 2181 2182 2183 2184 2185 2186 2187 2188 2189 2190 2191 2192 2193 2194 2195 2196 2197 2198 2199 2200 2201 2202 2203 2204 2205 2206 2207 2208 2209 2210 2211 2212 2213 2214 2215 2216 2217 2218 2219 2220 2221 2222 2223 2224 2225 2226 2227 2228 2229 2230 2231 2232 2233 2234 2235 2236 2237 2238 2239 2240 2241 2242 2243 2244 2245 2246 2247 2248 2249 2250 2251 2252 2253 2254 2255 2256 2257 2258 2259 2260 class SubscriptionSchedule ( StripeModel ): \"\"\" Subscription schedules allow you to create and manage the lifecycle of a subscription by predefining expected changes. Stripe documentation: https://stripe.com/docs/api/subscription_schedules?lang=python \"\"\" stripe_class = stripe . SubscriptionSchedule stripe_dashboard_item_name = \"subscription_schedules\" canceled_at = StripeDateTimeField ( null = True , blank = True , help_text = \"Time at which the subscription schedule was canceled.\" , ) completed_at = StripeDateTimeField ( null = True , blank = True , help_text = \"Time at which the subscription schedule was completed.\" , ) current_phase = JSONField ( null = True , blank = True , help_text = \"Object representing the start and end dates for the \" \"current phase of the subscription schedule, if it is `active`.\" , ) customer = models . ForeignKey ( \"Customer\" , on_delete = models . CASCADE , related_name = \"schedules\" , help_text = \"The customer who owns the subscription schedule.\" , ) default_settings = JSONField ( null = True , blank = True , help_text = \"Object representing the subscription schedule's default settings.\" , ) end_behavior = StripeEnumField ( enum = enums . SubscriptionScheduleEndBehavior , help_text = \"Behavior of the subscription schedule and underlying \" \"subscription when it ends.\" , ) phases = JSONField ( null = True , blank = True , help_text = \"Configuration for the subscription schedule's phases.\" , ) released_at = StripeDateTimeField ( null = True , blank = True , help_text = \"Time at which the subscription schedule was released.\" , ) released_subscription = models . ForeignKey ( \"Subscription\" , null = True , blank = True , on_delete = models . SET_NULL , related_name = \"released_schedules\" , help_text = \"The subscription once managed by this subscription schedule \" \"(if it is released).\" , ) status = StripeEnumField ( enum = enums . SubscriptionScheduleStatus , help_text = \"The present status of the subscription schedule. Possible \" \"values are `not_started`, `active`, `completed`, `released`, and \" \"`canceled`.\" , ) subscription = models . ForeignKey ( \"Subscription\" , null = True , blank = True , on_delete = models . SET_NULL , related_name = \"subscriptions\" , help_text = \"ID of the subscription managed by the subscription schedule.\" , ) def release ( self , api_key = None , stripe_account = None , ** kwargs ): \"\"\" Releases the subscription schedule immediately, which will stop scheduling of its phases, but leave any existing subscription in place. A schedule can only be released if its status is not_started or active. If the subscription schedule is currently associated with a subscription, releasing it will remove its subscription property and set the subscription\u2019s ID to the released_subscription property and returns the Released SubscriptionSchedule. :param api_key: The api key to use for this request. Defaults to djstripe_settings.STRIPE_SECRET_KEY. :type api_key: string :param stripe_account: The optional connected account \\ for which this request is being made. :type stripe_account: string \"\"\" api_key = api_key or self . default_api_key # Prefer passed in stripe_account if set. if not stripe_account : stripe_account = self . _get_stripe_account_id ( api_key ) stripe_subscription_schedule = self . stripe_class . release ( self . id , api_key = api_key , stripe_account = stripe_account , stripe_version = djstripe_settings . STRIPE_API_VERSION , ** kwargs , ) return SubscriptionSchedule . sync_from_stripe_data ( stripe_subscription_schedule ) def cancel ( self , api_key = None , stripe_account = None , ** kwargs ): \"\"\" Cancels a subscription schedule and its associated subscription immediately (if the subscription schedule has an active subscription). A subscription schedule can only be canceled if its status is not_started or active and returns the Canceled SubscriptionSchedule. :param api_key: The api key to use for this request. Defaults to djstripe_settings.STRIPE_SECRET_KEY. :type api_key: string :param stripe_account: The optional connected account \\ for which this request is being made. :type stripe_account: string \"\"\" api_key = api_key or self . default_api_key # Prefer passed in stripe_account if set. if not stripe_account : stripe_account = self . _get_stripe_account_id ( api_key ) stripe_subscription_schedule = self . stripe_class . cancel ( self . id , api_key = api_key , stripe_account = stripe_account , stripe_version = djstripe_settings . STRIPE_API_VERSION , ** kwargs , ) return SubscriptionSchedule . sync_from_stripe_data ( stripe_subscription_schedule ) def update ( self , api_key = None , stripe_account = None , ** kwargs ): \"\"\" Updates an existing subscription schedule and returns the updated SubscriptionSchedule. :param api_key: The api key to use for this request. Defaults to djstripe_settings.STRIPE_SECRET_KEY. :type api_key: string :param stripe_account: The optional connected account \\ for which this request is being made. :type stripe_account: string \"\"\" stripe_subscription_schedule = self . _api_update ( api_key = api_key , stripe_account = stripe_account , ** kwargs ) return SubscriptionSchedule . sync_from_stripe_data ( stripe_subscription_schedule )","title":"SubscriptionSchedule"},{"location":"reference/models/#djstripe.models.billing.SubscriptionSchedule-attributes","text":"","title":"Attributes"},{"location":"reference/models/#djstripe.models.billing.SubscriptionSchedule.canceled_at","text":"","title":"canceled_at"},{"location":"reference/models/#djstripe.models.billing.SubscriptionSchedule.completed_at","text":"","title":"completed_at"},{"location":"reference/models/#djstripe.models.billing.SubscriptionSchedule.current_phase","text":"","title":"current_phase"},{"location":"reference/models/#djstripe.models.billing.SubscriptionSchedule.customer","text":"","title":"customer"},{"location":"reference/models/#djstripe.models.billing.SubscriptionSchedule.default_settings","text":"","title":"default_settings"},{"location":"reference/models/#djstripe.models.billing.SubscriptionSchedule.end_behavior","text":"","title":"end_behavior"},{"location":"reference/models/#djstripe.models.billing.SubscriptionSchedule.phases","text":"","title":"phases"},{"location":"reference/models/#djstripe.models.billing.SubscriptionSchedule.released_at","text":"","title":"released_at"},{"location":"reference/models/#djstripe.models.billing.SubscriptionSchedule.released_subscription","text":"","title":"released_subscription"},{"location":"reference/models/#djstripe.models.billing.SubscriptionSchedule.status","text":"","title":"status"},{"location":"reference/models/#djstripe.models.billing.SubscriptionSchedule.stripe_class","text":"","title":"stripe_class"},{"location":"reference/models/#djstripe.models.billing.SubscriptionSchedule.stripe_dashboard_item_name","text":"","title":"stripe_dashboard_item_name"},{"location":"reference/models/#djstripe.models.billing.SubscriptionSchedule.subscription","text":"","title":"subscription"},{"location":"reference/models/#djstripe.models.billing.SubscriptionSchedule-functions","text":"","title":"Functions"},{"location":"reference/models/#djstripe.models.billing.SubscriptionSchedule.cancel","text":"Cancels a subscription schedule and its associated subscription immediately (if the subscription schedule has an active subscription). A subscription schedule can only be canceled if its status is not_started or active and returns the Canceled SubscriptionSchedule. :param api_key: The api key to use for this request. Defaults to djstripe_settings.STRIPE_SECRET_KEY. :type api_key: string :param stripe_account: The optional connected account for which this request is being made. :type stripe_account: string Source code in djstripe/models/billing.py 2218 2219 2220 2221 2222 2223 2224 2225 2226 2227 2228 2229 2230 2231 2232 2233 2234 2235 2236 2237 2238 2239 2240 2241 2242 2243 2244 def cancel ( self , api_key = None , stripe_account = None , ** kwargs ): \"\"\" Cancels a subscription schedule and its associated subscription immediately (if the subscription schedule has an active subscription). A subscription schedule can only be canceled if its status is not_started or active and returns the Canceled SubscriptionSchedule. :param api_key: The api key to use for this request. Defaults to djstripe_settings.STRIPE_SECRET_KEY. :type api_key: string :param stripe_account: The optional connected account \\ for which this request is being made. :type stripe_account: string \"\"\" api_key = api_key or self . default_api_key # Prefer passed in stripe_account if set. if not stripe_account : stripe_account = self . _get_stripe_account_id ( api_key ) stripe_subscription_schedule = self . stripe_class . cancel ( self . id , api_key = api_key , stripe_account = stripe_account , stripe_version = djstripe_settings . STRIPE_API_VERSION , ** kwargs , ) return SubscriptionSchedule . sync_from_stripe_data ( stripe_subscription_schedule )","title":"cancel()"},{"location":"reference/models/#djstripe.models.billing.SubscriptionSchedule.release","text":"Releases the subscription schedule immediately, which will stop scheduling of its phases, but leave any existing subscription in place. A schedule can only be released if its status is not_started or active. If the subscription schedule is currently associated with a subscription, releasing it will remove its subscription property and set the subscription\u2019s ID to the released_subscription property and returns the Released SubscriptionSchedule. :param api_key: The api key to use for this request. Defaults to djstripe_settings.STRIPE_SECRET_KEY. :type api_key: string :param stripe_account: The optional connected account for which this request is being made. :type stripe_account: string Source code in djstripe/models/billing.py 2186 2187 2188 2189 2190 2191 2192 2193 2194 2195 2196 2197 2198 2199 2200 2201 2202 2203 2204 2205 2206 2207 2208 2209 2210 2211 2212 2213 2214 2215 2216 def release ( self , api_key = None , stripe_account = None , ** kwargs ): \"\"\" Releases the subscription schedule immediately, which will stop scheduling of its phases, but leave any existing subscription in place. A schedule can only be released if its status is not_started or active. If the subscription schedule is currently associated with a subscription, releasing it will remove its subscription property and set the subscription\u2019s ID to the released_subscription property and returns the Released SubscriptionSchedule. :param api_key: The api key to use for this request. Defaults to djstripe_settings.STRIPE_SECRET_KEY. :type api_key: string :param stripe_account: The optional connected account \\ for which this request is being made. :type stripe_account: string \"\"\" api_key = api_key or self . default_api_key # Prefer passed in stripe_account if set. if not stripe_account : stripe_account = self . _get_stripe_account_id ( api_key ) stripe_subscription_schedule = self . stripe_class . release ( self . id , api_key = api_key , stripe_account = stripe_account , stripe_version = djstripe_settings . STRIPE_API_VERSION , ** kwargs , ) return SubscriptionSchedule . sync_from_stripe_data ( stripe_subscription_schedule )","title":"release()"},{"location":"reference/models/#djstripe.models.billing.SubscriptionSchedule.update","text":"Updates an existing subscription schedule and returns the updated SubscriptionSchedule. :param api_key: The api key to use for this request. Defaults to djstripe_settings.STRIPE_SECRET_KEY. :type api_key: string :param stripe_account: The optional connected account for which this request is being made. :type stripe_account: string Source code in djstripe/models/billing.py 2246 2247 2248 2249 2250 2251 2252 2253 2254 2255 2256 2257 2258 2259 2260 def update ( self , api_key = None , stripe_account = None , ** kwargs ): \"\"\" Updates an existing subscription schedule and returns the updated SubscriptionSchedule. :param api_key: The api key to use for this request. Defaults to djstripe_settings.STRIPE_SECRET_KEY. :type api_key: string :param stripe_account: The optional connected account \\ for which this request is being made. :type stripe_account: string \"\"\" stripe_subscription_schedule = self . _api_update ( api_key = api_key , stripe_account = stripe_account , ** kwargs ) return SubscriptionSchedule . sync_from_stripe_data ( stripe_subscription_schedule )","title":"update()"},{"location":"reference/models/#djstripe.models.billing.TaxCode","text":"Bases: StripeModel Tax codes classify goods and services for tax purposes. Stripe documentation: https://stripe.com/docs/api/tax_codes Source code in djstripe/models/billing.py 2328 2329 2330 2331 2332 2333 2334 2335 2336 2337 2338 2339 2340 2341 2342 2343 2344 2345 2346 2347 2348 2349 2350 2351 2352 class TaxCode ( StripeModel ): \"\"\" Tax codes classify goods and services for tax purposes. Stripe documentation: https://stripe.com/docs/api/tax_codes \"\"\" stripe_class = stripe . TaxCode metadata = None name = models . CharField ( max_length = 128 , help_text = \"A short name for the tax code.\" , ) class Meta ( StripeModel . Meta ): verbose_name = \"Tax Code\" def __str__ ( self ): return f \" { self . name } : { self . id } \" @classmethod def _find_owner_account ( cls , data , api_key = djstripe_settings . STRIPE_SECRET_KEY ): # Tax Codes do not belong to any Stripe Account pass","title":"TaxCode"},{"location":"reference/models/#djstripe.models.billing.TaxCode-attributes","text":"","title":"Attributes"},{"location":"reference/models/#djstripe.models.billing.TaxCode.metadata","text":"","title":"metadata"},{"location":"reference/models/#djstripe.models.billing.TaxCode.name","text":"","title":"name"},{"location":"reference/models/#djstripe.models.billing.TaxCode.stripe_class","text":"","title":"stripe_class"},{"location":"reference/models/#djstripe.models.billing.TaxCode-classes","text":"","title":"Classes"},{"location":"reference/models/#djstripe.models.billing.TaxCode.Meta","text":"Bases: StripeModel . Meta Source code in djstripe/models/billing.py 2343 2344 class Meta ( StripeModel . Meta ): verbose_name = \"Tax Code\"","title":"Meta"},{"location":"reference/models/#djstripe.models.billing.TaxCode.Meta-attributes","text":"djstripe . models . billing . TaxCode . Meta . verbose_name = 'Tax Code' class-attribute","title":"Attributes"},{"location":"reference/models/#djstripe.models.billing.TaxCode-functions","text":"","title":"Functions"},{"location":"reference/models/#djstripe.models.billing.TaxCode.__str__","text":"Source code in djstripe/models/billing.py 2346 2347 def __str__ ( self ): return f \" { self . name } : { self . id } \"","title":"__str__()"},{"location":"reference/models/#djstripe.models.billing.TaxCode._find_owner_account","text":"Source code in djstripe/models/billing.py 2349 2350 2351 2352 @classmethod def _find_owner_account ( cls , data , api_key = djstripe_settings . STRIPE_SECRET_KEY ): # Tax Codes do not belong to any Stripe Account pass","title":"_find_owner_account()"},{"location":"reference/models/#djstripe.models.billing.TaxId","text":"Bases: StripeModel Add one or multiple tax IDs to a customer. A customer's tax IDs are displayed on invoices and credit notes issued for the customer. Stripe documentation: https://stripe.com/docs/api/customer_tax_ids?lang=python Source code in djstripe/models/billing.py 2355 2356 2357 2358 2359 2360 2361 2362 2363 2364 2365 2366 2367 2368 2369 2370 2371 2372 2373 2374 2375 2376 2377 2378 2379 2380 2381 2382 2383 2384 2385 2386 2387 2388 2389 2390 2391 2392 2393 2394 2395 2396 2397 2398 2399 2400 2401 2402 2403 2404 2405 2406 2407 2408 2409 2410 2411 2412 2413 2414 2415 2416 2417 2418 2419 2420 2421 2422 2423 2424 2425 2426 2427 2428 2429 2430 2431 2432 2433 2434 2435 2436 2437 2438 2439 2440 2441 2442 2443 2444 2445 2446 2447 class TaxId ( StripeModel ): \"\"\" Add one or multiple tax IDs to a customer. A customer's tax IDs are displayed on invoices and credit notes issued for the customer. Stripe documentation: https://stripe.com/docs/api/customer_tax_ids?lang=python \"\"\" stripe_class = stripe . TaxId description = None metadata = None country = models . CharField ( max_length = 2 , help_text = \"Two-letter ISO code representing the country of the tax ID.\" , ) customer = StripeForeignKey ( \"djstripe.customer\" , on_delete = models . CASCADE , related_name = \"tax_ids\" ) type = StripeEnumField ( enum = enums . TaxIdType , help_text = \"The status of this subscription.\" ) value = models . CharField ( max_length = 50 , help_text = \"Value of the tax ID.\" ) verification = JSONField ( help_text = \"Tax ID verification information.\" ) def __str__ ( self ): return f \" { enums . TaxIdType . humanize ( self . type ) } { self . value } ( { self . verification . get ( 'status' ) } )\" class Meta ( StripeModel . Meta ): verbose_name = \"Tax ID\" @classmethod def _api_create ( cls , api_key = djstripe_settings . STRIPE_SECRET_KEY , ** kwargs ): \"\"\" Call the stripe API's create operation for this model. :param api_key: The api key to use for this request. \\ Defaults to djstripe_settings.STRIPE_SECRET_KEY. :type api_key: string \"\"\" if not kwargs . get ( \"id\" ): raise KeyError ( \"Customer Object ID is missing\" ) try : Customer . objects . get ( id = kwargs [ \"id\" ]) except Customer . DoesNotExist : raise return stripe . Customer . create_tax_id ( api_key = api_key , ** kwargs ) def api_retrieve ( self , api_key = None , stripe_account = None ): \"\"\" Call the stripe API's retrieve operation for this model. :param api_key: The api key to use for this request. \\ Defaults to djstripe_settings.STRIPE_SECRET_KEY. :type api_key: string :param stripe_account: The optional connected account \\ for which this request is being made. :type stripe_account: string \"\"\" nested_id = self . id id = self . customer . id # Prefer passed in stripe_account if set. if not stripe_account : stripe_account = self . _get_stripe_account_id ( api_key ) return stripe . Customer . retrieve_tax_id ( id = id , nested_id = nested_id , api_key = api_key or self . default_api_key , expand = self . expand_fields , stripe_account = stripe_account , stripe_version = djstripe_settings . STRIPE_API_VERSION , ) @classmethod def api_list ( cls , api_key = djstripe_settings . STRIPE_SECRET_KEY , ** kwargs ): \"\"\" Call the stripe API's list operation for this model. :param api_key: The api key to use for this request. \\ Defaults to djstripe_settings.STRIPE_SECRET_KEY. :type api_key: string See Stripe documentation for accepted kwargs for each object. :returns: an iterator over all items in the query \"\"\" return stripe . Customer . list_tax_ids ( api_key = api_key , stripe_version = djstripe_settings . STRIPE_API_VERSION , ** kwargs , ) . auto_paging_iter ()","title":"TaxId"},{"location":"reference/models/#djstripe.models.billing.TaxId-attributes","text":"","title":"Attributes"},{"location":"reference/models/#djstripe.models.billing.TaxId.country","text":"","title":"country"},{"location":"reference/models/#djstripe.models.billing.TaxId.customer","text":"","title":"customer"},{"location":"reference/models/#djstripe.models.billing.TaxId.description","text":"","title":"description"},{"location":"reference/models/#djstripe.models.billing.TaxId.metadata","text":"","title":"metadata"},{"location":"reference/models/#djstripe.models.billing.TaxId.stripe_class","text":"","title":"stripe_class"},{"location":"reference/models/#djstripe.models.billing.TaxId.type","text":"","title":"type"},{"location":"reference/models/#djstripe.models.billing.TaxId.value","text":"","title":"value"},{"location":"reference/models/#djstripe.models.billing.TaxId.verification","text":"","title":"verification"},{"location":"reference/models/#djstripe.models.billing.TaxId-classes","text":"","title":"Classes"},{"location":"reference/models/#djstripe.models.billing.TaxId.Meta","text":"Bases: StripeModel . Meta Source code in djstripe/models/billing.py 2384 2385 class Meta ( StripeModel . Meta ): verbose_name = \"Tax ID\"","title":"Meta"},{"location":"reference/models/#djstripe.models.billing.TaxId.Meta-attributes","text":"djstripe . models . billing . TaxId . Meta . verbose_name = 'Tax ID' class-attribute","title":"Attributes"},{"location":"reference/models/#djstripe.models.billing.TaxId-functions","text":"","title":"Functions"},{"location":"reference/models/#djstripe.models.billing.TaxId.__str__","text":"Source code in djstripe/models/billing.py 2381 2382 def __str__ ( self ): return f \" { enums . TaxIdType . humanize ( self . type ) } { self . value } ( { self . verification . get ( 'status' ) } )\"","title":"__str__()"},{"location":"reference/models/#djstripe.models.billing.TaxId._api_create","text":"Call the stripe API's create operation for this model. :param api_key: The api key to use for this request. Defaults to djstripe_settings.STRIPE_SECRET_KEY. :type api_key: string Source code in djstripe/models/billing.py 2387 2388 2389 2390 2391 2392 2393 2394 2395 2396 2397 2398 2399 2400 2401 2402 2403 2404 2405 @classmethod def _api_create ( cls , api_key = djstripe_settings . STRIPE_SECRET_KEY , ** kwargs ): \"\"\" Call the stripe API's create operation for this model. :param api_key: The api key to use for this request. \\ Defaults to djstripe_settings.STRIPE_SECRET_KEY. :type api_key: string \"\"\" if not kwargs . get ( \"id\" ): raise KeyError ( \"Customer Object ID is missing\" ) try : Customer . objects . get ( id = kwargs [ \"id\" ]) except Customer . DoesNotExist : raise return stripe . Customer . create_tax_id ( api_key = api_key , ** kwargs )","title":"_api_create()"},{"location":"reference/models/#djstripe.models.billing.TaxId.api_list","text":"Call the stripe API's list operation for this model. :param api_key: The api key to use for this request. Defaults to djstripe_settings.STRIPE_SECRET_KEY. :type api_key: string See Stripe documentation for accepted kwargs for each object. :returns: an iterator over all items in the query Source code in djstripe/models/billing.py 2433 2434 2435 2436 2437 2438 2439 2440 2441 2442 2443 2444 2445 2446 2447 @classmethod def api_list ( cls , api_key = djstripe_settings . STRIPE_SECRET_KEY , ** kwargs ): \"\"\" Call the stripe API's list operation for this model. :param api_key: The api key to use for this request. \\ Defaults to djstripe_settings.STRIPE_SECRET_KEY. :type api_key: string See Stripe documentation for accepted kwargs for each object. :returns: an iterator over all items in the query \"\"\" return stripe . Customer . list_tax_ids ( api_key = api_key , stripe_version = djstripe_settings . STRIPE_API_VERSION , ** kwargs , ) . auto_paging_iter ()","title":"api_list()"},{"location":"reference/models/#djstripe.models.billing.TaxId.api_retrieve","text":"Call the stripe API's retrieve operation for this model. :param api_key: The api key to use for this request. Defaults to djstripe_settings.STRIPE_SECRET_KEY. :type api_key: string :param stripe_account: The optional connected account for which this request is being made. :type stripe_account: string Source code in djstripe/models/billing.py 2407 2408 2409 2410 2411 2412 2413 2414 2415 2416 2417 2418 2419 2420 2421 2422 2423 2424 2425 2426 2427 2428 2429 2430 2431 def api_retrieve ( self , api_key = None , stripe_account = None ): \"\"\" Call the stripe API's retrieve operation for this model. :param api_key: The api key to use for this request. \\ Defaults to djstripe_settings.STRIPE_SECRET_KEY. :type api_key: string :param stripe_account: The optional connected account \\ for which this request is being made. :type stripe_account: string \"\"\" nested_id = self . id id = self . customer . id # Prefer passed in stripe_account if set. if not stripe_account : stripe_account = self . _get_stripe_account_id ( api_key ) return stripe . Customer . retrieve_tax_id ( id = id , nested_id = nested_id , api_key = api_key or self . default_api_key , expand = self . expand_fields , stripe_account = stripe_account , stripe_version = djstripe_settings . STRIPE_API_VERSION , )","title":"api_retrieve()"},{"location":"reference/models/#djstripe.models.billing.TaxRate","text":"Bases: StripeModel Tax rates can be applied to invoices and subscriptions to collect tax. Stripe documentation: https://stripe.com/docs/api/tax_rates?lang=python Source code in djstripe/models/billing.py 2450 2451 2452 2453 2454 2455 2456 2457 2458 2459 2460 2461 2462 2463 2464 2465 2466 2467 2468 2469 2470 2471 2472 2473 2474 2475 2476 2477 2478 2479 2480 2481 2482 2483 2484 2485 2486 2487 2488 2489 2490 2491 2492 2493 2494 2495 2496 2497 2498 2499 2500 2501 2502 2503 2504 2505 2506 2507 2508 2509 2510 class TaxRate ( StripeModel ): \"\"\" Tax rates can be applied to invoices and subscriptions to collect tax. Stripe documentation: https://stripe.com/docs/api/tax_rates?lang=python \"\"\" stripe_class = stripe . TaxRate stripe_dashboard_item_name = \"tax-rates\" active = models . BooleanField ( default = True , help_text = \"Defaults to true. When set to false, this tax rate cannot be \" \"applied to objects in the API, but will still be applied to subscriptions \" \"and invoices that already have it set.\" , ) country = models . CharField ( max_length = 2 , default = \"\" , blank = True , help_text = \"Two-letter country code.\" , ) display_name = models . CharField ( max_length = 50 , default = \"\" , blank = True , help_text = \"The display name of the tax rates as it will appear to your \" \"customer on their receipt email, PDF, and the hosted invoice page.\" , ) inclusive = models . BooleanField ( help_text = \"This specifies if the tax rate is inclusive or exclusive.\" ) jurisdiction = models . CharField ( max_length = 50 , default = \"\" , blank = True , help_text = \"The jurisdiction for the tax rate.\" , ) percentage = StripePercentField ( decimal_places = 4 , max_digits = 7 , help_text = \"This represents the tax rate percent out of 100.\" , ) state = models . CharField ( max_length = 2 , default = \"\" , blank = True , help_text = \"ISO 3166-2 subdivision code, without country prefix.\" , ) tax_type = models . CharField ( default = \"\" , blank = True , max_length = 50 , help_text = \"The high-level tax type, such as vat, gst, sales_tax or custom.\" , ) def __str__ ( self ): return f \" { self . display_name } at { self . percentage } %\" class Meta ( StripeModel . Meta ): verbose_name = \"Tax Rate\"","title":"TaxRate"},{"location":"reference/models/#djstripe.models.billing.TaxRate-attributes","text":"","title":"Attributes"},{"location":"reference/models/#djstripe.models.billing.TaxRate.active","text":"","title":"active"},{"location":"reference/models/#djstripe.models.billing.TaxRate.country","text":"","title":"country"},{"location":"reference/models/#djstripe.models.billing.TaxRate.display_name","text":"","title":"display_name"},{"location":"reference/models/#djstripe.models.billing.TaxRate.inclusive","text":"","title":"inclusive"},{"location":"reference/models/#djstripe.models.billing.TaxRate.jurisdiction","text":"","title":"jurisdiction"},{"location":"reference/models/#djstripe.models.billing.TaxRate.percentage","text":"","title":"percentage"},{"location":"reference/models/#djstripe.models.billing.TaxRate.state","text":"","title":"state"},{"location":"reference/models/#djstripe.models.billing.TaxRate.stripe_class","text":"","title":"stripe_class"},{"location":"reference/models/#djstripe.models.billing.TaxRate.stripe_dashboard_item_name","text":"","title":"stripe_dashboard_item_name"},{"location":"reference/models/#djstripe.models.billing.TaxRate.tax_type","text":"","title":"tax_type"},{"location":"reference/models/#djstripe.models.billing.TaxRate-classes","text":"","title":"Classes"},{"location":"reference/models/#djstripe.models.billing.TaxRate.Meta","text":"Bases: StripeModel . Meta Source code in djstripe/models/billing.py 2509 2510 class Meta ( StripeModel . Meta ): verbose_name = \"Tax Rate\"","title":"Meta"},{"location":"reference/models/#djstripe.models.billing.TaxRate.Meta-attributes","text":"djstripe . models . billing . TaxRate . Meta . verbose_name = 'Tax Rate' class-attribute","title":"Attributes"},{"location":"reference/models/#djstripe.models.billing.TaxRate-functions","text":"","title":"Functions"},{"location":"reference/models/#djstripe.models.billing.TaxRate.__str__","text":"Source code in djstripe/models/billing.py 2506 2507 def __str__ ( self ): return f \" { self . display_name } at { self . percentage } %\"","title":"__str__()"},{"location":"reference/models/#djstripe.models.billing.UpcomingInvoice","text":"Bases: BaseInvoice The preview of an upcoming invoice - does not exist in the Django database. See BaseInvoice.upcoming() Logically it should be set abstract, but that doesn't quite work since we do actually want to instantiate the model and use relations. Source code in djstripe/models/billing.py 853 854 855 856 857 858 859 860 861 862 863 864 865 866 867 868 869 870 871 872 873 874 875 876 877 878 879 880 881 882 883 884 885 886 887 888 889 890 891 892 893 894 895 896 897 898 899 900 901 902 903 904 905 906 907 908 909 910 911 912 913 914 915 916 917 918 919 920 921 922 923 924 925 926 927 928 929 930 931 932 933 934 935 936 937 938 939 940 941 942 943 944 945 946 947 948 949 950 951 952 953 954 955 956 957 958 959 960 961 962 963 964 965 966 967 968 969 970 971 972 973 974 975 976 977 978 979 980 981 982 983 984 985 986 987 988 989 990 991 992 class UpcomingInvoice ( BaseInvoice ): \"\"\" The preview of an upcoming invoice - does not exist in the Django database. See BaseInvoice.upcoming() Logically it should be set abstract, but that doesn't quite work since we do actually want to instantiate the model and use relations. \"\"\" default_source = PaymentMethodForeignKey ( on_delete = models . SET_NULL , null = True , related_name = \"upcoming_invoices\" , help_text = \"The default payment source for the invoice. \" \"It must belong to the customer associated with the invoice and be \" \"in a chargeable state. If not set, defaults to the subscription's \" \"default source, if any, or to the customer's default source.\" , ) def __init__ ( self , * args , ** kwargs ): super () . __init__ ( * args , ** kwargs ) self . _lineitems = [] self . _default_tax_rates = [] self . _total_tax_amounts = [] def get_stripe_dashboard_url ( self ): return \"\" def _attach_objects_hook ( self , cls , data , api_key = djstripe_settings . STRIPE_SECRET_KEY , current_ids = None ): super () . _attach_objects_hook ( cls , data , api_key = api_key , current_ids = current_ids ) self . _lineitems = cls . _stripe_object_to_line_items ( target_cls = LineItem , data = data , invoice = self , api_key = api_key ) def _attach_objects_post_save_hook ( self , cls , data , api_key = djstripe_settings . STRIPE_SECRET_KEY , pending_relations = None , ): super () . _attach_objects_post_save_hook ( cls , data , api_key = api_key , pending_relations = pending_relations ) self . _default_tax_rates = cls . _stripe_object_to_default_tax_rates ( target_cls = TaxRate , data = data , api_key = api_key ) total_tax_amounts = [] for tax_amount_data in data . get ( \"total_tax_amounts\" , []): tax_rate_id = tax_amount_data [ \"tax_rate\" ] if not isinstance ( tax_rate_id , str ): tax_rate_id = tax_rate_id [ \"tax_rate\" ] tax_rate = TaxRate . _get_or_retrieve ( id = tax_rate_id , api_key = api_key ) tax_amount = DjstripeUpcomingInvoiceTotalTaxAmount ( invoice = self , amount = tax_amount_data [ \"amount\" ], inclusive = tax_amount_data [ \"inclusive\" ], tax_rate = tax_rate , ) total_tax_amounts . append ( tax_amount ) self . _total_tax_amounts = total_tax_amounts @property def invoiceitems ( self ): \"\"\" Gets the invoice items associated with this upcoming invoice. This differs from normal (non-upcoming) invoices, in that upcoming invoices are in-memory and do not persist to the database. Therefore, all of the data comes from the Stripe API itself. Instead of returning a normal queryset for the invoiceitems, this will return a mock of a queryset, but with the data fetched from Stripe - It will act like a normal queryset, but mutation will silently fail. \"\"\" # filter lineitems with type=\"invoice_item\" and fetch all the actual InvoiceItem objects items = [] for item in self . _lineitems : if item . type == \"invoice_item\" : items . append ( item . invoice_item ) return QuerySetMock . from_iterable ( InvoiceItem , items ) @property def lineitems ( self ): \"\"\" Gets the line items associated with this upcoming invoice. This differs from normal (non-upcoming) invoices, in that upcoming invoices are in-memory and do not persist to the database. Therefore, all of the data comes from the Stripe API itself. Instead of returning a normal queryset for the lineitems, this will return a mock of a queryset, but with the data fetched from Stripe - It will act like a normal queryset, but mutation will silently fail. \"\"\" return QuerySetMock . from_iterable ( LineItem , self . _lineitems ) @property def default_tax_rates ( self ): \"\"\" Gets the default tax rates associated with this upcoming invoice. :return: \"\"\" return QuerySetMock . from_iterable ( TaxRate , self . _default_tax_rates ) @property def total_tax_amounts ( self ): \"\"\" Gets the total tax amounts associated with this upcoming invoice. :return: \"\"\" return QuerySetMock . from_iterable ( DjstripeUpcomingInvoiceTotalTaxAmount , self . _total_tax_amounts ) @property def id ( self ): return None @id . setter def id ( self , value ): return # noop def save ( self , * args , ** kwargs ): return # noop","title":"UpcomingInvoice"},{"location":"reference/models/#djstripe.models.billing.UpcomingInvoice-attributes","text":"","title":"Attributes"},{"location":"reference/models/#djstripe.models.billing.UpcomingInvoice._default_tax_rates","text":"","title":"_default_tax_rates"},{"location":"reference/models/#djstripe.models.billing.UpcomingInvoice._lineitems","text":"","title":"_lineitems"},{"location":"reference/models/#djstripe.models.billing.UpcomingInvoice._total_tax_amounts","text":"","title":"_total_tax_amounts"},{"location":"reference/models/#djstripe.models.billing.UpcomingInvoice.default_source","text":"","title":"default_source"},{"location":"reference/models/#djstripe.models.billing.UpcomingInvoice.default_tax_rates","text":"Gets the default tax rates associated with this upcoming invoice. :return:","title":"default_tax_rates"},{"location":"reference/models/#djstripe.models.billing.UpcomingInvoice.id","text":"","title":"id"},{"location":"reference/models/#djstripe.models.billing.UpcomingInvoice.invoiceitems","text":"Gets the invoice items associated with this upcoming invoice. This differs from normal (non-upcoming) invoices, in that upcoming invoices are in-memory and do not persist to the database. Therefore, all of the data comes from the Stripe API itself. Instead of returning a normal queryset for the invoiceitems, this will return a mock of a queryset, but with the data fetched from Stripe - It will act like a normal queryset, but mutation will silently fail.","title":"invoiceitems"},{"location":"reference/models/#djstripe.models.billing.UpcomingInvoice.lineitems","text":"Gets the line items associated with this upcoming invoice. This differs from normal (non-upcoming) invoices, in that upcoming invoices are in-memory and do not persist to the database. Therefore, all of the data comes from the Stripe API itself. Instead of returning a normal queryset for the lineitems, this will return a mock of a queryset, but with the data fetched from Stripe - It will act like a normal queryset, but mutation will silently fail.","title":"lineitems"},{"location":"reference/models/#djstripe.models.billing.UpcomingInvoice.total_tax_amounts","text":"Gets the total tax amounts associated with this upcoming invoice. :return:","title":"total_tax_amounts"},{"location":"reference/models/#djstripe.models.billing.UpcomingInvoice-functions","text":"","title":"Functions"},{"location":"reference/models/#djstripe.models.billing.UpcomingInvoice.__init__","text":"Source code in djstripe/models/billing.py 873 874 875 876 877 878 def __init__ ( self , * args , ** kwargs ): super () . __init__ ( * args , ** kwargs ) self . _lineitems = [] self . _default_tax_rates = [] self . _total_tax_amounts = []","title":"__init__()"},{"location":"reference/models/#djstripe.models.billing.UpcomingInvoice._attach_objects_hook","text":"Source code in djstripe/models/billing.py 883 884 885 886 887 888 889 890 891 892 def _attach_objects_hook ( self , cls , data , api_key = djstripe_settings . STRIPE_SECRET_KEY , current_ids = None ): super () . _attach_objects_hook ( cls , data , api_key = api_key , current_ids = current_ids ) self . _lineitems = cls . _stripe_object_to_line_items ( target_cls = LineItem , data = data , invoice = self , api_key = api_key )","title":"_attach_objects_hook()"},{"location":"reference/models/#djstripe.models.billing.UpcomingInvoice._attach_objects_post_save_hook","text":"Source code in djstripe/models/billing.py 894 895 896 897 898 899 900 901 902 903 904 905 906 907 908 909 910 911 912 913 914 915 916 917 918 919 920 921 922 923 924 925 926 927 def _attach_objects_post_save_hook ( self , cls , data , api_key = djstripe_settings . STRIPE_SECRET_KEY , pending_relations = None , ): super () . _attach_objects_post_save_hook ( cls , data , api_key = api_key , pending_relations = pending_relations ) self . _default_tax_rates = cls . _stripe_object_to_default_tax_rates ( target_cls = TaxRate , data = data , api_key = api_key ) total_tax_amounts = [] for tax_amount_data in data . get ( \"total_tax_amounts\" , []): tax_rate_id = tax_amount_data [ \"tax_rate\" ] if not isinstance ( tax_rate_id , str ): tax_rate_id = tax_rate_id [ \"tax_rate\" ] tax_rate = TaxRate . _get_or_retrieve ( id = tax_rate_id , api_key = api_key ) tax_amount = DjstripeUpcomingInvoiceTotalTaxAmount ( invoice = self , amount = tax_amount_data [ \"amount\" ], inclusive = tax_amount_data [ \"inclusive\" ], tax_rate = tax_rate , ) total_tax_amounts . append ( tax_amount ) self . _total_tax_amounts = total_tax_amounts","title":"_attach_objects_post_save_hook()"},{"location":"reference/models/#djstripe.models.billing.UpcomingInvoice.get_stripe_dashboard_url","text":"Source code in djstripe/models/billing.py 880 881 def get_stripe_dashboard_url ( self ): return \"\"","title":"get_stripe_dashboard_url()"},{"location":"reference/models/#djstripe.models.billing.UpcomingInvoice.save","text":"Source code in djstripe/models/billing.py 991 992 def save ( self , * args , ** kwargs ): return # noop","title":"save()"},{"location":"reference/models/#djstripe.models.billing.UsageRecord","text":"Bases: StripeModel Usage records allow you to continually report usage and metrics to Stripe for metered billing of plans. Stripe documentation: https://stripe.com/docs/api?lang=python#usage_records Source code in djstripe/models/billing.py 2513 2514 2515 2516 2517 2518 2519 2520 2521 2522 2523 2524 2525 2526 2527 2528 2529 2530 2531 2532 2533 2534 2535 2536 2537 2538 2539 2540 2541 2542 2543 2544 2545 2546 2547 2548 2549 2550 2551 2552 2553 2554 2555 2556 2557 2558 2559 2560 2561 2562 2563 2564 2565 2566 2567 2568 2569 2570 2571 2572 2573 2574 2575 2576 2577 2578 2579 2580 2581 2582 2583 2584 2585 2586 class UsageRecord ( StripeModel ): \"\"\" Usage records allow you to continually report usage and metrics to Stripe for metered billing of plans. Stripe documentation: https://stripe.com/docs/api?lang=python#usage_records \"\"\" description = None metadata = None stripe_class = stripe . UsageRecord quantity = models . PositiveIntegerField ( help_text = ( \"The quantity of the plan to which the customer should be subscribed.\" ) ) subscription_item = StripeForeignKey ( \"SubscriptionItem\" , on_delete = models . CASCADE , related_name = \"usage_records\" , help_text = \"The subscription item this usage record contains data for.\" , ) timestamp = StripeDateTimeField ( null = True , blank = True , help_text = \"The timestamp for the usage event. This timestamp must be within the current billing period of the subscription of the provided subscription_item.\" , ) action = StripeEnumField ( enum = enums . UsageAction , default = enums . UsageAction . increment , help_text = \"When using increment the specified quantity will be added to the usage at the specified timestamp. The set action will overwrite the usage quantity at that timestamp. If the subscription has billing thresholds, increment is the only allowed value.\" , ) def __str__ ( self ): return f \"Usage for { self . subscription_item } ( { self . action } ) is { self . quantity } \" @classmethod def _api_create ( cls , api_key = djstripe_settings . STRIPE_SECRET_KEY , ** kwargs ): \"\"\" Call the stripe API's create operation for this model. :param api_key: The api key to use for this request. \\ Defaults to djstripe_settings.STRIPE_SECRET_KEY. :type api_key: string \"\"\" if not kwargs . get ( \"id\" ): raise KeyError ( \"SubscriptionItem Object ID is missing\" ) try : SubscriptionItem . objects . get ( id = kwargs [ \"id\" ]) except SubscriptionItem . DoesNotExist : raise usage_stripe_data = stripe . SubscriptionItem . create_usage_record ( api_key = api_key , ** kwargs ) # ! Hack: there is no way to retrieve a UsageRecord object from Stripe, # ! which is why we create and sync it right here cls . sync_from_stripe_data ( usage_stripe_data , api_key = api_key ) return usage_stripe_data @classmethod def create ( cls , ** kwargs ): \"\"\" A wrapper around _api_create() to allow one to create and sync UsageRecord Objects \"\"\" return cls . _api_create ( ** kwargs )","title":"UsageRecord"},{"location":"reference/models/#djstripe.models.billing.UsageRecord-attributes","text":"","title":"Attributes"},{"location":"reference/models/#djstripe.models.billing.UsageRecord.action","text":"","title":"action"},{"location":"reference/models/#djstripe.models.billing.UsageRecord.description","text":"","title":"description"},{"location":"reference/models/#djstripe.models.billing.UsageRecord.metadata","text":"","title":"metadata"},{"location":"reference/models/#djstripe.models.billing.UsageRecord.quantity","text":"","title":"quantity"},{"location":"reference/models/#djstripe.models.billing.UsageRecord.stripe_class","text":"","title":"stripe_class"},{"location":"reference/models/#djstripe.models.billing.UsageRecord.subscription_item","text":"","title":"subscription_item"},{"location":"reference/models/#djstripe.models.billing.UsageRecord.timestamp","text":"","title":"timestamp"},{"location":"reference/models/#djstripe.models.billing.UsageRecord-functions","text":"","title":"Functions"},{"location":"reference/models/#djstripe.models.billing.UsageRecord.__str__","text":"Source code in djstripe/models/billing.py 2550 2551 def __str__ ( self ): return f \"Usage for { self . subscription_item } ( { self . action } ) is { self . quantity } \"","title":"__str__()"},{"location":"reference/models/#djstripe.models.billing.UsageRecord._api_create","text":"Call the stripe API's create operation for this model. :param api_key: The api key to use for this request. Defaults to djstripe_settings.STRIPE_SECRET_KEY. :type api_key: string Source code in djstripe/models/billing.py 2553 2554 2555 2556 2557 2558 2559 2560 2561 2562 2563 2564 2565 2566 2567 2568 2569 2570 2571 2572 2573 2574 2575 2576 2577 2578 2579 @classmethod def _api_create ( cls , api_key = djstripe_settings . STRIPE_SECRET_KEY , ** kwargs ): \"\"\" Call the stripe API's create operation for this model. :param api_key: The api key to use for this request. \\ Defaults to djstripe_settings.STRIPE_SECRET_KEY. :type api_key: string \"\"\" if not kwargs . get ( \"id\" ): raise KeyError ( \"SubscriptionItem Object ID is missing\" ) try : SubscriptionItem . objects . get ( id = kwargs [ \"id\" ]) except SubscriptionItem . DoesNotExist : raise usage_stripe_data = stripe . SubscriptionItem . create_usage_record ( api_key = api_key , ** kwargs ) # ! Hack: there is no way to retrieve a UsageRecord object from Stripe, # ! which is why we create and sync it right here cls . sync_from_stripe_data ( usage_stripe_data , api_key = api_key ) return usage_stripe_data","title":"_api_create()"},{"location":"reference/models/#djstripe.models.billing.UsageRecord.create","text":"A wrapper around _api_create() to allow one to create and sync UsageRecord Objects Source code in djstripe/models/billing.py 2581 2582 2583 2584 2585 2586 @classmethod def create ( cls , ** kwargs ): \"\"\" A wrapper around _api_create() to allow one to create and sync UsageRecord Objects \"\"\" return cls . _api_create ( ** kwargs )","title":"create()"},{"location":"reference/models/#djstripe.models.billing.UsageRecordSummary","text":"Bases: StripeModel Usage record summaries provides usage information that's been summarized from multiple usage records and over a subscription billing period (e.g., 15 usage records in the month of September). Since new usage records can still be added, the returned summary information for the subscription item's ID should be seen as unstable until the subscription billing period ends. Stripe documentation: https://stripe.com/docs/api/usage_records/subscription_item_summary_list?lang=python Source code in djstripe/models/billing.py 2589 2590 2591 2592 2593 2594 2595 2596 2597 2598 2599 2600 2601 2602 2603 2604 2605 2606 2607 2608 2609 2610 2611 2612 2613 2614 2615 2616 2617 2618 2619 2620 2621 2622 2623 2624 2625 2626 2627 2628 2629 2630 2631 2632 2633 2634 2635 2636 2637 2638 2639 2640 2641 2642 2643 2644 2645 2646 2647 2648 2649 2650 2651 2652 2653 2654 2655 2656 2657 2658 2659 2660 2661 2662 2663 2664 2665 2666 2667 2668 2669 2670 2671 2672 2673 2674 class UsageRecordSummary ( StripeModel ): \"\"\" Usage record summaries provides usage information that's been summarized from multiple usage records and over a subscription billing period (e.g., 15 usage records in the month of September). Since new usage records can still be added, the returned summary information for the subscription item's ID should be seen as unstable until the subscription billing period ends. Stripe documentation: https://stripe.com/docs/api/usage_records/subscription_item_summary_list?lang=python \"\"\" stripe_class = stripe . UsageRecordSummary description = None metadata = None invoice = StripeForeignKey ( \"Invoice\" , null = True , blank = True , on_delete = models . CASCADE , related_name = \"usage_record_summaries\" , ) period = JSONField ( null = True , blank = True , help_text = \"Subscription Billing period for the SubscriptionItem\" , ) period_end = StripeDateTimeField ( null = True , blank = True , help_text = \"End of the Subscription Billing period for the SubscriptionItem\" , ) period_start = StripeDateTimeField ( null = True , blank = True , help_text = \"Start of the Subscription Billing period for the SubscriptionItem\" , ) total_usage = models . PositiveIntegerField ( help_text = ( \"The quantity of the plan to which the customer should be subscribed.\" ) ) subscription_item = StripeForeignKey ( \"SubscriptionItem\" , on_delete = models . CASCADE , related_name = \"usage_record_summaries\" , help_text = \"The subscription item this usage record contains data for.\" , ) def __str__ ( self ): return f \"Usage Summary for { self . subscription_item } ( { self . invoice } ) is { self . total_usage } \" @classmethod def _manipulate_stripe_object_hook ( cls , data ): data [ \"period_start\" ] = data [ \"period\" ][ \"start\" ] data [ \"period_end\" ] = data [ \"period\" ][ \"end\" ] return data @classmethod def api_list ( cls , api_key = djstripe_settings . STRIPE_SECRET_KEY , ** kwargs ): \"\"\" Call the stripe API's list operation for this model. :param api_key: The api key to use for this request. \\ Defaults to djstripe_settings.STRIPE_SECRET_KEY. :type api_key: string See Stripe documentation for accepted kwargs for each object. :returns: an iterator over all items in the query \"\"\" if not kwargs . get ( \"id\" ): raise KeyError ( \"SubscriptionItem Object ID is missing\" ) try : SubscriptionItem . objects . get ( id = kwargs [ \"id\" ]) except SubscriptionItem . DoesNotExist : raise return stripe . SubscriptionItem . list_usage_record_summaries ( api_key = api_key , stripe_version = djstripe_settings . STRIPE_API_VERSION , ** kwargs , ) . auto_paging_iter ()","title":"UsageRecordSummary"},{"location":"reference/models/#djstripe.models.billing.UsageRecordSummary-attributes","text":"","title":"Attributes"},{"location":"reference/models/#djstripe.models.billing.UsageRecordSummary.description","text":"","title":"description"},{"location":"reference/models/#djstripe.models.billing.UsageRecordSummary.invoice","text":"","title":"invoice"},{"location":"reference/models/#djstripe.models.billing.UsageRecordSummary.metadata","text":"","title":"metadata"},{"location":"reference/models/#djstripe.models.billing.UsageRecordSummary.period","text":"","title":"period"},{"location":"reference/models/#djstripe.models.billing.UsageRecordSummary.period_end","text":"","title":"period_end"},{"location":"reference/models/#djstripe.models.billing.UsageRecordSummary.period_start","text":"","title":"period_start"},{"location":"reference/models/#djstripe.models.billing.UsageRecordSummary.stripe_class","text":"","title":"stripe_class"},{"location":"reference/models/#djstripe.models.billing.UsageRecordSummary.subscription_item","text":"","title":"subscription_item"},{"location":"reference/models/#djstripe.models.billing.UsageRecordSummary.total_usage","text":"","title":"total_usage"},{"location":"reference/models/#djstripe.models.billing.UsageRecordSummary-functions","text":"","title":"Functions"},{"location":"reference/models/#djstripe.models.billing.UsageRecordSummary.__str__","text":"Source code in djstripe/models/billing.py 2639 2640 def __str__ ( self ): return f \"Usage Summary for { self . subscription_item } ( { self . invoice } ) is { self . total_usage } \"","title":"__str__()"},{"location":"reference/models/#djstripe.models.billing.UsageRecordSummary._manipulate_stripe_object_hook","text":"Source code in djstripe/models/billing.py 2642 2643 2644 2645 2646 2647 @classmethod def _manipulate_stripe_object_hook ( cls , data ): data [ \"period_start\" ] = data [ \"period\" ][ \"start\" ] data [ \"period_end\" ] = data [ \"period\" ][ \"end\" ] return data","title":"_manipulate_stripe_object_hook()"},{"location":"reference/models/#djstripe.models.billing.UsageRecordSummary.api_list","text":"Call the stripe API's list operation for this model. :param api_key: The api key to use for this request. Defaults to djstripe_settings.STRIPE_SECRET_KEY. :type api_key: string See Stripe documentation for accepted kwargs for each object. :returns: an iterator over all items in the query Source code in djstripe/models/billing.py 2649 2650 2651 2652 2653 2654 2655 2656 2657 2658 2659 2660 2661 2662 2663 2664 2665 2666 2667 2668 2669 2670 2671 2672 2673 2674 @classmethod def api_list ( cls , api_key = djstripe_settings . STRIPE_SECRET_KEY , ** kwargs ): \"\"\" Call the stripe API's list operation for this model. :param api_key: The api key to use for this request. \\ Defaults to djstripe_settings.STRIPE_SECRET_KEY. :type api_key: string See Stripe documentation for accepted kwargs for each object. :returns: an iterator over all items in the query \"\"\" if not kwargs . get ( \"id\" ): raise KeyError ( \"SubscriptionItem Object ID is missing\" ) try : SubscriptionItem . objects . get ( id = kwargs [ \"id\" ]) except SubscriptionItem . DoesNotExist : raise return stripe . SubscriptionItem . list_usage_record_summaries ( api_key = api_key , stripe_version = djstripe_settings . STRIPE_API_VERSION , ** kwargs , ) . auto_paging_iter ()","title":"api_list()"},{"location":"reference/models/#djstripe.models.billing-functions","text":"","title":"Functions"},{"location":"reference/models/#connect","text":"","title":"Connect"},{"location":"reference/models/#djstripe.models.account-attributes","text":"","title":"Attributes"},{"location":"reference/models/#djstripe.models.account-classes","text":"","title":"Classes"},{"location":"reference/models/#djstripe.models.account.Account","text":"Bases: StripeModel This is an object representing a Stripe account. You can retrieve it to see properties on the account like its current e-mail address or if the account is enabled yet to make live charges. Stripe documentation: https://stripe.com/docs/api/accounts?lang=python Source code in djstripe/models/account.py 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 class Account ( StripeModel ): \"\"\" This is an object representing a Stripe account. You can retrieve it to see properties on the account like its current e-mail address or if the account is enabled yet to make live charges. Stripe documentation: https://stripe.com/docs/api/accounts?lang=python \"\"\" stripe_class = stripe . Account business_profile = JSONField ( null = True , blank = True , help_text = \"Optional information related to the business.\" ) business_type = StripeEnumField ( enum = enums . BusinessType , default = \"\" , blank = True , help_text = \"The business type.\" ) charges_enabled = models . BooleanField ( help_text = \"Whether the account can create live charges\" ) country = models . CharField ( max_length = 2 , help_text = \"The country of the account\" ) company = JSONField ( null = True , blank = True , help_text = ( \"Information about the company or business. \" \"This field is null unless business_type is set to company.\" ), ) default_currency = StripeCurrencyCodeField ( help_text = \"The currency this account has chosen to use as the default\" ) details_submitted = models . BooleanField ( help_text = ( \"Whether account details have been submitted. \" \"Standard accounts cannot receive payouts before this is true.\" ) ) email = models . CharField ( max_length = 255 , help_text = \"The primary user's email address.\" ) # TODO external_accounts = ... individual = JSONField ( null = True , blank = True , help_text = ( \"Information about the person represented by the account. \" \"This field is null unless business_type is set to individual.\" ), ) payouts_enabled = models . BooleanField ( null = True , help_text = \"Whether Stripe can send payouts to this account\" ) product_description = models . CharField ( max_length = 255 , default = \"\" , blank = True , help_text = \"Internal-only description of the product sold or service provided \" \"by the business. It's used by Stripe for risk and underwriting purposes.\" , ) requirements = JSONField ( null = True , blank = True , help_text = \"Information about the requirements for the account, \" \"including what information needs to be collected, and by when.\" , ) settings = JSONField ( null = True , blank = True , help_text = ( \"Account options for customizing how the account functions within Stripe.\" ), ) type = StripeEnumField ( enum = enums . AccountType , help_text = \"The Stripe account type.\" ) tos_acceptance = JSONField ( null = True , blank = True , help_text = \"Details on the acceptance of the Stripe Services Agreement\" , ) def get_stripe_dashboard_url ( self ) -> str : \"\"\"Get the stripe dashboard url for this object.\"\"\" return ( f \"https://dashboard.stripe.com/ { self . id } /\" f \" { 'test/' if not self . livemode else '' } dashboard\" ) @property def default_api_key ( self ) -> str : return self . get_default_api_key () def get_default_api_key ( self , livemode : bool = None ) -> str : if livemode is None : livemode = self . livemode api_key = APIKey . objects . filter ( djstripe_owner_account = self , type = APIKeyType . secret ) . first () else : api_key = APIKey . objects . filter ( djstripe_owner_account = self , type = APIKeyType . secret , livemode = livemode ) . first () if api_key : return api_key . secret return djstripe_settings . get_default_api_key ( livemode ) @property def business_url ( self ) -> str : \"\"\" The business's publicly available website. \"\"\" if self . business_profile : return self . business_profile . get ( \"url\" , \"\" ) return \"\" @classmethod def get_default_account ( cls , api_key = djstripe_settings . STRIPE_SECRET_KEY ): # As of API version 2020-03-02, there is no permission that can allow # restricted keys to call GET /v1/account if djstripe_settings . STRIPE_SECRET_KEY . startswith ( \"rk_\" ): return None account_data = cls . stripe_class . retrieve ( api_key = api_key , stripe_version = djstripe_settings . STRIPE_API_VERSION ) return cls . _get_or_create_from_stripe_object ( account_data , api_key = api_key )[ 0 ] @classmethod def get_or_retrieve_for_api_key ( cls , api_key : str ): with transaction . atomic (): apikey_instance , _ = APIKey . objects . get_or_create_by_api_key ( api_key ) if not apikey_instance . djstripe_owner_account : apikey_instance . refresh_account () return apikey_instance . djstripe_owner_account def __str__ ( self ): settings = self . settings or {} business_profile = self . business_profile or {} return ( settings . get ( \"dashboard\" , {}) . get ( \"display_name\" ) or business_profile . get ( \"name\" ) or super () . __str__ () ) def api_reject ( self , api_key = None , stripe_account = None , ** kwargs ): \"\"\" Call the stripe API's reject operation for Account model :param api_key: The api key to use for this request. Defaults to djstripe_settings.STRIPE_SECRET_KEY. :type api_key: string :param stripe_account: The optional connected account \\ for which this request is being made. :type stripe_account: string \"\"\" api_key = api_key or self . default_api_key # Prefer passed in stripe_account if set. if not stripe_account : stripe_account = self . _get_stripe_account_id ( api_key ) return self . stripe_class . reject ( self . id , api_key = api_key , stripe_account = stripe_account , stripe_version = djstripe_settings . STRIPE_API_VERSION , ** kwargs , ) @classmethod def _create_from_stripe_object ( cls , data , current_ids = None , pending_relations = None , save = True , stripe_account = None , api_key = djstripe_settings . STRIPE_SECRET_KEY , ): \"\"\" Set the stripe_account to the id of the Account instance being created. This ensures that the foreign-key relations that may exist in stripe are fetched using the appropriate connected account ID. \"\"\" return super () . _create_from_stripe_object ( data = data , current_ids = current_ids , pending_relations = pending_relations , save = save , stripe_account = data [ \"id\" ] if not stripe_account else stripe_account , api_key = api_key , ) # \"Special\" handling of the icon and logo fields # Previously available as properties, they moved to # settings.branding in Stripe 2019-02-19. # Currently, they return a File ID @property def branding_icon ( self ): from ..models.core import File id = self . settings . get ( \"branding\" , {}) . get ( \"icon\" ) return File . objects . filter ( id = id ) . first () if id else None @property def branding_logo ( self ): from ..models.core import File id = self . settings . get ( \"branding\" , {}) . get ( \"logo\" ) return File . objects . filter ( id = id ) . first () if id else None def _attach_objects_post_save_hook ( self , cls , data , pending_relations = None , api_key = djstripe_settings . STRIPE_SECRET_KEY , ): from ..models.core import File super () . _attach_objects_post_save_hook ( cls , data , pending_relations = pending_relations , api_key = api_key ) # set the livemode if not returned by data if \"livemode\" not in data . keys () and self . djstripe_owner_account is not None : # Platform Account if self == self . djstripe_owner_account : self . livemode = None else : # Connected Account _ , self . livemode = get_api_key_details_by_prefix ( api_key ) # save the updates self . save () # Retrieve and save the Files in the settings.branding object. for field in \"icon\" , \"logo\" : file_upload_id = self . settings and self . settings . get ( \"branding\" , {}) . get ( field ) if file_upload_id : try : File . sync_from_stripe_data ( File ( id = file_upload_id ) . api_retrieve ( stripe_account = self . id , api_key = api_key ), api_key = api_key , ) except stripe . error . PermissionError : # No permission to retrieve the data with the key logger . warning ( f \"Cannot retrieve business branding { field } for acct { self . id } with the key.\" ) except stripe . error . InvalidRequestError as e : if \"a similar object exists in\" in str ( e ): # HACK around a Stripe bug. # See #830 and commit c09d25f52bfdcf883e9eec0bf6c25af1771a644a pass else : raise except stripe . error . AuthenticationError : # This may happen if saving an account that has a logo, using # a different API key to the default. # OK, concretely, there is a chicken-and-egg problem here. # But, the logo file object is not a particularly important thing. # Until we have a better solution, just ignore this error. pass","title":"Account"},{"location":"reference/models/#djstripe.models.account.Account-attributes","text":"","title":"Attributes"},{"location":"reference/models/#djstripe.models.account.Account.branding_icon","text":"","title":"branding_icon"},{"location":"reference/models/#djstripe.models.account.Account.branding_logo","text":"","title":"branding_logo"},{"location":"reference/models/#djstripe.models.account.Account.business_profile","text":"","title":"business_profile"},{"location":"reference/models/#djstripe.models.account.Account.business_type","text":"","title":"business_type"},{"location":"reference/models/#djstripe.models.account.Account.business_url","text":"The business's publicly available website.","title":"business_url"},{"location":"reference/models/#djstripe.models.account.Account.charges_enabled","text":"","title":"charges_enabled"},{"location":"reference/models/#djstripe.models.account.Account.company","text":"","title":"company"},{"location":"reference/models/#djstripe.models.account.Account.country","text":"","title":"country"},{"location":"reference/models/#djstripe.models.account.Account.default_api_key","text":"","title":"default_api_key"},{"location":"reference/models/#djstripe.models.account.Account.default_currency","text":"","title":"default_currency"},{"location":"reference/models/#djstripe.models.account.Account.details_submitted","text":"","title":"details_submitted"},{"location":"reference/models/#djstripe.models.account.Account.email","text":"","title":"email"},{"location":"reference/models/#djstripe.models.account.Account.individual","text":"","title":"individual"},{"location":"reference/models/#djstripe.models.account.Account.payouts_enabled","text":"","title":"payouts_enabled"},{"location":"reference/models/#djstripe.models.account.Account.product_description","text":"","title":"product_description"},{"location":"reference/models/#djstripe.models.account.Account.requirements","text":"","title":"requirements"},{"location":"reference/models/#djstripe.models.account.Account.settings","text":"","title":"settings"},{"location":"reference/models/#djstripe.models.account.Account.stripe_class","text":"","title":"stripe_class"},{"location":"reference/models/#djstripe.models.account.Account.tos_acceptance","text":"","title":"tos_acceptance"},{"location":"reference/models/#djstripe.models.account.Account.type","text":"","title":"type"},{"location":"reference/models/#djstripe.models.account.Account-functions","text":"","title":"Functions"},{"location":"reference/models/#djstripe.models.account.Account.__str__","text":"Source code in djstripe/models/account.py 149 150 151 152 153 154 155 156 def __str__ ( self ): settings = self . settings or {} business_profile = self . business_profile or {} return ( settings . get ( \"dashboard\" , {}) . get ( \"display_name\" ) or business_profile . get ( \"name\" ) or super () . __str__ () )","title":"__str__()"},{"location":"reference/models/#djstripe.models.account.Account.api_reject","text":"Call the stripe API's reject operation for Account model :param api_key: The api key to use for this request. Defaults to djstripe_settings.STRIPE_SECRET_KEY. :type api_key: string :param stripe_account: The optional connected account for which this request is being made. :type stripe_account: string Source code in djstripe/models/account.py 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 def api_reject ( self , api_key = None , stripe_account = None , ** kwargs ): \"\"\" Call the stripe API's reject operation for Account model :param api_key: The api key to use for this request. Defaults to djstripe_settings.STRIPE_SECRET_KEY. :type api_key: string :param stripe_account: The optional connected account \\ for which this request is being made. :type stripe_account: string \"\"\" api_key = api_key or self . default_api_key # Prefer passed in stripe_account if set. if not stripe_account : stripe_account = self . _get_stripe_account_id ( api_key ) return self . stripe_class . reject ( self . id , api_key = api_key , stripe_account = stripe_account , stripe_version = djstripe_settings . STRIPE_API_VERSION , ** kwargs , )","title":"api_reject()"},{"location":"reference/models/#djstripe.models.account.Account.get_default_account","text":"Source code in djstripe/models/account.py 127 128 129 130 131 132 133 134 135 136 137 138 @classmethod def get_default_account ( cls , api_key = djstripe_settings . STRIPE_SECRET_KEY ): # As of API version 2020-03-02, there is no permission that can allow # restricted keys to call GET /v1/account if djstripe_settings . STRIPE_SECRET_KEY . startswith ( \"rk_\" ): return None account_data = cls . stripe_class . retrieve ( api_key = api_key , stripe_version = djstripe_settings . STRIPE_API_VERSION ) return cls . _get_or_create_from_stripe_object ( account_data , api_key = api_key )[ 0 ]","title":"get_default_account()"},{"location":"reference/models/#djstripe.models.account.Account.get_default_api_key","text":"Source code in djstripe/models/account.py 103 104 105 106 107 108 109 110 111 112 113 114 115 116 def get_default_api_key ( self , livemode : bool = None ) -> str : if livemode is None : livemode = self . livemode api_key = APIKey . objects . filter ( djstripe_owner_account = self , type = APIKeyType . secret ) . first () else : api_key = APIKey . objects . filter ( djstripe_owner_account = self , type = APIKeyType . secret , livemode = livemode ) . first () if api_key : return api_key . secret return djstripe_settings . get_default_api_key ( livemode )","title":"get_default_api_key()"},{"location":"reference/models/#djstripe.models.account.Account.get_or_retrieve_for_api_key","text":"Source code in djstripe/models/account.py 140 141 142 143 144 145 146 147 @classmethod def get_or_retrieve_for_api_key ( cls , api_key : str ): with transaction . atomic (): apikey_instance , _ = APIKey . objects . get_or_create_by_api_key ( api_key ) if not apikey_instance . djstripe_owner_account : apikey_instance . refresh_account () return apikey_instance . djstripe_owner_account","title":"get_or_retrieve_for_api_key()"},{"location":"reference/models/#djstripe.models.account.Account.get_stripe_dashboard_url","text":"Get the stripe dashboard url for this object. Source code in djstripe/models/account.py 92 93 94 95 96 97 def get_stripe_dashboard_url ( self ) -> str : \"\"\"Get the stripe dashboard url for this object.\"\"\" return ( f \"https://dashboard.stripe.com/ { self . id } /\" f \" { 'test/' if not self . livemode else '' } dashboard\" )","title":"get_stripe_dashboard_url()"},{"location":"reference/models/#djstripe.models.account-functions","text":"","title":"Functions"},{"location":"reference/models/#djstripe.models.connect-attributes","text":"","title":"Attributes"},{"location":"reference/models/#djstripe.models.connect-classes","text":"","title":"Classes"},{"location":"reference/models/#djstripe.models.connect.ApplicationFee","text":"Bases: StripeModel When you collect a transaction fee on top of a charge made for your user (using Connect), an ApplicationFee is created in your account. Please note the model field charge exists on the Stripe Connected Account while the application_fee modelfield on Charge model exists on the Platform Account! Stripe documentation: https://stripe.com/docs/api?lang=python#application_fees Source code in djstripe/models/connect.py 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 class ApplicationFee ( StripeModel ): \"\"\" When you collect a transaction fee on top of a charge made for your user (using Connect), an ApplicationFee is created in your account. Please note the model field charge exists on the Stripe Connected Account while the application_fee modelfield on Charge model exists on the Platform Account! Stripe documentation: https://stripe.com/docs/api?lang=python#application_fees \"\"\" stripe_class = stripe . ApplicationFee account = StripeForeignKey ( \"Account\" , on_delete = models . PROTECT , related_name = \"application_fees\" , help_text = \"ID of the Stripe account this fee was taken from.\" , ) amount = StripeQuantumCurrencyAmountField ( help_text = \"Amount earned, in cents.\" ) amount_refunded = StripeQuantumCurrencyAmountField ( help_text = \"Amount in cents refunded (can be less than the amount attribute \" \"on the fee if a partial refund was issued)\" ) # TODO application = ... # balance_transaction exists on the platform account balance_transaction = StripeForeignKey ( \"BalanceTransaction\" , on_delete = models . CASCADE , help_text = \"Balance transaction that describes the impact on your account\" \" balance.\" , ) # charge exists on the Stripe Connected Account and not the Platform Account charge = StripeForeignKey ( \"Charge\" , on_delete = models . CASCADE , help_text = \"The charge that the application fee was taken from.\" , ) currency = StripeCurrencyCodeField () # TODO originating_transaction = ... (refs. both Charge and Transfer) refunded = models . BooleanField ( help_text = ( \"Whether the fee has been fully refunded. If the fee is only \" \"partially refunded, this attribute will still be false.\" ) )","title":"ApplicationFee"},{"location":"reference/models/#djstripe.models.connect.ApplicationFee-attributes","text":"","title":"Attributes"},{"location":"reference/models/#djstripe.models.connect.ApplicationFee.account","text":"","title":"account"},{"location":"reference/models/#djstripe.models.connect.ApplicationFee.amount","text":"","title":"amount"},{"location":"reference/models/#djstripe.models.connect.ApplicationFee.amount_refunded","text":"","title":"amount_refunded"},{"location":"reference/models/#djstripe.models.connect.ApplicationFee.balance_transaction","text":"","title":"balance_transaction"},{"location":"reference/models/#djstripe.models.connect.ApplicationFee.charge","text":"","title":"charge"},{"location":"reference/models/#djstripe.models.connect.ApplicationFee.currency","text":"","title":"currency"},{"location":"reference/models/#djstripe.models.connect.ApplicationFee.refunded","text":"","title":"refunded"},{"location":"reference/models/#djstripe.models.connect.ApplicationFee.stripe_class","text":"","title":"stripe_class"},{"location":"reference/models/#djstripe.models.connect.ApplicationFeeRefund","text":"Bases: StripeModel ApplicationFeeRefund objects allow you to refund an ApplicationFee that has previously been created but not yet refunded. Funds will be refunded to the Stripe account from which the fee was originally collected. Stripe documentation: https://stripe.com/docs/api?lang=python#fee_refunds Source code in djstripe/models/connect.py 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 class ApplicationFeeRefund ( StripeModel ): \"\"\" ApplicationFeeRefund objects allow you to refund an ApplicationFee that has previously been created but not yet refunded. Funds will be refunded to the Stripe account from which the fee was originally collected. Stripe documentation: https://stripe.com/docs/api?lang=python#fee_refunds \"\"\" description = None stripe_class = stripe . ApplicationFeeRefund amount = StripeQuantumCurrencyAmountField ( help_text = \"Amount refunded, in cents.\" ) balance_transaction = StripeForeignKey ( \"BalanceTransaction\" , on_delete = models . CASCADE , help_text = \"Balance transaction that describes the impact on your account \" \"balance.\" , ) currency = StripeCurrencyCodeField () fee = StripeForeignKey ( \"ApplicationFee\" , on_delete = models . CASCADE , related_name = \"refunds\" , help_text = \"The application fee that was refunded\" , )","title":"ApplicationFeeRefund"},{"location":"reference/models/#djstripe.models.connect.ApplicationFeeRefund-attributes","text":"","title":"Attributes"},{"location":"reference/models/#djstripe.models.connect.ApplicationFeeRefund.amount","text":"","title":"amount"},{"location":"reference/models/#djstripe.models.connect.ApplicationFeeRefund.balance_transaction","text":"","title":"balance_transaction"},{"location":"reference/models/#djstripe.models.connect.ApplicationFeeRefund.currency","text":"","title":"currency"},{"location":"reference/models/#djstripe.models.connect.ApplicationFeeRefund.description","text":"","title":"description"},{"location":"reference/models/#djstripe.models.connect.ApplicationFeeRefund.fee","text":"","title":"fee"},{"location":"reference/models/#djstripe.models.connect.ApplicationFeeRefund.stripe_class","text":"","title":"stripe_class"},{"location":"reference/models/#djstripe.models.connect.CountrySpec","text":"Bases: StripeBaseModel Stripe documentation: https://stripe.com/docs/api?lang=python#country_specs Source code in djstripe/models/connect.py 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 class CountrySpec ( StripeBaseModel ): \"\"\" Stripe documentation: https://stripe.com/docs/api?lang=python#country_specs \"\"\" stripe_class = stripe . CountrySpec id = models . CharField ( max_length = 2 , primary_key = True , serialize = True ) default_currency = StripeCurrencyCodeField ( help_text = ( \"The default currency for this country. \" \"This applies to both payment methods and bank accounts.\" ) ) supported_bank_account_currencies = JSONField ( help_text = \"Currencies that can be accepted in the specific country\" \" (for transfers).\" ) supported_payment_currencies = JSONField ( help_text = \"Currencies that can be accepted in the specified country\" \" (for payments).\" ) supported_payment_methods = JSONField ( help_text = \"Payment methods available in the specified country.\" ) supported_transfer_countries = JSONField ( help_text = \"Countries that can accept transfers from the specified country.\" ) verification_fields = JSONField ( help_text = \"Lists the types of verification data needed to keep an account open.\" ) @classmethod def sync_from_stripe_data ( cls , data , api_key = djstripe_settings . STRIPE_SECRET_KEY ) -> \"CountrySpec\" : \"\"\" Syncs this object from the stripe data provided. Foreign keys will also be retrieved and synced recursively. :param data: stripe object :type data: dict :rtype: cls \"\"\" data_id = data [ \"id\" ] supported_fields = ( \"default_currency\" , \"supported_bank_account_currencies\" , \"supported_payment_currencies\" , \"supported_payment_methods\" , \"supported_transfer_countries\" , \"verification_fields\" , ) instance , created = cls . objects . get_or_create ( id = data_id , defaults = { k : data [ k ] for k in supported_fields }, ) return instance def api_retrieve ( self , api_key : str = None , stripe_account = None ): if api_key is None : api_key = djstripe_settings . get_default_api_key ( livemode = None ) return self . stripe_class . retrieve ( id = self . id , api_key = api_key , stripe_version = djstripe_settings . STRIPE_API_VERSION , stripe_account = stripe_account , )","title":"CountrySpec"},{"location":"reference/models/#djstripe.models.connect.CountrySpec-attributes","text":"","title":"Attributes"},{"location":"reference/models/#djstripe.models.connect.CountrySpec.default_currency","text":"","title":"default_currency"},{"location":"reference/models/#djstripe.models.connect.CountrySpec.id","text":"","title":"id"},{"location":"reference/models/#djstripe.models.connect.CountrySpec.stripe_class","text":"","title":"stripe_class"},{"location":"reference/models/#djstripe.models.connect.CountrySpec.supported_bank_account_currencies","text":"","title":"supported_bank_account_currencies"},{"location":"reference/models/#djstripe.models.connect.CountrySpec.supported_payment_currencies","text":"","title":"supported_payment_currencies"},{"location":"reference/models/#djstripe.models.connect.CountrySpec.supported_payment_methods","text":"","title":"supported_payment_methods"},{"location":"reference/models/#djstripe.models.connect.CountrySpec.supported_transfer_countries","text":"","title":"supported_transfer_countries"},{"location":"reference/models/#djstripe.models.connect.CountrySpec.verification_fields","text":"","title":"verification_fields"},{"location":"reference/models/#djstripe.models.connect.CountrySpec-functions","text":"","title":"Functions"},{"location":"reference/models/#djstripe.models.connect.CountrySpec.api_retrieve","text":"Source code in djstripe/models/connect.py 163 164 165 166 167 168 169 170 171 172 def api_retrieve ( self , api_key : str = None , stripe_account = None ): if api_key is None : api_key = djstripe_settings . get_default_api_key ( livemode = None ) return self . stripe_class . retrieve ( id = self . id , api_key = api_key , stripe_version = djstripe_settings . STRIPE_API_VERSION , stripe_account = stripe_account , )","title":"api_retrieve()"},{"location":"reference/models/#djstripe.models.connect.CountrySpec.sync_from_stripe_data","text":"Syncs this object from the stripe data provided. Foreign keys will also be retrieved and synced recursively. :param data: stripe object :type data: dict :rtype: cls Source code in djstripe/models/connect.py 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 @classmethod def sync_from_stripe_data ( cls , data , api_key = djstripe_settings . STRIPE_SECRET_KEY ) -> \"CountrySpec\" : \"\"\" Syncs this object from the stripe data provided. Foreign keys will also be retrieved and synced recursively. :param data: stripe object :type data: dict :rtype: cls \"\"\" data_id = data [ \"id\" ] supported_fields = ( \"default_currency\" , \"supported_bank_account_currencies\" , \"supported_payment_currencies\" , \"supported_payment_methods\" , \"supported_transfer_countries\" , \"verification_fields\" , ) instance , created = cls . objects . get_or_create ( id = data_id , defaults = { k : data [ k ] for k in supported_fields }, ) return instance","title":"sync_from_stripe_data()"},{"location":"reference/models/#djstripe.models.connect.Transfer","text":"Bases: StripeModel When Stripe sends you money or you initiate a transfer to a bank account, debit card, or connected Stripe account, a transfer object will be created. Stripe documentation: https://stripe.com/docs/api?lang=python#transfers Source code in djstripe/models/connect.py 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 class Transfer ( StripeModel ): \"\"\" When Stripe sends you money or you initiate a transfer to a bank account, debit card, or connected Stripe account, a transfer object will be created. Stripe documentation: https://stripe.com/docs/api?lang=python#transfers \"\"\" stripe_class = stripe . Transfer expand_fields = [ \"balance_transaction\" ] stripe_dashboard_item_name = \"transfers\" objects = TransferManager () amount = StripeDecimalCurrencyAmountField ( help_text = \"The amount transferred\" ) amount_reversed = StripeDecimalCurrencyAmountField ( null = True , blank = True , help_text = \"The amount (as decimal) reversed (can be less than the amount \" \"attribute on the transfer if a partial reversal was issued).\" , ) balance_transaction = StripeForeignKey ( \"BalanceTransaction\" , on_delete = models . SET_NULL , null = True , blank = True , help_text = \"Balance transaction that describes the impact on your account\" \" balance.\" , ) currency = StripeCurrencyCodeField () destination = StripeIdField ( max_length = 255 , null = True , help_text = \"ID of the bank account, card, or Stripe account the transfer was sent to.\" , ) # todo implement payment model (for some reason py ids are showing up in the charge model) destination_payment = StripeIdField ( null = True , blank = True , help_text = \"If the destination is a Stripe account, this will be the ID of the \" \"payment that the destination account received for the transfer.\" , ) reversed = models . BooleanField ( default = False , help_text = \"Whether or not the transfer has been fully reversed. \" \"If the transfer is only partially reversed, this attribute will still \" \"be false.\" , ) source_transaction = StripeIdField ( null = True , help_text = \"ID of the charge (or other transaction) that was used to fund \" \"the transfer. If null, the transfer was funded from the available balance.\" , ) source_type = StripeEnumField ( enum = enums . LegacySourceType , help_text = \"The source balance from which this transfer came.\" , ) transfer_group = models . CharField ( max_length = 255 , default = \"\" , blank = True , help_text = \"A string that identifies this transaction as part of a group.\" , ) @property def fee ( self ): if self . balance_transaction : return self . balance_transaction . fee def __str__ ( self ): amount = get_friendly_currency_amount ( self . amount , self . currency ) if self . reversed : # Complete Reversal return f \" { amount } Reversed\" elif self . amount_reversed : # Partial Reversal return f \" { amount } Partially Reversed\" # No Reversal return f \" { amount } \" def _attach_objects_post_save_hook ( self , cls , data , api_key = djstripe_settings . STRIPE_SECRET_KEY , pending_relations = None , ): \"\"\" Iterate over reversals on the Transfer object to create and/or sync TransferReversal objects \"\"\" super () . _attach_objects_post_save_hook ( cls , data , api_key = api_key , pending_relations = pending_relations ) # Transfer Reversals exist as a list on the Transfer Object for reversals_data in data . get ( \"reversals\" ) . auto_paging_iter (): TransferReversal . sync_from_stripe_data ( reversals_data , api_key = api_key ) def get_stripe_dashboard_url ( self ) -> str : return ( f \" { self . _get_base_stripe_dashboard_url () } \" f \"connect/ { self . stripe_dashboard_item_name } / { self . id } \" )","title":"Transfer"},{"location":"reference/models/#djstripe.models.connect.Transfer-attributes","text":"","title":"Attributes"},{"location":"reference/models/#djstripe.models.connect.Transfer.amount","text":"","title":"amount"},{"location":"reference/models/#djstripe.models.connect.Transfer.amount_reversed","text":"","title":"amount_reversed"},{"location":"reference/models/#djstripe.models.connect.Transfer.balance_transaction","text":"","title":"balance_transaction"},{"location":"reference/models/#djstripe.models.connect.Transfer.currency","text":"","title":"currency"},{"location":"reference/models/#djstripe.models.connect.Transfer.destination","text":"","title":"destination"},{"location":"reference/models/#djstripe.models.connect.Transfer.destination_payment","text":"","title":"destination_payment"},{"location":"reference/models/#djstripe.models.connect.Transfer.expand_fields","text":"","title":"expand_fields"},{"location":"reference/models/#djstripe.models.connect.Transfer.fee","text":"","title":"fee"},{"location":"reference/models/#djstripe.models.connect.Transfer.objects","text":"","title":"objects"},{"location":"reference/models/#djstripe.models.connect.Transfer.reversed","text":"","title":"reversed"},{"location":"reference/models/#djstripe.models.connect.Transfer.source_transaction","text":"","title":"source_transaction"},{"location":"reference/models/#djstripe.models.connect.Transfer.source_type","text":"","title":"source_type"},{"location":"reference/models/#djstripe.models.connect.Transfer.stripe_class","text":"","title":"stripe_class"},{"location":"reference/models/#djstripe.models.connect.Transfer.stripe_dashboard_item_name","text":"","title":"stripe_dashboard_item_name"},{"location":"reference/models/#djstripe.models.connect.Transfer.transfer_group","text":"","title":"transfer_group"},{"location":"reference/models/#djstripe.models.connect.Transfer-functions","text":"","title":"Functions"},{"location":"reference/models/#djstripe.models.connect.Transfer.__str__","text":"Source code in djstripe/models/connect.py 246 247 248 249 250 251 252 253 254 255 def __str__ ( self ): amount = get_friendly_currency_amount ( self . amount , self . currency ) if self . reversed : # Complete Reversal return f \" { amount } Reversed\" elif self . amount_reversed : # Partial Reversal return f \" { amount } Partially Reversed\" # No Reversal return f \" { amount } \"","title":"__str__()"},{"location":"reference/models/#djstripe.models.connect.Transfer.get_stripe_dashboard_url","text":"Source code in djstripe/models/connect.py 277 278 279 280 281 def get_stripe_dashboard_url ( self ) -> str : return ( f \" { self . _get_base_stripe_dashboard_url () } \" f \"connect/ { self . stripe_dashboard_item_name } / { self . id } \" )","title":"get_stripe_dashboard_url()"},{"location":"reference/models/#djstripe.models.connect.TransferReversal","text":"Bases: StripeModel Stripe documentation: https://stripe.com/docs/api?lang=python#transfer_reversals Source code in djstripe/models/connect.py 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 class TransferReversal ( StripeModel ): \"\"\" Stripe documentation: https://stripe.com/docs/api?lang=python#transfer_reversals \"\"\" expand_fields = [ \"balance_transaction\" , \"transfer\" ] stripe_dashboard_item_name = \"transfer_reversals\" # TransferReversal classmethods are derived from # and attached to the stripe.Transfer class stripe_class = stripe . Transfer amount = StripeQuantumCurrencyAmountField ( help_text = \"Amount, in cents.\" ) balance_transaction = StripeForeignKey ( \"BalanceTransaction\" , on_delete = models . SET_NULL , null = True , blank = True , related_name = \"transfer_reversals\" , help_text = \"Balance transaction that describes the impact on your account \" \"balance.\" , ) currency = StripeCurrencyCodeField () transfer = StripeForeignKey ( \"Transfer\" , on_delete = models . CASCADE , help_text = \"The transfer that was reversed.\" , related_name = \"reversals\" , ) def __str__ ( self ): return str ( self . transfer ) @classmethod def _api_create ( cls , api_key = djstripe_settings . STRIPE_SECRET_KEY , ** kwargs ): \"\"\" Call the stripe API's create operation for this model. :param api_key: The api key to use for this request. \\ Defaults to djstripe_settings.STRIPE_SECRET_KEY. :type api_key: string \"\"\" if not kwargs . get ( \"id\" ): raise KeyError ( \"Transfer Object ID is missing\" ) try : Transfer . objects . get ( id = kwargs [ \"id\" ]) except Transfer . DoesNotExist : raise return stripe . Transfer . create_reversal ( api_key = api_key , stripe_version = djstripe_settings . STRIPE_API_VERSION , ** kwargs , ) def api_retrieve ( self , api_key = None , stripe_account = None ): \"\"\" Call the stripe API's retrieve operation for this model. :param api_key: The api key to use for this request. \\ Defaults to djstripe_settings.STRIPE_SECRET_KEY. :type api_key: string :param stripe_account: The optional connected account \\ for which this request is being made. :type stripe_account: string \"\"\" nested_id = self . id id = self . transfer . id # Prefer passed in stripe_account if set. if not stripe_account : stripe_account = self . _get_stripe_account_id ( api_key ) return stripe . Transfer . retrieve_reversal ( id = id , nested_id = nested_id , api_key = api_key or self . default_api_key , stripe_version = djstripe_settings . STRIPE_API_VERSION , expand = self . expand_fields , stripe_account = stripe_account , ) @classmethod def api_list ( cls , api_key = djstripe_settings . STRIPE_SECRET_KEY , ** kwargs ): \"\"\" Call the stripe API's list operation for this model. :param api_key: The api key to use for this request. \\ Defaults to djstripe_settings.STRIPE_SECRET_KEY. :type api_key: string See Stripe documentation for accepted kwargs for each object. :returns: an iterator over all items in the query \"\"\" return stripe . Transfer . list_reversals ( api_key = api_key , stripe_version = djstripe_settings . STRIPE_API_VERSION , ** kwargs , ) . auto_paging_iter () @classmethod def is_valid_object ( cls , data ): \"\"\" Returns whether the data is a valid object for the class \"\"\" return data and data . get ( \"object\" ) == \"transfer_reversal\"","title":"TransferReversal"},{"location":"reference/models/#djstripe.models.connect.TransferReversal-attributes","text":"","title":"Attributes"},{"location":"reference/models/#djstripe.models.connect.TransferReversal.amount","text":"","title":"amount"},{"location":"reference/models/#djstripe.models.connect.TransferReversal.balance_transaction","text":"","title":"balance_transaction"},{"location":"reference/models/#djstripe.models.connect.TransferReversal.currency","text":"","title":"currency"},{"location":"reference/models/#djstripe.models.connect.TransferReversal.expand_fields","text":"","title":"expand_fields"},{"location":"reference/models/#djstripe.models.connect.TransferReversal.stripe_class","text":"","title":"stripe_class"},{"location":"reference/models/#djstripe.models.connect.TransferReversal.stripe_dashboard_item_name","text":"","title":"stripe_dashboard_item_name"},{"location":"reference/models/#djstripe.models.connect.TransferReversal.transfer","text":"","title":"transfer"},{"location":"reference/models/#djstripe.models.connect.TransferReversal-functions","text":"","title":"Functions"},{"location":"reference/models/#djstripe.models.connect.TransferReversal.__str__","text":"Source code in djstripe/models/connect.py 315 316 def __str__ ( self ): return str ( self . transfer )","title":"__str__()"},{"location":"reference/models/#djstripe.models.connect.TransferReversal.api_list","text":"Call the stripe API's list operation for this model. :param api_key: The api key to use for this request. Defaults to djstripe_settings.STRIPE_SECRET_KEY. :type api_key: string See Stripe documentation for accepted kwargs for each object. :returns: an iterator over all items in the query Source code in djstripe/models/connect.py 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 @classmethod def api_list ( cls , api_key = djstripe_settings . STRIPE_SECRET_KEY , ** kwargs ): \"\"\" Call the stripe API's list operation for this model. :param api_key: The api key to use for this request. \\ Defaults to djstripe_settings.STRIPE_SECRET_KEY. :type api_key: string See Stripe documentation for accepted kwargs for each object. :returns: an iterator over all items in the query \"\"\" return stripe . Transfer . list_reversals ( api_key = api_key , stripe_version = djstripe_settings . STRIPE_API_VERSION , ** kwargs , ) . auto_paging_iter ()","title":"api_list()"},{"location":"reference/models/#djstripe.models.connect.TransferReversal.api_retrieve","text":"Call the stripe API's retrieve operation for this model. :param api_key: The api key to use for this request. Defaults to djstripe_settings.STRIPE_SECRET_KEY. :type api_key: string :param stripe_account: The optional connected account for which this request is being made. :type stripe_account: string Source code in djstripe/models/connect.py 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 def api_retrieve ( self , api_key = None , stripe_account = None ): \"\"\" Call the stripe API's retrieve operation for this model. :param api_key: The api key to use for this request. \\ Defaults to djstripe_settings.STRIPE_SECRET_KEY. :type api_key: string :param stripe_account: The optional connected account \\ for which this request is being made. :type stripe_account: string \"\"\" nested_id = self . id id = self . transfer . id # Prefer passed in stripe_account if set. if not stripe_account : stripe_account = self . _get_stripe_account_id ( api_key ) return stripe . Transfer . retrieve_reversal ( id = id , nested_id = nested_id , api_key = api_key or self . default_api_key , stripe_version = djstripe_settings . STRIPE_API_VERSION , expand = self . expand_fields , stripe_account = stripe_account , )","title":"api_retrieve()"},{"location":"reference/models/#djstripe.models.connect.TransferReversal.is_valid_object","text":"Returns whether the data is a valid object for the class Source code in djstripe/models/connect.py 383 384 385 386 387 388 @classmethod def is_valid_object ( cls , data ): \"\"\" Returns whether the data is a valid object for the class \"\"\" return data and data . get ( \"object\" ) == \"transfer_reversal\"","title":"is_valid_object()"},{"location":"reference/models/#djstripe.models.connect-functions","text":"","title":"Functions"},{"location":"reference/models/#fraud","text":"","title":"Fraud"},{"location":"reference/models/#orders","text":"","title":"Orders"},{"location":"reference/models/#djstripe.models.orders-attributes","text":"","title":"Attributes"},{"location":"reference/models/#djstripe.models.orders-classes","text":"","title":"Classes"},{"location":"reference/models/#djstripe.models.orders.Order","text":"Bases: StripeModel An Order describes a purchase being made by a customer, including the products & quantities being purchased, the order status, the payment information, and the billing/shipping details. Stripe documentation: https://stripe.com/docs/api/orders_v2/object?lang=python Source code in djstripe/models/orders.py 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 class Order ( StripeModel ): \"\"\" An Order describes a purchase being made by a customer, including the products & quantities being purchased, the order status, the payment information, and the billing/shipping details. Stripe documentation: https://stripe.com/docs/api/orders_v2/object?lang=python \"\"\" stripe_class = stripe . Order expand_fields = [ \"customer\" , \"line_items\" , \"discounts\" , \"total_details.breakdown\" ] stripe_dashboard_item_name = \"orders\" amount_subtotal = StripeQuantumCurrencyAmountField ( help_text = \"Order cost before any discounts or taxes are applied. A positive integer representing the subtotal of the order in the smallest currency unit (e.g., 100 cents to charge $1.00 or 100 to charge \u00a5100, a zero-decimal currency).\" ) amount_total = StripeQuantumCurrencyAmountField ( help_text = \"Total order cost after discounts and taxes are applied. A positive integer representing the cost of the order in the smallest currency unit (e.g., 100 cents to charge $1.00 or 100 to charge \u00a5100, a zero-decimal currency). To submit an order, the total must be either 0 or at least $0.50 USD or equivalent in charge currency.\" ) application = models . CharField ( max_length = 255 , blank = True , help_text = \"ID of the Connect application that created the Order, if any.\" , ) automatic_tax = JSONField ( help_text = \"Settings and latest results for automatic tax lookup for this Order.\" ) billing_details = JSONField ( null = True , blank = True , help_text = \"Customer billing details associated with the order.\" , ) client_secret = models . TextField ( max_length = 5000 , help_text = ( \"The client secret of this PaymentIntent. \" \"Used for client-side retrieval using a publishable key.\" ), ) currency = StripeCurrencyCodeField ( help_text = \"Three-letter ISO currency code, in lowercase. Must be a supported currency.\" ) # not deleting order when customer is deleted, because order may be important for taxation and audit purposes customer = StripeForeignKey ( \"Customer\" , on_delete = models . SET_NULL , null = True , blank = True , help_text = \"The customer which this orders belongs to.\" , ) discounts = JSONField ( null = True , blank = True , help_text = \"The discounts applied to the order.\" , ) ip_address = models . GenericIPAddressField ( null = True , blank = True , help_text = \"A recent IP address of the purchaser used for tax reporting and tax location inference.\" , ) line_items = JSONField ( help_text = \"A list of line items the customer is ordering. Each line item includes information about the product, the quantity, and the resulting cost. There is a maximum of 100 line items.\" , ) payment = JSONField ( help_text = \"Payment information associated with the order. Includes payment status, settings, and a PaymentIntent ID\" , ) payment_intent = StripeForeignKey ( \"PaymentIntent\" , on_delete = models . SET_NULL , null = True , blank = True , help_text = \"ID of the payment intent associated with this order. Null when the order is open.\" , ) shipping_cost = JSONField ( null = True , blank = True , help_text = \"The details of the customer cost of shipping, including the customer chosen ShippingRate.\" , ) shipping_details = JSONField ( null = True , blank = True , help_text = \"Customer shipping information associated with the order.\" , ) status = StripeEnumField ( enum = OrderStatus , help_text = \"The overall status of the order.\" ) tax_details = JSONField ( null = True , blank = True , help_text = \"Tax details about the purchaser for this order.\" , ) total_details = JSONField ( help_text = \"Tax, discount, and shipping details for the computed total amount of this order.\" , ) def __str__ ( self ): template = f \"on { self . created . strftime ( '%m/ %d /%Y' ) } ( { self . status } )\" if self . status in ( OrderStatus . open , OrderStatus . canceled ): return \"Created \" + template elif self . status in ( OrderStatus . submitted , OrderStatus . complete , OrderStatus . processing , ): return \"Placed \" + template return self . id @classmethod def _manipulate_stripe_object_hook ( cls , data ): data [ \"payment_intent\" ] = data [ \"payment\" ][ \"payment_intent\" ] return data def _attach_objects_post_save_hook ( self , cls , data , api_key = djstripe_settings . STRIPE_SECRET_KEY , pending_relations = None , ): super () . _attach_objects_post_save_hook ( cls , data , api_key = api_key , pending_relations = pending_relations ) # sync every discount for discount in self . discounts : Discount . sync_from_stripe_data ( discount , api_key = api_key ) def cancel ( self , api_key = None , stripe_account = None , ** kwargs ): \"\"\" Cancels the order as well as the payment intent if one is attached. :param api_key: The api key to use for this request. \\ Defaults to djstripe_settings.STRIPE_SECRET_KEY. :type api_key: string :param stripe_account: The optional connected account \\ for which this request is being made. :type stripe_account: string \"\"\" api_key = api_key or self . default_api_key # Prefer passed in stripe_account if set. if not stripe_account : stripe_account = self . _get_stripe_account_id ( api_key ) return self . stripe_class . cancel ( self . id , api_key = api_key , stripe_account = stripe_account , stripe_version = djstripe_settings . STRIPE_API_VERSION , ** kwargs , ) def reopen ( self , api_key = None , stripe_account = None , ** kwargs ): \"\"\" Reopens a submitted order. :param api_key: The api key to use for this request. \\ Defaults to djstripe_settings.STRIPE_SECRET_KEY. :type api_key: string :param stripe_account: The optional connected account \\ for which this request is being made. :type stripe_account: string \"\"\" api_key = api_key or self . default_api_key # Prefer passed in stripe_account if set. if not stripe_account : stripe_account = self . _get_stripe_account_id ( api_key ) return self . stripe_class . reopen ( self . id , api_key = api_key , stripe_account = stripe_account , stripe_version = djstripe_settings . STRIPE_API_VERSION , ** kwargs , ) def submit ( self , api_key = None , stripe_account = None , ** kwargs ): \"\"\" Submitting an Order transitions the status to processing and creates a PaymentIntent object so the order can be paid. If the Order has an amount_total of 0, no PaymentIntent object will be created. Once the order is submitted, its contents cannot be changed, unless the reopen method is called. :param api_key: The api key to use for this request. \\ Defaults to djstripe_settings.STRIPE_SECRET_KEY. :type api_key: string :param stripe_account: The optional connected account \\ for which this request is being made. :type stripe_account: string \"\"\" api_key = api_key or self . default_api_key # Prefer passed in stripe_account if set. if not stripe_account : stripe_account = self . _get_stripe_account_id ( api_key ) return self . stripe_class . submit ( self . id , api_key = api_key , stripe_account = stripe_account , stripe_version = djstripe_settings . STRIPE_API_VERSION , ** kwargs , )","title":"Order"},{"location":"reference/models/#djstripe.models.orders.Order-attributes","text":"","title":"Attributes"},{"location":"reference/models/#djstripe.models.orders.Order.amount_subtotal","text":"","title":"amount_subtotal"},{"location":"reference/models/#djstripe.models.orders.Order.amount_total","text":"","title":"amount_total"},{"location":"reference/models/#djstripe.models.orders.Order.application","text":"","title":"application"},{"location":"reference/models/#djstripe.models.orders.Order.automatic_tax","text":"","title":"automatic_tax"},{"location":"reference/models/#djstripe.models.orders.Order.billing_details","text":"","title":"billing_details"},{"location":"reference/models/#djstripe.models.orders.Order.client_secret","text":"","title":"client_secret"},{"location":"reference/models/#djstripe.models.orders.Order.currency","text":"","title":"currency"},{"location":"reference/models/#djstripe.models.orders.Order.customer","text":"","title":"customer"},{"location":"reference/models/#djstripe.models.orders.Order.discounts","text":"","title":"discounts"},{"location":"reference/models/#djstripe.models.orders.Order.expand_fields","text":"","title":"expand_fields"},{"location":"reference/models/#djstripe.models.orders.Order.ip_address","text":"","title":"ip_address"},{"location":"reference/models/#djstripe.models.orders.Order.line_items","text":"","title":"line_items"},{"location":"reference/models/#djstripe.models.orders.Order.payment","text":"","title":"payment"},{"location":"reference/models/#djstripe.models.orders.Order.payment_intent","text":"","title":"payment_intent"},{"location":"reference/models/#djstripe.models.orders.Order.shipping_cost","text":"","title":"shipping_cost"},{"location":"reference/models/#djstripe.models.orders.Order.shipping_details","text":"","title":"shipping_details"},{"location":"reference/models/#djstripe.models.orders.Order.status","text":"","title":"status"},{"location":"reference/models/#djstripe.models.orders.Order.stripe_class","text":"","title":"stripe_class"},{"location":"reference/models/#djstripe.models.orders.Order.stripe_dashboard_item_name","text":"","title":"stripe_dashboard_item_name"},{"location":"reference/models/#djstripe.models.orders.Order.tax_details","text":"","title":"tax_details"},{"location":"reference/models/#djstripe.models.orders.Order.total_details","text":"","title":"total_details"},{"location":"reference/models/#djstripe.models.orders.Order-functions","text":"","title":"Functions"},{"location":"reference/models/#djstripe.models.orders.Order.__str__","text":"Source code in djstripe/models/orders.py 114 115 116 117 118 119 120 121 122 123 124 def __str__ ( self ): template = f \"on { self . created . strftime ( '%m/ %d /%Y' ) } ( { self . status } )\" if self . status in ( OrderStatus . open , OrderStatus . canceled ): return \"Created \" + template elif self . status in ( OrderStatus . submitted , OrderStatus . complete , OrderStatus . processing , ): return \"Placed \" + template return self . id","title":"__str__()"},{"location":"reference/models/#djstripe.models.orders.Order.cancel","text":"Cancels the order as well as the payment intent if one is attached. :param api_key: The api key to use for this request. Defaults to djstripe_settings.STRIPE_SECRET_KEY. :type api_key: string :param stripe_account: The optional connected account for which this request is being made. :type stripe_account: string Source code in djstripe/models/orders.py 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 def cancel ( self , api_key = None , stripe_account = None , ** kwargs ): \"\"\" Cancels the order as well as the payment intent if one is attached. :param api_key: The api key to use for this request. \\ Defaults to djstripe_settings.STRIPE_SECRET_KEY. :type api_key: string :param stripe_account: The optional connected account \\ for which this request is being made. :type stripe_account: string \"\"\" api_key = api_key or self . default_api_key # Prefer passed in stripe_account if set. if not stripe_account : stripe_account = self . _get_stripe_account_id ( api_key ) return self . stripe_class . cancel ( self . id , api_key = api_key , stripe_account = stripe_account , stripe_version = djstripe_settings . STRIPE_API_VERSION , ** kwargs , )","title":"cancel()"},{"location":"reference/models/#djstripe.models.orders.Order.reopen","text":"Reopens a submitted order. :param api_key: The api key to use for this request. Defaults to djstripe_settings.STRIPE_SECRET_KEY. :type api_key: string :param stripe_account: The optional connected account for which this request is being made. :type stripe_account: string Source code in djstripe/models/orders.py 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 def reopen ( self , api_key = None , stripe_account = None , ** kwargs ): \"\"\" Reopens a submitted order. :param api_key: The api key to use for this request. \\ Defaults to djstripe_settings.STRIPE_SECRET_KEY. :type api_key: string :param stripe_account: The optional connected account \\ for which this request is being made. :type stripe_account: string \"\"\" api_key = api_key or self . default_api_key # Prefer passed in stripe_account if set. if not stripe_account : stripe_account = self . _get_stripe_account_id ( api_key ) return self . stripe_class . reopen ( self . id , api_key = api_key , stripe_account = stripe_account , stripe_version = djstripe_settings . STRIPE_API_VERSION , ** kwargs , )","title":"reopen()"},{"location":"reference/models/#djstripe.models.orders.Order.submit","text":"Submitting an Order transitions the status to processing and creates a PaymentIntent object so the order can be paid. If the Order has an amount_total of 0, no PaymentIntent object will be created. Once the order is submitted, its contents cannot be changed, unless the reopen method is called. :param api_key: The api key to use for this request. Defaults to djstripe_settings.STRIPE_SECRET_KEY. :type api_key: string :param stripe_account: The optional connected account for which this request is being made. :type stripe_account: string Source code in djstripe/models/orders.py 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 def submit ( self , api_key = None , stripe_account = None , ** kwargs ): \"\"\" Submitting an Order transitions the status to processing and creates a PaymentIntent object so the order can be paid. If the Order has an amount_total of 0, no PaymentIntent object will be created. Once the order is submitted, its contents cannot be changed, unless the reopen method is called. :param api_key: The api key to use for this request. \\ Defaults to djstripe_settings.STRIPE_SECRET_KEY. :type api_key: string :param stripe_account: The optional connected account \\ for which this request is being made. :type stripe_account: string \"\"\" api_key = api_key or self . default_api_key # Prefer passed in stripe_account if set. if not stripe_account : stripe_account = self . _get_stripe_account_id ( api_key ) return self . stripe_class . submit ( self . id , api_key = api_key , stripe_account = stripe_account , stripe_version = djstripe_settings . STRIPE_API_VERSION , ** kwargs , )","title":"submit()"},{"location":"reference/models/#sigma","text":"","title":"Sigma"},{"location":"reference/models/#djstripe.models.sigma-classes","text":"","title":"Classes"},{"location":"reference/models/#djstripe.models.sigma.ScheduledQueryRun","text":"Bases: StripeModel Stripe documentation: https://stripe.com/docs/api?lang=python#scheduled_queries Source code in djstripe/models/sigma.py 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 class ScheduledQueryRun ( StripeModel ): \"\"\" Stripe documentation: https://stripe.com/docs/api?lang=python#scheduled_queries \"\"\" stripe_class = stripe . sigma . ScheduledQueryRun data_load_time = StripeDateTimeField ( help_text = \"When the query was run, Sigma contained a snapshot of your \" \"Stripe data at this time.\" ) error = JSONField ( null = True , blank = True , help_text = \"If the query run was not succeesful, contains information \" \"about the failure.\" , ) file = StripeForeignKey ( \"file\" , on_delete = models . SET_NULL , null = True , blank = True , help_text = \"The file object representing the results of the query.\" , ) result_available_until = StripeDateTimeField ( help_text = \"Time at which the result expires and is no longer available \" \"for download.\" ) sql = models . TextField ( max_length = 5000 , help_text = \"SQL for the query.\" ) status = StripeEnumField ( enum = enums . ScheduledQueryRunStatus , help_text = \"The query's execution status.\" ) title = models . TextField ( max_length = 5000 , help_text = \"Title of the query.\" ) # TODO Write corresponding test def __str__ ( self ): return f \" { self . title or self . id } ( { self . status } )\"","title":"ScheduledQueryRun"},{"location":"reference/models/#djstripe.models.sigma.ScheduledQueryRun-attributes","text":"","title":"Attributes"},{"location":"reference/models/#djstripe.models.sigma.ScheduledQueryRun.data_load_time","text":"","title":"data_load_time"},{"location":"reference/models/#djstripe.models.sigma.ScheduledQueryRun.error","text":"","title":"error"},{"location":"reference/models/#djstripe.models.sigma.ScheduledQueryRun.file","text":"","title":"file"},{"location":"reference/models/#djstripe.models.sigma.ScheduledQueryRun.result_available_until","text":"","title":"result_available_until"},{"location":"reference/models/#djstripe.models.sigma.ScheduledQueryRun.sql","text":"","title":"sql"},{"location":"reference/models/#djstripe.models.sigma.ScheduledQueryRun.status","text":"","title":"status"},{"location":"reference/models/#djstripe.models.sigma.ScheduledQueryRun.stripe_class","text":"","title":"stripe_class"},{"location":"reference/models/#djstripe.models.sigma.ScheduledQueryRun.title","text":"","title":"title"},{"location":"reference/models/#djstripe.models.sigma.ScheduledQueryRun-functions","text":"","title":"Functions"},{"location":"reference/models/#djstripe.models.sigma.ScheduledQueryRun.__str__","text":"Source code in djstripe/models/sigma.py 45 46 def __str__ ( self ): return f \" { self . title or self . id } ( { self . status } )\"","title":"__str__()"},{"location":"reference/models/#webhooks","text":"Module for dj-stripe Webhook models","title":"Webhooks"},{"location":"reference/models/#djstripe.models.webhooks-attributes","text":"","title":"Attributes"},{"location":"reference/models/#djstripe.models.webhooks-classes","text":"","title":"Classes"},{"location":"reference/models/#djstripe.models.webhooks.WebhookEndpoint","text":"Bases: StripeModel Source code in djstripe/models/webhooks.py 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 class WebhookEndpoint ( StripeModel ): stripe_class = stripe . WebhookEndpoint stripe_dashboard_item_name = \"webhooks\" api_version = models . CharField ( max_length = 64 , blank = True , help_text = \"The API version events are rendered as for this webhook endpoint. Defaults to the configured Stripe API Version.\" , ) enabled_events = JSONField ( help_text = ( \"The list of events to enable for this endpoint. \" \"['*'] indicates that all events are enabled, except those that require explicit selection.\" ) ) secret = models . CharField ( max_length = 256 , blank = True , editable = False , help_text = \"The endpoint's secret, used to generate webhook signatures.\" , ) status = StripeEnumField ( enum = WebhookEndpointStatus , help_text = \"The status of the webhook. It can be enabled or disabled.\" , ) url = models . URLField ( help_text = \"The URL of the webhook endpoint.\" , max_length = 2048 ) application = models . CharField ( max_length = 255 , blank = True , help_text = \"The ID of the associated Connect application.\" , ) djstripe_uuid = models . UUIDField ( null = True , unique = True , default = uuid4 , help_text = \"A UUID specific to dj-stripe generated for the endpoint\" , ) def __str__ ( self ): return self . url or str ( self . djstripe_uuid ) def _attach_objects_hook ( self , cls , data , current_ids = None , api_key = djstripe_settings . STRIPE_SECRET_KEY ): \"\"\" Gets called by this object's create and sync methods just before save. Use this to populate fields before the model is saved. \"\"\" super () . _attach_objects_hook ( cls , data , current_ids = current_ids , api_key = api_key ) self . djstripe_uuid = data . get ( \"metadata\" , {}) . get ( \"djstripe_uuid\" )","title":"WebhookEndpoint"},{"location":"reference/models/#djstripe.models.webhooks.WebhookEndpoint-attributes","text":"","title":"Attributes"},{"location":"reference/models/#djstripe.models.webhooks.WebhookEndpoint.api_version","text":"","title":"api_version"},{"location":"reference/models/#djstripe.models.webhooks.WebhookEndpoint.application","text":"","title":"application"},{"location":"reference/models/#djstripe.models.webhooks.WebhookEndpoint.djstripe_uuid","text":"","title":"djstripe_uuid"},{"location":"reference/models/#djstripe.models.webhooks.WebhookEndpoint.enabled_events","text":"","title":"enabled_events"},{"location":"reference/models/#djstripe.models.webhooks.WebhookEndpoint.secret","text":"","title":"secret"},{"location":"reference/models/#djstripe.models.webhooks.WebhookEndpoint.status","text":"","title":"status"},{"location":"reference/models/#djstripe.models.webhooks.WebhookEndpoint.stripe_class","text":"","title":"stripe_class"},{"location":"reference/models/#djstripe.models.webhooks.WebhookEndpoint.stripe_dashboard_item_name","text":"","title":"stripe_dashboard_item_name"},{"location":"reference/models/#djstripe.models.webhooks.WebhookEndpoint.url","text":"","title":"url"},{"location":"reference/models/#djstripe.models.webhooks.WebhookEndpoint-functions","text":"","title":"Functions"},{"location":"reference/models/#djstripe.models.webhooks.WebhookEndpoint.__str__","text":"Source code in djstripe/models/webhooks.py 63 64 def __str__ ( self ): return self . url or str ( self . djstripe_uuid )","title":"__str__()"},{"location":"reference/models/#djstripe.models.webhooks.WebhookEventTrigger","text":"Bases: models . Model An instance of a request that reached the server endpoint for Stripe webhooks. Webhook Events are initially UNTRUSTED , as it is possible for any web entity to post any data to our webhook url. Data posted may be valid Stripe information, garbage, or even malicious. The 'valid' flag in this model monitors this. Source code in djstripe/models/webhooks.py 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 class WebhookEventTrigger ( models . Model ): \"\"\" An instance of a request that reached the server endpoint for Stripe webhooks. Webhook Events are initially **UNTRUSTED**, as it is possible for any web entity to post any data to our webhook url. Data posted may be valid Stripe information, garbage, or even malicious. The 'valid' flag in this model monitors this. \"\"\" id = models . BigAutoField ( primary_key = True ) remote_ip = models . GenericIPAddressField ( help_text = \"IP address of the request client.\" ) headers = JSONField () body = models . TextField ( blank = True ) valid = models . BooleanField ( default = False , help_text = \"Whether or not the webhook event has passed validation\" , ) processed = models . BooleanField ( default = False , help_text = \"Whether or not the webhook event has been successfully processed\" , ) exception = models . CharField ( max_length = 128 , blank = True ) traceback = models . TextField ( blank = True , help_text = \"Traceback if an exception was thrown during processing\" ) event = StripeForeignKey ( \"Event\" , on_delete = models . SET_NULL , null = True , blank = True , help_text = \"Event object contained in the (valid) Webhook\" , ) djstripe_version = models . CharField ( max_length = 32 , default = _get_version , # Needs to be a callable, otherwise it's a db default. help_text = \"The version of dj-stripe when the webhook was received\" , ) created = models . DateTimeField ( auto_now_add = True ) updated = models . DateTimeField ( auto_now = True ) stripe_trigger_account = StripeForeignKey ( \"djstripe.Account\" , on_delete = models . CASCADE , to_field = \"id\" , null = True , blank = True , help_text = \"The Stripe Account this object belongs to.\" , ) webhook_endpoint = StripeForeignKey ( \"WebhookEndpoint\" , on_delete = models . SET_NULL , null = True , blank = True , help_text = \"The endpoint this webhook was received on\" , ) def __str__ ( self ): return f \"id= { self . id } , valid= { self . valid } , processed= { self . processed } \" @classmethod def from_request ( cls , request , * , webhook_endpoint : WebhookEndpoint = None ): \"\"\" Create, validate and process a WebhookEventTrigger given a Django request object. The process is three-fold: 1. Create a WebhookEventTrigger object from a Django request. 2. Validate the WebhookEventTrigger as a Stripe event using the API. 3. If valid, process it into an Event object (and child resource). \"\"\" try : body = request . body . decode ( request . encoding or \"utf-8\" ) except Exception : body = \"(error decoding body)\" ip = get_remote_ip ( request ) try : data = json . loads ( body ) except ValueError : data = {} if webhook_endpoint is None : stripe_account = StripeModel . _find_owner_account ( data = data ) secret = djstripe_settings . WEBHOOK_SECRET else : stripe_account = webhook_endpoint . djstripe_owner_account secret = webhook_endpoint . secret obj = cls . objects . create ( headers = dict ( request . headers ), body = body , remote_ip = ip , stripe_trigger_account = stripe_account , webhook_endpoint = webhook_endpoint , ) api_key = ( stripe_account . default_api_key or djstripe_settings . get_default_api_key ( obj . livemode ) ) try : # Validate the webhook first signals . webhook_pre_validate . send ( sender = cls , instance = obj ) obj . valid = obj . validate ( secret = secret , api_key = api_key ) signals . webhook_post_validate . send ( sender = cls , instance = obj , valid = obj . valid ) if obj . valid : signals . webhook_pre_process . send ( sender = cls , instance = obj ) if djstripe_settings . WEBHOOK_EVENT_CALLBACK : # If WEBHOOK_EVENT_CALLBACK, pass it for processing djstripe_settings . WEBHOOK_EVENT_CALLBACK ( obj , api_key = api_key ) else : # Process the item (do not save it, it'll get saved below) obj . process ( save = False , api_key = api_key ) signals . webhook_post_process . send ( sender = cls , instance = obj , api_key = api_key ) except Exception as e : max_length = cls . _meta . get_field ( \"exception\" ) . max_length obj . exception = str ( e )[: max_length ] obj . traceback = format_exc () # Send the exception as the webhook_processing_error signal signals . webhook_processing_error . send ( sender = cls , instance = obj , api_key = api_key , exception = e , data = getattr ( e , \"http_body\" , \"\" ), ) # re-raise the exception so Django sees it raise e finally : obj . save () return obj @cached_property def json_body ( self ): try : return json . loads ( self . body ) except ValueError : return {} @property def is_test_event ( self ): event_id = self . json_body . get ( \"id\" ) return event_id and event_id . endswith ( \"_00000000000000\" ) def verify_signature ( self , secret : str , tolerance : int = djstripe_settings . WEBHOOK_TOLERANCE ) -> bool : if not secret : raise ValueError ( \"Cannot verify event signature without a secret\" ) # HTTP headers are case-insensitive, but we store them as a dict. headers = CaseInsensitiveMapping ( self . headers ) signature = headers . get ( \"stripe-signature\" ) local_cli_signing_secret = headers . get ( \"x-djstripe-webhook-secret\" ) try : # check if the x-djstripe-webhook-secret Custom Header exists if local_cli_signing_secret : # Set Endpoint Signing Secret to the output of Stripe CLI # for signature verification secret = local_cli_signing_secret stripe . WebhookSignature . verify_header ( self . body , signature , secret , tolerance ) except stripe . error . SignatureVerificationError : logger . exception ( \"Failed to verify header\" ) return False else : return True def validate ( self , api_key : str = None , secret : str = djstripe_settings . WEBHOOK_SECRET , tolerance : int = djstripe_settings . WEBHOOK_TOLERANCE , validation_method = djstripe_settings . WEBHOOK_VALIDATION , ): \"\"\" The original contents of the Event message must be confirmed by refetching it and comparing the fetched data with the original data. This function makes an API call to Stripe to redownload the Event data and returns whether or not it matches the WebhookEventTrigger data. \"\"\" local_data = self . json_body if \"id\" not in local_data or \"livemode\" not in local_data : logger . error ( '\"id\" not in json body or \"livemode\" not in json body( %s )' , local_data ) return False if self . is_test_event : logger . info ( \"Test webhook received and discarded: %s \" , local_data ) return False if validation_method is None : # validation disabled warnings . warn ( \"WEBHOOK VALIDATION is disabled.\" ) return True elif validation_method == \"verify_signature\" : return self . verify_signature ( secret = secret ) livemode = local_data [ \"livemode\" ] api_key = api_key or djstripe_settings . get_default_api_key ( livemode ) # Retrieve the event using the api_version specified in itself remote_data = Event . stripe_class . retrieve ( id = local_data [ \"id\" ], api_key = api_key , stripe_version = local_data [ \"api_version\" ], ) return local_data [ \"data\" ] == remote_data [ \"data\" ] def process ( self , save = True , api_key : str = None ): # Reset traceback and exception in case of reprocessing self . exception = \"\" self . traceback = \"\" self . event = Event . process ( self . json_body , api_key = api_key ) self . processed = True if save : self . save () return self . event","title":"WebhookEventTrigger"},{"location":"reference/models/#djstripe.models.webhooks.WebhookEventTrigger-attributes","text":"","title":"Attributes"},{"location":"reference/models/#djstripe.models.webhooks.WebhookEventTrigger.body","text":"","title":"body"},{"location":"reference/models/#djstripe.models.webhooks.WebhookEventTrigger.created","text":"","title":"created"},{"location":"reference/models/#djstripe.models.webhooks.WebhookEventTrigger.djstripe_version","text":"","title":"djstripe_version"},{"location":"reference/models/#djstripe.models.webhooks.WebhookEventTrigger.event","text":"","title":"event"},{"location":"reference/models/#djstripe.models.webhooks.WebhookEventTrigger.exception","text":"","title":"exception"},{"location":"reference/models/#djstripe.models.webhooks.WebhookEventTrigger.headers","text":"","title":"headers"},{"location":"reference/models/#djstripe.models.webhooks.WebhookEventTrigger.id","text":"","title":"id"},{"location":"reference/models/#djstripe.models.webhooks.WebhookEventTrigger.is_test_event","text":"","title":"is_test_event"},{"location":"reference/models/#djstripe.models.webhooks.WebhookEventTrigger.processed","text":"","title":"processed"},{"location":"reference/models/#djstripe.models.webhooks.WebhookEventTrigger.remote_ip","text":"","title":"remote_ip"},{"location":"reference/models/#djstripe.models.webhooks.WebhookEventTrigger.stripe_trigger_account","text":"","title":"stripe_trigger_account"},{"location":"reference/models/#djstripe.models.webhooks.WebhookEventTrigger.traceback","text":"","title":"traceback"},{"location":"reference/models/#djstripe.models.webhooks.WebhookEventTrigger.updated","text":"","title":"updated"},{"location":"reference/models/#djstripe.models.webhooks.WebhookEventTrigger.valid","text":"","title":"valid"},{"location":"reference/models/#djstripe.models.webhooks.WebhookEventTrigger.webhook_endpoint","text":"","title":"webhook_endpoint"},{"location":"reference/models/#djstripe.models.webhooks.WebhookEventTrigger-functions","text":"","title":"Functions"},{"location":"reference/models/#djstripe.models.webhooks.WebhookEventTrigger.__str__","text":"Source code in djstripe/models/webhooks.py 170 171 def __str__ ( self ): return f \"id= { self . id } , valid= { self . valid } , processed= { self . processed } \"","title":"__str__()"},{"location":"reference/models/#djstripe.models.webhooks.WebhookEventTrigger.from_request","text":"Create, validate and process a WebhookEventTrigger given a Django request object. The process is three-fold: 1. Create a WebhookEventTrigger object from a Django request. 2. Validate the WebhookEventTrigger as a Stripe event using the API. 3. If valid, process it into an Event object (and child resource). Source code in djstripe/models/webhooks.py 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 @classmethod def from_request ( cls , request , * , webhook_endpoint : WebhookEndpoint = None ): \"\"\" Create, validate and process a WebhookEventTrigger given a Django request object. The process is three-fold: 1. Create a WebhookEventTrigger object from a Django request. 2. Validate the WebhookEventTrigger as a Stripe event using the API. 3. If valid, process it into an Event object (and child resource). \"\"\" try : body = request . body . decode ( request . encoding or \"utf-8\" ) except Exception : body = \"(error decoding body)\" ip = get_remote_ip ( request ) try : data = json . loads ( body ) except ValueError : data = {} if webhook_endpoint is None : stripe_account = StripeModel . _find_owner_account ( data = data ) secret = djstripe_settings . WEBHOOK_SECRET else : stripe_account = webhook_endpoint . djstripe_owner_account secret = webhook_endpoint . secret obj = cls . objects . create ( headers = dict ( request . headers ), body = body , remote_ip = ip , stripe_trigger_account = stripe_account , webhook_endpoint = webhook_endpoint , ) api_key = ( stripe_account . default_api_key or djstripe_settings . get_default_api_key ( obj . livemode ) ) try : # Validate the webhook first signals . webhook_pre_validate . send ( sender = cls , instance = obj ) obj . valid = obj . validate ( secret = secret , api_key = api_key ) signals . webhook_post_validate . send ( sender = cls , instance = obj , valid = obj . valid ) if obj . valid : signals . webhook_pre_process . send ( sender = cls , instance = obj ) if djstripe_settings . WEBHOOK_EVENT_CALLBACK : # If WEBHOOK_EVENT_CALLBACK, pass it for processing djstripe_settings . WEBHOOK_EVENT_CALLBACK ( obj , api_key = api_key ) else : # Process the item (do not save it, it'll get saved below) obj . process ( save = False , api_key = api_key ) signals . webhook_post_process . send ( sender = cls , instance = obj , api_key = api_key ) except Exception as e : max_length = cls . _meta . get_field ( \"exception\" ) . max_length obj . exception = str ( e )[: max_length ] obj . traceback = format_exc () # Send the exception as the webhook_processing_error signal signals . webhook_processing_error . send ( sender = cls , instance = obj , api_key = api_key , exception = e , data = getattr ( e , \"http_body\" , \"\" ), ) # re-raise the exception so Django sees it raise e finally : obj . save () return obj","title":"from_request()"},{"location":"reference/models/#djstripe.models.webhooks.WebhookEventTrigger.json_body","text":"Source code in djstripe/models/webhooks.py 256 257 258 259 260 261 @cached_property def json_body ( self ): try : return json . loads ( self . body ) except ValueError : return {}","title":"json_body()"},{"location":"reference/models/#djstripe.models.webhooks.WebhookEventTrigger.process","text":"Source code in djstripe/models/webhooks.py 339 340 341 342 343 344 345 346 347 348 349 def process ( self , save = True , api_key : str = None ): # Reset traceback and exception in case of reprocessing self . exception = \"\" self . traceback = \"\" self . event = Event . process ( self . json_body , api_key = api_key ) self . processed = True if save : self . save () return self . event","title":"process()"},{"location":"reference/models/#djstripe.models.webhooks.WebhookEventTrigger.validate","text":"The original contents of the Event message must be confirmed by refetching it and comparing the fetched data with the original data. This function makes an API call to Stripe to redownload the Event data and returns whether or not it matches the WebhookEventTrigger data. Source code in djstripe/models/webhooks.py 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 def validate ( self , api_key : str = None , secret : str = djstripe_settings . WEBHOOK_SECRET , tolerance : int = djstripe_settings . WEBHOOK_TOLERANCE , validation_method = djstripe_settings . WEBHOOK_VALIDATION , ): \"\"\" The original contents of the Event message must be confirmed by refetching it and comparing the fetched data with the original data. This function makes an API call to Stripe to redownload the Event data and returns whether or not it matches the WebhookEventTrigger data. \"\"\" local_data = self . json_body if \"id\" not in local_data or \"livemode\" not in local_data : logger . error ( '\"id\" not in json body or \"livemode\" not in json body( %s )' , local_data ) return False if self . is_test_event : logger . info ( \"Test webhook received and discarded: %s \" , local_data ) return False if validation_method is None : # validation disabled warnings . warn ( \"WEBHOOK VALIDATION is disabled.\" ) return True elif validation_method == \"verify_signature\" : return self . verify_signature ( secret = secret ) livemode = local_data [ \"livemode\" ] api_key = api_key or djstripe_settings . get_default_api_key ( livemode ) # Retrieve the event using the api_version specified in itself remote_data = Event . stripe_class . retrieve ( id = local_data [ \"id\" ], api_key = api_key , stripe_version = local_data [ \"api_version\" ], ) return local_data [ \"data\" ] == remote_data [ \"data\" ]","title":"validate()"},{"location":"reference/models/#djstripe.models.webhooks.WebhookEventTrigger.verify_signature","text":"Source code in djstripe/models/webhooks.py 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 def verify_signature ( self , secret : str , tolerance : int = djstripe_settings . WEBHOOK_TOLERANCE ) -> bool : if not secret : raise ValueError ( \"Cannot verify event signature without a secret\" ) # HTTP headers are case-insensitive, but we store them as a dict. headers = CaseInsensitiveMapping ( self . headers ) signature = headers . get ( \"stripe-signature\" ) local_cli_signing_secret = headers . get ( \"x-djstripe-webhook-secret\" ) try : # check if the x-djstripe-webhook-secret Custom Header exists if local_cli_signing_secret : # Set Endpoint Signing Secret to the output of Stripe CLI # for signature verification secret = local_cli_signing_secret stripe . WebhookSignature . verify_header ( self . body , signature , secret , tolerance ) except stripe . error . SignatureVerificationError : logger . exception ( \"Failed to verify header\" ) return False else : return True","title":"verify_signature()"},{"location":"reference/models/#djstripe.models.webhooks-functions","text":"","title":"Functions"},{"location":"reference/models/#djstripe.models.webhooks.get_remote_ip","text":"Given the HTTPRequest object return the IP Address of the client :param request: client request :type request: HTTPRequest :Returns: the client ip address Source code in djstripe/models/webhooks.py 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 def get_remote_ip ( request ): \"\"\"Given the HTTPRequest object return the IP Address of the client :param request: client request :type request: HTTPRequest :Returns: the client ip address \"\"\" # x-forwarded-for is relevant for django running behind a proxy x_forwarded_for = request . headers . get ( \"x-forwarded-for\" ) if x_forwarded_for : ip = x_forwarded_for . split ( \",\" )[ 0 ] else : ip = request . META . get ( \"REMOTE_ADDR\" ) if not ip : warnings . warn ( \"Could not determine remote IP (missing REMOTE_ADDR). \" \"This is likely an issue with your wsgi/server setup.\" ) ip = \"0.0.0.0\" return ip","title":"get_remote_ip()"},{"location":"reference/project/","text":"A Fake or multiple fakes for each stripe object. Originally collected using API VERSION 2015-07-28. Updated to API VERSION 2016-03-07 with bogus fields. Attributes tests . FAKE_ACCOUNT = { 'id' : 'acct_1032D82eZvKYlo2C' , 'object' : 'account' , 'business_profile' : { 'name' : 'dj-stripe' , 'support_email' : 'djstripe@example.com' , 'support_phone' : None , 'support_url' : 'https://djstripe.com/support/' , 'url' : 'https://djstripe.com' }, 'settings' : { 'branding' : { 'icon' : 'file_4hshrsKatMEEd6736724HYAXyj' , 'logo' : 'file_1E3fssKatMEEd6736724HYAXyj' , 'primary_color' : '#092e20' }, 'dashboard' : { 'display_name' : 'dj-stripe' , 'timezone' : 'Etc/UTC' }, 'payments' : { 'statement_descriptor' : 'DJSTRIPE' }}, 'charges_enabled' : True , 'country' : 'US' , 'default_currency' : 'usd' , 'details_submitted' : True , 'email' : 'djstripe@example.com' , 'payouts_enabled' : True , 'type' : 'standard' } module-attribute tests . FAKE_BALANCE_TRANSACTION = load_fixture ( 'balance_transaction_txn_fake_ch_fakefakefakefakefake0001.json' ) module-attribute tests . FAKE_BALANCE_TRANSACTION_II = { 'id' : 'txn_16g5h62eZvKYlo2CQ2AHA89s' , 'object' : 'balance_transaction' , 'amount' : 65400 , 'available_on' : 1441670400 , 'created' : 1441079064 , 'currency' : 'usd' , 'description' : None , 'fee' : 1927 , 'fee_details' : [{ 'amount' : 1927 , 'currency' : 'usd' , 'type' : 'stripe_fee' , 'description' : 'Stripe processing fees' , 'application' : None }], 'net' : 63473 , 'source' : 'ch_16g5h62eZvKYlo2CMRXkSqa0' , 'sourced_transfers' : { 'object' : 'list' , 'total_count' : 0 , 'has_more' : False , 'url' : '/v1/transfers?source_transaction=ch_16g5h62eZvKYlo2CMRXkSqa0' , 'data' : []}, 'status' : 'pending' , 'type' : 'charge' } module-attribute tests . FAKE_BALANCE_TRANSACTION_III = { 'id' : 'txn_16g5h62eZvKYlo2CQ2AHA89s' , 'object' : 'balance_transaction' , 'amount' : 2000 , 'available_on' : 1441670400 , 'created' : 1441079064 , 'currency' : 'usd' , 'description' : None , 'fee' : 1927 , 'fee_details' : [{ 'amount' : 1927 , 'currency' : 'usd' , 'type' : 'stripe_fee' , 'description' : 'Stripe processing fees' , 'application' : None }], 'net' : 73 , 'source' : 'ch_16g5h62eZvKYlo2CMRXkSqa0' , 'sourced_transfers' : { 'object' : 'list' , 'total_count' : 0 , 'has_more' : False , 'url' : '/v1/transfers?source_transaction=ch_16g5h62eZvKYlo2CMRXkSqa0' , 'data' : []}, 'status' : 'pending' , 'type' : 'charge' } module-attribute tests . FAKE_BALANCE_TRANSACTION_IV = { 'id' : 'txn_16g5h62eZvKYlo2CQ2AHA89s' , 'object' : 'balance_transaction' , 'amount' : 19010 , 'available_on' : 1441670400 , 'created' : 1441079064 , 'currency' : 'usd' , 'description' : None , 'fee' : 1927 , 'fee_details' : [{ 'amount' : 1927 , 'currency' : 'usd' , 'type' : 'stripe_fee' , 'description' : 'Stripe processing fees' , 'application' : None }], 'net' : 17083 , 'source' : 'ch_16g5h62eZvKYlo2CMRXkSqa0' , 'sourced_transfers' : { 'object' : 'list' , 'total_count' : 0 , 'has_more' : False , 'url' : '/v1/transfers?source_transaction=ch_16g5h62eZvKYlo2CMRXkSqa0' , 'data' : []}, 'status' : 'pending' , 'type' : 'charge' } module-attribute tests . FAKE_BALANCE_TRANSACTION_REFUND = { 'id' : 'txn_1E0he8KaGRDEd998TDswMZuN' , 'amount' : - 1 * FAKE_CHARGE_REFUNDED [ 'amount_refunded' ], 'available_on' : 1549425864 , 'created' : 1549425864 , 'currency' : 'usd' , 'description' : 'REFUND FOR CHARGE (Payment for invoice G432DF1C-0028)' , 'exchange_rate' : None , 'fee' : 0 , 'fee_details' : [], 'net' : - 1 * FAKE_CHARGE_REFUNDED [ 'amount_refunded' ], 'object' : 'balance_transaction' , 'source' : FAKE_REFUND [ 'id' ], 'status' : 'available' , 'type' : 'refund' } module-attribute tests . FAKE_BANK_ACCOUNT = { 'id' : 'ba_16hTzo2eZvKYlo2CeSjfb0tS' , 'object' : 'bank_account' , 'account_holder_name' : None , 'account_holder_type' : None , 'bank_name' : 'STRIPE TEST BANK' , 'country' : 'US' , 'currency' : 'usd' , 'fingerprint' : '1JWtPxqbdX5Gamtc' , 'last4' : '6789' , 'routing_number' : '110000000' , 'status' : 'new' } module-attribute tests . FAKE_BANK_ACCOUNT_II = { 'id' : 'ba_17O4Tz2eZvKYlo2CMYsxroV5' , 'object' : 'bank_account' , 'account_holder_name' : None , 'account_holder_type' : None , 'bank_name' : None , 'country' : 'US' , 'currency' : 'usd' , 'fingerprint' : '1JWtPxqbdX5Gamtc' , 'last4' : '6789' , 'routing_number' : '110000000' , 'status' : 'new' } module-attribute tests . FAKE_BANK_ACCOUNT_IV = BankAccountDict ( load_fixture ( 'bank_account_ba_fakefakefakefakefake0004.json' )) module-attribute tests . FAKE_BANK_ACCOUNT_SOURCE = BankAccountDict ( load_fixture ( 'bank_account_ba_fakefakefakefakefake0003.json' )) module-attribute tests . FAKE_CARD = CardDict ( load_fixture ( 'card_card_fakefakefakefakefake0001.json' )) module-attribute tests . FAKE_CARD_AS_PAYMENT_METHOD = PaymentMethodDict ( load_fixture ( 'payment_method_card_fakefakefakefakefake0001.json' )) module-attribute tests . FAKE_CARD_II = CardDict ( load_fixture ( 'card_card_fakefakefakefakefake0002.json' )) module-attribute tests . FAKE_CARD_III = CardDict ( load_fixture ( 'card_card_fakefakefakefakefake0003.json' )) module-attribute tests . FAKE_CARD_IV = CardDict ( load_fixture ( 'card_card_fakefakefakefakefake0004.json' )) module-attribute tests . FAKE_CHARGE = ChargeDict ( load_fixture ( 'charge_ch_fakefakefakefakefake0001.json' )) module-attribute tests . FAKE_CHARGE_II = ChargeDict ({ 'id' : 'ch_16ag432eZvKYlo2CGDe6lvVs' , 'object' : 'charge' , 'amount' : 3000 , 'amount_captured' : 0 , 'amount_refunded' : 0 , 'application_fee' : None , 'application_fee_amount' : None , 'balance_transaction' : FAKE_BALANCE_TRANSACTION [ 'id' ], 'billing_details' : { 'address' : { 'city' : None , 'country' : 'US' , 'line1' : None , 'line2' : None , 'postal_code' : '92082' , 'state' : None }, 'email' : 'kyoung@hotmail.com' , 'name' : 'John Foo' , 'phone' : None }, 'calculated_statement_descriptor' : 'Stripe' , 'captured' : False , 'created' : 1439788903 , 'currency' : 'usd' , 'customer' : 'cus_4UbFSo9tl62jqj' , 'description' : None , 'destination' : None , 'dispute' : None , 'disputed' : False , 'failure_code' : 'expired_card' , 'failure_message' : 'Your card has expired.' , 'fraud_details' : {}, 'invoice' : 'in_16af5A2eZvKYlo2CJjANLL81' , 'livemode' : False , 'metadata' : {}, 'on_behalf_of' : None , 'order' : None , 'outcome' : { 'network_status' : 'declined_by_network' , 'reason' : 'expired_card' , 'risk_level' : 'normal' , 'risk_score' : 1 , 'seller_message' : 'The bank returned the decline code `expired_card`.' , 'type' : 'issuer_declined' }, 'paid' : False , 'payment_intent' : FAKE_PAYMENT_INTENT_II [ 'id' ], 'payment_method' : FAKE_CARD_AS_PAYMENT_METHOD [ 'id' ], 'payment_method_details' : { 'card' : { 'brand' : 'visa' , 'checks' : { 'address_line1_check' : None , 'address_postal_code_check' : None , 'cvc_check' : None }, 'country' : 'US' , 'exp_month' : 6 , 'exp_year' : 2021 , 'fingerprint' : '88PuXw9tEmvYe69o' , 'funding' : 'credit' , 'installments' : None , 'last4' : '4242' , 'network' : 'visa' , 'three_d_secure' : None , 'wallet' : None }, 'type' : 'card' }, 'receipt_email' : None , 'receipt_number' : None , 'receipt_url' : None , 'refunded' : False , 'refunds' : { 'object' : 'list' , 'total_count' : 0 , 'has_more' : False , 'url' : '/v1/charges/ch_16ag432eZvKYlo2CGDe6lvVs/refunds' , 'data' : []}, 'review' : None , 'shipping' : None , 'source' : deepcopy ( FAKE_CARD_II ), 'source_transfer' : None , 'statement_descriptor' : None , 'statement_descriptor_suffix' : None , 'status' : 'failed' , 'transfer_data' : None , 'transfer_group' : None }) module-attribute tests . FAKE_CHARGE_REFUNDED = FAKE_CHARGE_REFUNDED . refund ( amount = FAKE_CHARGE_REFUNDED [ 'amount' ]) module-attribute tests . FAKE_COUPON = { 'id' : 'fake-coupon-1' , 'object' : 'coupon' , 'applies_to' : { 'products' : [ 'prod_fake1' ]}, 'amount_off' : None , 'created' : 1490157071 , 'currency' : None , 'duration' : 'once' , 'duration_in_months' : None , 'livemode' : False , 'max_redemptions' : None , 'metadata' : {}, 'percent_off' : 1 , 'redeem_by' : None , 'times_redeemed' : 0 , 'valid' : True } module-attribute tests . FAKE_CUSTOMER = CustomerDict ( load_fixture ( 'customer_cus_6lsBvm5rJ0zyHc.json' )) module-attribute tests . FAKE_CUSTOMER_II = CustomerDict ( load_fixture ( 'customer_cus_4UbFSo9tl62jqj.json' )) module-attribute tests . FAKE_CUSTOMER_III = CustomerDict ( load_fixture ( 'customer_cus_4QWKsZuuTHcs7X.json' )) module-attribute tests . FAKE_CUSTOMER_IV = CustomerDict ( load_fixture ( 'customer_cus_example_with_bank_account.json' )) module-attribute tests . FAKE_CUSTOM_ACCOUNT = AccountDict ( load_fixture ( 'account_custom_acct_1IuHosQveW0ONQsd.json' )) module-attribute tests . FAKE_DISCOUNT = { 'id' : 'di_fakefakefakefakefake0001' , 'object' : 'discount' , 'description' : '' , 'checkout_session' : None , 'coupon' : deepcopy ( FAKE_COUPON ), 'customer' : FAKE_CUSTOMER , 'end' : None , 'invoice' : None , 'invoice_item' : None , 'promotion_code' : '' , 'start' : 1493206114 , 'subscription' : 'sub_fakefakefakefakefake0001' } module-attribute tests . FAKE_DISCOUNT_CUSTOMER = { 'id' : 'di_fakefakefakefakefake0002' , 'object' : 'discount' , 'coupon' : deepcopy ( FAKE_COUPON ), 'customer' : deepcopy ( FAKE_CUSTOMER ), 'start' : 1493206114 , 'end' : None , 'subscription' : None } module-attribute tests . FAKE_DISPUTE_BALANCE_TRANSACTION = load_fixture ( 'dispute_txn_fakefakefakefake01.json' ) module-attribute tests . FAKE_DISPUTE_BALANCE_TRANSACTION_REFUND_FULL = deepcopy ( FAKE_DISPUTE_BALANCE_TRANSACTION ) module-attribute tests . FAKE_DISPUTE_BALANCE_TRANSACTION_REFUND_PARTIAL = deepcopy ( FAKE_DISPUTE_BALANCE_TRANSACTION ) module-attribute tests . FAKE_DISPUTE_CHARGE = load_fixture ( 'dispute_ch_fakefakefakefake01.json' ) module-attribute tests . FAKE_DISPUTE_I = load_fixture ( 'dispute_dp_fakefakefakefake01.json' ) module-attribute tests . FAKE_DISPUTE_II = load_fixture ( 'dispute_dp_fakefakefakefake02.json' ) module-attribute tests . FAKE_DISPUTE_III = deepcopy ( FAKE_DISPUTE_II ) module-attribute tests . FAKE_DISPUTE_IV = deepcopy ( FAKE_DISPUTE_II ) module-attribute tests . FAKE_DISPUTE_PAYMENT_INTENT = load_fixture ( 'dispute_pi_fakefakefakefake01.json' ) module-attribute tests . FAKE_DISPUTE_PAYMENT_METHOD = load_fixture ( 'dispute_pm_fakefakefakefake01.json' ) module-attribute tests . FAKE_DISPUTE_V_FULL = load_fixture ( 'dispute_dp_funds_reinstated_full.json' ) module-attribute tests . FAKE_DISPUTE_V_PARTIAL = load_fixture ( 'dispute_dp_funds_reinstated_full.json' ) module-attribute tests . FAKE_EVENT_ACCOUNT_APPLICATION_AUTHORIZED = dict ( load_fixture ( 'event_account_application_authorized.json' )) module-attribute tests . FAKE_EVENT_ACCOUNT_APPLICATION_DEAUTHORIZED = dict ( load_fixture ( 'event_account_application_deauthorized.json' )) module-attribute tests . FAKE_EVENT_ACCOUNT_EXTERNAL_ACCOUNT_BANK_ACCOUNT_CREATED = dict ( load_fixture ( 'event_external_account_bank_account_created.json' )) module-attribute tests . FAKE_EVENT_ACCOUNT_EXTERNAL_ACCOUNT_BANK_ACCOUNT_DELETED = dict ( load_fixture ( 'event_external_account_bank_account_deleted.json' )) module-attribute tests . FAKE_EVENT_ACCOUNT_EXTERNAL_ACCOUNT_BANK_ACCOUNT_UPDATED = dict ( load_fixture ( 'event_external_account_bank_account_updated.json' )) module-attribute tests . FAKE_EVENT_ACCOUNT_EXTERNAL_ACCOUNT_CARD_CREATED = dict ( load_fixture ( 'event_external_account_card_created.json' )) module-attribute tests . FAKE_EVENT_ACCOUNT_EXTERNAL_ACCOUNT_CARD_DELETED = dict ( load_fixture ( 'event_external_account_card_deleted.json' )) module-attribute tests . FAKE_EVENT_ACCOUNT_EXTERNAL_ACCOUNT_CARD_UPDATED = dict ( load_fixture ( 'event_external_account_card_updated.json' )) module-attribute tests . FAKE_EVENT_CARD_PAYMENT_METHOD_ATTACHED = { 'id' : 'evt_1FDOwDKatMEEd998o5Fghgfh' , 'object' : 'event' , 'api_version' : '2019-08-14' , 'created' : 1567228549 , 'data' : { 'object' : deepcopy ( FAKE_CARD_AS_PAYMENT_METHOD )}, 'livemode' : False , 'pending_webhooks' : 0 , 'request' : { 'id' : 'req_9c9djVqxUhgfh' , 'idempotency_key' : None }, 'type' : 'payment_method.attached' } module-attribute tests . FAKE_EVENT_CARD_PAYMENT_METHOD_DETACHED = { 'id' : 'evt_1FDOwDKatMEEd998o5435345' , 'object' : 'event' , 'api_version' : '2019-08-14' , 'created' : 1567228549 , 'data' : { 'object' : deepcopy ( FAKE_CARD_AS_PAYMENT_METHOD )}, 'livemode' : False , 'pending_webhooks' : 0 , 'request' : { 'id' : 'req_9c9djVqx6tgeg' , 'idempotency_key' : None }, 'type' : 'payment_method.detached' } module-attribute tests . FAKE_EVENT_CHARGE_SUCCEEDED = { 'id' : 'evt_16YKQi2eZvKYlo2CT2oe5ff3' , 'object' : 'event' , 'api_version' : '2016-03-07' , 'created' : 1439229084 , 'data' : { 'object' : deepcopy ( FAKE_CHARGE )}, 'livemode' : False , 'pending_webhooks' : 0 , 'request' : 'req_6lsB7hkicwhaDj' , 'type' : 'charge.succeeded' } module-attribute tests . FAKE_EVENT_CUSTOMER_CREATED = { 'id' : 'evt_38DHch3whaDvKYlo2CT2oe5ff3' , 'object' : 'event' , 'api_version' : '2016-03-07; orders_beta=v3' , 'created' : 1439229084 , 'data' : { 'object' : deepcopy ( FAKE_CUSTOMER )}, 'livemode' : False , 'pending_webhooks' : 0 , 'request' : 'req_6l38DHch3whaDj' , 'type' : 'customer.created' } module-attribute tests . FAKE_EVENT_CUSTOMER_DELETED = deepcopy ( FAKE_EVENT_CUSTOMER_CREATED ) module-attribute tests . FAKE_EVENT_CUSTOMER_DISCOUNT_CREATED = { 'id' : 'AGBWvF5zBm4sMCsLLPZrw9YY' , 'object' : 'event' , 'api_version' : '2018-05-21' , 'created' : 1439229084 , 'data' : { 'object' : deepcopy ( FAKE_DISCOUNT_CUSTOMER )}, 'livemode' : False , 'pending_webhooks' : 0 , 'request' : 'req_6l38DHch3whaDj' , 'type' : 'customer.discount.created' } module-attribute tests . FAKE_EVENT_CUSTOMER_DISCOUNT_DELETED = { 'id' : 'AGBWvF5zBm4sMCsLLPZrw9XX' , 'type' : 'customer.discount.deleted' , 'api_version' : '2017-02-14' , 'created' : 1439229084 , 'object' : 'event' , 'livemode' : False , 'pending_webhooks' : 0 , 'request' : 'req_6l38DHch3whaDj' , 'data' : { 'object' : deepcopy ( FAKE_DISCOUNT_CUSTOMER )}} module-attribute tests . FAKE_EVENT_CUSTOMER_SOURCE_CREATED = { 'id' : 'evt_DvKYlo38huDvKYlo2C7SXedrZk' , 'object' : 'event' , 'api_version' : '2016-03-07' , 'created' : 1439229084 , 'data' : { 'object' : deepcopy ( FAKE_CARD )}, 'livemode' : False , 'pending_webhooks' : 0 , 'request' : 'req_o3whaDvh3whaDj' , 'type' : 'customer.source.created' } module-attribute tests . FAKE_EVENT_CUSTOMER_SOURCE_DELETED = deepcopy ( FAKE_EVENT_CUSTOMER_SOURCE_CREATED ) module-attribute tests . FAKE_EVENT_CUSTOMER_SOURCE_DELETED_DUPE = deepcopy ( FAKE_EVENT_CUSTOMER_SOURCE_DELETED ) module-attribute tests . FAKE_EVENT_CUSTOMER_SUBSCRIPTION_CREATED = { 'id' : 'evt_38DHch3wHD2eZvKYlCT2oe5ff3' , 'object' : 'event' , 'api_version' : '2016-03-07' , 'created' : 1439229084 , 'data' : { 'object' : deepcopy ( FAKE_SUBSCRIPTION )}, 'livemode' : False , 'pending_webhooks' : 0 , 'request' : 'req_6l87IHch3diaDj' , 'type' : 'customer.subscription.created' } module-attribute tests . FAKE_EVENT_CUSTOMER_SUBSCRIPTION_DELETED = deepcopy ( FAKE_EVENT_CUSTOMER_SUBSCRIPTION_CREATED ) module-attribute tests . FAKE_EVENT_CUSTOMER_UPDATED = deepcopy ( FAKE_EVENT_CUSTOMER_CREATED ) module-attribute tests . FAKE_EVENT_CUSTOM_ACCOUNT_UPDATED = dict ( load_fixture ( 'event_account_updated_custom.json' )) module-attribute tests . FAKE_EVENT_DISPUTE_CLOSED = { 'id' : 'evt_1JAyTxJSZQVUcJYgNk1Jqu8o' , 'object' : 'event' , 'api_version' : '2020-08-27' , 'created' : 1439229084 , 'data' : { 'object' : deepcopy ( FAKE_DISPUTE_IV )}, 'livemode' : False , 'pending_webhooks' : 0 , 'request' : 'req_6lsB7hkicwhaDj' , 'type' : 'charge.dispute.closed' } module-attribute tests . FAKE_EVENT_DISPUTE_CREATED = { 'id' : 'evt_16YKQi2eZvKYlo2CT2oe5ff3' , 'object' : 'event' , 'api_version' : '2017-08-15' , 'created' : 1439229084 , 'data' : { 'object' : deepcopy ( FAKE_DISPUTE_I )}, 'livemode' : False , 'pending_webhooks' : 0 , 'request' : 'req_6lsB7hkicwhaDj' , 'type' : 'charge.dispute.created' } module-attribute tests . FAKE_EVENT_DISPUTE_FUNDS_REINSTATED_FULL = { 'id' : 'evt_1JAyTxJSZQVUcJYgNk1Jqu8o' , 'object' : 'event' , 'api_version' : '2020-08-27' , 'created' : 1439229084 , 'data' : { 'object' : deepcopy ( FAKE_DISPUTE_V_FULL )}, 'livemode' : False , 'pending_webhooks' : 0 , 'request' : 'req_6lsB7hkicwhaDj' , 'type' : 'charge.dispute.funds_reinstated' } module-attribute tests . FAKE_EVENT_DISPUTE_FUNDS_REINSTATED_PARTIAL = { 'id' : 'evt_1JAyTxJSZQVUcJYgNk1Jqu8o' , 'object' : 'event' , 'api_version' : '2020-08-27' , 'created' : 1439229084 , 'data' : { 'object' : deepcopy ( FAKE_DISPUTE_V_PARTIAL )}, 'livemode' : False , 'pending_webhooks' : 0 , 'request' : 'req_6lsB7hkicwhaDj' , 'type' : 'charge.dispute.funds_reinstated' } module-attribute tests . FAKE_EVENT_DISPUTE_FUNDS_WITHDRAWN = { 'id' : 'evt_1JAyTxJSZQVUcJYgNk1Jqu8o' , 'object' : 'event' , 'api_version' : '2020-08-27' , 'created' : 1439229084 , 'data' : { 'object' : deepcopy ( FAKE_DISPUTE_II )}, 'livemode' : False , 'pending_webhooks' : 0 , 'request' : 'req_6lsB7hkicwhaDj' , 'type' : 'charge.dispute.funds_withdrawn' } module-attribute tests . FAKE_EVENT_DISPUTE_UPDATED = { 'id' : 'evt_1JAyTxJSZQVUcJYgNk1Jqu8o' , 'object' : 'event' , 'api_version' : '2020-08-27' , 'created' : 1439229084 , 'data' : { 'object' : deepcopy ( FAKE_DISPUTE_III )}, 'livemode' : False , 'pending_webhooks' : 0 , 'request' : 'req_6lsB7hkicwhaDj' , 'type' : 'charge.dispute.funds_withdrawn' } module-attribute tests . FAKE_EVENT_EXPRESS_ACCOUNT_UPDATED = dict ( load_fixture ( 'event_account_updated_express.json' )) module-attribute tests . FAKE_EVENT_FILE_CREATED = { 'id' : 'evt_1J5TusR44xKqawmIQVXSrGyf' , 'object' : 'event' , 'api_version' : '2020-08-27' , 'created' : 1439229084 , 'data' : { 'object' : deepcopy ( FAKE_FILEUPLOAD_ICON )}, 'livemode' : False , 'pending_webhooks' : 0 , 'request' : 'req_sTSstDDIOpKi2w' , 'type' : 'file.created' } module-attribute tests . FAKE_EVENT_INVOICEITEM_CREATED = { 'id' : 'evt_187IHD2eZvKYlo2C7SXedrZk' , 'object' : 'event' , 'api_version' : '2016-03-07' , 'created' : 1462338623 , 'data' : { 'object' : deepcopy ( FAKE_INVOICEITEM )}, 'livemode' : False , 'pending_webhooks' : 0 , 'request' : 'req_8O4Qbs2EDobDVT' , 'type' : 'invoiceitem.created' } module-attribute tests . FAKE_EVENT_INVOICEITEM_DELETED = deepcopy ( FAKE_EVENT_INVOICEITEM_CREATED ) module-attribute tests . FAKE_EVENT_INVOICE_CREATED = { 'id' : 'evt_187IHD2eZvKYlo2C6YKQi2eZ' , 'object' : 'event' , 'api_version' : '2016-03-07' , 'created' : 1462338623 , 'data' : { 'object' : deepcopy ( FAKE_INVOICE )}, 'livemode' : False , 'pending_webhooks' : 0 , 'request' : 'req_8O4sB7hkDobVT' , 'type' : 'invoice.created' } module-attribute tests . FAKE_EVENT_INVOICE_DELETED = deepcopy ( FAKE_EVENT_INVOICE_CREATED ) module-attribute tests . FAKE_EVENT_INVOICE_UPCOMING = { 'id' : 'evt_187IHD2eZvKYlo2C6YKQi2bc' , 'object' : 'event' , 'api_version' : '2017-02-14' , 'created' : 1501859641 , 'data' : { 'object' : deepcopy ( FAKE_INVOICE )}, 'livemode' : False , 'pending_webhooks' : 0 , 'request' : 'req_8O4sB7hkDobZA' , 'type' : 'invoice.upcoming' } module-attribute tests . FAKE_EVENT_ORDER_CANCELLED = deepcopy ( FAKE_EVENT_ORDER_UPDATED ) module-attribute tests . FAKE_EVENT_ORDER_COMPLETED = deepcopy ( FAKE_EVENT_ORDER_UPDATED ) module-attribute tests . FAKE_EVENT_ORDER_CREATED = { 'id' : 'evt_16igNU2eZvKYlo2CYyMkYvet' , 'object' : 'event' , 'api_version' : '2016-03-07' , 'created' : 1441696732 , 'data' : { 'object' : deepcopy ( FAKE_ORDER_WITH_CUSTOMER_WITHOUT_PAYMENT_INTENT )}, 'livemode' : False , 'pending_webhooks' : 0 , 'request' : 'req_6wZW9MskhYU15Y' , 'type' : 'order.created' } module-attribute tests . FAKE_EVENT_ORDER_PROCESSING = deepcopy ( FAKE_EVENT_ORDER_UPDATED ) module-attribute tests . FAKE_EVENT_ORDER_SUBMITTED = deepcopy ( FAKE_EVENT_ORDER_UPDATED ) module-attribute tests . FAKE_EVENT_ORDER_UPDATED = { 'id' : 'evt_16igNU2eZvKYlo2CYyMkYvet' , 'object' : 'event' , 'api_version' : '2016-03-07' , 'created' : 1441696732 , 'data' : { 'object' : deepcopy ( FAKE_ORDER_WITH_CUSTOMER_WITH_PAYMENT_INTENT )}, 'livemode' : False , 'pending_webhooks' : 0 , 'request' : 'req_6wZW9MskhYU15Y' , 'type' : 'order.created' } module-attribute tests . FAKE_EVENT_PAYMENT_INTENT_SUCCEEDED_DESTINATION_CHARGE = { 'id' : 'evt_1FG74XB7kbjcJ8Qq22i2BPdt' , 'object' : 'event' , 'api_version' : '2019-05-16' , 'created' : 1567874857 , 'data' : { 'object' : deepcopy ( FAKE_PAYMENT_INTENT_DESTINATION_CHARGE )}, 'livemode' : False , 'pending_webhooks' : 1 , 'request' : { 'id' : 'req_AJAmnJE4eiPIzb' , 'idempotency_key' : None }, 'type' : 'payment_intent.succeeded' } module-attribute tests . FAKE_EVENT_PAYMENT_METHOD_ATTACHED = { 'id' : 'evt_1FDOwDKatMEEd998o5FyxxAB' , 'object' : 'event' , 'api_version' : '2019-08-14' , 'created' : 1567228549 , 'data' : { 'object' : deepcopy ( FAKE_PAYMENT_METHOD_I )}, 'livemode' : False , 'pending_webhooks' : 0 , 'request' : { 'id' : 'req_9c9djVqxUZIKNr' , 'idempotency_key' : None }, 'type' : 'payment_method.attached' } module-attribute tests . FAKE_EVENT_PAYMENT_METHOD_DETACHED = { 'id' : 'evt_1FDOwDKatMEEd998o5Fdadfds' , 'object' : 'event' , 'api_version' : '2019-08-14' , 'created' : 1567228549 , 'data' : { 'object' : deepcopy ( FAKE_PAYMENT_METHOD_I )}, 'livemode' : False , 'pending_webhooks' : 0 , 'request' : { 'id' : 'req_9c9djVqxcxgdfg' , 'idempotency_key' : None }, 'type' : 'payment_method.detached' } module-attribute tests . FAKE_EVENT_PLAN_CREATED = { 'id' : 'evt_1877X72eZvKYlo2CLK6daFxu' , 'object' : 'event' , 'api_version' : '2016-03-07' , 'created' : 1462297325 , 'data' : { 'object' : deepcopy ( FAKE_PLAN )}, 'livemode' : False , 'pending_webhooks' : 0 , 'request' : 'req_8NtJXPttxSvFyM' , 'type' : 'plan.created' } module-attribute tests . FAKE_EVENT_PLAN_DELETED = deepcopy ( FAKE_EVENT_PLAN_CREATED ) module-attribute tests . FAKE_EVENT_PLAN_REQUEST_IS_OBJECT = { 'id' : 'evt_1AcdbXXXXXXXXXXXXXXXXXXX' , 'object' : 'event' , 'api_version' : '2017-06-05' , 'created' : 1499361420 , 'data' : { 'object' : FAKE_PLAN , 'previous_attributes' : { 'name' : 'Plan anual test4' }}, 'livemode' : False , 'pending_webhooks' : 1 , 'request' : { 'id' : 'req_AyamqQWoi5AMR2' , 'idempotency_key' : None }, 'type' : 'plan.updated' } module-attribute tests . FAKE_EVENT_PRICE_CREATED = { 'id' : 'evt_1HlZWCFz0jfFqjGsXOiPW10r' , 'object' : 'event' , 'api_version' : '2020-03-02' , 'created' : 1604925044 , 'data' : { 'object' : deepcopy ( FAKE_PRICE )}, 'livemode' : False , 'pending_webhooks' : 0 , 'request' : { 'id' : 'req_Nq7dDuP0HRrqcP' , 'idempotency_key' : None }, 'type' : 'price.created' } module-attribute tests . FAKE_EVENT_PRICE_DELETED = deepcopy ( FAKE_EVENT_PRICE_CREATED ) module-attribute tests . FAKE_EVENT_PRICE_UPDATED = { 'id' : 'evt_1HlZbxFz0jfFqjGsZwiHHf7h' , 'object' : 'event' , 'api_version' : '2020-03-02' , 'created' : 1604925401 , 'data' : { 'object' : FAKE_PRICE , 'previous_attributes' : { 'unit_amount' : 2000 , 'unit_amount_decimal' : '2000' }}, 'livemode' : False , 'pending_webhooks' : 0 , 'request' : { 'id' : 'req_78pnxbwPMvOIwe' , 'idempotency_key' : None }, 'type' : 'price.updated' } module-attribute tests . FAKE_EVENT_SESSION_COMPLETED = { 'id' : 'evt_1JAyTxJSZQVUcJYgNk1Jqu8o' , 'object' : 'event' , 'api_version' : '2020-08-27' , 'created' : 1439229084 , 'data' : { 'object' : deepcopy ( FAKE_SESSION_I )}, 'livemode' : False , 'pending_webhooks' : 0 , 'request' : 'req_6lsB7hkicwhaDj' , 'type' : 'checkout.session.completed' } module-attribute tests . FAKE_EVENT_STANDARD_ACCOUNT_UPDATED = dict ( load_fixture ( 'event_account_updated_standard.json' )) module-attribute tests . FAKE_EVENT_SUBSCRIPTION_SCHEDULE_ABORTED = deepcopy ( FAKE_EVENT_SUBSCRIPTION_SCHEDULE_CREATED ) module-attribute tests . FAKE_EVENT_SUBSCRIPTION_SCHEDULE_CANCELED = deepcopy ( FAKE_EVENT_SUBSCRIPTION_SCHEDULE_CREATED ) module-attribute tests . FAKE_EVENT_SUBSCRIPTION_SCHEDULE_COMPLETED = deepcopy ( FAKE_EVENT_SUBSCRIPTION_SCHEDULE_CREATED ) module-attribute tests . FAKE_EVENT_SUBSCRIPTION_SCHEDULE_CREATED = { 'id' : 'evt_1Hm7q6Fz0jfFqjGsJSG4N91w' , 'object' : 'event' , 'api_version' : '2020-03-02' , 'created' : 1605056974 , 'data' : { 'object' : deepcopy ( FAKE_SUBSCRIPTION_SCHEDULE )}, 'livemode' : False , 'pending_webhooks' : 0 , 'request' : { 'id' : 'req_Pttj3aW5RJwees' , 'idempotency_key' : 'd2a77191-cc07-4c60-abab-5fb11357bd63' }, 'type' : 'subscription_schedule.created' } module-attribute tests . FAKE_EVENT_SUBSCRIPTION_SCHEDULE_EXPIRING = deepcopy ( FAKE_EVENT_SUBSCRIPTION_SCHEDULE_CREATED ) module-attribute tests . FAKE_EVENT_SUBSCRIPTION_SCHEDULE_RELEASED = deepcopy ( FAKE_EVENT_SUBSCRIPTION_SCHEDULE_CREATED ) module-attribute tests . FAKE_EVENT_SUBSCRIPTION_SCHEDULE_UPDATED = deepcopy ( FAKE_EVENT_SUBSCRIPTION_SCHEDULE_CREATED ) module-attribute tests . FAKE_EVENT_TAX_ID_CREATED = { 'id' : 'evt_16YKQi2eZvKYlo2CT2oe5ff3' , 'object' : 'event' , 'api_version' : '2020-08-27' , 'created' : 1439229084 , 'data' : { 'object' : deepcopy ( FAKE_TAX_ID )}, 'livemode' : False , 'pending_webhooks' : 0 , 'request' : 'req_ZoH080M8fny6yR' , 'type' : 'customer.tax_id.created' } module-attribute tests . FAKE_EVENT_TAX_ID_DELETED = deepcopy ( FAKE_EVENT_TAX_ID_UPDATED ) module-attribute tests . FAKE_EVENT_TAX_ID_UPDATED = { 'id' : 'evt_1J6Fy3JSZQVUcJYgnddjnMzx' , 'object' : 'event' , 'api_version' : '2020-08-27' , 'created' : 1439229084 , 'data' : { 'object' : deepcopy ( FAKE_TAX_ID_UPDATED )}, 'livemode' : False , 'pending_webhooks' : 0 , 'request' : 'req_ZoH080M8fny6yR' , 'type' : 'customer.tax_id.updated' } module-attribute tests . FAKE_EVENT_TEST_CHARGE_SUCCEEDED = deepcopy ( FAKE_EVENT_CHARGE_SUCCEEDED ) module-attribute tests . FAKE_EVENT_TRANSFER_CREATED = { 'id' : 'evt_16igNU2eZvKYlo2CYyMkYvet' , 'object' : 'event' , 'api_version' : '2016-03-07' , 'created' : 1441696732 , 'data' : { 'object' : deepcopy ( FAKE_TRANSFER )}, 'livemode' : False , 'pending_webhooks' : 0 , 'request' : 'req_6wZW9MskhYU15Y' , 'type' : 'transfer.created' } module-attribute tests . FAKE_EVENT_TRANSFER_DELETED = deepcopy ( FAKE_EVENT_TRANSFER_CREATED ) module-attribute tests . FAKE_EXPRESS_ACCOUNT = AccountDict ( load_fixture ( 'account_express_acct_1IuHosQveW0ONQsd.json' )) module-attribute tests . FAKE_FILEUPLOAD_ICON = { 'created' : 1550134074 , 'filename' : 'icon_preview.png' , 'id' : 'file_4hshrsKatMEEd6736724HYAXyj' , 'links' : { 'data' : [{ 'created' : 1550134074 , 'expired' : False , 'expires_at' : 1850134074 , 'file' : 'file_4hshrsKatMEEd6736724HYAXyj' , 'id' : 'link_4jsdgsKatMEEd673672V0JSH' , 'livemode' : False , 'metadata' : {}, 'object' : 'file_link' , 'url' : 'https://files.stripe.com/links/fl_test_69vG4ISDx9Chjklasrf06BJeQo' }], 'has_more' : False , 'object' : 'list' , 'url' : '/v1/file_links?file=file_4hshrsKatMEEd6736724HYAXyj' }, 'object' : 'file_upload' , 'purpose' : 'business_logo' , 'size' : 6650 , 'type' : 'png' , 'url' : 'https://files.stripe.com/files/f_test_BTJFKcS7VDahgkjqw8EVNWlM' } module-attribute tests . FAKE_FILEUPLOAD_LOGO = { 'created' : 1550134074 , 'filename' : 'logo_preview.png' , 'id' : 'file_1E3fssKatMEEd6736724HYAXyj' , 'links' : { 'data' : [{ 'created' : 1550134074 , 'expired' : False , 'expires_at' : 1850134074 , 'file' : 'file_1E3fssKatMEEd6736724HYAXyj' , 'id' : 'link_1E3fssKatMEEd673672V0JSH' , 'livemode' : False , 'metadata' : {}, 'object' : 'file_link' , 'url' : 'https://files.stripe.com/links/fl_test_69vG4ISDx9Chjklasrf06BJeQo' }], 'has_more' : False , 'object' : 'list' , 'url' : '/v1/file_links?file=file_1E3fssKatMEEd6736724HYAXyj' }, 'object' : 'file_upload' , 'purpose' : 'business_logo' , 'size' : 6650 , 'type' : 'png' , 'url' : 'https://files.stripe.com/files/f_test_BTJFKcS7VDahgkjqw8EVNWlM' } module-attribute tests . FAKE_INVOICE = InvoiceDict ( FAKE_INVOICE ) module-attribute tests . FAKE_INVOICEITEM = { 'id' : 'ii_fakefakefakefakefake0001' , 'object' : 'invoiceitem' , 'amount' : 2000 , 'currency' : 'usd' , 'customer' : FAKE_CUSTOMER [ 'id' ], 'date' : 1439033216 , 'description' : 'One-time setup fee' , 'discountable' : True , 'discounts' : [], 'invoice' : FAKE_INVOICE [ 'id' ], 'livemode' : False , 'metadata' : { 'key1' : 'value1' , 'key2' : 'value2' }, 'period' : { 'start' : 1439033216 , 'end' : 1439033216 }, 'plan' : None , 'price' : None , 'proration' : False , 'quantity' : None , 'subscription' : None , 'subscription_item' : None , 'tax_rates' : [], 'unit_amount' : 2000 , 'unit_amount_decimal' : '2000' } module-attribute tests . FAKE_INVOICEITEM_II = { 'id' : 'ii_fakefakefakefakefake0001' , 'object' : 'invoiceitem' , 'amount' : 2000 , 'currency' : 'usd' , 'customer' : FAKE_CUSTOMER_II [ 'id' ], 'date' : 1439033216 , 'description' : 'One-time setup fee' , 'discountable' : True , 'discounts' : [], 'invoice' : FAKE_INVOICE_II [ 'id' ], 'livemode' : False , 'metadata' : { 'key1' : 'value1' , 'key2' : 'value2' }, 'period' : { 'start' : 1439033216 , 'end' : 1439033216 }, 'plan' : None , 'price' : None , 'proration' : False , 'quantity' : None , 'subscription' : None , 'subscription_item' : None , 'tax_rates' : [], 'unit_amount' : 2000 , 'unit_amount_decimal' : '2000' } module-attribute tests . FAKE_INVOICEITEM_III = { 'id' : 'ii_fakefakefakefakefake0001' , 'object' : 'invoiceitem' , 'amount' : 2000 , 'currency' : 'usd' , 'customer' : FAKE_CUSTOMER_II [ 'id' ], 'date' : 1439033216 , 'description' : 'One-time setup fee' , 'discountable' : True , 'discounts' : [], 'invoice' : FAKE_INVOICE_II [ 'id' ], 'livemode' : False , 'metadata' : { 'key1' : 'value1' , 'key2' : 'value2' }, 'period' : { 'start' : 1439033216 , 'end' : 1439033216 }, 'plan' : None , 'price' : None , 'proration' : False , 'quantity' : None , 'subscription' : None , 'subscription_item' : None , 'tax_rates' : [ FAKE_TAX_RATE_EXAMPLE_1_VAT ], 'unit_amount' : 2000 , 'unit_amount_decimal' : '2000' } module-attribute tests . FAKE_INVOICE_II = InvoiceDict ({ 'id' : 'in_16af5A2eZvKYlo2CJjANLL81' , 'object' : 'invoice' , 'amount_due' : 3000 , 'amount_paid' : 0 , 'amount_remaining' : 3000 , 'application_fee_amount' : None , 'attempt_count' : 1 , 'attempted' : True , 'auto_advance' : True , 'collection_method' : 'charge_automatically' , 'charge' : FAKE_CHARGE_II [ 'id' ], 'currency' : 'usd' , 'customer' : 'cus_4UbFSo9tl62jqj' , 'created' : 1439785128 , 'description' : None , 'discount' : None , 'discounts' : [], 'due_date' : None , 'ending_balance' : 0 , 'lines' : { 'data' : [ deepcopy ( FAKE_LINE_ITEM_SUBSCRIPTION )], 'total_count' : 1 , 'object' : 'list' , 'url' : '/v1/invoices/in_16af5A2eZvKYlo2CJjANLL81/lines' }, 'livemode' : False , 'metadata' : {}, 'next_payment_attempt' : 1440048103 , 'number' : 'XXXXXXX-0002' , 'paid' : False , 'period_end' : 1439784771 , 'period_start' : 1439698371 , 'receipt_number' : None , 'starting_balance' : 0 , 'statement_descriptor' : None , 'subscription' : FAKE_SUBSCRIPTION_III [ 'id' ], 'subtotal' : 3000 , 'tax' : None , 'tax_percent' : None , 'total' : 3000 , 'webhooks_delivered_at' : 1439785139 }) module-attribute tests . FAKE_INVOICE_III = InvoiceDict ({ 'id' : 'in_16Z9dP2eZvKYlo2CgFHgFx2Z' , 'object' : 'invoice' , 'amount_due' : 0 , 'amount_paid' : 0 , 'amount_remaining' : 0 , 'application_fee_amount' : None , 'attempt_count' : 0 , 'attempted' : True , 'auto_advance' : True , 'collection_method' : 'charge_automatically' , 'charge' : None , 'created' : 1439425915 , 'currency' : 'usd' , 'customer' : 'cus_6lsBvm5rJ0zyHc' , 'description' : None , 'discount' : None , 'discounts' : [], 'due_date' : None , 'ending_balance' : 20 , 'lines' : { 'data' : [ deepcopy ( FAKE_LINE_ITEM_SUBSCRIPTION )], 'total_count' : 1 , 'object' : 'list' , 'url' : '/v1/invoices/in_16Z9dP2eZvKYlo2CgFHgFx2Z/lines' }, 'livemode' : False , 'metadata' : {}, 'next_payment_attempt' : None , 'number' : 'XXXXXXX-0003' , 'paid' : False , 'period_end' : 1439424571 , 'period_start' : 1436746171 , 'receipt_number' : None , 'starting_balance' : 0 , 'statement_descriptor' : None , 'subscription' : FAKE_SUBSCRIPTION [ 'id' ], 'subtotal' : 20 , 'tax' : None , 'tax_percent' : None , 'total' : 20 , 'webhooks_delivered_at' : 1439426955 }) module-attribute tests . FAKE_INVOICE_IV = InvoiceDict ( load_fixture ( 'invoice_in_fakefakefakefakefake0004.json' )) module-attribute tests . FAKE_INVOICE_METERED_SUBSCRIPTION = InvoiceDict ({ 'id' : 'in_1JGGM6JSZQVUcJYgpWqfBOIl' , 'livemode' : False , 'created' : 1439425915 , 'metadata' : {}, 'description' : '' , 'amount_due' : '1.05' , 'amount_paid' : '1.05' , 'amount_remaining' : '0.00' , 'application_fee_amount' : None , 'attempt_count' : 1 , 'attempted' : True , 'auto_advance' : False , 'collection_method' : 'charge_automatically' , 'currency' : 'usd' , 'customer' : FAKE_CUSTOMER_II [ 'id' ], 'object' : 'invoice' , 'charge' : None , 'discount' : None , 'discounts' : [], 'due_date' : None , 'ending_balance' : 0 , 'lines' : { 'data' : [ deepcopy ( FAKE_LINE_ITEM_SUBSCRIPTION )], 'total_count' : 1 , 'object' : 'list' , 'url' : '/v1/invoices/in_1JGGM6JSZQVUcJYgpWqfBOIl/lines' }, 'next_payment_attempt' : None , 'number' : '84DE1540-0004' , 'paid' : True , 'period_end' : 1439424571 , 'period_start' : 1436746171 , 'receipt_number' : None , 'starting_balance' : 0 , 'statement_descriptor' : None , 'subscription' : FAKE_INVOICE_METERED_SUBSCRIPTION_USAGE [ 'id' ], 'subtotal' : '1.00' , 'tax' : None , 'tax_percent' : None , 'total' : '1.00' , 'webhooks_delivered_at' : 1439426955 }) module-attribute tests . FAKE_INVOICE_METERED_SUBSCRIPTION_USAGE = deepcopy ( FAKE_SUBSCRIPTION_METERED ) module-attribute tests . FAKE_LINE_ITEM = load_fixture ( 'line_item_il_invoice_item_fakefakefakefakefake0001.json' ) module-attribute tests . FAKE_LINE_ITEM_SUBSCRIPTION = load_fixture ( 'line_item_il_invoice_item_fakefakefakefakefake0002.json' ) module-attribute tests . FAKE_ORDER_WITHOUT_CUSTOMER_WITHOUT_PAYMENT_INTENT = deepcopy ( FAKE_ORDER_WITH_CUSTOMER_WITH_PAYMENT_INTENT ) module-attribute tests . FAKE_ORDER_WITHOUT_CUSTOMER_WITH_PAYMENT_INTENT = deepcopy ( FAKE_ORDER_WITH_CUSTOMER_WITH_PAYMENT_INTENT ) module-attribute tests . FAKE_ORDER_WITH_CUSTOMER_WITHOUT_PAYMENT_INTENT = deepcopy ( FAKE_ORDER_WITH_CUSTOMER_WITH_PAYMENT_INTENT ) module-attribute tests . FAKE_ORDER_WITH_CUSTOMER_WITH_PAYMENT_INTENT = load_fixture ( 'order_order_fakefakefakefake0001.json' ) module-attribute tests . FAKE_PAYMENT_INTENT_DESTINATION_CHARGE = load_fixture ( 'payment_intent_pi_destination_charge.json' ) module-attribute tests . FAKE_PAYMENT_INTENT_I = load_fixture ( 'payment_intent_pi_fakefakefakefakefake0001.json' ) module-attribute tests . FAKE_PAYMENT_INTENT_II = deepcopy ( FAKE_PAYMENT_INTENT_I ) module-attribute tests . FAKE_PAYMENT_METHOD_I = PaymentMethodDict ( load_fixture ( 'payment_method_pm_fakefakefakefake0001.json' )) module-attribute tests . FAKE_PAYMENT_METHOD_II = deepcopy ( FAKE_PAYMENT_METHOD_I ) module-attribute tests . FAKE_PAYOUT_CUSTOM_BANK_ACCOUNT = PayoutDict ( load_fixture ( 'payout_custom_bank_account.json' )) module-attribute tests . FAKE_PAYOUT_CUSTOM_CARD = PayoutDict ( load_fixture ( 'payout_custom_card.json' )) module-attribute tests . FAKE_PLAN = load_fixture ( 'plan_gold21323.json' ) module-attribute tests . FAKE_PLAN_II = load_fixture ( 'plan_silver41294.json' ) module-attribute tests . FAKE_PLAN_METERED = { 'id' : 'plan_fakemetered' , 'billing_scheme' : 'per_unit' , 'object' : 'plan' , 'active' : True , 'aggregate_usage' : 'sum' , 'amount' : 200 , 'collection_method' : 'per_unit' , 'created' : 1552632817 , 'currency' : 'usd' , 'interval' : 'month' , 'interval_count' : 1 , 'livemode' : False , 'metadata' : {}, 'nickname' : 'Sum Metered Plan' , 'product' : FAKE_PRODUCT [ 'id' ], 'tiers' : None , 'tiers_mode' : None , 'transform_usage' : None , 'trial_period_days' : None , 'usage_type' : 'metered' } module-attribute tests . FAKE_PLATFORM_ACCOUNT = deepcopy ( FAKE_STANDARD_ACCOUNT ) module-attribute tests . FAKE_PRICE = load_fixture ( 'price_gold21323.json' ) module-attribute tests . FAKE_PRICE_II = load_fixture ( 'price_silver41294.json' ) module-attribute tests . FAKE_PRICE_METERED = { 'active' : True , 'billing_scheme' : 'per_unit' , 'created' : 1552632817 , 'currency' : 'usd' , 'id' : 'price_fakemetered' , 'livemode' : False , 'lookup_key' : None , 'metadata' : {}, 'nickname' : 'Sum Metered Price' , 'object' : 'price' , 'product' : FAKE_PRODUCT [ 'id' ], 'recurring' : { 'aggregate_usage' : 'sum' , 'interval' : 'month' , 'interval_count' : 1 , 'trial_period_days' : None , 'usage_type' : 'metered' }, 'tiers_mode' : None , 'transform_quantity' : None , 'type' : 'recurring' , 'unit_amount' : 200 , 'unit_amount_decimal' : '200' } module-attribute tests . FAKE_PRICE_ONETIME = { 'active' : True , 'billing_scheme' : 'per_unit' , 'created' : 1552632818 , 'currency' : 'usd' , 'id' : 'price_fakeonetime' , 'livemode' : False , 'lookup_key' : None , 'metadata' : {}, 'nickname' : 'One-Time Price' , 'object' : 'price' , 'product' : FAKE_PRODUCT [ 'id' ], 'recurring' : None , 'tiers_mode' : None , 'transform_quantity' : None , 'type' : 'one_time' , 'unit_amount' : 2000 , 'unit_amount_decimal' : '2000' } module-attribute tests . FAKE_PRICE_TIER = { 'active' : True , 'billing_scheme' : 'tiered' , 'created' : 1386247539 , 'currency' : 'usd' , 'id' : 'price_tier21323' , 'livemode' : False , 'lookup_key' : None , 'metadata' : {}, 'nickname' : 'New price name' , 'object' : 'price' , 'product' : FAKE_PRODUCT [ 'id' ], 'recurring' : { 'aggregate_usage' : None , 'interval' : 'month' , 'interval_count' : 1 , 'trial_period_days' : None , 'usage_type' : 'licensed' }, 'tiers' : [{ 'flat_amount' : 4900 , 'flat_amount_decimal' : '4900' , 'unit_amount' : 1000 , 'unit_amount_decimal' : '1000' , 'up_to' : 5 }, { 'flat_amount' : None , 'flat_amount_decimal' : None , 'unit_amount' : 900 , 'unit_amount_decimal' : '900' , 'up_to' : None }], 'tiers_mode' : 'graduated' , 'transform_quantity' : None , 'type' : 'recurring' , 'unit_amount' : None , 'unit_amount_decimal' : None } module-attribute tests . FAKE_PRODUCT = load_fixture ( 'product_prod_fake1.json' ) module-attribute tests . FAKE_REFUND = { 'id' : 're_1E0he8KatMEEd8456454S01Vc' , 'object' : 'refund' , 'amount' : FAKE_CHARGE_REFUNDED [ 'amount_refunded' ], 'balance_transaction' : 'txn_1E0he8KaGRDEd998TDswMZuN' , 'charge' : FAKE_CHARGE_REFUNDED [ 'id' ], 'created' : 1549425864 , 'currency' : 'usd' , 'metadata' : {}, 'reason' : None , 'receipt_number' : None , 'source_transfer_reversal' : None , 'status' : 'succeeded' , 'transfer_reversal' : None } module-attribute tests . FAKE_SESSION_I = { 'id' : 'cs_test_OAgNmy75Td25OeREvKUs8XZ7SjMPO9qAplqHO1sBaEjOg9fYbaeMh2nA' , 'object' : 'checkout.session' , 'amount_total' : 1500 , 'amount_subtotal' : 1500 , 'billing_address_collection' : None , 'cancel_url' : 'https://example.com/cancel' , 'client_reference_id' : None , 'currency' : 'usd' , 'customer' : 'cus_6lsBvm5rJ0zyHc' , 'customer_email' : None , 'display_items' : [{ 'amount' : 1500 , 'currency' : 'usd' , 'custom' : { 'description' : 'Comfortable cotton t-shirt' , 'images' : None , 'name' : 'T-shirt' }, 'quantity' : 2 , 'type' : 'custom' }], 'livemode' : False , 'locale' : None , 'mode' : None , 'payment_intent' : FAKE_PAYMENT_INTENT_I [ 'id' ], 'payment_method_types' : [ 'card' ], 'payment_status' : 'unpaid' , 'setup_intent' : FAKE_SETUP_INTENT_II [ 'id' ], 'shipping_address_collection' : {}, 'shipping_cost' : {}, 'shipping_details' : {}, 'shipping_options' : {}, 'status' : 'open' , 'submit_type' : None , 'subscription' : None , 'success_url' : 'https://example.com/success' , 'metadata' : {}, 'line_tems' : {}, 'url' : '' , 'total_details' : {}} module-attribute tests . FAKE_SETUP_INTENT_DESTINATION_CHARGE = load_fixture ( 'setup_intent_pi_destination_charge.json' ) module-attribute tests . FAKE_SETUP_INTENT_I = { 'id' : 'seti_fakefakefakefake0001' , 'object' : 'setup_intent' , 'cancellation_reason' : None , 'payment_method_types' : [ 'card' ], 'status' : 'requires_payment_method' , 'usage' : 'off_session' , 'payment_method' : None , 'on_behalf_of' : None , 'customer' : None } module-attribute tests . FAKE_SETUP_INTENT_II = { 'application' : None , 'cancellation_reason' : None , 'client_secret' : 'seti_1J0g0WJSZQVUcJYgWE2XSi1K_secret_Jdxw2mOaIEHBdE6eTsfJ2IfmamgNJaF' , 'created' : 1623301244 , 'customer' : 'cus_6lsBvm5rJ0zyHc' , 'description' : None , 'id' : 'seti_1J0g0WJSZQVUcJYgWE2XSi1K' , 'last_setup_error' : None , 'latest_attempt' : 'setatt_1J0g0WJSZQVUcJYgsrFgwxVh' , 'livemode' : False , 'mandate' : None , 'metadata' : {}, 'next_action' : None , 'object' : 'setup_intent' , 'on_behalf_of' : None , 'payment_method' : 'pm_fakefakefakefake0001' , 'payment_method_options' : { 'card' : { 'request_three_d_secure' : 'automatic' }}, 'payment_method_types' : [ 'card' ], 'single_use_mandate' : None , 'status' : 'succeeded' , 'usage' : 'off_session' } module-attribute tests . FAKE_SHIPPING_RATE = load_fixture ( 'shipping_rate_shr_fakefakefakefakefake0001.json' ) module-attribute tests . FAKE_SHIPPING_RATE_WITH_TAX_CODE = load_fixture ( 'shipping_rate_shr_fakefakefakefakefake0002.json' ) module-attribute tests . FAKE_SOURCE = SourceDict ( load_fixture ( 'source_src_fakefakefakefakefake0001.json' )) module-attribute tests . FAKE_SOURCE_II = SourceDict ({ 'id' : 'src_1DuuGjkE6hxDGaasasjdlajl' , 'object' : 'source' , 'amount' : None , 'card' : { 'address_line1_check' : None , 'address_zip_check' : 'pass' , 'brand' : 'Visa' , 'country' : 'US' , 'cvc_check' : 'pass' , 'dynamic_last4' : None , 'exp_month' : 10 , 'exp_year' : 2029 , 'fingerprint' : 'TmOrYzPdAoO6YFNB' , 'funding' : 'credit' , 'last4' : '4242' , 'name' : None , 'three_d_secure' : 'optional' , 'tokenization_method' : None }, 'client_secret' : 'src_client_secret_ENg5dyB1KTXCAEJGJQWEf67X' , 'created' : 1548046215 , 'currency' : None , 'flow' : 'none' , 'livemode' : False , 'metadata' : { 'djstripe_test_fake_id' : 'src_fakefakefakefakefake0002' }, 'owner' : { 'address' : { 'city' : None , 'country' : None , 'line1' : None , 'line2' : None , 'postal_code' : '90210' , 'state' : None }, 'email' : None , 'name' : None , 'phone' : None , 'verified_address' : None , 'verified_email' : None , 'verified_name' : None , 'verified_phone' : None }, 'statement_descriptor' : None , 'status' : 'consumed' , 'type' : 'card' , 'usage' : 'reusable' }) module-attribute tests . FAKE_STANDARD_ACCOUNT = AccountDict ( load_fixture ( 'account_standard_acct_1Fg9jUA3kq9o1aTc.json' )) module-attribute tests . FAKE_SUBSCRIPTION = SubscriptionDict ( load_fixture ( 'subscription_sub_fakefakefakefakefake0001.json' )) module-attribute tests . FAKE_SUBSCRIPTION_CANCELED = deepcopy ( FAKE_SUBSCRIPTION ) module-attribute tests . FAKE_SUBSCRIPTION_CANCELED_AT_PERIOD_END = deepcopy ( FAKE_SUBSCRIPTION ) module-attribute tests . FAKE_SUBSCRIPTION_II = SubscriptionDict ( load_fixture ( 'subscription_sub_fakefakefakefakefake0002.json' )) module-attribute tests . FAKE_SUBSCRIPTION_III = SubscriptionDict ( load_fixture ( 'subscription_sub_fakefakefakefakefake0003.json' )) module-attribute tests . FAKE_SUBSCRIPTION_ITEM = { 'id' : 'si_JiphMAMFxZKW8s' , 'object' : 'subscription_item' , 'metadata' : {}, 'billing_thresholds' : '' , 'created' : 1441907581 , 'plan' : deepcopy ( FAKE_PLAN_METERED ), 'price' : deepcopy ( FAKE_PRICE_METERED ), 'quantity' : 1 , 'subscription' : FAKE_INVOICE_METERED_SUBSCRIPTION_USAGE [ 'id' ], 'tax_rates' : []} module-attribute tests . FAKE_SUBSCRIPTION_ITEM_METERED = { 'id' : 'si_JiphMAMFxZKW8s' , 'object' : 'subscription_item' , 'metadata' : {}, 'billing_thresholds' : '' , 'created' : 1441907581 , 'plan' : deepcopy ( FAKE_PLAN_METERED ), 'price' : deepcopy ( FAKE_PRICE_METERED ), 'quantity' : 1 , 'subscription' : FAKE_SUBSCRIPTION_METERED [ 'id' ], 'tax_rates' : []} module-attribute tests . FAKE_SUBSCRIPTION_ITEM_MULTI_PLAN = { 'id' : 'si_JiphMAMFxZKW8s' , 'object' : 'subscription_item' , 'metadata' : {}, 'billing_thresholds' : '' , 'created' : 1441907581 , 'plan' : deepcopy ( FAKE_PLAN ), 'price' : deepcopy ( FAKE_PRICE ), 'quantity' : 1 , 'subscription' : FAKE_SUBSCRIPTION_MULTI_PLAN [ 'id' ], 'tax_rates' : []} module-attribute tests . FAKE_SUBSCRIPTION_ITEM_TAX_RATES = { 'id' : 'si_JiphMAMFxZKW8s' , 'object' : 'subscription_item' , 'metadata' : {}, 'billing_thresholds' : '' , 'created' : 1441907581 , 'plan' : deepcopy ( FAKE_PLAN_II ), 'price' : deepcopy ( FAKE_PRICE_II ), 'quantity' : 1 , 'subscription' : FAKE_SUBSCRIPTION_II [ 'id' ], 'tax_rates' : [{ 'id' : 'txr_fakefakefakefakefake0001' , 'object' : 'tax_rate' , 'active' : True , 'created' : 1593225980 , 'description' : None , 'display_name' : 'VAT' , 'inclusive' : True , 'jurisdiction' : 'Example1' , 'livemode' : False , 'metadata' : { 'djstripe_test_fake_id' : 'txr_fakefakefakefakefake0001' }, 'percentage' : 15.0 }]} module-attribute tests . FAKE_SUBSCRIPTION_METERED = SubscriptionDict ({ 'id' : 'sub_1rn1dp7WgjMtx9' , 'object' : 'subscription' , 'application_fee_percent' : None , 'collection_method' : 'charge_automatically' , 'cancel_at_period_end' : False , 'canceled_at' : None , 'current_period_end' : 1441907581 , 'current_period_start' : 1439229181 , 'customer' : 'cus_6lsBvm5rJ0zyHc' , 'discount' : None , 'ended_at' : None , 'metadata' : { 'djstripe_test_fake_id' : 'sub_fakefakefakefakefake0005' }, 'items' : { 'data' : [{ 'created' : 1441907581 , 'id' : 'si_UXYmKmJp6aWTw6' , 'metadata' : {}, 'object' : 'subscription_item' , 'plan' : deepcopy ( FAKE_PLAN_METERED ), 'subscription' : 'sub_1rn1dp7WgjMtx9' }]}, 'pause_collection' : None , 'plan' : deepcopy ( FAKE_PLAN_METERED ), 'quantity' : 1 , 'start' : 1439229181 , 'start_date' : 1439229181 , 'status' : 'active' , 'tax_percent' : None , 'trial_end' : None , 'trial_start' : None }) module-attribute tests . FAKE_SUBSCRIPTION_MULTI_PLAN = SubscriptionDict ( load_fixture ( 'subscription_sub_fakefakefakefakefake0004.json' )) module-attribute tests . FAKE_SUBSCRIPTION_NOT_PERIOD_CURRENT = deepcopy ( FAKE_SUBSCRIPTION ) module-attribute tests . FAKE_SUBSCRIPTION_SCHEDULE = { 'id' : 'sub_sched_1Hm7q6Fz0jfFqjGs2OxOSCzD' , 'object' : 'subscription_schedule' , 'canceled_at' : None , 'completed_at' : None , 'created' : 1605056974 , 'current_phase' : {}, 'customer' : 'cus_6lsBvm5rJ0zyHc' , 'default_settings' : { 'billing_cycle_anchor' : 'automatic' , 'billing_thresholds' : None , 'collection_method' : 'charge_automatically' , 'default_payment_method' : None , 'default_source' : None , 'invoice_settings' : None , 'transfer_data' : None }, 'end_behavior' : 'release' , 'livemode' : False , 'metadata' : {}, 'phases' : [{ 'add_invoice_items' : [], 'application_fee_percent' : None , 'billing_cycle_anchor' : None , 'billing_thresholds' : None , 'collection_method' : None , 'coupon' : None , 'default_payment_method' : None , 'default_tax_rates' : [], 'end_date' : 1637195591 , 'invoice_settings' : None , 'plans' : [{ 'billing_thresholds' : None , 'plan' : FAKE_PLAN_II [ 'id' ], 'price' : FAKE_PRICE_II [ 'id' ], 'quantity' : None , 'tax_rates' : []}], 'prorate' : True , 'proration_behavior' : 'create_prorations' , 'start_date' : 1605659591 , 'tax_percent' : None , 'transfer_data' : None , 'trial_end' : None }], 'released_at' : None , 'released_subscription' : None , 'renewal_interval' : None , 'status' : 'not_started' , 'subscription' : FAKE_SUBSCRIPTION [ 'id' ]} module-attribute tests . FAKE_TAX_CODE = load_fixture ( 'tax_code_txcd_fakefakefakefakefake0001.json' ) module-attribute tests . FAKE_TAX_ID = load_fixture ( 'tax_id_txi_fakefakefakefakefake0001.json' ) module-attribute tests . FAKE_TAX_ID_UPDATED = deepcopy ( FAKE_TAX_ID ) module-attribute tests . FAKE_TAX_RATE_EXAMPLE_1_VAT = load_fixture ( 'tax_rate_txr_fakefakefakefakefake0001.json' ) module-attribute tests . FAKE_TAX_RATE_EXAMPLE_2_SALES = load_fixture ( 'tax_rate_txr_fakefakefakefakefake0002.json' ) module-attribute tests . FAKE_TIER_PLAN = { 'id' : 'tier21323' , 'object' : 'plan' , 'active' : True , 'amount' : None , 'created' : 1386247539 , 'currency' : 'usd' , 'interval' : 'month' , 'interval_count' : 1 , 'livemode' : False , 'metadata' : {}, 'nickname' : 'New plan name' , 'product' : FAKE_PRODUCT [ 'id' ], 'trial_period_days' : None , 'usage_type' : 'licensed' , 'tiers_mode' : 'graduated' , 'tiers' : [{ 'flat_amount' : 4900 , 'unit_amount' : 1000 , 'up_to' : 5 }, { 'flat_amount' : None , 'unit_amount' : 900 , 'up_to' : None }]} module-attribute tests . FAKE_TOKEN = { 'id' : 'tok_16YDIe2eZvKYlo2CPvqprIJd' , 'object' : 'token' , 'card' : deepcopy ( FAKE_CARD ), 'client_ip' : None , 'created' : 1439201676 , 'livemode' : False , 'type' : 'card' , 'used' : False } module-attribute tests . FAKE_TRANSFER = { 'id' : 'tr_16Y9BK2eZvKYlo2CR0ySu1BA' , 'object' : 'transfer' , 'amount' : 100 , 'amount_reversed' : 0 , 'application_fee_amount' : None , 'balance_transaction' : deepcopy ( FAKE_BALANCE_TRANSACTION_II ), 'created' : 1439185846 , 'currency' : 'usd' , 'description' : 'Test description - 1439185984' , 'destination' : FAKE_STANDARD_ACCOUNT [ 'id' ], 'destination_payment' : 'py_16Y9BKFso9hLaeLueFmWAYUi' , 'livemode' : False , 'metadata' : {}, 'recipient' : None , 'reversals' : { 'object' : 'list' , 'total_count' : 0 , 'has_more' : False , 'url' : '/v1/transfers/tr_16Y9BK2eZvKYlo2CR0ySu1BA/reversals' , 'data' : []}, 'reversed' : False , 'source_transaction' : None , 'source_type' : 'bank_account' } module-attribute tests . FAKE_TRANSFER_WITH_1_REVERSAL = { 'id' : 'tr_16Y9BK2eZvKYlo2CR0ySu1BA' , 'object' : 'transfer' , 'amount' : 100 , 'amount_reversed' : 0 , 'application_fee_amount' : None , 'balance_transaction' : deepcopy ( FAKE_BALANCE_TRANSACTION_II ), 'created' : 1439185846 , 'currency' : 'usd' , 'description' : 'Test description - 1439185984' , 'destination' : FAKE_STANDARD_ACCOUNT [ 'id' ], 'destination_payment' : 'py_16Y9BKFso9hLaeLueFmWAYUi' , 'livemode' : False , 'metadata' : {}, 'recipient' : None , 'reversals' : { 'object' : 'list' , 'total_count' : 1 , 'has_more' : False , 'url' : '/v1/transfers/tr_16Y9BK2eZvKYlo2CR0ySu1BA/reversals' , 'data' : [{ 'id' : 'trr_1J5UlFJSZQVUcJYgb38m1OZO' , 'object' : 'transfer_reversal' , 'amount' : 20 , 'balance_transaction' : deepcopy ( FAKE_BALANCE_TRANSACTION_II ), 'created' : 1624449653 , 'currency' : 'usd' , 'destination_payment_refund' : 'pyr_1J5UlFR44xKqawmIBvFa6gW9' , 'metadata' : {}, 'source_refund' : None , 'transfer' : deepcopy ( FAKE_TRANSFER )}]}, 'reversed' : False , 'source_transaction' : None , 'source_type' : 'bank_account' } module-attribute tests . FAKE_UPCOMING_INVOICE = InvoiceDict ({ 'id' : 'in' , 'object' : 'invoice' , 'amount_due' : 2000 , 'amount_paid' : 0 , 'amount_remaining' : 2000 , 'application_fee_amount' : None , 'attempt_count' : 1 , 'attempted' : False , 'collection_method' : 'charge_automatically' , 'charge' : None , 'created' : 1439218864 , 'currency' : 'usd' , 'customer' : FAKE_CUSTOMER [ 'id' ], 'description' : None , 'default_tax_rates' : [{ 'id' : 'txr_fakefakefakefakefake0001' , 'object' : 'tax_rate' , 'active' : True , 'created' : 1570921289 , 'description' : None , 'display_name' : 'VAT' , 'inclusive' : True , 'jurisdiction' : 'Example1' , 'livemode' : False , 'metadata' : { 'djstripe_test_fake_id' : 'txr_fakefakefakefakefake0001' }, 'percentage' : 15.0 }], 'discount' : None , 'discounts' : [], 'due_date' : None , 'ending_balance' : None , 'lines' : { 'data' : [ deepcopy ( FAKE_LINE_ITEM_SUBSCRIPTION )], 'total_count' : 1 , 'object' : 'list' , 'url' : '/v1/invoices/in_fakefakefakefakefake0001/lines' }, 'livemode' : False , 'metadata' : {}, 'next_payment_attempt' : 1439218689 , 'number' : None , 'paid' : False , 'period_end' : 1439218689 , 'period_start' : 1439132289 , 'receipt_number' : None , 'starting_balance' : 0 , 'statement_descriptor' : None , 'subscription' : FAKE_SUBSCRIPTION [ 'id' ], 'subtotal' : 2000 , 'tax' : 261 , 'tax_percent' : None , 'total' : 2000 , 'total_tax_amounts' : [{ 'amount' : 261 , 'inclusive' : True , 'tax_rate' : 'txr_fakefakefakefakefake0001' }], 'webhooks_delivered_at' : 1439218870 }) module-attribute tests . FAKE_USAGE_RECORD = { 'id' : 'mbur_1JPJz2JSZQVUcJYgK4otTE2V' , 'livemode' : False , 'object' : 'usage_record' , 'quantity' : 100 , 'subscription_item' : FAKE_SUBSCRIPTION_ITEM [ 'id' ], 'timestamp' : 1629174774 , 'action' : 'increment' } module-attribute tests . FAKE_USAGE_RECORD_SUMMARY = UsageRecordSummaryDict ( load_fixture ( 'usage_record_summary_sis_fakefakefakefakefake0001.json' )) module-attribute tests . FAKE_WEBHOOK_ENDPOINT_1 = WebhookEndpointDict ( load_fixture ( 'webhook_endpoint_fake0001.json' )) module-attribute tests . FIXTURE_DIR_PATH = Path ( __file__ ) . parent . joinpath ( 'fixtures' ) module-attribute tests . FUTURE_DATE = datetime . datetime ( 2100 , 4 , 30 , tzinfo = get_timezone_utc ()) module-attribute tests . logger = logging . getLogger ( __name__ ) module-attribute Classes tests.AccountDict Bases: dict Source code in tests/__init__.py 232 233 234 235 236 237 238 239 240 241 242 243 244 245 class AccountDict ( dict ): def save ( self , idempotency_key = None ): return self @property def external_accounts ( self ): return ExternalAccounts ( external_account_fakes = self [ \"external_accounts\" ][ \"data\" ] ) def create ( self ): from djstripe.models import Account return Account . sync_from_stripe_data ( self ) Attributes tests . AccountDict . external_accounts property Functions tests . AccountDict . create () Source code in tests/__init__.py 242 243 244 245 def create ( self ): from djstripe.models import Account return Account . sync_from_stripe_data ( self ) tests . AccountDict . save ( idempotency_key = None ) Source code in tests/__init__.py 233 234 def save ( self , idempotency_key = None ): return self tests.AssertStripeFksMixin Source code in tests/__init__.py 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 class AssertStripeFksMixin : def _get_field_str ( self , field ) -> str : if isinstance ( field , models . OneToOneRel ): if field . parent_link : return \"\" else : reverse_id_name = str ( field . remote_field . foreign_related_fields [ 0 ]) return ( reverse_id_name . replace ( \"djstripe_id\" , field . name ) + \" (related name)\" ) elif isinstance ( field , models . ForeignKey ): return str ( field ) else : return \"\" def assert_fks ( self , obj , expected_blank_fks , processed_stripe_ids = None ): \"\"\" Recursively walk through fks on obj, asserting they're not-none :param obj: :param expected_blank_fks: fields that are expected to be None :param processed_stripe_ids: set of objects ids already processed :return: \"\"\" if processed_stripe_ids is None : processed_stripe_ids = set () processed_stripe_ids . add ( obj . id ) for field in obj . _meta . get_fields (): field_str = self . _get_field_str ( field ) if not field_str or field_str . endswith ( \".djstripe_owner_account\" ): continue try : field_value = getattr ( obj , field . name ) except ObjectDoesNotExist : field_value = None if field_str in expected_blank_fks : self . assertIsNone ( field_value , field_str ) else : self . assertIsNotNone ( field_value , field_str ) if field_value . id not in processed_stripe_ids : # recurse into the object if it's not already been checked self . assert_fks ( field_value , expected_blank_fks , processed_stripe_ids ) logger . warning ( \"checked %s \" , field_str ) Functions tests . AssertStripeFksMixin . assert_fks ( obj , expected_blank_fks , processed_stripe_ids = None ) Recursively walk through fks on obj, asserting they're not-none :param obj: :param expected_blank_fks: fields that are expected to be None :param processed_stripe_ids: set of objects ids already processed :return: Source code in tests/__init__.py 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 def assert_fks ( self , obj , expected_blank_fks , processed_stripe_ids = None ): \"\"\" Recursively walk through fks on obj, asserting they're not-none :param obj: :param expected_blank_fks: fields that are expected to be None :param processed_stripe_ids: set of objects ids already processed :return: \"\"\" if processed_stripe_ids is None : processed_stripe_ids = set () processed_stripe_ids . add ( obj . id ) for field in obj . _meta . get_fields (): field_str = self . _get_field_str ( field ) if not field_str or field_str . endswith ( \".djstripe_owner_account\" ): continue try : field_value = getattr ( obj , field . name ) except ObjectDoesNotExist : field_value = None if field_str in expected_blank_fks : self . assertIsNone ( field_value , field_str ) else : self . assertIsNotNone ( field_value , field_str ) if field_value . id not in processed_stripe_ids : # recurse into the object if it's not already been checked self . assert_fks ( field_value , expected_blank_fks , processed_stripe_ids ) logger . warning ( \"checked %s \" , field_str ) tests.BankAccountDict Bases: LegacySourceDict Source code in tests/__init__.py 368 369 class BankAccountDict ( LegacySourceDict ): pass tests.CardDict Bases: LegacySourceDict Source code in tests/__init__.py 409 410 class CardDict ( LegacySourceDict ): pass tests.ChargeDict Bases: StripeItem Source code in tests/__init__.py 684 685 686 687 688 689 690 691 692 693 694 695 696 class ChargeDict ( StripeItem ): def __init__ ( self , * args , ** kwargs ): \"\"\"Match Stripe's behavior: return a stripe iterable on `charge.refunds`.\"\"\" super () . __init__ ( * args , ** kwargs ) self . refunds = StripeList ( self . refunds ) def refund ( self , amount = None , reason = None ): self . update ({ \"refunded\" : True , \"amount_refunded\" : amount }) return self def capture ( self ): self . update ({ \"captured\" : True }) return self Attributes tests . ChargeDict . refunds = StripeList ( self . refunds ) instance-attribute Functions tests . ChargeDict . __init__ ( * args , ** kwargs ) Match Stripe's behavior: return a stripe iterable on charge.refunds . Source code in tests/__init__.py 685 686 687 688 def __init__ ( self , * args , ** kwargs ): \"\"\"Match Stripe's behavior: return a stripe iterable on `charge.refunds`.\"\"\" super () . __init__ ( * args , ** kwargs ) self . refunds = StripeList ( self . refunds ) tests . ChargeDict . capture () Source code in tests/__init__.py 694 695 696 def capture ( self ): self . update ({ \"captured\" : True }) return self tests . ChargeDict . refund ( amount = None , reason = None ) Source code in tests/__init__.py 690 691 692 def refund ( self , amount = None , reason = None ): self . update ({ \"refunded\" : True , \"amount_refunded\" : amount }) return self tests.CustomerDict Bases: dict Source code in tests/__init__.py 1344 1345 1346 1347 1348 1349 1350 1351 1352 1353 1354 1355 1356 1357 1358 1359 1360 1361 1362 1363 1364 1365 1366 1367 1368 1369 class CustomerDict ( dict ): def __init__ ( self , * args , ** kwargs ): super () . __init__ ( * args , ** kwargs ) self [ \"default_source\" ] = convert_source_dict ( self [ \"default_source\" ]) for n , d in enumerate ( self [ \"sources\" ] . get ( \"data\" , [])): self [ \"sources\" ][ \"data\" ][ n ] = convert_source_dict ( d ) def save ( self , idempotency_key = None ): return self def delete ( self ): return self @property def sources ( self ): return Sources ( card_fakes = self [ \"sources\" ][ \"data\" ]) def create_for_user ( self , user ): from djstripe.models import Customer stripe_customer = Customer . sync_from_stripe_data ( self ) stripe_customer . subscriber = user stripe_customer . save () return stripe_customer Attributes tests . CustomerDict . sources property Functions tests . CustomerDict . __init__ ( * args , ** kwargs ) Source code in tests/__init__.py 1345 1346 1347 1348 1349 1350 1351 def __init__ ( self , * args , ** kwargs ): super () . __init__ ( * args , ** kwargs ) self [ \"default_source\" ] = convert_source_dict ( self [ \"default_source\" ]) for n , d in enumerate ( self [ \"sources\" ] . get ( \"data\" , [])): self [ \"sources\" ][ \"data\" ][ n ] = convert_source_dict ( d ) tests . CustomerDict . create_for_user ( user ) Source code in tests/__init__.py 1363 1364 1365 1366 1367 1368 1369 def create_for_user ( self , user ): from djstripe.models import Customer stripe_customer = Customer . sync_from_stripe_data ( self ) stripe_customer . subscriber = user stripe_customer . save () return stripe_customer tests . CustomerDict . delete () Source code in tests/__init__.py 1356 1357 def delete ( self ): return self tests . CustomerDict . save ( idempotency_key = None ) Source code in tests/__init__.py 1353 1354 def save ( self , idempotency_key = None ): return self tests.ExternalAccounts Bases: object Source code in tests/__init__.py 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 class ExternalAccounts ( object ): def __init__ ( self , external_account_fakes ): self . external_account_fakes = external_account_fakes def create ( self , source , api_key = None ): for fake_external_account in self . external_account_fakes : if fake_external_account [ \"id\" ] == source : return fake_external_account def retrieve ( self , id , expand = None ): for fake_external_account in self . external_account_fakes : if fake_external_account [ \"id\" ] == id : return fake_external_account def list ( self , ** kwargs ): return StripeList ( data = self . external_account_fakes ) Attributes tests . ExternalAccounts . external_account_fakes = external_account_fakes instance-attribute Functions tests . ExternalAccounts . __init__ ( external_account_fakes ) Source code in tests/__init__.py 215 216 def __init__ ( self , external_account_fakes ): self . external_account_fakes = external_account_fakes tests . ExternalAccounts . create ( source , api_key = None ) Source code in tests/__init__.py 218 219 220 221 def create ( self , source , api_key = None ): for fake_external_account in self . external_account_fakes : if fake_external_account [ \"id\" ] == source : return fake_external_account tests . ExternalAccounts . list ( ** kwargs ) Source code in tests/__init__.py 228 229 def list ( self , ** kwargs ): return StripeList ( data = self . external_account_fakes ) tests . ExternalAccounts . retrieve ( id , expand = None ) Source code in tests/__init__.py 223 224 225 226 def retrieve ( self , id , expand = None ): for fake_external_account in self . external_account_fakes : if fake_external_account [ \"id\" ] == id : return fake_external_account tests.InvoiceDict Bases: StripeItem Source code in tests/__init__.py 1425 1426 1427 1428 1429 1430 1431 1432 class InvoiceDict ( StripeItem ): def __init__ ( self , * args , ** kwargs ): \"\"\"Match Stripe's behavior: return a stripe iterable on `invoice.lines`.\"\"\" super () . __init__ ( * args , ** kwargs ) self . lines = StripeList ( self . lines ) def pay ( self ): return self Attributes tests . InvoiceDict . lines = StripeList ( self . lines ) instance-attribute Functions tests . InvoiceDict . __init__ ( * args , ** kwargs ) Match Stripe's behavior: return a stripe iterable on invoice.lines . Source code in tests/__init__.py 1426 1427 1428 1429 def __init__ ( self , * args , ** kwargs ): \"\"\"Match Stripe's behavior: return a stripe iterable on `invoice.lines`.\"\"\" super () . __init__ ( * args , ** kwargs ) self . lines = StripeList ( self . lines ) tests . InvoiceDict . pay () Source code in tests/__init__.py 1431 1432 def pay ( self ): return self tests.LegacySourceDict Bases: dict Source code in tests/__init__.py 363 364 365 class LegacySourceDict ( dict ): def delete ( self ): return self Functions tests . LegacySourceDict . delete () Source code in tests/__init__.py 364 365 def delete ( self ): return self tests.PaymentMethodDict Bases: dict Source code in tests/__init__.py 496 497 498 499 class PaymentMethodDict ( dict ): def detach ( self ): self . pop ( \"customer\" ) return self Functions tests . PaymentMethodDict . detach () Source code in tests/__init__.py 497 498 499 def detach ( self ): self . pop ( \"customer\" ) return self tests.PayoutDict Bases: StripeItem Source code in tests/__init__.py 1893 1894 class PayoutDict ( StripeItem ): pass tests.SourceDict Bases: dict Source code in tests/__init__.py 423 424 425 426 427 class SourceDict ( dict ): def detach ( self ): self . pop ( \"customer\" ) self . update ({ \"status\" : \"consumed\" }) return self Functions tests . SourceDict . detach () Source code in tests/__init__.py 424 425 426 427 def detach ( self ): self . pop ( \"customer\" ) self . update ({ \"status\" : \"consumed\" }) return self tests.Sources Bases: object Source code in tests/__init__.py 1311 1312 1313 1314 1315 1316 1317 1318 1319 1320 1321 1322 1323 1324 1325 1326 class Sources ( object ): def __init__ ( self , card_fakes ): self . card_fakes = card_fakes def create ( self , source , api_key = None ): for fake_card in self . card_fakes : if fake_card [ \"id\" ] == source : return fake_card def retrieve ( self , id , expand = None ): for fake_card in self . card_fakes : if fake_card [ \"id\" ] == id : return fake_card def list ( self , ** kwargs ): return StripeList ( data = self . card_fakes ) Attributes tests . Sources . card_fakes = card_fakes instance-attribute Functions tests . Sources . __init__ ( card_fakes ) Source code in tests/__init__.py 1312 1313 def __init__ ( self , card_fakes ): self . card_fakes = card_fakes tests . Sources . create ( source , api_key = None ) Source code in tests/__init__.py 1315 1316 1317 1318 def create ( self , source , api_key = None ): for fake_card in self . card_fakes : if fake_card [ \"id\" ] == source : return fake_card tests . Sources . list ( ** kwargs ) Source code in tests/__init__.py 1325 1326 def list ( self , ** kwargs ): return StripeList ( data = self . card_fakes ) tests . Sources . retrieve ( id , expand = None ) Source code in tests/__init__.py 1320 1321 1322 1323 def retrieve ( self , id , expand = None ): for fake_card in self . card_fakes : if fake_card [ \"id\" ] == id : return fake_card tests.StripeItem Bases: dict Flexible class built to mock any generic Stripe object. Implements object access + deletion methods to match the behavior of Stripe's library, which allows both object + dictionary access. Has a delete method since (most) Stripe objects can be deleted. Source code in tests/__init__.py 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 class StripeItem ( dict ): \"\"\"Flexible class built to mock any generic Stripe object. Implements object access + deletion methods to match the behavior of Stripe's library, which allows both object + dictionary access. Has a delete method since (most) Stripe objects can be deleted. \"\"\" def __getattr__ ( self , name ): \"\"\"Give StripeItem normal object access to match Stripe behavior.\"\"\" if name in self : return self [ name ] else : raise AttributeError ( \"No such attribute: \" + name ) def __setattr__ ( self , name , value ): self [ name ] = value def __delattr__ ( self , name ): if name in self : del self [ name ] else : raise AttributeError ( \"No such attribute: \" + name ) def delete ( self ) -> bool : \"\"\"Superficial mock that adds a deleted attribute.\"\"\" self . deleted = True return self . deleted @classmethod def class_url ( cls ): return \"/v1/test-items/\" def instance_url ( self ): \"\"\"Superficial mock that emulates instance_url.\"\"\" id = self . get ( \"id\" ) base = self . class_url () return \" %s / %s \" % ( base , id ) def request ( self , method , url , params ) -> Dict : \"\"\"Superficial mock that emulates request method.\"\"\" assert method == \"post\" for key , value in params . items (): self . __setattr__ ( key , value ) return self Functions tests . StripeItem . __delattr__ ( name ) Source code in tests/__init__.py 116 117 118 119 120 def __delattr__ ( self , name ): if name in self : del self [ name ] else : raise AttributeError ( \"No such attribute: \" + name ) tests . StripeItem . __getattr__ ( name ) Give StripeItem normal object access to match Stripe behavior. Source code in tests/__init__.py 106 107 108 109 110 111 def __getattr__ ( self , name ): \"\"\"Give StripeItem normal object access to match Stripe behavior.\"\"\" if name in self : return self [ name ] else : raise AttributeError ( \"No such attribute: \" + name ) tests . StripeItem . __setattr__ ( name , value ) Source code in tests/__init__.py 113 114 def __setattr__ ( self , name , value ): self [ name ] = value tests . StripeItem . class_url () classmethod Source code in tests/__init__.py 128 129 130 @classmethod def class_url ( cls ): return \"/v1/test-items/\" tests . StripeItem . delete () Superficial mock that adds a deleted attribute. Source code in tests/__init__.py 122 123 124 125 126 def delete ( self ) -> bool : \"\"\"Superficial mock that adds a deleted attribute.\"\"\" self . deleted = True return self . deleted tests . StripeItem . instance_url () Superficial mock that emulates instance_url. Source code in tests/__init__.py 132 133 134 135 136 def instance_url ( self ): \"\"\"Superficial mock that emulates instance_url.\"\"\" id = self . get ( \"id\" ) base = self . class_url () return \" %s / %s \" % ( base , id ) tests . StripeItem . request ( method , url , params ) Superficial mock that emulates request method. Source code in tests/__init__.py 138 139 140 141 142 143 def request ( self , method , url , params ) -> Dict : \"\"\"Superficial mock that emulates request method.\"\"\" assert method == \"post\" for key , value in params . items (): self . __setattr__ ( key , value ) return self tests.StripeList Bases: dict Mock a generic Stripe Iterable. It has the relevant attributes of a stripe iterable (has_more, data). This mock is important so we can use stripe's list method in our testing. StripeList.list() will return the StripeList. Additionally, iterating over instances of MockStripeIterable will iterate over the data attribute, just like Stripe iterables. Attributes: Name Type Description has_more mock has_more flag. Default False. **kwargs all of the fields of the stripe object, generally as a dictionary. Source code in tests/__init__.py 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 class StripeList ( dict ): \"\"\"Mock a generic Stripe Iterable. It has the relevant attributes of a stripe iterable (has_more, data). This mock is important so we can use stripe's `list` method in our testing. StripeList.list() will return the StripeList. Additionally, iterating over instances of MockStripeIterable will iterate over the data attribute, just like Stripe iterables. Attributes: has_more: mock has_more flag. Default False. **kwargs: all of the fields of the stripe object, generally as a dictionary. \"\"\" object = \"list\" url = \"/v1/fakes\" has_more = False def __getattr__ ( self , name ): \"\"\"Give StripeItem normal object access to match Stripe behavior.\"\"\" if name in self : return self [ name ] else : raise AttributeError ( \"No such attribute: \" + name ) def __setattr__ ( self , name , value ): self [ name ] = value def __delattr__ ( self , name ): if name in self : del self [ name ] else : raise AttributeError ( \"No such attribute: \" + name ) def __iter__ ( self ) -> Any : \"\"\"Make StripeList an iterable, to match the Stripe iterable behavior.\"\"\" self . iter_copy = self . data . copy () return self def __next__ ( self ) -> StripeItem : \"\"\"Define iteration for StripeList.\"\"\" if len ( self . iter_copy ) > 0 : return self . iter_copy . pop ( 0 ) else : raise StopIteration () def list ( self , ** kwargs : Any ) -> \"StripeList\" : \"\"\"Add a list method to the StripeList which returns itself. list() accepts arbitrary kwargs, be careful is you expect the argument-accepting functionality of Stripe's list() method. \"\"\" return self def auto_paging_iter ( self ) -> \"StripeList\" : \"\"\"Add an auto_paging_iter method to the StripeList which returns itself. The StripeList is an iterable, so this mimics the real behavior. \"\"\" return self @property def total_count ( self ): return len ( self . data ) Attributes tests . StripeList . has_more = False class-attribute tests . StripeList . object = 'list' class-attribute tests . StripeList . total_count property tests . StripeList . url = '/v1/fakes' class-attribute Functions tests . StripeList . __delattr__ ( name ) Source code in tests/__init__.py 176 177 178 179 180 def __delattr__ ( self , name ): if name in self : del self [ name ] else : raise AttributeError ( \"No such attribute: \" + name ) tests . StripeList . __getattr__ ( name ) Give StripeItem normal object access to match Stripe behavior. Source code in tests/__init__.py 166 167 168 169 170 171 def __getattr__ ( self , name ): \"\"\"Give StripeItem normal object access to match Stripe behavior.\"\"\" if name in self : return self [ name ] else : raise AttributeError ( \"No such attribute: \" + name ) tests . StripeList . __iter__ () Make StripeList an iterable, to match the Stripe iterable behavior. Source code in tests/__init__.py 182 183 184 185 def __iter__ ( self ) -> Any : \"\"\"Make StripeList an iterable, to match the Stripe iterable behavior.\"\"\" self . iter_copy = self . data . copy () return self tests . StripeList . __next__ () Define iteration for StripeList. Source code in tests/__init__.py 187 188 189 190 191 192 def __next__ ( self ) -> StripeItem : \"\"\"Define iteration for StripeList.\"\"\" if len ( self . iter_copy ) > 0 : return self . iter_copy . pop ( 0 ) else : raise StopIteration () tests . StripeList . __setattr__ ( name , value ) Source code in tests/__init__.py 173 174 def __setattr__ ( self , name , value ): self [ name ] = value tests . StripeList . auto_paging_iter () Add an auto_paging_iter method to the StripeList which returns itself. The StripeList is an iterable, so this mimics the real behavior. Source code in tests/__init__.py 202 203 204 205 206 207 def auto_paging_iter ( self ) -> \"StripeList\" : \"\"\"Add an auto_paging_iter method to the StripeList which returns itself. The StripeList is an iterable, so this mimics the real behavior. \"\"\" return self tests . StripeList . list ( ** kwargs ) Add a list method to the StripeList which returns itself. list() accepts arbitrary kwargs, be careful is you expect the argument-accepting functionality of Stripe's list() method. Source code in tests/__init__.py 194 195 196 197 198 199 200 def list ( self , ** kwargs : Any ) -> \"StripeList\" : \"\"\"Add a list method to the StripeList which returns itself. list() accepts arbitrary kwargs, be careful is you expect the argument-accepting functionality of Stripe's list() method. \"\"\" return self tests.SubscriptionDict Bases: StripeItem Source code in tests/__init__.py 1086 1087 1088 1089 1090 1091 1092 1093 1094 1095 1096 1097 1098 1099 1100 1101 1102 1103 1104 1105 1106 1107 1108 1109 1110 1111 1112 1113 1114 1115 1116 1117 1118 1119 1120 class SubscriptionDict ( StripeItem ): def __init__ ( self , * args , ** kwargs ): \"\"\"Match Stripe's behavior: return a stripe iterable on `subscription.items`.\"\"\" super () . __init__ ( * args , ** kwargs ) self [ \"items\" ] = StripeList ( self [ \"items\" ]) def __setattr__ ( self , name , value ): if type ( value ) == datetime . datetime : value = datetime_to_unix ( value ) # Special case for price and plan if name == \"price\" : for price in [ FAKE_PRICE , FAKE_PRICE_II , FAKE_PRICE_TIER , FAKE_PRICE_METERED , ]: if value == price [ \"id\" ]: value = price elif name == \"plan\" : for plan in [ FAKE_PLAN , FAKE_PLAN_II , FAKE_TIER_PLAN , FAKE_PLAN_METERED ]: if value == plan [ \"id\" ]: value = plan self [ name ] = value def delete ( self , ** kwargs ): if \"at_period_end\" in kwargs : self [ \"cancel_at_period_end\" ] = kwargs [ \"at_period_end\" ] return self def save ( self , idempotency_key = None ): return self Functions tests . SubscriptionDict . __init__ ( * args , ** kwargs ) Match Stripe's behavior: return a stripe iterable on subscription.items . Source code in tests/__init__.py 1087 1088 1089 1090 def __init__ ( self , * args , ** kwargs ): \"\"\"Match Stripe's behavior: return a stripe iterable on `subscription.items`.\"\"\" super () . __init__ ( * args , ** kwargs ) self [ \"items\" ] = StripeList ( self [ \"items\" ]) tests . SubscriptionDict . __setattr__ ( name , value ) Source code in tests/__init__.py 1092 1093 1094 1095 1096 1097 1098 1099 1100 1101 1102 1103 1104 1105 1106 1107 1108 1109 1110 1111 def __setattr__ ( self , name , value ): if type ( value ) == datetime . datetime : value = datetime_to_unix ( value ) # Special case for price and plan if name == \"price\" : for price in [ FAKE_PRICE , FAKE_PRICE_II , FAKE_PRICE_TIER , FAKE_PRICE_METERED , ]: if value == price [ \"id\" ]: value = price elif name == \"plan\" : for plan in [ FAKE_PLAN , FAKE_PLAN_II , FAKE_TIER_PLAN , FAKE_PLAN_METERED ]: if value == plan [ \"id\" ]: value = plan self [ name ] = value tests . SubscriptionDict . delete ( ** kwargs ) Source code in tests/__init__.py 1113 1114 1115 1116 1117 def delete ( self , ** kwargs ): if \"at_period_end\" in kwargs : self [ \"cancel_at_period_end\" ] = kwargs [ \"at_period_end\" ] return self tests . SubscriptionDict . save ( idempotency_key = None ) Source code in tests/__init__.py 1119 1120 def save ( self , idempotency_key = None ): return self tests.UsageRecordSummaryDict Bases: StripeItem Source code in tests/__init__.py 1875 1876 class UsageRecordSummaryDict ( StripeItem ): pass tests.WebhookEndpointDict Bases: StripeItem Source code in tests/__init__.py 1884 1885 class WebhookEndpointDict ( StripeItem ): pass Functions tests . convert_source_dict ( data ) Source code in tests/__init__.py 1329 1330 1331 1332 1333 1334 1335 1336 1337 1338 1339 1340 1341 def convert_source_dict ( data ): if data : source_type = data [ \"object\" ] if source_type == \"card\" : data = CardDict ( data ) elif source_type == \"bank_account\" : data = BankAccountDict ( data ) elif source_type == \"source\" : data = SourceDict ( data ) else : raise ValueError ( f \"Unknown source type: { source_type } \" ) return data tests . datetime_to_unix ( datetime_ ) Source code in tests/__init__.py 93 94 def datetime_to_unix ( datetime_ ): return int ( dateformat . format ( datetime_ , \"U\" )) tests . load_fixture ( filename ) Source code in tests/__init__.py 88 89 90 def load_fixture ( filename ): with FIXTURE_DIR_PATH . joinpath ( filename ) . open ( \"r\" ) as f : return json . load ( f )","title":"Project"},{"location":"reference/project/#tests-attributes","text":"","title":"Attributes"},{"location":"reference/project/#tests.FAKE_ACCOUNT","text":"","title":"FAKE_ACCOUNT"},{"location":"reference/project/#tests.FAKE_BALANCE_TRANSACTION","text":"","title":"FAKE_BALANCE_TRANSACTION"},{"location":"reference/project/#tests.FAKE_BALANCE_TRANSACTION_II","text":"","title":"FAKE_BALANCE_TRANSACTION_II"},{"location":"reference/project/#tests.FAKE_BALANCE_TRANSACTION_III","text":"","title":"FAKE_BALANCE_TRANSACTION_III"},{"location":"reference/project/#tests.FAKE_BALANCE_TRANSACTION_IV","text":"","title":"FAKE_BALANCE_TRANSACTION_IV"},{"location":"reference/project/#tests.FAKE_BALANCE_TRANSACTION_REFUND","text":"","title":"FAKE_BALANCE_TRANSACTION_REFUND"},{"location":"reference/project/#tests.FAKE_BANK_ACCOUNT","text":"","title":"FAKE_BANK_ACCOUNT"},{"location":"reference/project/#tests.FAKE_BANK_ACCOUNT_II","text":"","title":"FAKE_BANK_ACCOUNT_II"},{"location":"reference/project/#tests.FAKE_BANK_ACCOUNT_IV","text":"","title":"FAKE_BANK_ACCOUNT_IV"},{"location":"reference/project/#tests.FAKE_BANK_ACCOUNT_SOURCE","text":"","title":"FAKE_BANK_ACCOUNT_SOURCE"},{"location":"reference/project/#tests.FAKE_CARD","text":"","title":"FAKE_CARD"},{"location":"reference/project/#tests.FAKE_CARD_AS_PAYMENT_METHOD","text":"","title":"FAKE_CARD_AS_PAYMENT_METHOD"},{"location":"reference/project/#tests.FAKE_CARD_II","text":"","title":"FAKE_CARD_II"},{"location":"reference/project/#tests.FAKE_CARD_III","text":"","title":"FAKE_CARD_III"},{"location":"reference/project/#tests.FAKE_CARD_IV","text":"","title":"FAKE_CARD_IV"},{"location":"reference/project/#tests.FAKE_CHARGE","text":"","title":"FAKE_CHARGE"},{"location":"reference/project/#tests.FAKE_CHARGE_II","text":"","title":"FAKE_CHARGE_II"},{"location":"reference/project/#tests.FAKE_CHARGE_REFUNDED","text":"","title":"FAKE_CHARGE_REFUNDED"},{"location":"reference/project/#tests.FAKE_COUPON","text":"","title":"FAKE_COUPON"},{"location":"reference/project/#tests.FAKE_CUSTOMER","text":"","title":"FAKE_CUSTOMER"},{"location":"reference/project/#tests.FAKE_CUSTOMER_II","text":"","title":"FAKE_CUSTOMER_II"},{"location":"reference/project/#tests.FAKE_CUSTOMER_III","text":"","title":"FAKE_CUSTOMER_III"},{"location":"reference/project/#tests.FAKE_CUSTOMER_IV","text":"","title":"FAKE_CUSTOMER_IV"},{"location":"reference/project/#tests.FAKE_CUSTOM_ACCOUNT","text":"","title":"FAKE_CUSTOM_ACCOUNT"},{"location":"reference/project/#tests.FAKE_DISCOUNT","text":"","title":"FAKE_DISCOUNT"},{"location":"reference/project/#tests.FAKE_DISCOUNT_CUSTOMER","text":"","title":"FAKE_DISCOUNT_CUSTOMER"},{"location":"reference/project/#tests.FAKE_DISPUTE_BALANCE_TRANSACTION","text":"","title":"FAKE_DISPUTE_BALANCE_TRANSACTION"},{"location":"reference/project/#tests.FAKE_DISPUTE_BALANCE_TRANSACTION_REFUND_FULL","text":"","title":"FAKE_DISPUTE_BALANCE_TRANSACTION_REFUND_FULL"},{"location":"reference/project/#tests.FAKE_DISPUTE_BALANCE_TRANSACTION_REFUND_PARTIAL","text":"","title":"FAKE_DISPUTE_BALANCE_TRANSACTION_REFUND_PARTIAL"},{"location":"reference/project/#tests.FAKE_DISPUTE_CHARGE","text":"","title":"FAKE_DISPUTE_CHARGE"},{"location":"reference/project/#tests.FAKE_DISPUTE_I","text":"","title":"FAKE_DISPUTE_I"},{"location":"reference/project/#tests.FAKE_DISPUTE_II","text":"","title":"FAKE_DISPUTE_II"},{"location":"reference/project/#tests.FAKE_DISPUTE_III","text":"","title":"FAKE_DISPUTE_III"},{"location":"reference/project/#tests.FAKE_DISPUTE_IV","text":"","title":"FAKE_DISPUTE_IV"},{"location":"reference/project/#tests.FAKE_DISPUTE_PAYMENT_INTENT","text":"","title":"FAKE_DISPUTE_PAYMENT_INTENT"},{"location":"reference/project/#tests.FAKE_DISPUTE_PAYMENT_METHOD","text":"","title":"FAKE_DISPUTE_PAYMENT_METHOD"},{"location":"reference/project/#tests.FAKE_DISPUTE_V_FULL","text":"","title":"FAKE_DISPUTE_V_FULL"},{"location":"reference/project/#tests.FAKE_DISPUTE_V_PARTIAL","text":"","title":"FAKE_DISPUTE_V_PARTIAL"},{"location":"reference/project/#tests.FAKE_EVENT_ACCOUNT_APPLICATION_AUTHORIZED","text":"","title":"FAKE_EVENT_ACCOUNT_APPLICATION_AUTHORIZED"},{"location":"reference/project/#tests.FAKE_EVENT_ACCOUNT_APPLICATION_DEAUTHORIZED","text":"","title":"FAKE_EVENT_ACCOUNT_APPLICATION_DEAUTHORIZED"},{"location":"reference/project/#tests.FAKE_EVENT_ACCOUNT_EXTERNAL_ACCOUNT_BANK_ACCOUNT_CREATED","text":"","title":"FAKE_EVENT_ACCOUNT_EXTERNAL_ACCOUNT_BANK_ACCOUNT_CREATED"},{"location":"reference/project/#tests.FAKE_EVENT_ACCOUNT_EXTERNAL_ACCOUNT_BANK_ACCOUNT_DELETED","text":"","title":"FAKE_EVENT_ACCOUNT_EXTERNAL_ACCOUNT_BANK_ACCOUNT_DELETED"},{"location":"reference/project/#tests.FAKE_EVENT_ACCOUNT_EXTERNAL_ACCOUNT_BANK_ACCOUNT_UPDATED","text":"","title":"FAKE_EVENT_ACCOUNT_EXTERNAL_ACCOUNT_BANK_ACCOUNT_UPDATED"},{"location":"reference/project/#tests.FAKE_EVENT_ACCOUNT_EXTERNAL_ACCOUNT_CARD_CREATED","text":"","title":"FAKE_EVENT_ACCOUNT_EXTERNAL_ACCOUNT_CARD_CREATED"},{"location":"reference/project/#tests.FAKE_EVENT_ACCOUNT_EXTERNAL_ACCOUNT_CARD_DELETED","text":"","title":"FAKE_EVENT_ACCOUNT_EXTERNAL_ACCOUNT_CARD_DELETED"},{"location":"reference/project/#tests.FAKE_EVENT_ACCOUNT_EXTERNAL_ACCOUNT_CARD_UPDATED","text":"","title":"FAKE_EVENT_ACCOUNT_EXTERNAL_ACCOUNT_CARD_UPDATED"},{"location":"reference/project/#tests.FAKE_EVENT_CARD_PAYMENT_METHOD_ATTACHED","text":"","title":"FAKE_EVENT_CARD_PAYMENT_METHOD_ATTACHED"},{"location":"reference/project/#tests.FAKE_EVENT_CARD_PAYMENT_METHOD_DETACHED","text":"","title":"FAKE_EVENT_CARD_PAYMENT_METHOD_DETACHED"},{"location":"reference/project/#tests.FAKE_EVENT_CHARGE_SUCCEEDED","text":"","title":"FAKE_EVENT_CHARGE_SUCCEEDED"},{"location":"reference/project/#tests.FAKE_EVENT_CUSTOMER_CREATED","text":"","title":"FAKE_EVENT_CUSTOMER_CREATED"},{"location":"reference/project/#tests.FAKE_EVENT_CUSTOMER_DELETED","text":"","title":"FAKE_EVENT_CUSTOMER_DELETED"},{"location":"reference/project/#tests.FAKE_EVENT_CUSTOMER_DISCOUNT_CREATED","text":"","title":"FAKE_EVENT_CUSTOMER_DISCOUNT_CREATED"},{"location":"reference/project/#tests.FAKE_EVENT_CUSTOMER_DISCOUNT_DELETED","text":"","title":"FAKE_EVENT_CUSTOMER_DISCOUNT_DELETED"},{"location":"reference/project/#tests.FAKE_EVENT_CUSTOMER_SOURCE_CREATED","text":"","title":"FAKE_EVENT_CUSTOMER_SOURCE_CREATED"},{"location":"reference/project/#tests.FAKE_EVENT_CUSTOMER_SOURCE_DELETED","text":"","title":"FAKE_EVENT_CUSTOMER_SOURCE_DELETED"},{"location":"reference/project/#tests.FAKE_EVENT_CUSTOMER_SOURCE_DELETED_DUPE","text":"","title":"FAKE_EVENT_CUSTOMER_SOURCE_DELETED_DUPE"},{"location":"reference/project/#tests.FAKE_EVENT_CUSTOMER_SUBSCRIPTION_CREATED","text":"","title":"FAKE_EVENT_CUSTOMER_SUBSCRIPTION_CREATED"},{"location":"reference/project/#tests.FAKE_EVENT_CUSTOMER_SUBSCRIPTION_DELETED","text":"","title":"FAKE_EVENT_CUSTOMER_SUBSCRIPTION_DELETED"},{"location":"reference/project/#tests.FAKE_EVENT_CUSTOMER_UPDATED","text":"","title":"FAKE_EVENT_CUSTOMER_UPDATED"},{"location":"reference/project/#tests.FAKE_EVENT_CUSTOM_ACCOUNT_UPDATED","text":"","title":"FAKE_EVENT_CUSTOM_ACCOUNT_UPDATED"},{"location":"reference/project/#tests.FAKE_EVENT_DISPUTE_CLOSED","text":"","title":"FAKE_EVENT_DISPUTE_CLOSED"},{"location":"reference/project/#tests.FAKE_EVENT_DISPUTE_CREATED","text":"","title":"FAKE_EVENT_DISPUTE_CREATED"},{"location":"reference/project/#tests.FAKE_EVENT_DISPUTE_FUNDS_REINSTATED_FULL","text":"","title":"FAKE_EVENT_DISPUTE_FUNDS_REINSTATED_FULL"},{"location":"reference/project/#tests.FAKE_EVENT_DISPUTE_FUNDS_REINSTATED_PARTIAL","text":"","title":"FAKE_EVENT_DISPUTE_FUNDS_REINSTATED_PARTIAL"},{"location":"reference/project/#tests.FAKE_EVENT_DISPUTE_FUNDS_WITHDRAWN","text":"","title":"FAKE_EVENT_DISPUTE_FUNDS_WITHDRAWN"},{"location":"reference/project/#tests.FAKE_EVENT_DISPUTE_UPDATED","text":"","title":"FAKE_EVENT_DISPUTE_UPDATED"},{"location":"reference/project/#tests.FAKE_EVENT_EXPRESS_ACCOUNT_UPDATED","text":"","title":"FAKE_EVENT_EXPRESS_ACCOUNT_UPDATED"},{"location":"reference/project/#tests.FAKE_EVENT_FILE_CREATED","text":"","title":"FAKE_EVENT_FILE_CREATED"},{"location":"reference/project/#tests.FAKE_EVENT_INVOICEITEM_CREATED","text":"","title":"FAKE_EVENT_INVOICEITEM_CREATED"},{"location":"reference/project/#tests.FAKE_EVENT_INVOICEITEM_DELETED","text":"","title":"FAKE_EVENT_INVOICEITEM_DELETED"},{"location":"reference/project/#tests.FAKE_EVENT_INVOICE_CREATED","text":"","title":"FAKE_EVENT_INVOICE_CREATED"},{"location":"reference/project/#tests.FAKE_EVENT_INVOICE_DELETED","text":"","title":"FAKE_EVENT_INVOICE_DELETED"},{"location":"reference/project/#tests.FAKE_EVENT_INVOICE_UPCOMING","text":"","title":"FAKE_EVENT_INVOICE_UPCOMING"},{"location":"reference/project/#tests.FAKE_EVENT_ORDER_CANCELLED","text":"","title":"FAKE_EVENT_ORDER_CANCELLED"},{"location":"reference/project/#tests.FAKE_EVENT_ORDER_COMPLETED","text":"","title":"FAKE_EVENT_ORDER_COMPLETED"},{"location":"reference/project/#tests.FAKE_EVENT_ORDER_CREATED","text":"","title":"FAKE_EVENT_ORDER_CREATED"},{"location":"reference/project/#tests.FAKE_EVENT_ORDER_PROCESSING","text":"","title":"FAKE_EVENT_ORDER_PROCESSING"},{"location":"reference/project/#tests.FAKE_EVENT_ORDER_SUBMITTED","text":"","title":"FAKE_EVENT_ORDER_SUBMITTED"},{"location":"reference/project/#tests.FAKE_EVENT_ORDER_UPDATED","text":"","title":"FAKE_EVENT_ORDER_UPDATED"},{"location":"reference/project/#tests.FAKE_EVENT_PAYMENT_INTENT_SUCCEEDED_DESTINATION_CHARGE","text":"","title":"FAKE_EVENT_PAYMENT_INTENT_SUCCEEDED_DESTINATION_CHARGE"},{"location":"reference/project/#tests.FAKE_EVENT_PAYMENT_METHOD_ATTACHED","text":"","title":"FAKE_EVENT_PAYMENT_METHOD_ATTACHED"},{"location":"reference/project/#tests.FAKE_EVENT_PAYMENT_METHOD_DETACHED","text":"","title":"FAKE_EVENT_PAYMENT_METHOD_DETACHED"},{"location":"reference/project/#tests.FAKE_EVENT_PLAN_CREATED","text":"","title":"FAKE_EVENT_PLAN_CREATED"},{"location":"reference/project/#tests.FAKE_EVENT_PLAN_DELETED","text":"","title":"FAKE_EVENT_PLAN_DELETED"},{"location":"reference/project/#tests.FAKE_EVENT_PLAN_REQUEST_IS_OBJECT","text":"","title":"FAKE_EVENT_PLAN_REQUEST_IS_OBJECT"},{"location":"reference/project/#tests.FAKE_EVENT_PRICE_CREATED","text":"","title":"FAKE_EVENT_PRICE_CREATED"},{"location":"reference/project/#tests.FAKE_EVENT_PRICE_DELETED","text":"","title":"FAKE_EVENT_PRICE_DELETED"},{"location":"reference/project/#tests.FAKE_EVENT_PRICE_UPDATED","text":"","title":"FAKE_EVENT_PRICE_UPDATED"},{"location":"reference/project/#tests.FAKE_EVENT_SESSION_COMPLETED","text":"","title":"FAKE_EVENT_SESSION_COMPLETED"},{"location":"reference/project/#tests.FAKE_EVENT_STANDARD_ACCOUNT_UPDATED","text":"","title":"FAKE_EVENT_STANDARD_ACCOUNT_UPDATED"},{"location":"reference/project/#tests.FAKE_EVENT_SUBSCRIPTION_SCHEDULE_ABORTED","text":"","title":"FAKE_EVENT_SUBSCRIPTION_SCHEDULE_ABORTED"},{"location":"reference/project/#tests.FAKE_EVENT_SUBSCRIPTION_SCHEDULE_CANCELED","text":"","title":"FAKE_EVENT_SUBSCRIPTION_SCHEDULE_CANCELED"},{"location":"reference/project/#tests.FAKE_EVENT_SUBSCRIPTION_SCHEDULE_COMPLETED","text":"","title":"FAKE_EVENT_SUBSCRIPTION_SCHEDULE_COMPLETED"},{"location":"reference/project/#tests.FAKE_EVENT_SUBSCRIPTION_SCHEDULE_CREATED","text":"","title":"FAKE_EVENT_SUBSCRIPTION_SCHEDULE_CREATED"},{"location":"reference/project/#tests.FAKE_EVENT_SUBSCRIPTION_SCHEDULE_EXPIRING","text":"","title":"FAKE_EVENT_SUBSCRIPTION_SCHEDULE_EXPIRING"},{"location":"reference/project/#tests.FAKE_EVENT_SUBSCRIPTION_SCHEDULE_RELEASED","text":"","title":"FAKE_EVENT_SUBSCRIPTION_SCHEDULE_RELEASED"},{"location":"reference/project/#tests.FAKE_EVENT_SUBSCRIPTION_SCHEDULE_UPDATED","text":"","title":"FAKE_EVENT_SUBSCRIPTION_SCHEDULE_UPDATED"},{"location":"reference/project/#tests.FAKE_EVENT_TAX_ID_CREATED","text":"","title":"FAKE_EVENT_TAX_ID_CREATED"},{"location":"reference/project/#tests.FAKE_EVENT_TAX_ID_DELETED","text":"","title":"FAKE_EVENT_TAX_ID_DELETED"},{"location":"reference/project/#tests.FAKE_EVENT_TAX_ID_UPDATED","text":"","title":"FAKE_EVENT_TAX_ID_UPDATED"},{"location":"reference/project/#tests.FAKE_EVENT_TEST_CHARGE_SUCCEEDED","text":"","title":"FAKE_EVENT_TEST_CHARGE_SUCCEEDED"},{"location":"reference/project/#tests.FAKE_EVENT_TRANSFER_CREATED","text":"","title":"FAKE_EVENT_TRANSFER_CREATED"},{"location":"reference/project/#tests.FAKE_EVENT_TRANSFER_DELETED","text":"","title":"FAKE_EVENT_TRANSFER_DELETED"},{"location":"reference/project/#tests.FAKE_EXPRESS_ACCOUNT","text":"","title":"FAKE_EXPRESS_ACCOUNT"},{"location":"reference/project/#tests.FAKE_FILEUPLOAD_ICON","text":"","title":"FAKE_FILEUPLOAD_ICON"},{"location":"reference/project/#tests.FAKE_FILEUPLOAD_LOGO","text":"","title":"FAKE_FILEUPLOAD_LOGO"},{"location":"reference/project/#tests.FAKE_INVOICE","text":"","title":"FAKE_INVOICE"},{"location":"reference/project/#tests.FAKE_INVOICEITEM","text":"","title":"FAKE_INVOICEITEM"},{"location":"reference/project/#tests.FAKE_INVOICEITEM_II","text":"","title":"FAKE_INVOICEITEM_II"},{"location":"reference/project/#tests.FAKE_INVOICEITEM_III","text":"","title":"FAKE_INVOICEITEM_III"},{"location":"reference/project/#tests.FAKE_INVOICE_II","text":"","title":"FAKE_INVOICE_II"},{"location":"reference/project/#tests.FAKE_INVOICE_III","text":"","title":"FAKE_INVOICE_III"},{"location":"reference/project/#tests.FAKE_INVOICE_IV","text":"","title":"FAKE_INVOICE_IV"},{"location":"reference/project/#tests.FAKE_INVOICE_METERED_SUBSCRIPTION","text":"","title":"FAKE_INVOICE_METERED_SUBSCRIPTION"},{"location":"reference/project/#tests.FAKE_INVOICE_METERED_SUBSCRIPTION_USAGE","text":"","title":"FAKE_INVOICE_METERED_SUBSCRIPTION_USAGE"},{"location":"reference/project/#tests.FAKE_LINE_ITEM","text":"","title":"FAKE_LINE_ITEM"},{"location":"reference/project/#tests.FAKE_LINE_ITEM_SUBSCRIPTION","text":"","title":"FAKE_LINE_ITEM_SUBSCRIPTION"},{"location":"reference/project/#tests.FAKE_ORDER_WITHOUT_CUSTOMER_WITHOUT_PAYMENT_INTENT","text":"","title":"FAKE_ORDER_WITHOUT_CUSTOMER_WITHOUT_PAYMENT_INTENT"},{"location":"reference/project/#tests.FAKE_ORDER_WITHOUT_CUSTOMER_WITH_PAYMENT_INTENT","text":"","title":"FAKE_ORDER_WITHOUT_CUSTOMER_WITH_PAYMENT_INTENT"},{"location":"reference/project/#tests.FAKE_ORDER_WITH_CUSTOMER_WITHOUT_PAYMENT_INTENT","text":"","title":"FAKE_ORDER_WITH_CUSTOMER_WITHOUT_PAYMENT_INTENT"},{"location":"reference/project/#tests.FAKE_ORDER_WITH_CUSTOMER_WITH_PAYMENT_INTENT","text":"","title":"FAKE_ORDER_WITH_CUSTOMER_WITH_PAYMENT_INTENT"},{"location":"reference/project/#tests.FAKE_PAYMENT_INTENT_DESTINATION_CHARGE","text":"","title":"FAKE_PAYMENT_INTENT_DESTINATION_CHARGE"},{"location":"reference/project/#tests.FAKE_PAYMENT_INTENT_I","text":"","title":"FAKE_PAYMENT_INTENT_I"},{"location":"reference/project/#tests.FAKE_PAYMENT_INTENT_II","text":"","title":"FAKE_PAYMENT_INTENT_II"},{"location":"reference/project/#tests.FAKE_PAYMENT_METHOD_I","text":"","title":"FAKE_PAYMENT_METHOD_I"},{"location":"reference/project/#tests.FAKE_PAYMENT_METHOD_II","text":"","title":"FAKE_PAYMENT_METHOD_II"},{"location":"reference/project/#tests.FAKE_PAYOUT_CUSTOM_BANK_ACCOUNT","text":"","title":"FAKE_PAYOUT_CUSTOM_BANK_ACCOUNT"},{"location":"reference/project/#tests.FAKE_PAYOUT_CUSTOM_CARD","text":"","title":"FAKE_PAYOUT_CUSTOM_CARD"},{"location":"reference/project/#tests.FAKE_PLAN","text":"","title":"FAKE_PLAN"},{"location":"reference/project/#tests.FAKE_PLAN_II","text":"","title":"FAKE_PLAN_II"},{"location":"reference/project/#tests.FAKE_PLAN_METERED","text":"","title":"FAKE_PLAN_METERED"},{"location":"reference/project/#tests.FAKE_PLATFORM_ACCOUNT","text":"","title":"FAKE_PLATFORM_ACCOUNT"},{"location":"reference/project/#tests.FAKE_PRICE","text":"","title":"FAKE_PRICE"},{"location":"reference/project/#tests.FAKE_PRICE_II","text":"","title":"FAKE_PRICE_II"},{"location":"reference/project/#tests.FAKE_PRICE_METERED","text":"","title":"FAKE_PRICE_METERED"},{"location":"reference/project/#tests.FAKE_PRICE_ONETIME","text":"","title":"FAKE_PRICE_ONETIME"},{"location":"reference/project/#tests.FAKE_PRICE_TIER","text":"","title":"FAKE_PRICE_TIER"},{"location":"reference/project/#tests.FAKE_PRODUCT","text":"","title":"FAKE_PRODUCT"},{"location":"reference/project/#tests.FAKE_REFUND","text":"","title":"FAKE_REFUND"},{"location":"reference/project/#tests.FAKE_SESSION_I","text":"","title":"FAKE_SESSION_I"},{"location":"reference/project/#tests.FAKE_SETUP_INTENT_DESTINATION_CHARGE","text":"","title":"FAKE_SETUP_INTENT_DESTINATION_CHARGE"},{"location":"reference/project/#tests.FAKE_SETUP_INTENT_I","text":"","title":"FAKE_SETUP_INTENT_I"},{"location":"reference/project/#tests.FAKE_SETUP_INTENT_II","text":"","title":"FAKE_SETUP_INTENT_II"},{"location":"reference/project/#tests.FAKE_SHIPPING_RATE","text":"","title":"FAKE_SHIPPING_RATE"},{"location":"reference/project/#tests.FAKE_SHIPPING_RATE_WITH_TAX_CODE","text":"","title":"FAKE_SHIPPING_RATE_WITH_TAX_CODE"},{"location":"reference/project/#tests.FAKE_SOURCE","text":"","title":"FAKE_SOURCE"},{"location":"reference/project/#tests.FAKE_SOURCE_II","text":"","title":"FAKE_SOURCE_II"},{"location":"reference/project/#tests.FAKE_STANDARD_ACCOUNT","text":"","title":"FAKE_STANDARD_ACCOUNT"},{"location":"reference/project/#tests.FAKE_SUBSCRIPTION","text":"","title":"FAKE_SUBSCRIPTION"},{"location":"reference/project/#tests.FAKE_SUBSCRIPTION_CANCELED","text":"","title":"FAKE_SUBSCRIPTION_CANCELED"},{"location":"reference/project/#tests.FAKE_SUBSCRIPTION_CANCELED_AT_PERIOD_END","text":"","title":"FAKE_SUBSCRIPTION_CANCELED_AT_PERIOD_END"},{"location":"reference/project/#tests.FAKE_SUBSCRIPTION_II","text":"","title":"FAKE_SUBSCRIPTION_II"},{"location":"reference/project/#tests.FAKE_SUBSCRIPTION_III","text":"","title":"FAKE_SUBSCRIPTION_III"},{"location":"reference/project/#tests.FAKE_SUBSCRIPTION_ITEM","text":"","title":"FAKE_SUBSCRIPTION_ITEM"},{"location":"reference/project/#tests.FAKE_SUBSCRIPTION_ITEM_METERED","text":"","title":"FAKE_SUBSCRIPTION_ITEM_METERED"},{"location":"reference/project/#tests.FAKE_SUBSCRIPTION_ITEM_MULTI_PLAN","text":"","title":"FAKE_SUBSCRIPTION_ITEM_MULTI_PLAN"},{"location":"reference/project/#tests.FAKE_SUBSCRIPTION_ITEM_TAX_RATES","text":"","title":"FAKE_SUBSCRIPTION_ITEM_TAX_RATES"},{"location":"reference/project/#tests.FAKE_SUBSCRIPTION_METERED","text":"","title":"FAKE_SUBSCRIPTION_METERED"},{"location":"reference/project/#tests.FAKE_SUBSCRIPTION_MULTI_PLAN","text":"","title":"FAKE_SUBSCRIPTION_MULTI_PLAN"},{"location":"reference/project/#tests.FAKE_SUBSCRIPTION_NOT_PERIOD_CURRENT","text":"","title":"FAKE_SUBSCRIPTION_NOT_PERIOD_CURRENT"},{"location":"reference/project/#tests.FAKE_SUBSCRIPTION_SCHEDULE","text":"","title":"FAKE_SUBSCRIPTION_SCHEDULE"},{"location":"reference/project/#tests.FAKE_TAX_CODE","text":"","title":"FAKE_TAX_CODE"},{"location":"reference/project/#tests.FAKE_TAX_ID","text":"","title":"FAKE_TAX_ID"},{"location":"reference/project/#tests.FAKE_TAX_ID_UPDATED","text":"","title":"FAKE_TAX_ID_UPDATED"},{"location":"reference/project/#tests.FAKE_TAX_RATE_EXAMPLE_1_VAT","text":"","title":"FAKE_TAX_RATE_EXAMPLE_1_VAT"},{"location":"reference/project/#tests.FAKE_TAX_RATE_EXAMPLE_2_SALES","text":"","title":"FAKE_TAX_RATE_EXAMPLE_2_SALES"},{"location":"reference/project/#tests.FAKE_TIER_PLAN","text":"","title":"FAKE_TIER_PLAN"},{"location":"reference/project/#tests.FAKE_TOKEN","text":"","title":"FAKE_TOKEN"},{"location":"reference/project/#tests.FAKE_TRANSFER","text":"","title":"FAKE_TRANSFER"},{"location":"reference/project/#tests.FAKE_TRANSFER_WITH_1_REVERSAL","text":"","title":"FAKE_TRANSFER_WITH_1_REVERSAL"},{"location":"reference/project/#tests.FAKE_UPCOMING_INVOICE","text":"","title":"FAKE_UPCOMING_INVOICE"},{"location":"reference/project/#tests.FAKE_USAGE_RECORD","text":"","title":"FAKE_USAGE_RECORD"},{"location":"reference/project/#tests.FAKE_USAGE_RECORD_SUMMARY","text":"","title":"FAKE_USAGE_RECORD_SUMMARY"},{"location":"reference/project/#tests.FAKE_WEBHOOK_ENDPOINT_1","text":"","title":"FAKE_WEBHOOK_ENDPOINT_1"},{"location":"reference/project/#tests.FIXTURE_DIR_PATH","text":"","title":"FIXTURE_DIR_PATH"},{"location":"reference/project/#tests.FUTURE_DATE","text":"","title":"FUTURE_DATE"},{"location":"reference/project/#tests.logger","text":"","title":"logger"},{"location":"reference/project/#tests-classes","text":"","title":"Classes"},{"location":"reference/project/#tests.AccountDict","text":"Bases: dict Source code in tests/__init__.py 232 233 234 235 236 237 238 239 240 241 242 243 244 245 class AccountDict ( dict ): def save ( self , idempotency_key = None ): return self @property def external_accounts ( self ): return ExternalAccounts ( external_account_fakes = self [ \"external_accounts\" ][ \"data\" ] ) def create ( self ): from djstripe.models import Account return Account . sync_from_stripe_data ( self )","title":"AccountDict"},{"location":"reference/project/#tests.AccountDict-attributes","text":"","title":"Attributes"},{"location":"reference/project/#tests.AccountDict.external_accounts","text":"","title":"external_accounts"},{"location":"reference/project/#tests.AccountDict-functions","text":"","title":"Functions"},{"location":"reference/project/#tests.AccountDict.create","text":"Source code in tests/__init__.py 242 243 244 245 def create ( self ): from djstripe.models import Account return Account . sync_from_stripe_data ( self )","title":"create()"},{"location":"reference/project/#tests.AccountDict.save","text":"Source code in tests/__init__.py 233 234 def save ( self , idempotency_key = None ): return self","title":"save()"},{"location":"reference/project/#tests.AssertStripeFksMixin","text":"Source code in tests/__init__.py 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 class AssertStripeFksMixin : def _get_field_str ( self , field ) -> str : if isinstance ( field , models . OneToOneRel ): if field . parent_link : return \"\" else : reverse_id_name = str ( field . remote_field . foreign_related_fields [ 0 ]) return ( reverse_id_name . replace ( \"djstripe_id\" , field . name ) + \" (related name)\" ) elif isinstance ( field , models . ForeignKey ): return str ( field ) else : return \"\" def assert_fks ( self , obj , expected_blank_fks , processed_stripe_ids = None ): \"\"\" Recursively walk through fks on obj, asserting they're not-none :param obj: :param expected_blank_fks: fields that are expected to be None :param processed_stripe_ids: set of objects ids already processed :return: \"\"\" if processed_stripe_ids is None : processed_stripe_ids = set () processed_stripe_ids . add ( obj . id ) for field in obj . _meta . get_fields (): field_str = self . _get_field_str ( field ) if not field_str or field_str . endswith ( \".djstripe_owner_account\" ): continue try : field_value = getattr ( obj , field . name ) except ObjectDoesNotExist : field_value = None if field_str in expected_blank_fks : self . assertIsNone ( field_value , field_str ) else : self . assertIsNotNone ( field_value , field_str ) if field_value . id not in processed_stripe_ids : # recurse into the object if it's not already been checked self . assert_fks ( field_value , expected_blank_fks , processed_stripe_ids ) logger . warning ( \"checked %s \" , field_str )","title":"AssertStripeFksMixin"},{"location":"reference/project/#tests.AssertStripeFksMixin-functions","text":"","title":"Functions"},{"location":"reference/project/#tests.AssertStripeFksMixin.assert_fks","text":"Recursively walk through fks on obj, asserting they're not-none :param obj: :param expected_blank_fks: fields that are expected to be None :param processed_stripe_ids: set of objects ids already processed :return: Source code in tests/__init__.py 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 def assert_fks ( self , obj , expected_blank_fks , processed_stripe_ids = None ): \"\"\" Recursively walk through fks on obj, asserting they're not-none :param obj: :param expected_blank_fks: fields that are expected to be None :param processed_stripe_ids: set of objects ids already processed :return: \"\"\" if processed_stripe_ids is None : processed_stripe_ids = set () processed_stripe_ids . add ( obj . id ) for field in obj . _meta . get_fields (): field_str = self . _get_field_str ( field ) if not field_str or field_str . endswith ( \".djstripe_owner_account\" ): continue try : field_value = getattr ( obj , field . name ) except ObjectDoesNotExist : field_value = None if field_str in expected_blank_fks : self . assertIsNone ( field_value , field_str ) else : self . assertIsNotNone ( field_value , field_str ) if field_value . id not in processed_stripe_ids : # recurse into the object if it's not already been checked self . assert_fks ( field_value , expected_blank_fks , processed_stripe_ids ) logger . warning ( \"checked %s \" , field_str )","title":"assert_fks()"},{"location":"reference/project/#tests.BankAccountDict","text":"Bases: LegacySourceDict Source code in tests/__init__.py 368 369 class BankAccountDict ( LegacySourceDict ): pass","title":"BankAccountDict"},{"location":"reference/project/#tests.CardDict","text":"Bases: LegacySourceDict Source code in tests/__init__.py 409 410 class CardDict ( LegacySourceDict ): pass","title":"CardDict"},{"location":"reference/project/#tests.ChargeDict","text":"Bases: StripeItem Source code in tests/__init__.py 684 685 686 687 688 689 690 691 692 693 694 695 696 class ChargeDict ( StripeItem ): def __init__ ( self , * args , ** kwargs ): \"\"\"Match Stripe's behavior: return a stripe iterable on `charge.refunds`.\"\"\" super () . __init__ ( * args , ** kwargs ) self . refunds = StripeList ( self . refunds ) def refund ( self , amount = None , reason = None ): self . update ({ \"refunded\" : True , \"amount_refunded\" : amount }) return self def capture ( self ): self . update ({ \"captured\" : True }) return self","title":"ChargeDict"},{"location":"reference/project/#tests.ChargeDict-attributes","text":"","title":"Attributes"},{"location":"reference/project/#tests.ChargeDict.refunds","text":"","title":"refunds"},{"location":"reference/project/#tests.ChargeDict-functions","text":"","title":"Functions"},{"location":"reference/project/#tests.ChargeDict.__init__","text":"Match Stripe's behavior: return a stripe iterable on charge.refunds . Source code in tests/__init__.py 685 686 687 688 def __init__ ( self , * args , ** kwargs ): \"\"\"Match Stripe's behavior: return a stripe iterable on `charge.refunds`.\"\"\" super () . __init__ ( * args , ** kwargs ) self . refunds = StripeList ( self . refunds )","title":"__init__()"},{"location":"reference/project/#tests.ChargeDict.capture","text":"Source code in tests/__init__.py 694 695 696 def capture ( self ): self . update ({ \"captured\" : True }) return self","title":"capture()"},{"location":"reference/project/#tests.ChargeDict.refund","text":"Source code in tests/__init__.py 690 691 692 def refund ( self , amount = None , reason = None ): self . update ({ \"refunded\" : True , \"amount_refunded\" : amount }) return self","title":"refund()"},{"location":"reference/project/#tests.CustomerDict","text":"Bases: dict Source code in tests/__init__.py 1344 1345 1346 1347 1348 1349 1350 1351 1352 1353 1354 1355 1356 1357 1358 1359 1360 1361 1362 1363 1364 1365 1366 1367 1368 1369 class CustomerDict ( dict ): def __init__ ( self , * args , ** kwargs ): super () . __init__ ( * args , ** kwargs ) self [ \"default_source\" ] = convert_source_dict ( self [ \"default_source\" ]) for n , d in enumerate ( self [ \"sources\" ] . get ( \"data\" , [])): self [ \"sources\" ][ \"data\" ][ n ] = convert_source_dict ( d ) def save ( self , idempotency_key = None ): return self def delete ( self ): return self @property def sources ( self ): return Sources ( card_fakes = self [ \"sources\" ][ \"data\" ]) def create_for_user ( self , user ): from djstripe.models import Customer stripe_customer = Customer . sync_from_stripe_data ( self ) stripe_customer . subscriber = user stripe_customer . save () return stripe_customer","title":"CustomerDict"},{"location":"reference/project/#tests.CustomerDict-attributes","text":"","title":"Attributes"},{"location":"reference/project/#tests.CustomerDict.sources","text":"","title":"sources"},{"location":"reference/project/#tests.CustomerDict-functions","text":"","title":"Functions"},{"location":"reference/project/#tests.CustomerDict.__init__","text":"Source code in tests/__init__.py 1345 1346 1347 1348 1349 1350 1351 def __init__ ( self , * args , ** kwargs ): super () . __init__ ( * args , ** kwargs ) self [ \"default_source\" ] = convert_source_dict ( self [ \"default_source\" ]) for n , d in enumerate ( self [ \"sources\" ] . get ( \"data\" , [])): self [ \"sources\" ][ \"data\" ][ n ] = convert_source_dict ( d )","title":"__init__()"},{"location":"reference/project/#tests.CustomerDict.create_for_user","text":"Source code in tests/__init__.py 1363 1364 1365 1366 1367 1368 1369 def create_for_user ( self , user ): from djstripe.models import Customer stripe_customer = Customer . sync_from_stripe_data ( self ) stripe_customer . subscriber = user stripe_customer . save () return stripe_customer","title":"create_for_user()"},{"location":"reference/project/#tests.CustomerDict.delete","text":"Source code in tests/__init__.py 1356 1357 def delete ( self ): return self","title":"delete()"},{"location":"reference/project/#tests.CustomerDict.save","text":"Source code in tests/__init__.py 1353 1354 def save ( self , idempotency_key = None ): return self","title":"save()"},{"location":"reference/project/#tests.ExternalAccounts","text":"Bases: object Source code in tests/__init__.py 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 class ExternalAccounts ( object ): def __init__ ( self , external_account_fakes ): self . external_account_fakes = external_account_fakes def create ( self , source , api_key = None ): for fake_external_account in self . external_account_fakes : if fake_external_account [ \"id\" ] == source : return fake_external_account def retrieve ( self , id , expand = None ): for fake_external_account in self . external_account_fakes : if fake_external_account [ \"id\" ] == id : return fake_external_account def list ( self , ** kwargs ): return StripeList ( data = self . external_account_fakes )","title":"ExternalAccounts"},{"location":"reference/project/#tests.ExternalAccounts-attributes","text":"","title":"Attributes"},{"location":"reference/project/#tests.ExternalAccounts.external_account_fakes","text":"","title":"external_account_fakes"},{"location":"reference/project/#tests.ExternalAccounts-functions","text":"","title":"Functions"},{"location":"reference/project/#tests.ExternalAccounts.__init__","text":"Source code in tests/__init__.py 215 216 def __init__ ( self , external_account_fakes ): self . external_account_fakes = external_account_fakes","title":"__init__()"},{"location":"reference/project/#tests.ExternalAccounts.create","text":"Source code in tests/__init__.py 218 219 220 221 def create ( self , source , api_key = None ): for fake_external_account in self . external_account_fakes : if fake_external_account [ \"id\" ] == source : return fake_external_account","title":"create()"},{"location":"reference/project/#tests.ExternalAccounts.list","text":"Source code in tests/__init__.py 228 229 def list ( self , ** kwargs ): return StripeList ( data = self . external_account_fakes )","title":"list()"},{"location":"reference/project/#tests.ExternalAccounts.retrieve","text":"Source code in tests/__init__.py 223 224 225 226 def retrieve ( self , id , expand = None ): for fake_external_account in self . external_account_fakes : if fake_external_account [ \"id\" ] == id : return fake_external_account","title":"retrieve()"},{"location":"reference/project/#tests.InvoiceDict","text":"Bases: StripeItem Source code in tests/__init__.py 1425 1426 1427 1428 1429 1430 1431 1432 class InvoiceDict ( StripeItem ): def __init__ ( self , * args , ** kwargs ): \"\"\"Match Stripe's behavior: return a stripe iterable on `invoice.lines`.\"\"\" super () . __init__ ( * args , ** kwargs ) self . lines = StripeList ( self . lines ) def pay ( self ): return self","title":"InvoiceDict"},{"location":"reference/project/#tests.InvoiceDict-attributes","text":"","title":"Attributes"},{"location":"reference/project/#tests.InvoiceDict.lines","text":"","title":"lines"},{"location":"reference/project/#tests.InvoiceDict-functions","text":"","title":"Functions"},{"location":"reference/project/#tests.InvoiceDict.__init__","text":"Match Stripe's behavior: return a stripe iterable on invoice.lines . Source code in tests/__init__.py 1426 1427 1428 1429 def __init__ ( self , * args , ** kwargs ): \"\"\"Match Stripe's behavior: return a stripe iterable on `invoice.lines`.\"\"\" super () . __init__ ( * args , ** kwargs ) self . lines = StripeList ( self . lines )","title":"__init__()"},{"location":"reference/project/#tests.InvoiceDict.pay","text":"Source code in tests/__init__.py 1431 1432 def pay ( self ): return self","title":"pay()"},{"location":"reference/project/#tests.LegacySourceDict","text":"Bases: dict Source code in tests/__init__.py 363 364 365 class LegacySourceDict ( dict ): def delete ( self ): return self","title":"LegacySourceDict"},{"location":"reference/project/#tests.LegacySourceDict-functions","text":"","title":"Functions"},{"location":"reference/project/#tests.LegacySourceDict.delete","text":"Source code in tests/__init__.py 364 365 def delete ( self ): return self","title":"delete()"},{"location":"reference/project/#tests.PaymentMethodDict","text":"Bases: dict Source code in tests/__init__.py 496 497 498 499 class PaymentMethodDict ( dict ): def detach ( self ): self . pop ( \"customer\" ) return self","title":"PaymentMethodDict"},{"location":"reference/project/#tests.PaymentMethodDict-functions","text":"","title":"Functions"},{"location":"reference/project/#tests.PaymentMethodDict.detach","text":"Source code in tests/__init__.py 497 498 499 def detach ( self ): self . pop ( \"customer\" ) return self","title":"detach()"},{"location":"reference/project/#tests.PayoutDict","text":"Bases: StripeItem Source code in tests/__init__.py 1893 1894 class PayoutDict ( StripeItem ): pass","title":"PayoutDict"},{"location":"reference/project/#tests.SourceDict","text":"Bases: dict Source code in tests/__init__.py 423 424 425 426 427 class SourceDict ( dict ): def detach ( self ): self . pop ( \"customer\" ) self . update ({ \"status\" : \"consumed\" }) return self","title":"SourceDict"},{"location":"reference/project/#tests.SourceDict-functions","text":"","title":"Functions"},{"location":"reference/project/#tests.SourceDict.detach","text":"Source code in tests/__init__.py 424 425 426 427 def detach ( self ): self . pop ( \"customer\" ) self . update ({ \"status\" : \"consumed\" }) return self","title":"detach()"},{"location":"reference/project/#tests.Sources","text":"Bases: object Source code in tests/__init__.py 1311 1312 1313 1314 1315 1316 1317 1318 1319 1320 1321 1322 1323 1324 1325 1326 class Sources ( object ): def __init__ ( self , card_fakes ): self . card_fakes = card_fakes def create ( self , source , api_key = None ): for fake_card in self . card_fakes : if fake_card [ \"id\" ] == source : return fake_card def retrieve ( self , id , expand = None ): for fake_card in self . card_fakes : if fake_card [ \"id\" ] == id : return fake_card def list ( self , ** kwargs ): return StripeList ( data = self . card_fakes )","title":"Sources"},{"location":"reference/project/#tests.Sources-attributes","text":"","title":"Attributes"},{"location":"reference/project/#tests.Sources.card_fakes","text":"","title":"card_fakes"},{"location":"reference/project/#tests.Sources-functions","text":"","title":"Functions"},{"location":"reference/project/#tests.Sources.__init__","text":"Source code in tests/__init__.py 1312 1313 def __init__ ( self , card_fakes ): self . card_fakes = card_fakes","title":"__init__()"},{"location":"reference/project/#tests.Sources.create","text":"Source code in tests/__init__.py 1315 1316 1317 1318 def create ( self , source , api_key = None ): for fake_card in self . card_fakes : if fake_card [ \"id\" ] == source : return fake_card","title":"create()"},{"location":"reference/project/#tests.Sources.list","text":"Source code in tests/__init__.py 1325 1326 def list ( self , ** kwargs ): return StripeList ( data = self . card_fakes )","title":"list()"},{"location":"reference/project/#tests.Sources.retrieve","text":"Source code in tests/__init__.py 1320 1321 1322 1323 def retrieve ( self , id , expand = None ): for fake_card in self . card_fakes : if fake_card [ \"id\" ] == id : return fake_card","title":"retrieve()"},{"location":"reference/project/#tests.StripeItem","text":"Bases: dict Flexible class built to mock any generic Stripe object. Implements object access + deletion methods to match the behavior of Stripe's library, which allows both object + dictionary access. Has a delete method since (most) Stripe objects can be deleted. Source code in tests/__init__.py 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 class StripeItem ( dict ): \"\"\"Flexible class built to mock any generic Stripe object. Implements object access + deletion methods to match the behavior of Stripe's library, which allows both object + dictionary access. Has a delete method since (most) Stripe objects can be deleted. \"\"\" def __getattr__ ( self , name ): \"\"\"Give StripeItem normal object access to match Stripe behavior.\"\"\" if name in self : return self [ name ] else : raise AttributeError ( \"No such attribute: \" + name ) def __setattr__ ( self , name , value ): self [ name ] = value def __delattr__ ( self , name ): if name in self : del self [ name ] else : raise AttributeError ( \"No such attribute: \" + name ) def delete ( self ) -> bool : \"\"\"Superficial mock that adds a deleted attribute.\"\"\" self . deleted = True return self . deleted @classmethod def class_url ( cls ): return \"/v1/test-items/\" def instance_url ( self ): \"\"\"Superficial mock that emulates instance_url.\"\"\" id = self . get ( \"id\" ) base = self . class_url () return \" %s / %s \" % ( base , id ) def request ( self , method , url , params ) -> Dict : \"\"\"Superficial mock that emulates request method.\"\"\" assert method == \"post\" for key , value in params . items (): self . __setattr__ ( key , value ) return self","title":"StripeItem"},{"location":"reference/project/#tests.StripeItem-functions","text":"","title":"Functions"},{"location":"reference/project/#tests.StripeItem.__delattr__","text":"Source code in tests/__init__.py 116 117 118 119 120 def __delattr__ ( self , name ): if name in self : del self [ name ] else : raise AttributeError ( \"No such attribute: \" + name )","title":"__delattr__()"},{"location":"reference/project/#tests.StripeItem.__getattr__","text":"Give StripeItem normal object access to match Stripe behavior. Source code in tests/__init__.py 106 107 108 109 110 111 def __getattr__ ( self , name ): \"\"\"Give StripeItem normal object access to match Stripe behavior.\"\"\" if name in self : return self [ name ] else : raise AttributeError ( \"No such attribute: \" + name )","title":"__getattr__()"},{"location":"reference/project/#tests.StripeItem.__setattr__","text":"Source code in tests/__init__.py 113 114 def __setattr__ ( self , name , value ): self [ name ] = value","title":"__setattr__()"},{"location":"reference/project/#tests.StripeItem.class_url","text":"Source code in tests/__init__.py 128 129 130 @classmethod def class_url ( cls ): return \"/v1/test-items/\"","title":"class_url()"},{"location":"reference/project/#tests.StripeItem.delete","text":"Superficial mock that adds a deleted attribute. Source code in tests/__init__.py 122 123 124 125 126 def delete ( self ) -> bool : \"\"\"Superficial mock that adds a deleted attribute.\"\"\" self . deleted = True return self . deleted","title":"delete()"},{"location":"reference/project/#tests.StripeItem.instance_url","text":"Superficial mock that emulates instance_url. Source code in tests/__init__.py 132 133 134 135 136 def instance_url ( self ): \"\"\"Superficial mock that emulates instance_url.\"\"\" id = self . get ( \"id\" ) base = self . class_url () return \" %s / %s \" % ( base , id )","title":"instance_url()"},{"location":"reference/project/#tests.StripeItem.request","text":"Superficial mock that emulates request method. Source code in tests/__init__.py 138 139 140 141 142 143 def request ( self , method , url , params ) -> Dict : \"\"\"Superficial mock that emulates request method.\"\"\" assert method == \"post\" for key , value in params . items (): self . __setattr__ ( key , value ) return self","title":"request()"},{"location":"reference/project/#tests.StripeList","text":"Bases: dict Mock a generic Stripe Iterable. It has the relevant attributes of a stripe iterable (has_more, data). This mock is important so we can use stripe's list method in our testing. StripeList.list() will return the StripeList. Additionally, iterating over instances of MockStripeIterable will iterate over the data attribute, just like Stripe iterables. Attributes: Name Type Description has_more mock has_more flag. Default False. **kwargs all of the fields of the stripe object, generally as a dictionary. Source code in tests/__init__.py 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 class StripeList ( dict ): \"\"\"Mock a generic Stripe Iterable. It has the relevant attributes of a stripe iterable (has_more, data). This mock is important so we can use stripe's `list` method in our testing. StripeList.list() will return the StripeList. Additionally, iterating over instances of MockStripeIterable will iterate over the data attribute, just like Stripe iterables. Attributes: has_more: mock has_more flag. Default False. **kwargs: all of the fields of the stripe object, generally as a dictionary. \"\"\" object = \"list\" url = \"/v1/fakes\" has_more = False def __getattr__ ( self , name ): \"\"\"Give StripeItem normal object access to match Stripe behavior.\"\"\" if name in self : return self [ name ] else : raise AttributeError ( \"No such attribute: \" + name ) def __setattr__ ( self , name , value ): self [ name ] = value def __delattr__ ( self , name ): if name in self : del self [ name ] else : raise AttributeError ( \"No such attribute: \" + name ) def __iter__ ( self ) -> Any : \"\"\"Make StripeList an iterable, to match the Stripe iterable behavior.\"\"\" self . iter_copy = self . data . copy () return self def __next__ ( self ) -> StripeItem : \"\"\"Define iteration for StripeList.\"\"\" if len ( self . iter_copy ) > 0 : return self . iter_copy . pop ( 0 ) else : raise StopIteration () def list ( self , ** kwargs : Any ) -> \"StripeList\" : \"\"\"Add a list method to the StripeList which returns itself. list() accepts arbitrary kwargs, be careful is you expect the argument-accepting functionality of Stripe's list() method. \"\"\" return self def auto_paging_iter ( self ) -> \"StripeList\" : \"\"\"Add an auto_paging_iter method to the StripeList which returns itself. The StripeList is an iterable, so this mimics the real behavior. \"\"\" return self @property def total_count ( self ): return len ( self . data )","title":"StripeList"},{"location":"reference/project/#tests.StripeList-attributes","text":"","title":"Attributes"},{"location":"reference/project/#tests.StripeList.has_more","text":"","title":"has_more"},{"location":"reference/project/#tests.StripeList.object","text":"","title":"object"},{"location":"reference/project/#tests.StripeList.total_count","text":"","title":"total_count"},{"location":"reference/project/#tests.StripeList.url","text":"","title":"url"},{"location":"reference/project/#tests.StripeList-functions","text":"","title":"Functions"},{"location":"reference/project/#tests.StripeList.__delattr__","text":"Source code in tests/__init__.py 176 177 178 179 180 def __delattr__ ( self , name ): if name in self : del self [ name ] else : raise AttributeError ( \"No such attribute: \" + name )","title":"__delattr__()"},{"location":"reference/project/#tests.StripeList.__getattr__","text":"Give StripeItem normal object access to match Stripe behavior. Source code in tests/__init__.py 166 167 168 169 170 171 def __getattr__ ( self , name ): \"\"\"Give StripeItem normal object access to match Stripe behavior.\"\"\" if name in self : return self [ name ] else : raise AttributeError ( \"No such attribute: \" + name )","title":"__getattr__()"},{"location":"reference/project/#tests.StripeList.__iter__","text":"Make StripeList an iterable, to match the Stripe iterable behavior. Source code in tests/__init__.py 182 183 184 185 def __iter__ ( self ) -> Any : \"\"\"Make StripeList an iterable, to match the Stripe iterable behavior.\"\"\" self . iter_copy = self . data . copy () return self","title":"__iter__()"},{"location":"reference/project/#tests.StripeList.__next__","text":"Define iteration for StripeList. Source code in tests/__init__.py 187 188 189 190 191 192 def __next__ ( self ) -> StripeItem : \"\"\"Define iteration for StripeList.\"\"\" if len ( self . iter_copy ) > 0 : return self . iter_copy . pop ( 0 ) else : raise StopIteration ()","title":"__next__()"},{"location":"reference/project/#tests.StripeList.__setattr__","text":"Source code in tests/__init__.py 173 174 def __setattr__ ( self , name , value ): self [ name ] = value","title":"__setattr__()"},{"location":"reference/project/#tests.StripeList.auto_paging_iter","text":"Add an auto_paging_iter method to the StripeList which returns itself. The StripeList is an iterable, so this mimics the real behavior. Source code in tests/__init__.py 202 203 204 205 206 207 def auto_paging_iter ( self ) -> \"StripeList\" : \"\"\"Add an auto_paging_iter method to the StripeList which returns itself. The StripeList is an iterable, so this mimics the real behavior. \"\"\" return self","title":"auto_paging_iter()"},{"location":"reference/project/#tests.StripeList.list","text":"Add a list method to the StripeList which returns itself. list() accepts arbitrary kwargs, be careful is you expect the argument-accepting functionality of Stripe's list() method. Source code in tests/__init__.py 194 195 196 197 198 199 200 def list ( self , ** kwargs : Any ) -> \"StripeList\" : \"\"\"Add a list method to the StripeList which returns itself. list() accepts arbitrary kwargs, be careful is you expect the argument-accepting functionality of Stripe's list() method. \"\"\" return self","title":"list()"},{"location":"reference/project/#tests.SubscriptionDict","text":"Bases: StripeItem Source code in tests/__init__.py 1086 1087 1088 1089 1090 1091 1092 1093 1094 1095 1096 1097 1098 1099 1100 1101 1102 1103 1104 1105 1106 1107 1108 1109 1110 1111 1112 1113 1114 1115 1116 1117 1118 1119 1120 class SubscriptionDict ( StripeItem ): def __init__ ( self , * args , ** kwargs ): \"\"\"Match Stripe's behavior: return a stripe iterable on `subscription.items`.\"\"\" super () . __init__ ( * args , ** kwargs ) self [ \"items\" ] = StripeList ( self [ \"items\" ]) def __setattr__ ( self , name , value ): if type ( value ) == datetime . datetime : value = datetime_to_unix ( value ) # Special case for price and plan if name == \"price\" : for price in [ FAKE_PRICE , FAKE_PRICE_II , FAKE_PRICE_TIER , FAKE_PRICE_METERED , ]: if value == price [ \"id\" ]: value = price elif name == \"plan\" : for plan in [ FAKE_PLAN , FAKE_PLAN_II , FAKE_TIER_PLAN , FAKE_PLAN_METERED ]: if value == plan [ \"id\" ]: value = plan self [ name ] = value def delete ( self , ** kwargs ): if \"at_period_end\" in kwargs : self [ \"cancel_at_period_end\" ] = kwargs [ \"at_period_end\" ] return self def save ( self , idempotency_key = None ): return self","title":"SubscriptionDict"},{"location":"reference/project/#tests.SubscriptionDict-functions","text":"","title":"Functions"},{"location":"reference/project/#tests.SubscriptionDict.__init__","text":"Match Stripe's behavior: return a stripe iterable on subscription.items . Source code in tests/__init__.py 1087 1088 1089 1090 def __init__ ( self , * args , ** kwargs ): \"\"\"Match Stripe's behavior: return a stripe iterable on `subscription.items`.\"\"\" super () . __init__ ( * args , ** kwargs ) self [ \"items\" ] = StripeList ( self [ \"items\" ])","title":"__init__()"},{"location":"reference/project/#tests.SubscriptionDict.__setattr__","text":"Source code in tests/__init__.py 1092 1093 1094 1095 1096 1097 1098 1099 1100 1101 1102 1103 1104 1105 1106 1107 1108 1109 1110 1111 def __setattr__ ( self , name , value ): if type ( value ) == datetime . datetime : value = datetime_to_unix ( value ) # Special case for price and plan if name == \"price\" : for price in [ FAKE_PRICE , FAKE_PRICE_II , FAKE_PRICE_TIER , FAKE_PRICE_METERED , ]: if value == price [ \"id\" ]: value = price elif name == \"plan\" : for plan in [ FAKE_PLAN , FAKE_PLAN_II , FAKE_TIER_PLAN , FAKE_PLAN_METERED ]: if value == plan [ \"id\" ]: value = plan self [ name ] = value","title":"__setattr__()"},{"location":"reference/project/#tests.SubscriptionDict.delete","text":"Source code in tests/__init__.py 1113 1114 1115 1116 1117 def delete ( self , ** kwargs ): if \"at_period_end\" in kwargs : self [ \"cancel_at_period_end\" ] = kwargs [ \"at_period_end\" ] return self","title":"delete()"},{"location":"reference/project/#tests.SubscriptionDict.save","text":"Source code in tests/__init__.py 1119 1120 def save ( self , idempotency_key = None ): return self","title":"save()"},{"location":"reference/project/#tests.UsageRecordSummaryDict","text":"Bases: StripeItem Source code in tests/__init__.py 1875 1876 class UsageRecordSummaryDict ( StripeItem ): pass","title":"UsageRecordSummaryDict"},{"location":"reference/project/#tests.WebhookEndpointDict","text":"Bases: StripeItem Source code in tests/__init__.py 1884 1885 class WebhookEndpointDict ( StripeItem ): pass","title":"WebhookEndpointDict"},{"location":"reference/project/#tests-functions","text":"","title":"Functions"},{"location":"reference/project/#tests.convert_source_dict","text":"Source code in tests/__init__.py 1329 1330 1331 1332 1333 1334 1335 1336 1337 1338 1339 1340 1341 def convert_source_dict ( data ): if data : source_type = data [ \"object\" ] if source_type == \"card\" : data = CardDict ( data ) elif source_type == \"bank_account\" : data = BankAccountDict ( data ) elif source_type == \"source\" : data = SourceDict ( data ) else : raise ValueError ( f \"Unknown source type: { source_type } \" ) return data","title":"convert_source_dict()"},{"location":"reference/project/#tests.datetime_to_unix","text":"Source code in tests/__init__.py 93 94 def datetime_to_unix ( datetime_ ): return int ( dateformat . format ( datetime_ , \"U\" ))","title":"datetime_to_unix()"},{"location":"reference/project/#tests.load_fixture","text":"Source code in tests/__init__.py 88 89 90 def load_fixture ( filename ): with FIXTURE_DIR_PATH . joinpath ( filename ) . open ( \"r\" ) as f : return json . load ( f )","title":"load_fixture()"},{"location":"reference/settings/","text":"Settings STRIPE_API_VERSION (='2020-08-27') The API version used to communicate with the Stripe API is configurable, and defaults to the latest version that has been tested as working. Using a value other than the default is allowed, as a string in the format of YYYY-MM-DD. For example, you can specify \"2020-03-02\" to use that API version: STRIPE_API_VERSION = \"2020-03-02\" However you do so at your own risk, as using a value other than the default might result in incompatibilities between Stripe and this library, especially if Stripe has labelled the differences between API versions as \"Major\". Even small differences such as a new enumeration value might cause issues. For this reason it is best to assume that only the default version is supported. For more information on API versioning, see the stripe documentation . See also API Versions . DJSTRIPE_FOREIGN_KEY_TO_FIELD (Introduced in 2.4.0) DJSTRIPE_FOREIGN_KEY_TO_FIELD is a setting introduced in dj-stripe version 2.4.0. You are required to set it in 2.4.0: It does not have a default value. In 3.0.0, the default will be \"id\", and we recommend setting it to \"id\" for new installations. Older installations should set it to \"djstripe_id\". Explanation below. In dj-stripe 2.3 and before, foreign keys for Stripe models were set to point to the foreign model's djstripe_id field, a numeric integer generated by the local database. This new setting allows dj-stripe users to change it to use the \"id\" field, which is the upstream, non-numeric Stripe identifier. When using the Stripe identifier as a foreign key, synchronization between Stripe and dj-stripe can be made far more efficient and robust. Furthermore, it removes the per-installation instability of a critical value. The plan is to get rid of djstripe_id altogether for the 3.0 release (we may retain the field itself until 4.0, but it will no longer be a primary key). How to migrate older installations from \"djstripe_id\" to \"id\"? Such a migration path has not been designed at the moment. Currently if you want to switch an older installation to \"id\", the easiest way is to wipe the djstripe db and sync again from scratch. This is obviously not ideal, and we will design a proper migration path before 3.0. DJSTRIPE_IDEMPOTENCY_KEY_CALLBACK (=djstripe.settings.djstripe_settings._get_idempotency_key) A function which will return an idempotency key for a particular object_type and action pair. By default, this is set to a function which will create a djstripe.IdempotencyKey object and return its uuid . You may want to customize this if you want to give your idempotency keys a different lifecycle than they normally would get. The function takes the following signature: def get_idempotency_key ( object_type : str , action : str , livemode : bool ): return \"<idempotency key>\" The function MUST return a string suitably random for the object_type/action pair, and usable in the Stripe Idempotency-Key HTTP header. For more information, see the stripe documentation . DJSTRIPE_SUBSCRIBER_CUSTOMER_KEY (=\"djstripe_subscriber\") Every Customer object created in Stripe is tagged with metadata This setting controls what the name of the key in Stripe should be. The key name must be a string no more than 40 characters long. You may set this to None or \"\" to disable that behaviour altogether. This is probably not something you want to do, though. DJSTRIPE_SUBSCRIBER_MODEL (=settings.AUTH_USER_MODEL) If the AUTH_USER_MODEL doesn't represent the object your application's subscription holder, you may define a subscriber model to use here. It should be a string in the form of 'app.model'. Note DJSTRIPE_SUBSCRIBER_MODEL must have an email field. If your existing model has no email field, add an email property that defines an email address to use. Example Model: class Organization ( models . Model ): name = CharField ( max_length = 200 , unique = True ) admin = ForeignKey ( settings . AUTH_USER_MODEL , on_delete = CASCADE ) @property def email ( self ): return self . admin . email DJSTRIPE_SUBSCRIBER_MODEL_MIGRATION_DEPENDENCY (=\"__first__\") If the model referenced in DJSTRIPE_SUBSCRIBER_MODEL is not created in the __first__ migration of an app you can specify the migration name to depend on here. For example: \"0003_here_the_subscriber_model_was_added\" DJSTRIPE_WEBHOOK_URL (=r\"^webhook/$\") Warning This setting is deprecated and will be removed in dj-stripe 2.9. This is where you can tell Stripe to send webhook responses. You can set this to what you want to prevent unnecessary hijinks from unfriendly people. As this is embedded in the URLConf, this must be a resolvable regular expression. DJSTRIPE_WEBHOOK_SECRET (=\"\") If this is set to a non-empty value, webhook signatures will be verified. Learn more about webhook signature verification . DJSTRIPE_WEBHOOK_VALIDATION= (=\"verify_signature\") This setting controls which type of validation is done on webhooks. Value can be \"verify_signature\" for signature verification (recommended default), \"retrieve_event\" for event retrieval (makes an extra HTTP request), or None for no validation at all. DJSTRIPE_WEBHOOK_TOLERANCE (=300) Controls the milliseconds tolerance which wards against replay attacks. Leave this to its default value unless you know what you're doing. DJSTRIPE_WEBHOOK_EVENT_CALLBACK (=None) Webhook event callbacks allow an application to take control of what happens when an event from Stripe is received. It must be a callable or importable string to a callable that takes an event object. One suggestion is to put the event onto a task queue (such as celery) for asynchronous processing. Examples: # callbacks.py def webhook_event_callback ( event , api_key ): \"\"\" Dispatches the event to celery for processing. \"\"\" from . import tasks # Ansychronous hand-off to celery so that we can continue immediately tasks . process_webhook_event . s ( event . pk ) . apply_async () # tasks.py from djstripe.models import WebhookEventTrigger from stripe.error import StripeError @shared_task ( bind = True ) def process_webhook_event ( self , pk ): \"\"\" Processes events from Stripe asynchronously. \"\"\" logger . info ( f \"Processing Stripe event: { pk } \" ) try : # get the event obj = WebhookEventTrigger . objects . get ( pk = pk ) # process the event. # internally, this creates a Stripe WebhookEvent Object and invokes the respective Webhooks event = obj . process () except StripeError as exc : logger . error ( f \"Failed to process Stripe event: { pk } . Retrying in 60 seconds.\" ) raise self . retry ( exc = exc , countdown = 60 ) # retry after 60 seconds except WebhookEventTrigger . DoesNotExist as exc : # This can happen in case the celery task got executed before the actual model got saved to the DB raise self . retry ( exc = exc , countdown = 10 ) # retry after 10 seconds return event . type or \"Stripe Event Processed\" # settings.py DJSTRIPE_WEBHOOK_EVENT_CALLBACK = 'callbacks.webhook_event_callback' STRIPE_API_HOST (= unset) If set, this sets the base API host for Stripe. You may want to set this to, for example, \"http://localhost:12111\" if you are running stripe-mock . If this is set in production (DEBUG=False), a warning will be raised on manage.py check . Source Code dj-stripe settings Attributes djstripe . settings . djstripe_settings = DjstripeSettings () module-attribute Classes djstripe.settings.DjstripeSettings Container for Dj-stripe settings :return: Initialised settings for Dj-stripe. :rtype: object Source code in djstripe/settings.py 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 class DjstripeSettings : \"\"\"Container for Dj-stripe settings :return: Initialised settings for Dj-stripe. :rtype: object \"\"\" DEFAULT_STRIPE_API_VERSION = \"2020-08-27\" ZERO_DECIMAL_CURRENCIES = { \"bif\" , \"clp\" , \"djf\" , \"gnf\" , \"jpy\" , \"kmf\" , \"krw\" , \"mga\" , \"pyg\" , \"rwf\" , \"vnd\" , \"vuv\" , \"xaf\" , \"xof\" , \"xpf\" , } def __init__ ( self ): # Set STRIPE_API_HOST if you want to use a different Stripe API server # Example: https://github.com/stripe/stripe-mock if hasattr ( settings , \"STRIPE_API_HOST\" ): stripe . api_base = getattr ( settings , \"STRIPE_API_HOST\" ) # generic setter and deleter methods to ensure object patching works def __setattr__ ( self , name , value ): self . __dict__ [ name ] = value def __delattr__ ( self , name ): del self . __dict__ [ name ] @property def subscriber_request_callback ( self ): return self . get_callback_function ( \"DJSTRIPE_SUBSCRIBER_MODEL_REQUEST_CALLBACK\" , default = ( lambda request : request . user ), ) @property def get_idempotency_key ( self ): return self . get_callback_function ( \"DJSTRIPE_IDEMPOTENCY_KEY_CALLBACK\" , self . _get_idempotency_key ) @property def DJSTRIPE_WEBHOOK_URL ( self ): return getattr ( settings , \"DJSTRIPE_WEBHOOK_URL\" , r \"^webhook/$\" ) @property def WEBHOOK_TOLERANCE ( self ): return getattr ( settings , \"DJSTRIPE_WEBHOOK_TOLERANCE\" , stripe . Webhook . DEFAULT_TOLERANCE ) @property def WEBHOOK_VALIDATION ( self ): return getattr ( settings , \"DJSTRIPE_WEBHOOK_VALIDATION\" , \"verify_signature\" ) @property def WEBHOOK_SECRET ( self ): return getattr ( settings , \"DJSTRIPE_WEBHOOK_SECRET\" , \"\" ) # Webhook event callbacks allow an application to take control of what happens # when an event from Stripe is received. One suggestion is to put the event # onto a task queue (such as celery) for asynchronous processing. @property def WEBHOOK_EVENT_CALLBACK ( self ): return self . get_callback_function ( \"DJSTRIPE_WEBHOOK_EVENT_CALLBACK\" ) @property def SUBSCRIBER_CUSTOMER_KEY ( self ): return getattr ( settings , \"DJSTRIPE_SUBSCRIBER_CUSTOMER_KEY\" , \"djstripe_subscriber\" ) @property def TEST_API_KEY ( self ): return getattr ( settings , \"STRIPE_TEST_SECRET_KEY\" , \"\" ) @property def LIVE_API_KEY ( self ): return getattr ( settings , \"STRIPE_LIVE_SECRET_KEY\" , \"\" ) # Determines whether we are in live mode or test mode @property def STRIPE_LIVE_MODE ( self ): return getattr ( settings , \"STRIPE_LIVE_MODE\" , False ) @property def STRIPE_SECRET_KEY ( self ): # Default secret key if hasattr ( settings , \"STRIPE_SECRET_KEY\" ): STRIPE_SECRET_KEY = settings . STRIPE_SECRET_KEY else : STRIPE_SECRET_KEY = ( self . LIVE_API_KEY if self . STRIPE_LIVE_MODE else self . TEST_API_KEY ) return STRIPE_SECRET_KEY @property def STRIPE_PUBLIC_KEY ( self ): # Default public key if hasattr ( settings , \"STRIPE_PUBLIC_KEY\" ): STRIPE_PUBLIC_KEY = settings . STRIPE_PUBLIC_KEY elif self . STRIPE_LIVE_MODE : STRIPE_PUBLIC_KEY = getattr ( settings , \"STRIPE_LIVE_PUBLIC_KEY\" , \"\" ) else : STRIPE_PUBLIC_KEY = getattr ( settings , \"STRIPE_TEST_PUBLIC_KEY\" , \"\" ) return STRIPE_PUBLIC_KEY @property def STRIPE_API_VERSION ( self ) -> str : \"\"\" Get the desired API version to use for Stripe requests. \"\"\" version = getattr ( settings , \"STRIPE_API_VERSION\" , stripe . api_version ) return version or self . DEFAULT_STRIPE_API_VERSION def get_callback_function ( self , setting_name , default = None ): \"\"\" Resolve a callback function based on a setting name. If the setting value isn't set, default is returned. If the setting value is already a callable function, that value is used - If the setting value is a string, an attempt is made to import it. Anything else will result in a failed import causing ImportError to be raised. :param setting_name: The name of the setting to resolve a callback from. :type setting_name: string (``str``/``unicode``) :param default: The default to return if setting isn't populated. :type default: ``bool`` :returns: The resolved callback function (if any). :type: ``callable`` \"\"\" func = getattr ( settings , setting_name , None ) if not func : return default if callable ( func ): return func if isinstance ( func , str ): func = import_string ( func ) if not callable ( func ): raise ImproperlyConfigured ( f \" { setting_name } must be callable.\" ) return func def _get_idempotency_key ( self , object_type , action , livemode ) -> str : from .models import IdempotencyKey action = f \" { object_type } : { action } \" idempotency_key , _created = IdempotencyKey . objects . get_or_create ( action = action , livemode = livemode ) return str ( idempotency_key . uuid ) def get_default_api_key ( self , livemode ) -> str : \"\"\" Returns the default API key for a value of `livemode`. \"\"\" if livemode is None : # Livemode is unknown. Use the default secret key. return self . STRIPE_SECRET_KEY elif livemode : # Livemode is true, use the live secret key return self . LIVE_API_KEY or self . STRIPE_SECRET_KEY else : # Livemode is false, use the test secret key return self . TEST_API_KEY or self . STRIPE_SECRET_KEY def get_subscriber_model_string ( self ) -> str : \"\"\"Get the configured subscriber model as a module path string.\"\"\" return getattr ( settings , \"DJSTRIPE_SUBSCRIBER_MODEL\" , settings . AUTH_USER_MODEL ) # type: ignore def get_subscriber_model ( self ): \"\"\" Attempt to pull settings.DJSTRIPE_SUBSCRIBER_MODEL. Users have the option of specifying a custom subscriber model via the DJSTRIPE_SUBSCRIBER_MODEL setting. This methods falls back to AUTH_USER_MODEL if DJSTRIPE_SUBSCRIBER_MODEL is not set. Returns the subscriber model that is active in this project. \"\"\" model_name = self . get_subscriber_model_string () # Attempt a Django 1.7 app lookup try : subscriber_model = django_apps . get_model ( model_name ) except ValueError : raise ImproperlyConfigured ( \"DJSTRIPE_SUBSCRIBER_MODEL must be of the form 'app_label.model_name'.\" ) except LookupError : raise ImproperlyConfigured ( f \"DJSTRIPE_SUBSCRIBER_MODEL refers to model ' { model_name } ' \" \"that has not been installed.\" ) if ( \"email\" not in [ field_ . name for field_ in subscriber_model . _meta . get_fields ()] ) and not hasattr ( subscriber_model , \"email\" ): raise ImproperlyConfigured ( \"DJSTRIPE_SUBSCRIBER_MODEL must have an email attribute.\" ) if model_name != settings . AUTH_USER_MODEL : # Custom user model detected. Make sure the callback is configured. func = self . get_callback_function ( \"DJSTRIPE_SUBSCRIBER_MODEL_REQUEST_CALLBACK\" ) if not func : raise ImproperlyConfigured ( \"DJSTRIPE_SUBSCRIBER_MODEL_REQUEST_CALLBACK must be implemented \" \"if a DJSTRIPE_SUBSCRIBER_MODEL is defined.\" ) return subscriber_model Attributes djstripe . settings . DjstripeSettings . DEFAULT_STRIPE_API_VERSION = '2020-08-27' class-attribute djstripe . settings . DjstripeSettings . DJSTRIPE_WEBHOOK_URL property djstripe . settings . DjstripeSettings . LIVE_API_KEY property djstripe . settings . DjstripeSettings . STRIPE_API_VERSION : str property Get the desired API version to use for Stripe requests. djstripe . settings . DjstripeSettings . STRIPE_LIVE_MODE property djstripe . settings . DjstripeSettings . STRIPE_PUBLIC_KEY property djstripe . settings . DjstripeSettings . STRIPE_SECRET_KEY property djstripe . settings . DjstripeSettings . SUBSCRIBER_CUSTOMER_KEY property djstripe . settings . DjstripeSettings . TEST_API_KEY property djstripe . settings . DjstripeSettings . WEBHOOK_EVENT_CALLBACK property djstripe . settings . DjstripeSettings . WEBHOOK_SECRET property djstripe . settings . DjstripeSettings . WEBHOOK_TOLERANCE property djstripe . settings . DjstripeSettings . WEBHOOK_VALIDATION property djstripe . settings . DjstripeSettings . ZERO_DECIMAL_CURRENCIES = { 'bif' , 'clp' , 'djf' , 'gnf' , 'jpy' , 'kmf' , 'krw' , 'mga' , 'pyg' , 'rwf' , 'vnd' , 'vuv' , 'xaf' , 'xof' , 'xpf' } class-attribute djstripe . settings . DjstripeSettings . get_idempotency_key property djstripe . settings . DjstripeSettings . subscriber_request_callback property Functions djstripe . settings . DjstripeSettings . __delattr__ ( name ) Source code in djstripe/settings.py 49 50 def __delattr__ ( self , name ): del self . __dict__ [ name ] djstripe . settings . DjstripeSettings . __init__ () Source code in djstripe/settings.py 39 40 41 42 43 def __init__ ( self ): # Set STRIPE_API_HOST if you want to use a different Stripe API server # Example: https://github.com/stripe/stripe-mock if hasattr ( settings , \"STRIPE_API_HOST\" ): stripe . api_base = getattr ( settings , \"STRIPE_API_HOST\" ) djstripe . settings . DjstripeSettings . __setattr__ ( name , value ) Source code in djstripe/settings.py 46 47 def __setattr__ ( self , name , value ): self . __dict__ [ name ] = value djstripe . settings . DjstripeSettings . get_callback_function ( setting_name , default = None ) Resolve a callback function based on a setting name. If the setting value isn't set, default is returned. If the setting value is already a callable function, that value is used - If the setting value is a string, an attempt is made to import it. Anything else will result in a failed import causing ImportError to be raised. :param setting_name: The name of the setting to resolve a callback from. :type setting_name: string ( str / unicode ) :param default: The default to return if setting isn't populated. :type default: bool :returns: The resolved callback function (if any). :type: callable Source code in djstripe/settings.py 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 def get_callback_function ( self , setting_name , default = None ): \"\"\" Resolve a callback function based on a setting name. If the setting value isn't set, default is returned. If the setting value is already a callable function, that value is used - If the setting value is a string, an attempt is made to import it. Anything else will result in a failed import causing ImportError to be raised. :param setting_name: The name of the setting to resolve a callback from. :type setting_name: string (``str``/``unicode``) :param default: The default to return if setting isn't populated. :type default: ``bool`` :returns: The resolved callback function (if any). :type: ``callable`` \"\"\" func = getattr ( settings , setting_name , None ) if not func : return default if callable ( func ): return func if isinstance ( func , str ): func = import_string ( func ) if not callable ( func ): raise ImproperlyConfigured ( f \" { setting_name } must be callable.\" ) return func djstripe . settings . DjstripeSettings . get_default_api_key ( livemode ) Returns the default API key for a value of livemode . Source code in djstripe/settings.py 179 180 181 182 183 184 185 186 187 188 189 190 191 def get_default_api_key ( self , livemode ) -> str : \"\"\" Returns the default API key for a value of `livemode`. \"\"\" if livemode is None : # Livemode is unknown. Use the default secret key. return self . STRIPE_SECRET_KEY elif livemode : # Livemode is true, use the live secret key return self . LIVE_API_KEY or self . STRIPE_SECRET_KEY else : # Livemode is false, use the test secret key return self . TEST_API_KEY or self . STRIPE_SECRET_KEY djstripe . settings . DjstripeSettings . get_subscriber_model () Attempt to pull settings.DJSTRIPE_SUBSCRIBER_MODEL. Users have the option of specifying a custom subscriber model via the DJSTRIPE_SUBSCRIBER_MODEL setting. This methods falls back to AUTH_USER_MODEL if DJSTRIPE_SUBSCRIBER_MODEL is not set. Returns the subscriber model that is active in this project. Source code in djstripe/settings.py 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 def get_subscriber_model ( self ): \"\"\" Attempt to pull settings.DJSTRIPE_SUBSCRIBER_MODEL. Users have the option of specifying a custom subscriber model via the DJSTRIPE_SUBSCRIBER_MODEL setting. This methods falls back to AUTH_USER_MODEL if DJSTRIPE_SUBSCRIBER_MODEL is not set. Returns the subscriber model that is active in this project. \"\"\" model_name = self . get_subscriber_model_string () # Attempt a Django 1.7 app lookup try : subscriber_model = django_apps . get_model ( model_name ) except ValueError : raise ImproperlyConfigured ( \"DJSTRIPE_SUBSCRIBER_MODEL must be of the form 'app_label.model_name'.\" ) except LookupError : raise ImproperlyConfigured ( f \"DJSTRIPE_SUBSCRIBER_MODEL refers to model ' { model_name } ' \" \"that has not been installed.\" ) if ( \"email\" not in [ field_ . name for field_ in subscriber_model . _meta . get_fields ()] ) and not hasattr ( subscriber_model , \"email\" ): raise ImproperlyConfigured ( \"DJSTRIPE_SUBSCRIBER_MODEL must have an email attribute.\" ) if model_name != settings . AUTH_USER_MODEL : # Custom user model detected. Make sure the callback is configured. func = self . get_callback_function ( \"DJSTRIPE_SUBSCRIBER_MODEL_REQUEST_CALLBACK\" ) if not func : raise ImproperlyConfigured ( \"DJSTRIPE_SUBSCRIBER_MODEL_REQUEST_CALLBACK must be implemented \" \"if a DJSTRIPE_SUBSCRIBER_MODEL is defined.\" ) return subscriber_model djstripe . settings . DjstripeSettings . get_subscriber_model_string () Get the configured subscriber model as a module path string. Source code in djstripe/settings.py 193 194 195 def get_subscriber_model_string ( self ) -> str : \"\"\"Get the configured subscriber model as a module path string.\"\"\" return getattr ( settings , \"DJSTRIPE_SUBSCRIBER_MODEL\" , settings . AUTH_USER_MODEL ) # type: ignore selection: filters: - \"!^ [^ ]\"","title":"Settings"},{"location":"reference/settings/#settings","text":"","title":"Settings"},{"location":"reference/settings/#stripe_api_version-2020-08-27","text":"The API version used to communicate with the Stripe API is configurable, and defaults to the latest version that has been tested as working. Using a value other than the default is allowed, as a string in the format of YYYY-MM-DD. For example, you can specify \"2020-03-02\" to use that API version: STRIPE_API_VERSION = \"2020-03-02\" However you do so at your own risk, as using a value other than the default might result in incompatibilities between Stripe and this library, especially if Stripe has labelled the differences between API versions as \"Major\". Even small differences such as a new enumeration value might cause issues. For this reason it is best to assume that only the default version is supported. For more information on API versioning, see the stripe documentation . See also API Versions .","title":"STRIPE_API_VERSION (='2020-08-27')"},{"location":"reference/settings/#djstripe_foreign_key_to_field","text":"(Introduced in 2.4.0) DJSTRIPE_FOREIGN_KEY_TO_FIELD is a setting introduced in dj-stripe version 2.4.0. You are required to set it in 2.4.0: It does not have a default value. In 3.0.0, the default will be \"id\", and we recommend setting it to \"id\" for new installations. Older installations should set it to \"djstripe_id\". Explanation below. In dj-stripe 2.3 and before, foreign keys for Stripe models were set to point to the foreign model's djstripe_id field, a numeric integer generated by the local database. This new setting allows dj-stripe users to change it to use the \"id\" field, which is the upstream, non-numeric Stripe identifier. When using the Stripe identifier as a foreign key, synchronization between Stripe and dj-stripe can be made far more efficient and robust. Furthermore, it removes the per-installation instability of a critical value. The plan is to get rid of djstripe_id altogether for the 3.0 release (we may retain the field itself until 4.0, but it will no longer be a primary key). How to migrate older installations from \"djstripe_id\" to \"id\"? Such a migration path has not been designed at the moment. Currently if you want to switch an older installation to \"id\", the easiest way is to wipe the djstripe db and sync again from scratch. This is obviously not ideal, and we will design a proper migration path before 3.0.","title":"DJSTRIPE_FOREIGN_KEY_TO_FIELD"},{"location":"reference/settings/#djstripe_idempotency_key_callback-djstripesettingsdjstripe_settings_get_idempotency_key","text":"A function which will return an idempotency key for a particular object_type and action pair. By default, this is set to a function which will create a djstripe.IdempotencyKey object and return its uuid . You may want to customize this if you want to give your idempotency keys a different lifecycle than they normally would get. The function takes the following signature: def get_idempotency_key ( object_type : str , action : str , livemode : bool ): return \"<idempotency key>\" The function MUST return a string suitably random for the object_type/action pair, and usable in the Stripe Idempotency-Key HTTP header. For more information, see the stripe documentation .","title":"DJSTRIPE_IDEMPOTENCY_KEY_CALLBACK (=djstripe.settings.djstripe_settings._get_idempotency_key)"},{"location":"reference/settings/#djstripe_subscriber_customer_key-djstripe_subscriber","text":"Every Customer object created in Stripe is tagged with metadata This setting controls what the name of the key in Stripe should be. The key name must be a string no more than 40 characters long. You may set this to None or \"\" to disable that behaviour altogether. This is probably not something you want to do, though.","title":"DJSTRIPE_SUBSCRIBER_CUSTOMER_KEY (=\"djstripe_subscriber\")"},{"location":"reference/settings/#djstripe_subscriber_model-settingsauth_user_model","text":"If the AUTH_USER_MODEL doesn't represent the object your application's subscription holder, you may define a subscriber model to use here. It should be a string in the form of 'app.model'. Note DJSTRIPE_SUBSCRIBER_MODEL must have an email field. If your existing model has no email field, add an email property that defines an email address to use. Example Model: class Organization ( models . Model ): name = CharField ( max_length = 200 , unique = True ) admin = ForeignKey ( settings . AUTH_USER_MODEL , on_delete = CASCADE ) @property def email ( self ): return self . admin . email","title":"DJSTRIPE_SUBSCRIBER_MODEL (=settings.AUTH_USER_MODEL)"},{"location":"reference/settings/#djstripe_subscriber_model_migration_dependency-__first__","text":"If the model referenced in DJSTRIPE_SUBSCRIBER_MODEL is not created in the __first__ migration of an app you can specify the migration name to depend on here. For example: \"0003_here_the_subscriber_model_was_added\"","title":"DJSTRIPE_SUBSCRIBER_MODEL_MIGRATION_DEPENDENCY (=\"__first__\")"},{"location":"reference/settings/#djstripe_webhook_url-rwebhook","text":"Warning This setting is deprecated and will be removed in dj-stripe 2.9. This is where you can tell Stripe to send webhook responses. You can set this to what you want to prevent unnecessary hijinks from unfriendly people. As this is embedded in the URLConf, this must be a resolvable regular expression.","title":"DJSTRIPE_WEBHOOK_URL (=r\"^webhook/$\")"},{"location":"reference/settings/#djstripe_webhook_secret","text":"If this is set to a non-empty value, webhook signatures will be verified. Learn more about webhook signature verification .","title":"DJSTRIPE_WEBHOOK_SECRET (=\"\")"},{"location":"reference/settings/#djstripe_webhook_validation-verify_signature","text":"This setting controls which type of validation is done on webhooks. Value can be \"verify_signature\" for signature verification (recommended default), \"retrieve_event\" for event retrieval (makes an extra HTTP request), or None for no validation at all.","title":"DJSTRIPE_WEBHOOK_VALIDATION= (=\"verify_signature\")"},{"location":"reference/settings/#djstripe_webhook_tolerance-300","text":"Controls the milliseconds tolerance which wards against replay attacks. Leave this to its default value unless you know what you're doing.","title":"DJSTRIPE_WEBHOOK_TOLERANCE (=300)"},{"location":"reference/settings/#djstripe_webhook_event_callback-none","text":"Webhook event callbacks allow an application to take control of what happens when an event from Stripe is received. It must be a callable or importable string to a callable that takes an event object. One suggestion is to put the event onto a task queue (such as celery) for asynchronous processing. Examples: # callbacks.py def webhook_event_callback ( event , api_key ): \"\"\" Dispatches the event to celery for processing. \"\"\" from . import tasks # Ansychronous hand-off to celery so that we can continue immediately tasks . process_webhook_event . s ( event . pk ) . apply_async () # tasks.py from djstripe.models import WebhookEventTrigger from stripe.error import StripeError @shared_task ( bind = True ) def process_webhook_event ( self , pk ): \"\"\" Processes events from Stripe asynchronously. \"\"\" logger . info ( f \"Processing Stripe event: { pk } \" ) try : # get the event obj = WebhookEventTrigger . objects . get ( pk = pk ) # process the event. # internally, this creates a Stripe WebhookEvent Object and invokes the respective Webhooks event = obj . process () except StripeError as exc : logger . error ( f \"Failed to process Stripe event: { pk } . Retrying in 60 seconds.\" ) raise self . retry ( exc = exc , countdown = 60 ) # retry after 60 seconds except WebhookEventTrigger . DoesNotExist as exc : # This can happen in case the celery task got executed before the actual model got saved to the DB raise self . retry ( exc = exc , countdown = 10 ) # retry after 10 seconds return event . type or \"Stripe Event Processed\" # settings.py DJSTRIPE_WEBHOOK_EVENT_CALLBACK = 'callbacks.webhook_event_callback'","title":"DJSTRIPE_WEBHOOK_EVENT_CALLBACK (=None)"},{"location":"reference/settings/#stripe_api_host-unset","text":"If set, this sets the base API host for Stripe. You may want to set this to, for example, \"http://localhost:12111\" if you are running stripe-mock . If this is set in production (DEBUG=False), a warning will be raised on manage.py check .","title":"STRIPE_API_HOST (= unset)"},{"location":"reference/settings/#source-code","text":"dj-stripe settings","title":"Source Code"},{"location":"reference/settings/#djstripe.settings-attributes","text":"","title":"Attributes"},{"location":"reference/settings/#djstripe.settings.djstripe_settings","text":"","title":"djstripe_settings"},{"location":"reference/settings/#djstripe.settings-classes","text":"","title":"Classes"},{"location":"reference/settings/#djstripe.settings.DjstripeSettings","text":"Container for Dj-stripe settings :return: Initialised settings for Dj-stripe. :rtype: object Source code in djstripe/settings.py 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 class DjstripeSettings : \"\"\"Container for Dj-stripe settings :return: Initialised settings for Dj-stripe. :rtype: object \"\"\" DEFAULT_STRIPE_API_VERSION = \"2020-08-27\" ZERO_DECIMAL_CURRENCIES = { \"bif\" , \"clp\" , \"djf\" , \"gnf\" , \"jpy\" , \"kmf\" , \"krw\" , \"mga\" , \"pyg\" , \"rwf\" , \"vnd\" , \"vuv\" , \"xaf\" , \"xof\" , \"xpf\" , } def __init__ ( self ): # Set STRIPE_API_HOST if you want to use a different Stripe API server # Example: https://github.com/stripe/stripe-mock if hasattr ( settings , \"STRIPE_API_HOST\" ): stripe . api_base = getattr ( settings , \"STRIPE_API_HOST\" ) # generic setter and deleter methods to ensure object patching works def __setattr__ ( self , name , value ): self . __dict__ [ name ] = value def __delattr__ ( self , name ): del self . __dict__ [ name ] @property def subscriber_request_callback ( self ): return self . get_callback_function ( \"DJSTRIPE_SUBSCRIBER_MODEL_REQUEST_CALLBACK\" , default = ( lambda request : request . user ), ) @property def get_idempotency_key ( self ): return self . get_callback_function ( \"DJSTRIPE_IDEMPOTENCY_KEY_CALLBACK\" , self . _get_idempotency_key ) @property def DJSTRIPE_WEBHOOK_URL ( self ): return getattr ( settings , \"DJSTRIPE_WEBHOOK_URL\" , r \"^webhook/$\" ) @property def WEBHOOK_TOLERANCE ( self ): return getattr ( settings , \"DJSTRIPE_WEBHOOK_TOLERANCE\" , stripe . Webhook . DEFAULT_TOLERANCE ) @property def WEBHOOK_VALIDATION ( self ): return getattr ( settings , \"DJSTRIPE_WEBHOOK_VALIDATION\" , \"verify_signature\" ) @property def WEBHOOK_SECRET ( self ): return getattr ( settings , \"DJSTRIPE_WEBHOOK_SECRET\" , \"\" ) # Webhook event callbacks allow an application to take control of what happens # when an event from Stripe is received. One suggestion is to put the event # onto a task queue (such as celery) for asynchronous processing. @property def WEBHOOK_EVENT_CALLBACK ( self ): return self . get_callback_function ( \"DJSTRIPE_WEBHOOK_EVENT_CALLBACK\" ) @property def SUBSCRIBER_CUSTOMER_KEY ( self ): return getattr ( settings , \"DJSTRIPE_SUBSCRIBER_CUSTOMER_KEY\" , \"djstripe_subscriber\" ) @property def TEST_API_KEY ( self ): return getattr ( settings , \"STRIPE_TEST_SECRET_KEY\" , \"\" ) @property def LIVE_API_KEY ( self ): return getattr ( settings , \"STRIPE_LIVE_SECRET_KEY\" , \"\" ) # Determines whether we are in live mode or test mode @property def STRIPE_LIVE_MODE ( self ): return getattr ( settings , \"STRIPE_LIVE_MODE\" , False ) @property def STRIPE_SECRET_KEY ( self ): # Default secret key if hasattr ( settings , \"STRIPE_SECRET_KEY\" ): STRIPE_SECRET_KEY = settings . STRIPE_SECRET_KEY else : STRIPE_SECRET_KEY = ( self . LIVE_API_KEY if self . STRIPE_LIVE_MODE else self . TEST_API_KEY ) return STRIPE_SECRET_KEY @property def STRIPE_PUBLIC_KEY ( self ): # Default public key if hasattr ( settings , \"STRIPE_PUBLIC_KEY\" ): STRIPE_PUBLIC_KEY = settings . STRIPE_PUBLIC_KEY elif self . STRIPE_LIVE_MODE : STRIPE_PUBLIC_KEY = getattr ( settings , \"STRIPE_LIVE_PUBLIC_KEY\" , \"\" ) else : STRIPE_PUBLIC_KEY = getattr ( settings , \"STRIPE_TEST_PUBLIC_KEY\" , \"\" ) return STRIPE_PUBLIC_KEY @property def STRIPE_API_VERSION ( self ) -> str : \"\"\" Get the desired API version to use for Stripe requests. \"\"\" version = getattr ( settings , \"STRIPE_API_VERSION\" , stripe . api_version ) return version or self . DEFAULT_STRIPE_API_VERSION def get_callback_function ( self , setting_name , default = None ): \"\"\" Resolve a callback function based on a setting name. If the setting value isn't set, default is returned. If the setting value is already a callable function, that value is used - If the setting value is a string, an attempt is made to import it. Anything else will result in a failed import causing ImportError to be raised. :param setting_name: The name of the setting to resolve a callback from. :type setting_name: string (``str``/``unicode``) :param default: The default to return if setting isn't populated. :type default: ``bool`` :returns: The resolved callback function (if any). :type: ``callable`` \"\"\" func = getattr ( settings , setting_name , None ) if not func : return default if callable ( func ): return func if isinstance ( func , str ): func = import_string ( func ) if not callable ( func ): raise ImproperlyConfigured ( f \" { setting_name } must be callable.\" ) return func def _get_idempotency_key ( self , object_type , action , livemode ) -> str : from .models import IdempotencyKey action = f \" { object_type } : { action } \" idempotency_key , _created = IdempotencyKey . objects . get_or_create ( action = action , livemode = livemode ) return str ( idempotency_key . uuid ) def get_default_api_key ( self , livemode ) -> str : \"\"\" Returns the default API key for a value of `livemode`. \"\"\" if livemode is None : # Livemode is unknown. Use the default secret key. return self . STRIPE_SECRET_KEY elif livemode : # Livemode is true, use the live secret key return self . LIVE_API_KEY or self . STRIPE_SECRET_KEY else : # Livemode is false, use the test secret key return self . TEST_API_KEY or self . STRIPE_SECRET_KEY def get_subscriber_model_string ( self ) -> str : \"\"\"Get the configured subscriber model as a module path string.\"\"\" return getattr ( settings , \"DJSTRIPE_SUBSCRIBER_MODEL\" , settings . AUTH_USER_MODEL ) # type: ignore def get_subscriber_model ( self ): \"\"\" Attempt to pull settings.DJSTRIPE_SUBSCRIBER_MODEL. Users have the option of specifying a custom subscriber model via the DJSTRIPE_SUBSCRIBER_MODEL setting. This methods falls back to AUTH_USER_MODEL if DJSTRIPE_SUBSCRIBER_MODEL is not set. Returns the subscriber model that is active in this project. \"\"\" model_name = self . get_subscriber_model_string () # Attempt a Django 1.7 app lookup try : subscriber_model = django_apps . get_model ( model_name ) except ValueError : raise ImproperlyConfigured ( \"DJSTRIPE_SUBSCRIBER_MODEL must be of the form 'app_label.model_name'.\" ) except LookupError : raise ImproperlyConfigured ( f \"DJSTRIPE_SUBSCRIBER_MODEL refers to model ' { model_name } ' \" \"that has not been installed.\" ) if ( \"email\" not in [ field_ . name for field_ in subscriber_model . _meta . get_fields ()] ) and not hasattr ( subscriber_model , \"email\" ): raise ImproperlyConfigured ( \"DJSTRIPE_SUBSCRIBER_MODEL must have an email attribute.\" ) if model_name != settings . AUTH_USER_MODEL : # Custom user model detected. Make sure the callback is configured. func = self . get_callback_function ( \"DJSTRIPE_SUBSCRIBER_MODEL_REQUEST_CALLBACK\" ) if not func : raise ImproperlyConfigured ( \"DJSTRIPE_SUBSCRIBER_MODEL_REQUEST_CALLBACK must be implemented \" \"if a DJSTRIPE_SUBSCRIBER_MODEL is defined.\" ) return subscriber_model","title":"DjstripeSettings"},{"location":"reference/settings/#djstripe.settings.DjstripeSettings-attributes","text":"","title":"Attributes"},{"location":"reference/settings/#djstripe.settings.DjstripeSettings.DEFAULT_STRIPE_API_VERSION","text":"","title":"DEFAULT_STRIPE_API_VERSION"},{"location":"reference/settings/#djstripe.settings.DjstripeSettings.DJSTRIPE_WEBHOOK_URL","text":"","title":"DJSTRIPE_WEBHOOK_URL"},{"location":"reference/settings/#djstripe.settings.DjstripeSettings.LIVE_API_KEY","text":"","title":"LIVE_API_KEY"},{"location":"reference/settings/#djstripe.settings.DjstripeSettings.STRIPE_API_VERSION","text":"Get the desired API version to use for Stripe requests.","title":"STRIPE_API_VERSION"},{"location":"reference/settings/#djstripe.settings.DjstripeSettings.STRIPE_LIVE_MODE","text":"","title":"STRIPE_LIVE_MODE"},{"location":"reference/settings/#djstripe.settings.DjstripeSettings.STRIPE_PUBLIC_KEY","text":"","title":"STRIPE_PUBLIC_KEY"},{"location":"reference/settings/#djstripe.settings.DjstripeSettings.STRIPE_SECRET_KEY","text":"","title":"STRIPE_SECRET_KEY"},{"location":"reference/settings/#djstripe.settings.DjstripeSettings.SUBSCRIBER_CUSTOMER_KEY","text":"","title":"SUBSCRIBER_CUSTOMER_KEY"},{"location":"reference/settings/#djstripe.settings.DjstripeSettings.TEST_API_KEY","text":"","title":"TEST_API_KEY"},{"location":"reference/settings/#djstripe.settings.DjstripeSettings.WEBHOOK_EVENT_CALLBACK","text":"","title":"WEBHOOK_EVENT_CALLBACK"},{"location":"reference/settings/#djstripe.settings.DjstripeSettings.WEBHOOK_SECRET","text":"","title":"WEBHOOK_SECRET"},{"location":"reference/settings/#djstripe.settings.DjstripeSettings.WEBHOOK_TOLERANCE","text":"","title":"WEBHOOK_TOLERANCE"},{"location":"reference/settings/#djstripe.settings.DjstripeSettings.WEBHOOK_VALIDATION","text":"","title":"WEBHOOK_VALIDATION"},{"location":"reference/settings/#djstripe.settings.DjstripeSettings.ZERO_DECIMAL_CURRENCIES","text":"","title":"ZERO_DECIMAL_CURRENCIES"},{"location":"reference/settings/#djstripe.settings.DjstripeSettings.get_idempotency_key","text":"","title":"get_idempotency_key"},{"location":"reference/settings/#djstripe.settings.DjstripeSettings.subscriber_request_callback","text":"","title":"subscriber_request_callback"},{"location":"reference/settings/#djstripe.settings.DjstripeSettings-functions","text":"","title":"Functions"},{"location":"reference/settings/#djstripe.settings.DjstripeSettings.__delattr__","text":"Source code in djstripe/settings.py 49 50 def __delattr__ ( self , name ): del self . __dict__ [ name ]","title":"__delattr__()"},{"location":"reference/settings/#djstripe.settings.DjstripeSettings.__init__","text":"Source code in djstripe/settings.py 39 40 41 42 43 def __init__ ( self ): # Set STRIPE_API_HOST if you want to use a different Stripe API server # Example: https://github.com/stripe/stripe-mock if hasattr ( settings , \"STRIPE_API_HOST\" ): stripe . api_base = getattr ( settings , \"STRIPE_API_HOST\" )","title":"__init__()"},{"location":"reference/settings/#djstripe.settings.DjstripeSettings.__setattr__","text":"Source code in djstripe/settings.py 46 47 def __setattr__ ( self , name , value ): self . __dict__ [ name ] = value","title":"__setattr__()"},{"location":"reference/settings/#djstripe.settings.DjstripeSettings.get_callback_function","text":"Resolve a callback function based on a setting name. If the setting value isn't set, default is returned. If the setting value is already a callable function, that value is used - If the setting value is a string, an attempt is made to import it. Anything else will result in a failed import causing ImportError to be raised. :param setting_name: The name of the setting to resolve a callback from. :type setting_name: string ( str / unicode ) :param default: The default to return if setting isn't populated. :type default: bool :returns: The resolved callback function (if any). :type: callable Source code in djstripe/settings.py 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 def get_callback_function ( self , setting_name , default = None ): \"\"\" Resolve a callback function based on a setting name. If the setting value isn't set, default is returned. If the setting value is already a callable function, that value is used - If the setting value is a string, an attempt is made to import it. Anything else will result in a failed import causing ImportError to be raised. :param setting_name: The name of the setting to resolve a callback from. :type setting_name: string (``str``/``unicode``) :param default: The default to return if setting isn't populated. :type default: ``bool`` :returns: The resolved callback function (if any). :type: ``callable`` \"\"\" func = getattr ( settings , setting_name , None ) if not func : return default if callable ( func ): return func if isinstance ( func , str ): func = import_string ( func ) if not callable ( func ): raise ImproperlyConfigured ( f \" { setting_name } must be callable.\" ) return func","title":"get_callback_function()"},{"location":"reference/settings/#djstripe.settings.DjstripeSettings.get_default_api_key","text":"Returns the default API key for a value of livemode . Source code in djstripe/settings.py 179 180 181 182 183 184 185 186 187 188 189 190 191 def get_default_api_key ( self , livemode ) -> str : \"\"\" Returns the default API key for a value of `livemode`. \"\"\" if livemode is None : # Livemode is unknown. Use the default secret key. return self . STRIPE_SECRET_KEY elif livemode : # Livemode is true, use the live secret key return self . LIVE_API_KEY or self . STRIPE_SECRET_KEY else : # Livemode is false, use the test secret key return self . TEST_API_KEY or self . STRIPE_SECRET_KEY","title":"get_default_api_key()"},{"location":"reference/settings/#djstripe.settings.DjstripeSettings.get_subscriber_model","text":"Attempt to pull settings.DJSTRIPE_SUBSCRIBER_MODEL. Users have the option of specifying a custom subscriber model via the DJSTRIPE_SUBSCRIBER_MODEL setting. This methods falls back to AUTH_USER_MODEL if DJSTRIPE_SUBSCRIBER_MODEL is not set. Returns the subscriber model that is active in this project. Source code in djstripe/settings.py 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 def get_subscriber_model ( self ): \"\"\" Attempt to pull settings.DJSTRIPE_SUBSCRIBER_MODEL. Users have the option of specifying a custom subscriber model via the DJSTRIPE_SUBSCRIBER_MODEL setting. This methods falls back to AUTH_USER_MODEL if DJSTRIPE_SUBSCRIBER_MODEL is not set. Returns the subscriber model that is active in this project. \"\"\" model_name = self . get_subscriber_model_string () # Attempt a Django 1.7 app lookup try : subscriber_model = django_apps . get_model ( model_name ) except ValueError : raise ImproperlyConfigured ( \"DJSTRIPE_SUBSCRIBER_MODEL must be of the form 'app_label.model_name'.\" ) except LookupError : raise ImproperlyConfigured ( f \"DJSTRIPE_SUBSCRIBER_MODEL refers to model ' { model_name } ' \" \"that has not been installed.\" ) if ( \"email\" not in [ field_ . name for field_ in subscriber_model . _meta . get_fields ()] ) and not hasattr ( subscriber_model , \"email\" ): raise ImproperlyConfigured ( \"DJSTRIPE_SUBSCRIBER_MODEL must have an email attribute.\" ) if model_name != settings . AUTH_USER_MODEL : # Custom user model detected. Make sure the callback is configured. func = self . get_callback_function ( \"DJSTRIPE_SUBSCRIBER_MODEL_REQUEST_CALLBACK\" ) if not func : raise ImproperlyConfigured ( \"DJSTRIPE_SUBSCRIBER_MODEL_REQUEST_CALLBACK must be implemented \" \"if a DJSTRIPE_SUBSCRIBER_MODEL is defined.\" ) return subscriber_model","title":"get_subscriber_model()"},{"location":"reference/settings/#djstripe.settings.DjstripeSettings.get_subscriber_model_string","text":"Get the configured subscriber model as a module path string. Source code in djstripe/settings.py 193 194 195 def get_subscriber_model_string ( self ) -> str : \"\"\"Get the configured subscriber model as a module path string.\"\"\" return getattr ( settings , \"DJSTRIPE_SUBSCRIBER_MODEL\" , settings . AUTH_USER_MODEL ) # type: ignore selection: filters: - \"!^ [^ ]\"","title":"get_subscriber_model_string()"},{"location":"reference/utils/","text":"Utilities Utility functions related to the djstripe app. Attributes djstripe . utils . CURRENCY_SIGILS = { 'CAD' : '$' , 'EUR' : '\u20ac' , 'GBP' : '\u00a3' , 'USD' : '$' } module-attribute Classes djstripe.utils.QuerySetMock Bases: QuerySet A mocked QuerySet class that does not handle updates. Used by UpcomingInvoice.invoiceitems (deprecated) and UpcomingInvoice.lineitems. Source code in djstripe/utils.py 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 class QuerySetMock ( QuerySet ): \"\"\" A mocked QuerySet class that does not handle updates. Used by UpcomingInvoice.invoiceitems (deprecated) and UpcomingInvoice.lineitems. \"\"\" @classmethod def from_iterable ( cls , model , iterable ): instance = cls ( model ) instance . _result_cache = list ( iterable ) instance . _prefetch_done = True return instance def _clone ( self ): return self . __class__ . from_iterable ( self . model , self . _result_cache ) def update ( self ): return 0 def delete ( self ): return 0 Functions djstripe . utils . QuerySetMock . delete () Source code in djstripe/utils.py 82 83 def delete ( self ): return 0 djstripe . utils . QuerySetMock . from_iterable ( model , iterable ) classmethod Source code in djstripe/utils.py 69 70 71 72 73 74 @classmethod def from_iterable ( cls , model , iterable ): instance = cls ( model ) instance . _result_cache = list ( iterable ) instance . _prefetch_done = True return instance djstripe . utils . QuerySetMock . update () Source code in djstripe/utils.py 79 80 def update ( self ): return 0 Functions djstripe . utils . clear_expired_idempotency_keys () Source code in djstripe/utils.py 31 32 33 34 35 def clear_expired_idempotency_keys (): from .models import IdempotencyKey threshold = timezone . now () - datetime . timedelta ( hours = 24 ) IdempotencyKey . objects . filter ( created__lt = threshold ) . delete () djstripe . utils . convert_tstamp ( response ) Convert a Stripe API timestamp response (unix epoch) to a native datetime. Source code in djstripe/utils.py 38 39 40 41 42 43 44 45 46 47 48 49 def convert_tstamp ( response ) -> Optional [ datetime . datetime ]: \"\"\" Convert a Stripe API timestamp response (unix epoch) to a native datetime. \"\"\" if response is None : # Allow passing None to convert_tstamp() return response # Overrides the set timezone to UTC - I think... tz = get_timezone_utc () if settings . USE_TZ else None return datetime . datetime . fromtimestamp ( response , tz ) djstripe . utils . get_friendly_currency_amount ( amount , currency ) Source code in djstripe/utils.py 56 57 58 59 60 def get_friendly_currency_amount ( amount , currency : str ) -> str : currency = currency . upper () sigil = CURRENCY_SIGILS . get ( currency , \"\" ) amount_two_decimals = f \" { amount : .2f } \" return f \" { sigil }{ intcomma ( amount_two_decimals ) } { currency } \" djstripe . utils . get_id_from_stripe_data ( data ) Extract stripe id from stripe field data Source code in djstripe/utils.py 86 87 88 89 90 91 92 93 94 95 96 97 98 def get_id_from_stripe_data ( data ): \"\"\" Extract stripe id from stripe field data \"\"\" if isinstance ( data , str ): # data like \"sub_6lsC8pt7IcFpjA\" return data elif data : # data like {\"id\": sub_6lsC8pt7IcFpjA\", ...} return data . get ( \"id\" ) else : return None djstripe . utils . get_model ( model_name ) Source code in djstripe/utils.py 101 102 103 104 105 def get_model ( model_name ): app_label = \"djstripe\" app_config = apps . get_app_config ( app_label ) model = app_config . get_model ( model_name ) return model djstripe . utils . get_queryset ( pks , model_name ) Source code in djstripe/utils.py 108 109 110 def get_queryset ( pks , model_name ): model = get_model ( model_name ) return model . objects . filter ( pk__in = pks ) djstripe . utils . get_supported_currency_choices ( api_key ) Pull a stripe account's supported currencies and returns a choices tuple of those supported currencies. :param api_key: The api key associated with the account from which to pull data. :type api_key: str Source code in djstripe/utils.py 15 16 17 18 19 20 21 22 23 24 25 26 27 28 def get_supported_currency_choices ( api_key ): \"\"\" Pull a stripe account's supported currencies and returns a choices tuple of those supported currencies. :param api_key: The api key associated with the account from which to pull data. :type api_key: str \"\"\" account = stripe . Account . retrieve ( api_key = api_key ) supported_payment_currencies = stripe . CountrySpec . retrieve ( account [ \"country\" ], api_key = api_key )[ \"supported_payment_currencies\" ] return [( currency , currency . upper ()) for currency in supported_payment_currencies ] djstripe . utils . get_timezone_utc () Returns UTC attribute in a backwards compatible way. UTC attribute has been moved from django.utils.timezone module to datetime.timezone class Source code in djstripe/utils.py 113 114 115 116 117 118 119 120 121 122 123 124 def get_timezone_utc (): \"\"\" Returns UTC attribute in a backwards compatible way. UTC attribute has been moved from django.utils.timezone module to datetime.timezone class \"\"\" try : # Django 4+ return datetime . timezone . utc except AttributeError : return timezone . utc","title":"Utilities"},{"location":"reference/utils/#utilities","text":"Utility functions related to the djstripe app.","title":"Utilities"},{"location":"reference/utils/#djstripe.utils-attributes","text":"","title":"Attributes"},{"location":"reference/utils/#djstripe.utils.CURRENCY_SIGILS","text":"","title":"CURRENCY_SIGILS"},{"location":"reference/utils/#djstripe.utils-classes","text":"","title":"Classes"},{"location":"reference/utils/#djstripe.utils.QuerySetMock","text":"Bases: QuerySet A mocked QuerySet class that does not handle updates. Used by UpcomingInvoice.invoiceitems (deprecated) and UpcomingInvoice.lineitems. Source code in djstripe/utils.py 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 class QuerySetMock ( QuerySet ): \"\"\" A mocked QuerySet class that does not handle updates. Used by UpcomingInvoice.invoiceitems (deprecated) and UpcomingInvoice.lineitems. \"\"\" @classmethod def from_iterable ( cls , model , iterable ): instance = cls ( model ) instance . _result_cache = list ( iterable ) instance . _prefetch_done = True return instance def _clone ( self ): return self . __class__ . from_iterable ( self . model , self . _result_cache ) def update ( self ): return 0 def delete ( self ): return 0","title":"QuerySetMock"},{"location":"reference/utils/#djstripe.utils.QuerySetMock-functions","text":"","title":"Functions"},{"location":"reference/utils/#djstripe.utils.QuerySetMock.delete","text":"Source code in djstripe/utils.py 82 83 def delete ( self ): return 0","title":"delete()"},{"location":"reference/utils/#djstripe.utils.QuerySetMock.from_iterable","text":"Source code in djstripe/utils.py 69 70 71 72 73 74 @classmethod def from_iterable ( cls , model , iterable ): instance = cls ( model ) instance . _result_cache = list ( iterable ) instance . _prefetch_done = True return instance","title":"from_iterable()"},{"location":"reference/utils/#djstripe.utils.QuerySetMock.update","text":"Source code in djstripe/utils.py 79 80 def update ( self ): return 0","title":"update()"},{"location":"reference/utils/#djstripe.utils-functions","text":"","title":"Functions"},{"location":"reference/utils/#djstripe.utils.clear_expired_idempotency_keys","text":"Source code in djstripe/utils.py 31 32 33 34 35 def clear_expired_idempotency_keys (): from .models import IdempotencyKey threshold = timezone . now () - datetime . timedelta ( hours = 24 ) IdempotencyKey . objects . filter ( created__lt = threshold ) . delete ()","title":"clear_expired_idempotency_keys()"},{"location":"reference/utils/#djstripe.utils.convert_tstamp","text":"Convert a Stripe API timestamp response (unix epoch) to a native datetime. Source code in djstripe/utils.py 38 39 40 41 42 43 44 45 46 47 48 49 def convert_tstamp ( response ) -> Optional [ datetime . datetime ]: \"\"\" Convert a Stripe API timestamp response (unix epoch) to a native datetime. \"\"\" if response is None : # Allow passing None to convert_tstamp() return response # Overrides the set timezone to UTC - I think... tz = get_timezone_utc () if settings . USE_TZ else None return datetime . datetime . fromtimestamp ( response , tz )","title":"convert_tstamp()"},{"location":"reference/utils/#djstripe.utils.get_friendly_currency_amount","text":"Source code in djstripe/utils.py 56 57 58 59 60 def get_friendly_currency_amount ( amount , currency : str ) -> str : currency = currency . upper () sigil = CURRENCY_SIGILS . get ( currency , \"\" ) amount_two_decimals = f \" { amount : .2f } \" return f \" { sigil }{ intcomma ( amount_two_decimals ) } { currency } \"","title":"get_friendly_currency_amount()"},{"location":"reference/utils/#djstripe.utils.get_id_from_stripe_data","text":"Extract stripe id from stripe field data Source code in djstripe/utils.py 86 87 88 89 90 91 92 93 94 95 96 97 98 def get_id_from_stripe_data ( data ): \"\"\" Extract stripe id from stripe field data \"\"\" if isinstance ( data , str ): # data like \"sub_6lsC8pt7IcFpjA\" return data elif data : # data like {\"id\": sub_6lsC8pt7IcFpjA\", ...} return data . get ( \"id\" ) else : return None","title":"get_id_from_stripe_data()"},{"location":"reference/utils/#djstripe.utils.get_model","text":"Source code in djstripe/utils.py 101 102 103 104 105 def get_model ( model_name ): app_label = \"djstripe\" app_config = apps . get_app_config ( app_label ) model = app_config . get_model ( model_name ) return model","title":"get_model()"},{"location":"reference/utils/#djstripe.utils.get_queryset","text":"Source code in djstripe/utils.py 108 109 110 def get_queryset ( pks , model_name ): model = get_model ( model_name ) return model . objects . filter ( pk__in = pks )","title":"get_queryset()"},{"location":"reference/utils/#djstripe.utils.get_supported_currency_choices","text":"Pull a stripe account's supported currencies and returns a choices tuple of those supported currencies. :param api_key: The api key associated with the account from which to pull data. :type api_key: str Source code in djstripe/utils.py 15 16 17 18 19 20 21 22 23 24 25 26 27 28 def get_supported_currency_choices ( api_key ): \"\"\" Pull a stripe account's supported currencies and returns a choices tuple of those supported currencies. :param api_key: The api key associated with the account from which to pull data. :type api_key: str \"\"\" account = stripe . Account . retrieve ( api_key = api_key ) supported_payment_currencies = stripe . CountrySpec . retrieve ( account [ \"country\" ], api_key = api_key )[ \"supported_payment_currencies\" ] return [( currency , currency . upper ()) for currency in supported_payment_currencies ]","title":"get_supported_currency_choices()"},{"location":"reference/utils/#djstripe.utils.get_timezone_utc","text":"Returns UTC attribute in a backwards compatible way. UTC attribute has been moved from django.utils.timezone module to datetime.timezone class Source code in djstripe/utils.py 113 114 115 116 117 118 119 120 121 122 123 124 def get_timezone_utc (): \"\"\" Returns UTC attribute in a backwards compatible way. UTC attribute has been moved from django.utils.timezone module to datetime.timezone class \"\"\" try : # Django 4+ return datetime . timezone . utc except AttributeError : return timezone . utc","title":"get_timezone_utc()"},{"location":"usage/creating_individual_charges/","text":"Creating individual charges On the subscriber's customer object, use the charge method to generate a Stripe charge. In this example, we're using the user named admin as the subscriber. from decimal import Decimal from django.contrib.auth import get_user_model from djstripe.models import Customer user = get_user_model () . objects . get ( username = \"admin\" ) customer , created = Customer . get_or_create ( subscriber = user ) customer . charge ( Decimal ( \"10.00\" ), currency = \"usd\" ) # Create charge for 10.00 USD","title":"Creating individual charges"},{"location":"usage/creating_individual_charges/#creating-individual-charges","text":"On the subscriber's customer object, use the charge method to generate a Stripe charge. In this example, we're using the user named admin as the subscriber. from decimal import Decimal from django.contrib.auth import get_user_model from djstripe.models import Customer user = get_user_model () . objects . get ( username = \"admin\" ) customer , created = Customer . get_or_create ( subscriber = user ) customer . charge ( Decimal ( \"10.00\" ), currency = \"usd\" ) # Create charge for 10.00 USD","title":"Creating individual charges"},{"location":"usage/creating_usage_record/","text":"Create a Stripe Usage Record Usage records allow you to report customer usage and metrics to Stripe for metered billing of subscription prices Usage records created using Djstripe's UsageRecord.create() method will both create and sync the created UsageRecord object with your db. Note UsageRecord objects created directly will not sync because Stripe does not expose a way to retrieve UsageRecord objects directly. They can thus only be synced at creation time. Code: from djstripe.models import UsageRecord # create and sync UsageRecord object UsageRecord . create ( id =< SUBSCRIPTION_ITEM_ID > , quantity =< SUBSCRIPTION_ITEM_QUANTITY > , timestamp = timestamp )","title":"Creating Usage Records"},{"location":"usage/creating_usage_record/#create-a-stripe-usage-record","text":"Usage records allow you to report customer usage and metrics to Stripe for metered billing of subscription prices Usage records created using Djstripe's UsageRecord.create() method will both create and sync the created UsageRecord object with your db. Note UsageRecord objects created directly will not sync because Stripe does not expose a way to retrieve UsageRecord objects directly. They can thus only be synced at creation time.","title":"Create a Stripe Usage Record"},{"location":"usage/creating_usage_record/#code","text":"from djstripe.models import UsageRecord # create and sync UsageRecord object UsageRecord . create ( id =< SUBSCRIPTION_ITEM_ID > , quantity =< SUBSCRIPTION_ITEM_QUANTITY > , timestamp = timestamp )","title":"Code:"},{"location":"usage/local_webhook_testing/","text":"Local Webhook Testing The Stripe CLI allows receiving webhooks events from Stripe on your local machine via a direct connection to Stripe's API. Set the --forward-to flag to the URL of a local webhook endpoint you created via the Django admin or the Stripe Dashboard. New Style UUID urls are also supported from v2.7 onwards. For example: stripe listen --forward-to http://localhost:8000/stripe/webhook/<UUID> The signatures of events sent by Stripe to the webhooks are verified to prevent third-parties from interacting with the endpoints. Events will be signed with a webhook secret different from existing endpoints (because Stripe CLI doesn't require a webhook endpoint to be set up). You can obtain this secret by looking at the output of stripe listen or by running stripe listen --print-secret . In order to let dj-stripe know about the secret key to verify the signature, it can be passed as an HTTP header; dj-stripe looks for a header called X-Djstripe-Webhook-Secret : stripe listen \\ --forward-to http://localhost:8000/djstripe/webhook/<UUID> \\ -H \"x-djstripe-webhook-secret: $( stripe listen --print-secret ) \" From now on, whenever you make changes on the Stripe Dashboard, the webhook endpoint you specified with --forward-to will called with the respective changes. Hint If the webhook secret is not passed to dj-stripe, signature validation will fail with an HTTP status code 400 and the message \"Failed to verify header\". Stripe events can now be triggered like so: stripe trigger customer.created","title":"Development with local webhooks"},{"location":"usage/local_webhook_testing/#local-webhook-testing","text":"The Stripe CLI allows receiving webhooks events from Stripe on your local machine via a direct connection to Stripe's API. Set the --forward-to flag to the URL of a local webhook endpoint you created via the Django admin or the Stripe Dashboard. New Style UUID urls are also supported from v2.7 onwards. For example: stripe listen --forward-to http://localhost:8000/stripe/webhook/<UUID> The signatures of events sent by Stripe to the webhooks are verified to prevent third-parties from interacting with the endpoints. Events will be signed with a webhook secret different from existing endpoints (because Stripe CLI doesn't require a webhook endpoint to be set up). You can obtain this secret by looking at the output of stripe listen or by running stripe listen --print-secret . In order to let dj-stripe know about the secret key to verify the signature, it can be passed as an HTTP header; dj-stripe looks for a header called X-Djstripe-Webhook-Secret : stripe listen \\ --forward-to http://localhost:8000/djstripe/webhook/<UUID> \\ -H \"x-djstripe-webhook-secret: $( stripe listen --print-secret ) \" From now on, whenever you make changes on the Stripe Dashboard, the webhook endpoint you specified with --forward-to will called with the respective changes. Hint If the webhook secret is not passed to dj-stripe, signature validation will fail with an HTTP status code 400 and the message \"Failed to verify header\". Stripe events can now be triggered like so: stripe trigger customer.created","title":"Local Webhook Testing"},{"location":"usage/managing_subscriptions/","text":"Managing subscriptions and payment sources Extending subscriptions For your convenience, dj-stripe provides a Subscription.extend(*delta*) method Subscriptions can be extended by using the Subscription.extend method, which takes a positive timedelta as its only property. This method is useful if you want to offer time-cards, gift-cards, or some other external way of subscribing users or extending subscriptions, while keeping the billing handling within Stripe. Warning Subscription extensions are achieved by manipulating the trial_end of the subscription instance, which means that Stripe will change the status to trialing .","title":"Managing subscriptions and payment sources"},{"location":"usage/managing_subscriptions/#managing-subscriptions-and-payment-sources","text":"","title":"Managing subscriptions and payment sources"},{"location":"usage/managing_subscriptions/#extending-subscriptions","text":"For your convenience, dj-stripe provides a Subscription.extend(*delta*) method Subscriptions can be extended by using the Subscription.extend method, which takes a positive timedelta as its only property. This method is useful if you want to offer time-cards, gift-cards, or some other external way of subscribing users or extending subscriptions, while keeping the billing handling within Stripe. Warning Subscription extensions are achieved by manipulating the trial_end of the subscription instance, which means that Stripe will change the status to trialing .","title":"Extending subscriptions"},{"location":"usage/manually_syncing_with_stripe/","text":"Manually syncing data with Stripe If you're using dj-stripe's webhook handlers then data will be automatically synced from Stripe to the Django database, but in some circumstances you may want to manually sync Stripe API data as well. Command line You can sync your database with stripe using the management command djstripe_sync_models , e.g. to populate an empty database from an existing Stripe account. ./manage.py djstripe_sync_models With no arguments this will sync all supported models for all in database API Keys , or a list of models to sync can also be provided. ./manage.py djstripe_sync_models Invoice Subscription Note that this may be redundant since we recursively sync related objects. A list of models to sync can also be provided along with the API Keys. ./manage.py djstripe_sync_models Invoice Subscription --api-keys sk_test_XXX sk_test_YYY This will sync all the Invoice and Subscription data for the given API Keys. Please note that the API Keys sk_test_YYY and sk_test_XXX need to be in the database. You can manually reprocess events using the management commands djstripe_process_events . By default this processes all events, but options can be passed to limit the events processed. Note the Stripe API documents a limitation where events are only guaranteed to be available for 30 days. # all events ./manage.py djstripe_process_events # failed events (events with pending webhooks or where all webhook delivery attempts failed) ./manage.py djstripe_process_events --failed # filter by event type (all payment_intent events in this example) ./manage.py djstripe_process_events --type payment_intent.* # specific events by ID ./manage.py djstripe_process_events --ids evt_foo evt_bar # more output for debugging processing failures ./manage.py djstripe_process_events -v 2 In Code To sync in code, for example if you write to the Stripe API and want to work with the resulting dj-stripe object without having to wait for the webhook trigger. This can be done using the classmethod sync_from_stripe_data that exists on all dj-stripe model classes. E.g. creating a product using the Stripe API, and then syncing the API return data to Django using dj-stripe:","title":"Manually syncing data with Stripe"},{"location":"usage/manually_syncing_with_stripe/#manually-syncing-data-with-stripe","text":"If you're using dj-stripe's webhook handlers then data will be automatically synced from Stripe to the Django database, but in some circumstances you may want to manually sync Stripe API data as well.","title":"Manually syncing data with Stripe"},{"location":"usage/manually_syncing_with_stripe/#command-line","text":"You can sync your database with stripe using the management command djstripe_sync_models , e.g. to populate an empty database from an existing Stripe account. ./manage.py djstripe_sync_models With no arguments this will sync all supported models for all in database API Keys , or a list of models to sync can also be provided. ./manage.py djstripe_sync_models Invoice Subscription Note that this may be redundant since we recursively sync related objects. A list of models to sync can also be provided along with the API Keys. ./manage.py djstripe_sync_models Invoice Subscription --api-keys sk_test_XXX sk_test_YYY This will sync all the Invoice and Subscription data for the given API Keys. Please note that the API Keys sk_test_YYY and sk_test_XXX need to be in the database. You can manually reprocess events using the management commands djstripe_process_events . By default this processes all events, but options can be passed to limit the events processed. Note the Stripe API documents a limitation where events are only guaranteed to be available for 30 days. # all events ./manage.py djstripe_process_events # failed events (events with pending webhooks or where all webhook delivery attempts failed) ./manage.py djstripe_process_events --failed # filter by event type (all payment_intent events in this example) ./manage.py djstripe_process_events --type payment_intent.* # specific events by ID ./manage.py djstripe_process_events --ids evt_foo evt_bar # more output for debugging processing failures ./manage.py djstripe_process_events -v 2","title":"Command line"},{"location":"usage/manually_syncing_with_stripe/#in-code","text":"To sync in code, for example if you write to the Stripe API and want to work with the resulting dj-stripe object without having to wait for the webhook trigger. This can be done using the classmethod sync_from_stripe_data that exists on all dj-stripe model classes. E.g. creating a product using the Stripe API, and then syncing the API return data to Django using dj-stripe:","title":"In Code"},{"location":"usage/subscribing_customers/","text":"Subscribing a customer to one or more prices (or plans) Recommended Approach # Recommended Approach to use items dict with Prices ## This will subscribe <customer> to both <price_1> and <price_2> price_1 = Price . objects . get ( nickname = \"one_price\" ) price_2 = Price . objects . get ( nickname = \"two_price\" ) customer = Customer . objects . first () customer . subscribe ( items = [{ \"price\" : price_1 }, { \"price\" : price_2 }]) ## This will subscribe <customer> to <price_1> price_1 = Price . objects . get ( nickname = \"one_price\" ) customer = Customer . objects . first () customer . subscribe ( items = [{ \"price\" : price_1 }]) Alternate Approach 1 (with legacy Plans) ## (Alternate Approach) This will subscribe <customer> to <price_1> price_1 = Price . objects . get ( nickname = \"one_price\" ) customer = Customer . objects . first () customer . subscribe ( price = price_1 ) # If you still use legacy Plans... ## This will subscribe <customer> to both <plan_1> and <plan_2> plan_1 = Plan . objects . get ( nickname = \"one_plan\" ) plan_2 = Plan . objects . get ( nickname = \"two_plan\" ) customer = Customer . objects . first () customer . subscribe ( items = [{ \"plan\" : plan_1 }, { \"plan\" : plan_2 }]) ## This will subscribe <customer> to <plan_1> plan_1 = Plan . objects . get ( nickname = \"one_plan\" ) customer = Customer . objects . first () customer . subscribe ( items = [{ \"plan\" : plan_1 }]) Alternate Approach 2 ## (Alternate Approach) This will subscribe <customer> to <plan_1> plan_1 = Plan . objects . get ( nickname = \"one_plan\" ) customer = Customer . objects . first () customer . subscribe ( plan = plan_1 ) However in some cases subscribe() might not support all the arguments you need for your implementation. When this happens you can just call the official stripe.Customer.subscribe() . Tip Check out the following examples: form_valid view example djstripe.models.Customer.add_payment_method Note that PaymentMethods can be used instead of Cards/Source by substituting # Add the payment method customer's default customer . add_payment_method ( payment_method ) instead of # Add the source as the customer's default card customer . add_card ( stripe_source ) in the above example.","title":"Subscribing a customer to a plan"},{"location":"usage/subscribing_customers/#subscribing-a-customer-to-one-or-more-prices-or-plans","text":"","title":"Subscribing a customer to one or more prices (or plans)"},{"location":"usage/subscribing_customers/#recommended-approach","text":"# Recommended Approach to use items dict with Prices ## This will subscribe <customer> to both <price_1> and <price_2> price_1 = Price . objects . get ( nickname = \"one_price\" ) price_2 = Price . objects . get ( nickname = \"two_price\" ) customer = Customer . objects . first () customer . subscribe ( items = [{ \"price\" : price_1 }, { \"price\" : price_2 }]) ## This will subscribe <customer> to <price_1> price_1 = Price . objects . get ( nickname = \"one_price\" ) customer = Customer . objects . first () customer . subscribe ( items = [{ \"price\" : price_1 }])","title":"Recommended Approach"},{"location":"usage/subscribing_customers/#alternate-approach-1-with-legacy-plans","text":"## (Alternate Approach) This will subscribe <customer> to <price_1> price_1 = Price . objects . get ( nickname = \"one_price\" ) customer = Customer . objects . first () customer . subscribe ( price = price_1 ) # If you still use legacy Plans... ## This will subscribe <customer> to both <plan_1> and <plan_2> plan_1 = Plan . objects . get ( nickname = \"one_plan\" ) plan_2 = Plan . objects . get ( nickname = \"two_plan\" ) customer = Customer . objects . first () customer . subscribe ( items = [{ \"plan\" : plan_1 }, { \"plan\" : plan_2 }]) ## This will subscribe <customer> to <plan_1> plan_1 = Plan . objects . get ( nickname = \"one_plan\" ) customer = Customer . objects . first () customer . subscribe ( items = [{ \"plan\" : plan_1 }])","title":"Alternate Approach 1 (with legacy Plans)"},{"location":"usage/subscribing_customers/#alternate-approach-2","text":"## (Alternate Approach) This will subscribe <customer> to <plan_1> plan_1 = Plan . objects . get ( nickname = \"one_plan\" ) customer = Customer . objects . first () customer . subscribe ( plan = plan_1 ) However in some cases subscribe() might not support all the arguments you need for your implementation. When this happens you can just call the official stripe.Customer.subscribe() . Tip Check out the following examples: form_valid view example djstripe.models.Customer.add_payment_method Note that PaymentMethods can be used instead of Cards/Source by substituting # Add the payment method customer's default customer . add_payment_method ( payment_method ) instead of # Add the source as the customer's default card customer . add_card ( stripe_source ) in the above example.","title":"Alternate Approach 2"},{"location":"usage/using_stripe_checkout/","text":"Create a Stripe Checkout Session For your convenience, dj-stripe has provided an example implementation on how to use Checkouts Please note that in order for dj-stripe to create a link between your customers and your subscribers , you need to add the DJSTRIPE_SUBSCRIBER_CUSTOMER_KEY key to the metadata parameter of Checkout . This has also been demonstrated in the aforementioned example","title":"Using Stripe Checkout"},{"location":"usage/using_stripe_checkout/#create-a-stripe-checkout-session","text":"For your convenience, dj-stripe has provided an example implementation on how to use Checkouts Please note that in order for dj-stripe to create a link between your customers and your subscribers , you need to add the DJSTRIPE_SUBSCRIBER_CUSTOMER_KEY key to the metadata parameter of Checkout . This has also been demonstrated in the aforementioned example","title":"Create a Stripe Checkout Session"},{"location":"usage/using_with_docker/","text":"Using with Docker A Docker image allows you to run the Stripe CLI in a container. Here is a sample docker-compose.yaml file that sets up all the services to use Stripe CLI in a dockerised django container (with djstripe) version : \"3.9\" volumes : postgres-data : {} services : db : image : postgres:12 volumes : - postgres-data:/var/lib/postgresql/data environment : - POSTGRES_DB=random_number - POSTGRES_USER=root - POSTGRES_PASSWORD=random_number web : build : context : . dockerfile : <PATH_TO_DOCKERFILE> command : python manage.py runserver 0.0.0.0:8000 volumes : - .:/app ports : - \"8000:8000\" depends_on : - db environment : # Stripe specific keys - STRIPE_PUBLIC_KEY=pk_test_****** - STRIPE_SECRET_KEY=sk_test_****** - DJSTRIPE_TEST_WEBHOOK_SECRET=whsec_****** # Database Specific Settings - DJSTRIPE_TEST_DB_VENDOR=postgres - DJSTRIPE_TEST_DB_PORT=5432 - DJSTRIPE_TEST_DB_USER=root - DJSTRIPE_TEST_DB_NAME=random_number - DJSTRIPE_TEST_DB_PASS=random_number - DJSTRIPE_TEST_DB_HOST=db stripe : image : stripe/stripe-cli:v1.7.4 # In case Stripe CLI is used to perform local webhook testing, set x-djstripe-webhook-secret custom header to output of Stripe CLI. command : [ \"listen\" , \"-H\" , \"x-djstripe-webhook-secret: whsec_******\" , \"--forward-to\" , \"http://web:8000/djstripe/webhook/\" ] depends_on : - web environment : - STRIPE_API_KEY=sk_test_****** - STRIPE_DEVICE_NAME=djstripe_docker Note In case the Stripe CLI is used to perform local webhook testing, set x-djstripe-webhook-secret Custom Header in Stripe listen to the Webhook Signing Secret output of Stripe CLI . That is what Stripe expects and uses to create the stripe-signature header.","title":"Using with Docker"},{"location":"usage/using_with_docker/#using-with-docker","text":"A Docker image allows you to run the Stripe CLI in a container. Here is a sample docker-compose.yaml file that sets up all the services to use Stripe CLI in a dockerised django container (with djstripe) version : \"3.9\" volumes : postgres-data : {} services : db : image : postgres:12 volumes : - postgres-data:/var/lib/postgresql/data environment : - POSTGRES_DB=random_number - POSTGRES_USER=root - POSTGRES_PASSWORD=random_number web : build : context : . dockerfile : <PATH_TO_DOCKERFILE> command : python manage.py runserver 0.0.0.0:8000 volumes : - .:/app ports : - \"8000:8000\" depends_on : - db environment : # Stripe specific keys - STRIPE_PUBLIC_KEY=pk_test_****** - STRIPE_SECRET_KEY=sk_test_****** - DJSTRIPE_TEST_WEBHOOK_SECRET=whsec_****** # Database Specific Settings - DJSTRIPE_TEST_DB_VENDOR=postgres - DJSTRIPE_TEST_DB_PORT=5432 - DJSTRIPE_TEST_DB_USER=root - DJSTRIPE_TEST_DB_NAME=random_number - DJSTRIPE_TEST_DB_PASS=random_number - DJSTRIPE_TEST_DB_HOST=db stripe : image : stripe/stripe-cli:v1.7.4 # In case Stripe CLI is used to perform local webhook testing, set x-djstripe-webhook-secret custom header to output of Stripe CLI. command : [ \"listen\" , \"-H\" , \"x-djstripe-webhook-secret: whsec_******\" , \"--forward-to\" , \"http://web:8000/djstripe/webhook/\" ] depends_on : - web environment : - STRIPE_API_KEY=sk_test_****** - STRIPE_DEVICE_NAME=djstripe_docker Note In case the Stripe CLI is used to perform local webhook testing, set x-djstripe-webhook-secret Custom Header in Stripe listen to the Webhook Signing Secret output of Stripe CLI . That is what Stripe expects and uses to create the stripe-signature header.","title":"Using with Docker"},{"location":"usage/webhooks/","text":"Using Stripe Webhooks Setting up a new webhook endpoint in dj-stripe As of dj-stripe 2.7.0, dj-stripe can create its own webhook endpoints on Stripe from the Django administration. Create a new webhook endpoint from the Django administration by going to dj-stripe -> Webhook endpoints -> Add webhook endpoint (or /admin/djstripe/webhookendpoint/add/ ). From there, you can choose an account to create the endpoint for. If no account is chosen, the default Stripe API key will be used to create the endpoint. You can also choose to create the endpoint in test mode or live mode. You may want to change the base URL of the endpoint. This field will be prefilled with the current site. If you're running on the local development server, you may see http://localhost:8000 or similar in there. Stripe won't let you save webhook endpoints with such a value, so you will want to change it to a real website URL. When saved from the admin, the endpoint will be created in Stripe with a dj-stripe specific UUID which will be part of the URL, making it impossible to guess externally by brute-force. Legacy setup Before dj-stripe 2.7.0, dj-stripe included a global webhook endpoint URL, which uses the setting DJSTRIPE_WEBHOOK_SECRET to validate incoming webhooks. This is not recommended as it makes the URL guessable, and may be removed in the future. Extra configuration dj-stripe provides the following settings to tune how your webhooks work: DJSTRIPE_WEBHOOK_VALIDATION DJSTRIPE_WEBHOOK_TOLERANCE DJSTRIPE_WEBHOOK_EVENT_CALLBACK Advanced usage dj-stripe comes with native support for webhooks as event listeners. Events allow you to do things like sending an email to a customer when his payment has failed or trial period is ending. This is how you use them: from djstripe import webhooks @webhooks . handler ( \"customer.subscription.trial_will_end\" ) def my_handler ( event , ** kwargs ): print ( \"We should probably notify the user at this point\" ) You can handle all events related to customers like this: from djstripe import webhooks @webhooks . handler ( \"customer\" ) def my_handler ( event , ** kwargs ): print ( \"We should probably notify the user at this point\" ) You can also handle different events in the same handler: from djstripe import webhooks @webhooks . handler ( \"price\" , \"product\" ) def my_handler ( event , ** kwargs ): print ( \"Triggered webhook \" + event . type ) Warning In order to get registrations picked up, you need to put them in a module that is imported like models.py or make sure you import it manually. Webhook event creation and processing is now wrapped in a transaction.atomic() block to better handle webhook errors. This will prevent any additional database modifications you may perform in your custom handler from being committed should something in the webhook processing chain fail. You can also take advantage of Django's transaction.on_commit() function to only perform an action if the transaction successfully commits (meaning the Event processing worked): from django.db import transaction from djstripe import webhooks def do_something (): pass # send a mail, invalidate a cache, fire off a Celery task, etc. @webhooks . handler ( \"price\" , \"product\" ) def my_handler ( event , ** kwargs ): transaction . on_commit ( do_something ) Official documentation Stripe docs for types of Events: https://stripe.com/docs/api/events/types Stripe docs for Webhooks: https://stripe.com/docs/webhooks Django docs for transactions: https://docs.djangoproject.com/en/dev/topics/db/transactions/#performing-actions-after-commit","title":"Using Stripe Webhooks"},{"location":"usage/webhooks/#using-stripe-webhooks","text":"","title":"Using Stripe Webhooks"},{"location":"usage/webhooks/#setting-up-a-new-webhook-endpoint-in-dj-stripe","text":"As of dj-stripe 2.7.0, dj-stripe can create its own webhook endpoints on Stripe from the Django administration. Create a new webhook endpoint from the Django administration by going to dj-stripe -> Webhook endpoints -> Add webhook endpoint (or /admin/djstripe/webhookendpoint/add/ ). From there, you can choose an account to create the endpoint for. If no account is chosen, the default Stripe API key will be used to create the endpoint. You can also choose to create the endpoint in test mode or live mode. You may want to change the base URL of the endpoint. This field will be prefilled with the current site. If you're running on the local development server, you may see http://localhost:8000 or similar in there. Stripe won't let you save webhook endpoints with such a value, so you will want to change it to a real website URL. When saved from the admin, the endpoint will be created in Stripe with a dj-stripe specific UUID which will be part of the URL, making it impossible to guess externally by brute-force.","title":"Setting up a new webhook endpoint in dj-stripe"},{"location":"usage/webhooks/#legacy-setup","text":"Before dj-stripe 2.7.0, dj-stripe included a global webhook endpoint URL, which uses the setting DJSTRIPE_WEBHOOK_SECRET to validate incoming webhooks. This is not recommended as it makes the URL guessable, and may be removed in the future.","title":"Legacy setup"},{"location":"usage/webhooks/#extra-configuration","text":"dj-stripe provides the following settings to tune how your webhooks work: DJSTRIPE_WEBHOOK_VALIDATION DJSTRIPE_WEBHOOK_TOLERANCE DJSTRIPE_WEBHOOK_EVENT_CALLBACK","title":"Extra configuration"},{"location":"usage/webhooks/#advanced-usage","text":"dj-stripe comes with native support for webhooks as event listeners. Events allow you to do things like sending an email to a customer when his payment has failed or trial period is ending. This is how you use them: from djstripe import webhooks @webhooks . handler ( \"customer.subscription.trial_will_end\" ) def my_handler ( event , ** kwargs ): print ( \"We should probably notify the user at this point\" ) You can handle all events related to customers like this: from djstripe import webhooks @webhooks . handler ( \"customer\" ) def my_handler ( event , ** kwargs ): print ( \"We should probably notify the user at this point\" ) You can also handle different events in the same handler: from djstripe import webhooks @webhooks . handler ( \"price\" , \"product\" ) def my_handler ( event , ** kwargs ): print ( \"Triggered webhook \" + event . type ) Warning In order to get registrations picked up, you need to put them in a module that is imported like models.py or make sure you import it manually. Webhook event creation and processing is now wrapped in a transaction.atomic() block to better handle webhook errors. This will prevent any additional database modifications you may perform in your custom handler from being committed should something in the webhook processing chain fail. You can also take advantage of Django's transaction.on_commit() function to only perform an action if the transaction successfully commits (meaning the Event processing worked): from django.db import transaction from djstripe import webhooks def do_something (): pass # send a mail, invalidate a cache, fire off a Celery task, etc. @webhooks . handler ( \"price\" , \"product\" ) def my_handler ( event , ** kwargs ): transaction . on_commit ( do_something )","title":"Advanced usage"},{"location":"usage/webhooks/#official-documentation","text":"Stripe docs for types of Events: https://stripe.com/docs/api/events/types Stripe docs for Webhooks: https://stripe.com/docs/webhooks Django docs for transactions: https://docs.djangoproject.com/en/dev/topics/db/transactions/#performing-actions-after-commit","title":"Official documentation"}]}