{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"dj-stripe - Django + Stripe Made Easy Stripe Models for Django. Introduction dj-stripe implements all of the Stripe models, for Django. Set up your webhook endpoint and start receiving model updates. You will then have a copy of all the Stripe models available in Django models, as soon as they are updated! The full documentation is available on Read the Docs . Features Stripe Core Stripe Billing Stripe Cards (JS v2) and Sources (JS v3) Payment Methods and Payment Intents (SCA support) Support for multiple accounts and API keys Stripe Connect (partial support) Tested with Stripe API 2020-08-27 (see API versions ) Requirements Django 3.2.5+ Python 3.7+ PostgreSQL engine (recommended) 9.6+ MySQL engine: MariaDB 10.2+ or MySQL 5.7+ SQLite: Not recommended in production. Version 3.26+ required. Installation Get the distribution Install dj-stripe with pip: pip install dj-stripe Or with Poetry (recommended): poetry add dj-stripe Configuration Add djstripe to your INSTALLED_APPS : INSTALLED_APPS =( ... \"djstripe\" , ... ) Add to urls.py: path ( \"stripe/\" , include ( \"djstripe.urls\" , namespace = \"djstripe\" )) , Tell Stripe about the webhook (Stripe webhook docs can be found here ) using the full URL of your endpoint from the urls.py step above (e.g. https://example.com/stripe/webhook ). Add your Stripe keys and set the operating mode: STRIPE_LIVE_SECRET_KEY = os.environ.get ( \"STRIPE_LIVE_SECRET_KEY\" , \"<your secret key>\" ) STRIPE_TEST_SECRET_KEY = os.environ.get ( \"STRIPE_TEST_SECRET_KEY\" , \"<your secret key>\" ) STRIPE_LIVE_MODE = False # Change to True in production DJSTRIPE_WEBHOOK_SECRET = \"whsec_xxx\" # Get it from the section in the Stripe dashboard where you added the webhook endpoint DJSTRIPE_USE_NATIVE_JSONFIELD = True # We recommend setting to True for new installations DJSTRIPE_FOREIGN_KEY_TO_FIELD = \"id\" Note djstripe expects STRIPE_LIVE_MODE to be a Boolean Type. In case you use Bash env vars or equivalent to inject its value, make sure to convert it to a Boolean type. We highly recommended the library django-environ Add some payment plans via the Stripe.com dashboard. Run the commands: python manage.py migrate python manage.py djstripe_sync_models See here for notes about usage of the Stripe Elements frontend JS library. Running Tests Assuming the tests are run against PostgreSQL: createdb djstripe pip install tox tox Changelog See release notes on Read the Docs . Funding and Support You can now become a sponsor to dj-stripe with GitHub Sponsors . We've been bringing dj-stripe to the world for over 7 years and are excited to be able to start dedicating some real resources to the project. Your sponsorship helps us keep a team of maintainers actively working to improve dj-stripe and ensure it stays up-to-date with the latest Stripe changes. If you use dj-stripe commercially, we would encourage you to invest in its continued development by signing up for a paid plan . Corporate sponsors receive priority support and development time . All contributions through GitHub sponsors flow into our Open Collective , which holds our funds and keeps an open ledger on how donations are spent. Our Gold sponsors img[alt=\"Stripe Logo\"] { max-width: 250px; } Similar libraries dj-paypal ( PayPal ) dj-paddle ( Paddle )","title":"Home"},{"location":"#dj-stripe-django-stripe-made-easy","text":"Stripe Models for Django.","title":"dj-stripe - Django + Stripe Made Easy"},{"location":"#introduction","text":"dj-stripe implements all of the Stripe models, for Django. Set up your webhook endpoint and start receiving model updates. You will then have a copy of all the Stripe models available in Django models, as soon as they are updated! The full documentation is available on Read the Docs .","title":"Introduction"},{"location":"#features","text":"Stripe Core Stripe Billing Stripe Cards (JS v2) and Sources (JS v3) Payment Methods and Payment Intents (SCA support) Support for multiple accounts and API keys Stripe Connect (partial support) Tested with Stripe API 2020-08-27 (see API versions )","title":"Features"},{"location":"#requirements","text":"Django 3.2.5+ Python 3.7+ PostgreSQL engine (recommended) 9.6+ MySQL engine: MariaDB 10.2+ or MySQL 5.7+ SQLite: Not recommended in production. Version 3.26+ required.","title":"Requirements"},{"location":"#installation","text":"","title":"Installation"},{"location":"#get-the-distribution","text":"Install dj-stripe with pip: pip install dj-stripe Or with Poetry (recommended): poetry add dj-stripe","title":"Get the distribution"},{"location":"#configuration","text":"Add djstripe to your INSTALLED_APPS : INSTALLED_APPS =( ... \"djstripe\" , ... ) Add to urls.py: path ( \"stripe/\" , include ( \"djstripe.urls\" , namespace = \"djstripe\" )) , Tell Stripe about the webhook (Stripe webhook docs can be found here ) using the full URL of your endpoint from the urls.py step above (e.g. https://example.com/stripe/webhook ). Add your Stripe keys and set the operating mode: STRIPE_LIVE_SECRET_KEY = os.environ.get ( \"STRIPE_LIVE_SECRET_KEY\" , \"<your secret key>\" ) STRIPE_TEST_SECRET_KEY = os.environ.get ( \"STRIPE_TEST_SECRET_KEY\" , \"<your secret key>\" ) STRIPE_LIVE_MODE = False # Change to True in production DJSTRIPE_WEBHOOK_SECRET = \"whsec_xxx\" # Get it from the section in the Stripe dashboard where you added the webhook endpoint DJSTRIPE_USE_NATIVE_JSONFIELD = True # We recommend setting to True for new installations DJSTRIPE_FOREIGN_KEY_TO_FIELD = \"id\" Note djstripe expects STRIPE_LIVE_MODE to be a Boolean Type. In case you use Bash env vars or equivalent to inject its value, make sure to convert it to a Boolean type. We highly recommended the library django-environ Add some payment plans via the Stripe.com dashboard. Run the commands: python manage.py migrate python manage.py djstripe_sync_models See here for notes about usage of the Stripe Elements frontend JS library.","title":"Configuration"},{"location":"#running-tests","text":"Assuming the tests are run against PostgreSQL: createdb djstripe pip install tox tox","title":"Running Tests"},{"location":"#changelog","text":"See release notes on Read the Docs .","title":"Changelog"},{"location":"#funding-and-support","text":"You can now become a sponsor to dj-stripe with GitHub Sponsors . We've been bringing dj-stripe to the world for over 7 years and are excited to be able to start dedicating some real resources to the project. Your sponsorship helps us keep a team of maintainers actively working to improve dj-stripe and ensure it stays up-to-date with the latest Stripe changes. If you use dj-stripe commercially, we would encourage you to invest in its continued development by signing up for a paid plan . Corporate sponsors receive priority support and development time . All contributions through GitHub sponsors flow into our Open Collective , which holds our funds and keeps an open ledger on how donations are spent.","title":"Funding and Support"},{"location":"#our-gold-sponsors","text":"img[alt=\"Stripe Logo\"] { max-width: 250px; }","title":"Our Gold sponsors"},{"location":"#similar-libraries","text":"dj-paypal ( PayPal ) dj-paddle ( Paddle )","title":"Similar libraries"},{"location":"CONTRIBUTING/","text":"Contributing Contributions are welcome, and they are greatly appreciated! Every little bit helps, and credit will always be given. You can contribute in many ways: Types of Contributions Report Bugs Report bugs at https://github.com/dj-stripe/dj-stripe/issues . If you are reporting a bug, please include: The version of python and Django you're running Detailed steps to reproduce the bug. Fix Bugs Look through the GitHub issues for bugs. Anything tagged with \"bug\" is open to whoever wants to implement it. Implement Features Look through the GitHub issues for features. Anything tagged with \"feature\" is open to whoever wants to implement it. Write Documentation dj-stripe could always use more documentation, whether as part of the official dj-stripe docs, in docstrings, or even on the web in blog posts, articles, and such. To see the project's documentation live, run the following command: mkdocs serve The documentation site will then be served on http://127.0.0.1:8000 . In case of any installation error In case you get the error that some plugin is not installed, please run: poetry install -E docs If you wish to just generate the documentation, you can replace serve with build , and the docs will be generated into the site/ folder. Submit Feedback The best way to send feedback is to file an issue at https://github.com/dj-stripe/dj-stripe/issues . If you are proposing a feature: Explain in detail how it would work. Keep the scope as narrow as possible, to make it easier to implement. Remember that this is a volunteer-driven project, and that contributions are welcome :) Contributor Discussion For questions regarding contributions to dj-stripe, another avenue is our Discord channel at https://discord.gg/UJY8fcc . Get Started! Ready to contribute? Here's how to set up local development. Fork dj-stripe on Github . Clone your fork locally: $ git clone git@github.com:your_name_here/dj-stripe.git Set up pre-commit : $ git init # A git repo is required to install pre-commit $ pre-commit install Set up your test database. If you're running tests using PostgreSQL: $ createdb djstripe or if you want to test vs sqlite (for convenience) or MySQL, they can be selected by setting this environment variable: $ export DJSTRIPE_TEST_DB_VENDOR = sqlite # or: export DJSTRIPE_TEST_DB_VENDOR=mysql For postgres and mysql, the database host,port,username and password can be set with environment variables, see tests/settings.py Install Poetry if you do not have it already. You can set up a virtual environment with: $ poetry install You can then, at any time, open a shell into that environment with: $ poetry shell When you're done making changes, check that your changes pass the tests. A quick test run can be done as follows: $ DJSTRIPE_TEST_DB_VENDOR = sqlite poetry run pytest --reuse-db You should also check that the tests pass with other python and Django versions with tox. pytest will output both command line and html coverage statistics and will warn you if your changes caused code coverage to drop.: $ pip install tox $ tox If your changes altered the models you may need to generate Django migrations: $ DJSTRIPE_TEST_DB_VENDOR = sqlite poetry run ./manage.py makemigrations Commit your changes and push your branch to GitHub: $ git add . $ git commit -m \"Your detailed description of your changes.\" $ git push Submit a pull request through the GitHub website. Congratulations, you're now a dj-stripe contributor! Have some \u2665 from us. Preferred Django Model Field Types When mapping from Stripe API field types to Django model fields, we try to follow Django best practises where practical. The following types should be preferred for fields that map to the Stripe API (which is almost all fields in our models). Strings Stripe API string fields have a default maximum length of 5,000 characters . In some cases a maximum length ( maxLength ) is specified in the Stripe OpenAPI schema . We follow Django's recommendation and avoid using null on string fields (which means we store \"\" for string fields that are null in stripe). Note that is enforced in the sync logic in StripeModel._stripe_object_to_record . For long string fields (eg above 255 characters) we prefer TextField over Charfield . Therefore the default type for string fields that don't have a maxLength specified in the Stripe OpenAPI schema should usually be: str_field = TextField(max_length=5000, default=\", blank=True, help_text=\"...\") Enumerations Fields that have a defined set of values can be implemented using StripeEnumField . Hash (dictionaries) Use the JSONField in djstripe.fields . Currency amounts Stripe handles all currency amounts as integer cents, we currently have a mixture of fields as integer cents and decimal (eg dollar, euro etc) values, but we are aiming to standardise on cents (see https://github.com/dj-stripe/dj-stripe/issues/955 ). All new currency amount fields should use StripeQuantumCurrencyAmountField . Dates and Datetimes The Stripe API uses an integer timestamp (seconds since the Unix epoch) for dates and datetimes. We store this as a datetime field, using StripeDateTimeField . Django Migration Policy Migrations are considered a breaking change, so it's not usually not acceptable to add a migration to a stable branch, it will be a new MAJOR.MINOR.0 release. A workaround to this in the case that the Stripe API data isn't compatible with out model (eg Stripe is sending null to a non-null field) is to implement the _manipulate_stripe_object_hook classmethod on the model. Avoid new migrations with non-schema changes If a code change produces a migration that doesn't alter the database schema (eg changing help_text ) then instead of adding a new migration you can edit the most recent migration that affects the field in question. e.g.: https://github.com/dj-stripe/dj-stripe/commit/e2762c38918a90f00c42ecf21187a920bd3a2087 Pull Request Guidelines Before you submit a pull request, check that it meets these guidelines: The pull request should include tests. The pull request must not drop code coverage below the current level. If the pull request adds functionality, the docs should be updated. Put your new functionality into a function with a docstring. If the pull request makes changes to a model, include Django migrations. The pull request should work for Python 3.6+. Check Github Actions and make sure that the tests pass for all supported Python versions. Code formatting: Make sure to install pre-commit to automatically run it on staged files or run manually with pre-commit run --all-files at the dj-stripe root to keep a consistent style.","title":"Contributing"},{"location":"CONTRIBUTING/#contributing","text":"Contributions are welcome, and they are greatly appreciated! Every little bit helps, and credit will always be given. You can contribute in many ways:","title":"Contributing"},{"location":"CONTRIBUTING/#types-of-contributions","text":"","title":"Types of Contributions"},{"location":"CONTRIBUTING/#report-bugs","text":"Report bugs at https://github.com/dj-stripe/dj-stripe/issues . If you are reporting a bug, please include: The version of python and Django you're running Detailed steps to reproduce the bug.","title":"Report Bugs"},{"location":"CONTRIBUTING/#fix-bugs","text":"Look through the GitHub issues for bugs. Anything tagged with \"bug\" is open to whoever wants to implement it.","title":"Fix Bugs"},{"location":"CONTRIBUTING/#implement-features","text":"Look through the GitHub issues for features. Anything tagged with \"feature\" is open to whoever wants to implement it.","title":"Implement Features"},{"location":"CONTRIBUTING/#write-documentation","text":"dj-stripe could always use more documentation, whether as part of the official dj-stripe docs, in docstrings, or even on the web in blog posts, articles, and such. To see the project's documentation live, run the following command: mkdocs serve The documentation site will then be served on http://127.0.0.1:8000 . In case of any installation error In case you get the error that some plugin is not installed, please run: poetry install -E docs If you wish to just generate the documentation, you can replace serve with build , and the docs will be generated into the site/ folder.","title":"Write Documentation"},{"location":"CONTRIBUTING/#submit-feedback","text":"The best way to send feedback is to file an issue at https://github.com/dj-stripe/dj-stripe/issues . If you are proposing a feature: Explain in detail how it would work. Keep the scope as narrow as possible, to make it easier to implement. Remember that this is a volunteer-driven project, and that contributions are welcome :)","title":"Submit Feedback"},{"location":"CONTRIBUTING/#contributor-discussion","text":"For questions regarding contributions to dj-stripe, another avenue is our Discord channel at https://discord.gg/UJY8fcc .","title":"Contributor Discussion"},{"location":"CONTRIBUTING/#get-started","text":"Ready to contribute? Here's how to set up local development. Fork dj-stripe on Github . Clone your fork locally: $ git clone git@github.com:your_name_here/dj-stripe.git Set up pre-commit : $ git init # A git repo is required to install pre-commit $ pre-commit install Set up your test database. If you're running tests using PostgreSQL: $ createdb djstripe or if you want to test vs sqlite (for convenience) or MySQL, they can be selected by setting this environment variable: $ export DJSTRIPE_TEST_DB_VENDOR = sqlite # or: export DJSTRIPE_TEST_DB_VENDOR=mysql For postgres and mysql, the database host,port,username and password can be set with environment variables, see tests/settings.py Install Poetry if you do not have it already. You can set up a virtual environment with: $ poetry install You can then, at any time, open a shell into that environment with: $ poetry shell When you're done making changes, check that your changes pass the tests. A quick test run can be done as follows: $ DJSTRIPE_TEST_DB_VENDOR = sqlite poetry run pytest --reuse-db You should also check that the tests pass with other python and Django versions with tox. pytest will output both command line and html coverage statistics and will warn you if your changes caused code coverage to drop.: $ pip install tox $ tox If your changes altered the models you may need to generate Django migrations: $ DJSTRIPE_TEST_DB_VENDOR = sqlite poetry run ./manage.py makemigrations Commit your changes and push your branch to GitHub: $ git add . $ git commit -m \"Your detailed description of your changes.\" $ git push Submit a pull request through the GitHub website. Congratulations, you're now a dj-stripe contributor! Have some \u2665 from us.","title":"Get Started!"},{"location":"CONTRIBUTING/#preferred-django-model-field-types","text":"When mapping from Stripe API field types to Django model fields, we try to follow Django best practises where practical. The following types should be preferred for fields that map to the Stripe API (which is almost all fields in our models).","title":"Preferred Django Model Field Types"},{"location":"CONTRIBUTING/#strings","text":"Stripe API string fields have a default maximum length of 5,000 characters . In some cases a maximum length ( maxLength ) is specified in the Stripe OpenAPI schema . We follow Django's recommendation and avoid using null on string fields (which means we store \"\" for string fields that are null in stripe). Note that is enforced in the sync logic in StripeModel._stripe_object_to_record . For long string fields (eg above 255 characters) we prefer TextField over Charfield . Therefore the default type for string fields that don't have a maxLength specified in the Stripe OpenAPI schema should usually be: str_field = TextField(max_length=5000, default=\", blank=True, help_text=\"...\")","title":"Strings"},{"location":"CONTRIBUTING/#enumerations","text":"Fields that have a defined set of values can be implemented using StripeEnumField .","title":"Enumerations"},{"location":"CONTRIBUTING/#hash-dictionaries","text":"Use the JSONField in djstripe.fields .","title":"Hash (dictionaries)"},{"location":"CONTRIBUTING/#currency-amounts","text":"Stripe handles all currency amounts as integer cents, we currently have a mixture of fields as integer cents and decimal (eg dollar, euro etc) values, but we are aiming to standardise on cents (see https://github.com/dj-stripe/dj-stripe/issues/955 ). All new currency amount fields should use StripeQuantumCurrencyAmountField .","title":"Currency amounts"},{"location":"CONTRIBUTING/#dates-and-datetimes","text":"The Stripe API uses an integer timestamp (seconds since the Unix epoch) for dates and datetimes. We store this as a datetime field, using StripeDateTimeField .","title":"Dates and Datetimes"},{"location":"CONTRIBUTING/#django-migration-policy","text":"Migrations are considered a breaking change, so it's not usually not acceptable to add a migration to a stable branch, it will be a new MAJOR.MINOR.0 release. A workaround to this in the case that the Stripe API data isn't compatible with out model (eg Stripe is sending null to a non-null field) is to implement the _manipulate_stripe_object_hook classmethod on the model.","title":"Django Migration Policy"},{"location":"CONTRIBUTING/#avoid-new-migrations-with-non-schema-changes","text":"If a code change produces a migration that doesn't alter the database schema (eg changing help_text ) then instead of adding a new migration you can edit the most recent migration that affects the field in question. e.g.: https://github.com/dj-stripe/dj-stripe/commit/e2762c38918a90f00c42ecf21187a920bd3a2087","title":"Avoid new migrations with non-schema changes"},{"location":"CONTRIBUTING/#pull-request-guidelines","text":"Before you submit a pull request, check that it meets these guidelines: The pull request should include tests. The pull request must not drop code coverage below the current level. If the pull request adds functionality, the docs should be updated. Put your new functionality into a function with a docstring. If the pull request makes changes to a model, include Django migrations. The pull request should work for Python 3.6+. Check Github Actions and make sure that the tests pass for all supported Python versions. Code formatting: Make sure to install pre-commit to automatically run it on staged files or run manually with pre-commit run --all-files at the dj-stripe root to keep a consistent style.","title":"Pull Request Guidelines"},{"location":"api_keys/","text":"Managing Stripe API keys Stripe API keys are stored in the database, and editable from the Django admin. Important Note By default, keys are visible by anyone who has access to the dj-stripe administration. Adding new API keys You may add new API keys via the Dj-Stripe \"API key\" administration. The only required value is the key's \"secret\" value itself. Example: Once saved, Dj-Stripe will automatically detect whether the key is a public, restricted or secret key, and whether it's for live or test mode. If it's a secret key, the matching Account object will automatically be fetched as well and the key will be associated with it, so that it can be used to communicate with the Stripe API when dealing with objects belonging to that Account. Updating the API keys When expiring or rolling new secret keys, you should create the new API key in Stripe, then add it from the Django administration. Whenever you are ready, you may delete the old key. (It is safe to keep it around, as long as it hasn't expired. Keeping expired keys in the database may result in errors during usage). FAQ Why store them in the database? As we work on supporting multiple Stripe accounts per instance, it is vital for dj-stripe to have a mechanism to store more than one Stripe API key. It also became obvious that we may want proper programmatic access to create and delete keys. Furthermore, API keys are a legitimate upstream Stripe object, and it is not unlikely the API may allow access to listing other API keys in the future, in which case we will want to move them to the database anyway. Isn't that insecure? Please do keep your billing database encrypted. There's a copy of all your customers' billing data on it! You may also instead create a read-only restricted key with all-read permissions for dj-stripe. There is no added risk there, given that dj-stripe holds a copy of all your data regardless. I'm using environment variables. Do I need to change anything? Not at this time. The settings STRIPE_LIVE_SECRET_KEY and STRIPE_TEST_SECRET_KEY can still be used. Their values will however be automatically saved to the database at the earliest opportunity. What about public keys? Setting STRIPE_LIVE_PUBLIC_KEY and STRIPE_TEST_PUBLIC_KEY will be deprecated in 2.5.0. You do not risk anything by leaving them in your settings: They are not used by Dj-Stripe outside of the Dj-Stripe mixins, which are now themselves deprecated. So you can safely leave them in your settings, or you can move them to the database as well (Keys beginning in pk_test_ and pk_live_ will be detected as publishable keys).","title":"Managing Stripe API Keys"},{"location":"api_keys/#managing-stripe-api-keys","text":"Stripe API keys are stored in the database, and editable from the Django admin. Important Note By default, keys are visible by anyone who has access to the dj-stripe administration.","title":"Managing Stripe API keys"},{"location":"api_keys/#adding-new-api-keys","text":"You may add new API keys via the Dj-Stripe \"API key\" administration. The only required value is the key's \"secret\" value itself. Example: Once saved, Dj-Stripe will automatically detect whether the key is a public, restricted or secret key, and whether it's for live or test mode. If it's a secret key, the matching Account object will automatically be fetched as well and the key will be associated with it, so that it can be used to communicate with the Stripe API when dealing with objects belonging to that Account.","title":"Adding new API keys"},{"location":"api_keys/#updating-the-api-keys","text":"When expiring or rolling new secret keys, you should create the new API key in Stripe, then add it from the Django administration. Whenever you are ready, you may delete the old key. (It is safe to keep it around, as long as it hasn't expired. Keeping expired keys in the database may result in errors during usage).","title":"Updating the API keys"},{"location":"api_keys/#faq","text":"","title":"FAQ"},{"location":"api_keys/#why-store-them-in-the-database","text":"As we work on supporting multiple Stripe accounts per instance, it is vital for dj-stripe to have a mechanism to store more than one Stripe API key. It also became obvious that we may want proper programmatic access to create and delete keys. Furthermore, API keys are a legitimate upstream Stripe object, and it is not unlikely the API may allow access to listing other API keys in the future, in which case we will want to move them to the database anyway.","title":"Why store them in the database?"},{"location":"api_keys/#isnt-that-insecure","text":"Please do keep your billing database encrypted. There's a copy of all your customers' billing data on it! You may also instead create a read-only restricted key with all-read permissions for dj-stripe. There is no added risk there, given that dj-stripe holds a copy of all your data regardless.","title":"Isn't that insecure?"},{"location":"api_keys/#im-using-environment-variables-do-i-need-to-change-anything","text":"Not at this time. The settings STRIPE_LIVE_SECRET_KEY and STRIPE_TEST_SECRET_KEY can still be used. Their values will however be automatically saved to the database at the earliest opportunity.","title":"I'm using environment variables. Do I need to change anything?"},{"location":"api_keys/#what-about-public-keys","text":"Setting STRIPE_LIVE_PUBLIC_KEY and STRIPE_TEST_PUBLIC_KEY will be deprecated in 2.5.0. You do not risk anything by leaving them in your settings: They are not used by Dj-Stripe outside of the Dj-Stripe mixins, which are now themselves deprecated. So you can safely leave them in your settings, or you can move them to the database as well (Keys beginning in pk_test_ and pk_live_ will be detected as publishable keys).","title":"What about public keys?"},{"location":"api_versions/","text":"A note on Stripe API versions A point that can cause confusion to new users of dj-stripe is that there are several different Stripe API versions in play at once. Attention Don't touch the STRIPE_API_VERSION setting, but don't worry, it doesn't need to match your Stripe account api version. See also Stripe API Versioning Your Stripe account's API version You can find this on your Stripe dashboard labelled \" default \" For new accounts this will be the latest Stripe version. When upgrading version Stripe only allows you to upgrade to the latest version. Tip Checkout Stripe Version Upgrade Documentation for Upgrading Stripe API version Note This is the version used by Stripe when sending webhook data to you (though during webhook processing, dj-stripe re-fetches the data with its preferred version). It's also the default version used by the Stripe API, but dj-stripe overrides the API version when talking to stripe (this override is triggered on import of djstripe.models ). As a result your Stripe account API version is mostly irrelevant, though from time to time we will increase the minimum supported API version, and it's good practise to regularly upgrade to the latest version with appropriate testing. Stripe's current latest API version You can find this on your Stripe dashboard labelled \" latest \" or in [Stripe's API documentation] (https://stripe.com/docs/upgrades#api-changelog) This is the version used by new accounts and it's also \" true \" internal version of Stripe's API Tip Checkout Stripe API Versioning Dj-stripe API version This is the Stripe API version used by dj-stripe in all communication with Stripe, including when processing webhooks (though webhook data is sent to you by Stripe with your API version, we re-fetch the data with dj-stripe's API version), this is because the API schema needs to match dj-stripe's Django model schema. This is defined by djstripe.settings.djstripe_settings.DEFAULT_STRIPE_API_VERSION and can be overridden by the function, djstripe.settings.djstripe_settings.set_stripe_api_version , though see the warning about doing this. Dj-stripe Latest Tested Version This is the most recent Stripe account API version used by the maintainers during testing, more recent versions account versions are probably fine though.","title":"A note on Stripe API Versions"},{"location":"api_versions/#a-note-on-stripe-api-versions","text":"A point that can cause confusion to new users of dj-stripe is that there are several different Stripe API versions in play at once. Attention Don't touch the STRIPE_API_VERSION setting, but don't worry, it doesn't need to match your Stripe account api version. See also Stripe API Versioning","title":"A note on Stripe API versions"},{"location":"api_versions/#your-stripe-accounts-api-version","text":"You can find this on your Stripe dashboard labelled \" default \" For new accounts this will be the latest Stripe version. When upgrading version Stripe only allows you to upgrade to the latest version. Tip Checkout Stripe Version Upgrade Documentation for Upgrading Stripe API version Note This is the version used by Stripe when sending webhook data to you (though during webhook processing, dj-stripe re-fetches the data with its preferred version). It's also the default version used by the Stripe API, but dj-stripe overrides the API version when talking to stripe (this override is triggered on import of djstripe.models ). As a result your Stripe account API version is mostly irrelevant, though from time to time we will increase the minimum supported API version, and it's good practise to regularly upgrade to the latest version with appropriate testing.","title":"Your Stripe account's API version"},{"location":"api_versions/#stripes-current-latest-api-version","text":"You can find this on your Stripe dashboard labelled \" latest \" or in [Stripe's API documentation] (https://stripe.com/docs/upgrades#api-changelog) This is the version used by new accounts and it's also \" true \" internal version of Stripe's API Tip Checkout Stripe API Versioning","title":"Stripe's current latest API version"},{"location":"api_versions/#dj-stripe-api-version","text":"This is the Stripe API version used by dj-stripe in all communication with Stripe, including when processing webhooks (though webhook data is sent to you by Stripe with your API version, we re-fetch the data with dj-stripe's API version), this is because the API schema needs to match dj-stripe's Django model schema. This is defined by djstripe.settings.djstripe_settings.DEFAULT_STRIPE_API_VERSION and can be overridden by the function, djstripe.settings.djstripe_settings.set_stripe_api_version , though see the warning about doing this.","title":"Dj-stripe API version"},{"location":"api_versions/#dj-stripe-latest-tested-version","text":"This is the most recent Stripe account API version used by the maintainers during testing, more recent versions account versions are probably fine though.","title":"Dj-stripe Latest Tested Version"},{"location":"installation/","text":"Installation Get the distribution Install dj-stripe with pip: pip install dj-stripe Or with Poetry (recommended): poetry add dj-stripe Configuration Add djstripe to your INSTALLED_APPS : INSTALLED_APPS =( ... \"djstripe\" , ... ) Add to urls.py: path ( \"stripe/\" , include ( \"djstripe.urls\" , namespace = \"djstripe\" )) , Tell Stripe about the webhook (Stripe webhook docs can be found here ) using the full URL of your endpoint from the urls.py step above (e.g. https://example.com/stripe/webhook ). Add your Stripe keys and set the operating mode: STRIPE_LIVE_SECRET_KEY = os.environ.get ( \"STRIPE_LIVE_SECRET_KEY\" , \"<your secret key>\" ) STRIPE_TEST_SECRET_KEY = os.environ.get ( \"STRIPE_TEST_SECRET_KEY\" , \"<your secret key>\" ) STRIPE_LIVE_MODE = False # Change to True in production DJSTRIPE_WEBHOOK_SECRET = \"whsec_xxx\" # Get it from the section in the Stripe dashboard where you added the webhook endpoint DJSTRIPE_USE_NATIVE_JSONFIELD = True # We recommend setting to True for new installations DJSTRIPE_FOREIGN_KEY_TO_FIELD = \"id\" Note djstripe expects STRIPE_LIVE_MODE to be a Boolean Type. In case you use Bash env vars or equivalent to inject its value, make sure to convert it to a Boolean type. We highly recommended the library django-environ Add some payment plans via the Stripe.com dashboard. Run the commands: python manage.py migrate python manage.py djstripe_sync_models See here for notes about usage of the Stripe Elements frontend JS library. Running Tests Assuming the tests are run against PostgreSQL: createdb djstripe pip install tox tox","title":"Installation"},{"location":"installation/#installation","text":"","title":"Installation"},{"location":"installation/#get-the-distribution","text":"Install dj-stripe with pip: pip install dj-stripe Or with Poetry (recommended): poetry add dj-stripe","title":"Get the distribution"},{"location":"installation/#configuration","text":"Add djstripe to your INSTALLED_APPS : INSTALLED_APPS =( ... \"djstripe\" , ... ) Add to urls.py: path ( \"stripe/\" , include ( \"djstripe.urls\" , namespace = \"djstripe\" )) , Tell Stripe about the webhook (Stripe webhook docs can be found here ) using the full URL of your endpoint from the urls.py step above (e.g. https://example.com/stripe/webhook ). Add your Stripe keys and set the operating mode: STRIPE_LIVE_SECRET_KEY = os.environ.get ( \"STRIPE_LIVE_SECRET_KEY\" , \"<your secret key>\" ) STRIPE_TEST_SECRET_KEY = os.environ.get ( \"STRIPE_TEST_SECRET_KEY\" , \"<your secret key>\" ) STRIPE_LIVE_MODE = False # Change to True in production DJSTRIPE_WEBHOOK_SECRET = \"whsec_xxx\" # Get it from the section in the Stripe dashboard where you added the webhook endpoint DJSTRIPE_USE_NATIVE_JSONFIELD = True # We recommend setting to True for new installations DJSTRIPE_FOREIGN_KEY_TO_FIELD = \"id\" Note djstripe expects STRIPE_LIVE_MODE to be a Boolean Type. In case you use Bash env vars or equivalent to inject its value, make sure to convert it to a Boolean type. We highly recommended the library django-environ Add some payment plans via the Stripe.com dashboard. Run the commands: python manage.py migrate python manage.py djstripe_sync_models See here for notes about usage of the Stripe Elements frontend JS library.","title":"Configuration"},{"location":"installation/#running-tests","text":"Assuming the tests are run against PostgreSQL: createdb djstripe pip install tox tox","title":"Running Tests"},{"location":"stripe_elements_js/","text":"Integrating Stripe Elements (JS SDK) Tip TLDR: If you haven't yet migrated to PaymentIntents, prefer stripe.createSource() over stripe.createToken() for better compatibility with PaymentMethods. Attention A point that can cause confusion when integrating Stripe on the web is that there are multiple generations of frontend JS APIs that use Stripe Elements with stripe js v3. In descending order of preference these are: Payment Intents (SCA compliant) The newest and preferred way of handling payments, which supports SCA compliance (3D secure etc). Charges using stripe.createSource() This creates Source objects within Stripe, and can be used for various different methods of payment (including, but not limited to cards), but isn't SCA compliant. The Card Elements Quickstart JS example can be used, except use stripe.createSource instead of stripe.createToken and the result.source instead of result.token . Checkout a working example of this Charges using stripe.createToken() This predates stripe.createSource , and creates legacy Card objects within Stripe, which have some compatibility issues with Payment Methods. If you're using stripe.createToken , see if you can upgrade to stripe.createSource or ideally to Payment Intents . Tip Checkout Card Elements Quickstart JS","title":"Integrating Stripe Elements"},{"location":"stripe_elements_js/#integrating-stripe-elements-js-sdk","text":"Tip TLDR: If you haven't yet migrated to PaymentIntents, prefer stripe.createSource() over stripe.createToken() for better compatibility with PaymentMethods. Attention A point that can cause confusion when integrating Stripe on the web is that there are multiple generations of frontend JS APIs that use Stripe Elements with stripe js v3.","title":"Integrating Stripe Elements (JS SDK)"},{"location":"stripe_elements_js/#in-descending-order-of-preference-these-are","text":"","title":"In descending order of preference these are:"},{"location":"stripe_elements_js/#payment-intents-sca-compliant","text":"The newest and preferred way of handling payments, which supports SCA compliance (3D secure etc).","title":"Payment Intents (SCA compliant)"},{"location":"stripe_elements_js/#charges-using-stripecreatesource","text":"This creates Source objects within Stripe, and can be used for various different methods of payment (including, but not limited to cards), but isn't SCA compliant. The Card Elements Quickstart JS example can be used, except use stripe.createSource instead of stripe.createToken and the result.source instead of result.token . Checkout a working example of this","title":"Charges using stripe.createSource()"},{"location":"stripe_elements_js/#charges-using-stripecreatetoken","text":"This predates stripe.createSource , and creates legacy Card objects within Stripe, which have some compatibility issues with Payment Methods. If you're using stripe.createToken , see if you can upgrade to stripe.createSource or ideally to Payment Intents . Tip Checkout Card Elements Quickstart JS","title":"Charges using stripe.createToken()"},{"location":"history/0_x/","text":"dj-stripe 0.x release notes 0.8.0 (2015-12-30) better plan ordering documentation (Thanks @cjrh) added a confirmation page when choosing a subscription (Thanks @chrissmejia, @areski) setup.py reverse dependency fix (#258/#268) (Thanks @ticosax) Dropped official support for Django 1.7 (no code changes were made) Python 3.5 support, Django 1.9.1 support Migration improvements (Thanks @michi88) Fixed \"Invoice matching query does not exist\" bug (#263) (Thanks @mthornhill) Fixed duplicate content in account view (Thanks @areski) 0.7.0 (2015-09-22) dj-stripe now responds to the invoice.created event (Thanks @wahuneke) dj-stripe now cancels subscriptions and purges customers during sync if they were deleted from the stripe dashboard (Thanks @unformatt) dj-stripe now checks for an active stripe subscription in the update_plan_quantity call (Thanks @ctrengove) Event processing is now handled by \"event handlers\" - functions outside of models that respond to various event types and subtypes. Documentation on how to tie into the event handler system coming soon. (Thanks @wahuneke) Experimental Python 3.5 support Support for Django 1.6 and lower is now officially gone. Much, much more! 0.6.0 (2015-07-12) Support for Django 1.6 and lower is now deprecated. Improved test harness now tests coverage and pep8 SubscribeFormView and ChangePlanView no longer populate self.error with form errors InvoiceItems.plan can now be null (as it is with individual charges), resolving #140 (Thanks @awechsler and @MichelleGlauser for help troubleshooting) Email templates are now packaged during distribution. sync_plans now takes an optional api_key 100% test coverage Stripe ID is now returned as part of each model's str method (Thanks @areski) Customer model now stores card expiration month and year (Thanks @jpadilla) Ability to extend subscriptions (Thanks @TigerDX) Support for plan heirarchies (Thanks @chrissmejia) Rest API endpoints for Subscriptions [contrib] (Thanks @philippeluickx) Admin interface search by email funtionality is removed (#221) (Thanks @jpadilla) 0.5.0 (2015-05-25) Began deprecation of support for Django 1.6 and lower. Added formal support for Django 1.8. Removed the StripeSubscriptionSignupForm Removed djstripe.safe_settings . Settings are now all located in djstripe.settings DJSTRIPE_TRIAL_PERIOD_FOR_SUBSCRIBER_CALLBACK can no longer be a module string The sync_subscriber argument has been renamed from subscriber_model to subscriber Moved available currencies to the DJSTRIPE_CURRENCIES setting (Thanks @martinhill) Allow passing of extra parameters to stripe Charge API (Thanks @mthornhill) Support for all available arguments when syncing plans (Thanks @jamesbrobb) charge.refund() now returns the refunded charge object (Thanks @mthornhill) Charge model now has captured field and a capture method (Thanks @mthornhill) Subscription deleted webhook bugfix South migrations are now up to date (Thanks @Tyrdall) 0.4.0 (2015-04-05) Formal Python 3.3+/Django 1.7 Support (including migrations) Removed Python 2.6 from Travis CI build. (Thanks @audreyr) Dropped Django 1.4 support. (Thanks @audreyr) Deprecated the djstripe.forms.StripeSubscriptionSignupForm . Making this form work easily with both dj-stripe and django-allauth required too much abstraction. It will be removed in the 0.5.0 release. Add the ability to add invoice items for a customer (Thanks @kavdev) Add the ability to use a custom customer model (Thanks @kavdev) Added setting to disable Invoice receipt emails (Thanks Chris Halpert) Enable proration when customer upgrades plan, and pass proration policy and cancellation at period end for upgrades in settings. (Thanks Yasmine Charif) Removed the redundant context processor. (Thanks @kavdev) Fixed create a token call in change_card.html (Thanks @dollydagr) Fix charge.dispute.closed typo. (Thanks @ipmb) Fix contributing docs formatting. (Thanks @audreyr) Fix subscription canceled_at_period_end field sync on plan upgrade (Thanks @nigma) Remove \"account\" bug in Middleware (Thanks @sromero84) Fix correct plan selection on subscription in subscribe_form template. (Thanks Yasmine Charif) Fix subscription status in account, _subscription_status, and cancel_subscription templates. (Thanks Yasmine Charif) Now using user.get_username() instead of user.username , to support custom User models. (Thanks @shvechikov) Update remaining DOM Ids for Bootstrap 3. (Thanks Yasmine Charif) Update publish command in setup.py. (Thanks @pydanny) Explicitly specify tox's virtual environment names. (Thanks @audreyr) Manually call django.setup() to populate apps registry. (Thanks @audreyr) 0.3.5 (2014-05-01) Fixed djstripe_init_customers management command so it works with custom user models. 0.3.4 (2014-05-01) Clarify documentation for redirects on app_name. If settings.DEBUG is True, then django-debug-toolbar is exempt from redirect to subscription form. Use collections.OrderedDict to ensure that plans are listed in order of price. Add ordereddict library to support Python 2.6 users. Switch from __unicode__ to __str__ methods on models to better support Python 3. Add python_2_unicode_compatible decorator to Models. Check for PY3 so the unicode(self.user) in models.Customer doesn't blow up in Python 3. 0.3.3 (2014-04-24) Increased the extendability of the views by removing as many hard-coded URLs as possible and replacing them with success_url and other attributes/methods. Added single unit purchasing to the cookbook 0.3.2 (2014-01-16) Made Yasmine Charif a core committer Take into account trial days in a subscription plan (Thanks Yasmine Charif) Correct invoice period end value (Thanks Yasmine Charif) Make plan cancellation and plan change consistently not prorating (Thanks Yasmine Charif) Fix circular import when ACCOUNT_SIGNUP_FORM_CLASS is defined (Thanks Dustin Farris) Add send e-mail receipt action in charges admin panel (Thanks Buddy Lindsay) Add created field to all ModelAdmins to help with internal auditing (Thanks Kulbir Singh) 0.3.1 (2013-11-14) Cancellation fix (Thanks Yasmine Charif) Add setup.cfg for wheel generation (Thanks Charlie Denton) 0.3.0 (2013-11-12) Fully tested against Django 1.6, 1.5, and 1.4 Fix boolean default issue in models (from now on they are all default to False ). Replace duplicated code with djstripe.utils.user_has_active_subscription . 0.2.9 (2013-09-06) Cancellation added to views. Support for kwargs on charge and invoice fetching. def charge() now supports send_receipt flag, default to True. Fixed templates to work with Bootstrap 3.0.0 column design. 0.2.8 (2013-09-02) Improved usage documentation. Corrected order of fields in StripeSubscriptionSignupForm. Corrected transaction history template layout. Updated models to take into account when settings.USE_TZ is disabled. 0.2.7 (2013-08-24) Add handy rest_framework permission class. Fixing attribution for django-stripe-payments. Add new status to Invoice model. 0.2.6 (2013-08-20) Changed name of division tag to djdiv. Added safe_setting.py module to handle edge cases when working with custom user models. Added cookbook page in the documentation. 0.2.5 (2013-08-18) Fixed bug in initial checkout You can't purchase the same plan that you currently have. 0.2.4 (2013-08-18) Recursive package finding. 0.2.3 (2013-08-16) Fix packaging so all submodules are loaded 0.2.2 (2013-08-15) Added Registration + Subscription form 0.2.1 (2013-08-12) Fixed a bug on CurrentSubscription tests Improved usage documentation Added to migration from other tools documentation 0.2.0 (2013-08-12) Cancellation of plans now works. Upgrades and downgrades of plans now work. Changing of cards now works. Added breadcrumbs to improve navigation. Improved installation instructions. Consolidation of test instructions. Minor improvement to django-stripe-payments documentation Added coverage.py to test process. Added south migrations. Fixed the subscription_payment_required function-based view decorator. Removed unnecessary django-crispy-forms 0.1.7 (2013-08-08) Middleware excepts all of the djstripe namespaced URLs. This way people can pay. 0.1.6 (2013-08-08) Fixed a couple template paths Fixed the manifest so we include html, images. 0.1.5 (2013-08-08) Fixed the manifest so we include html, css, js, images. 0.1.4 (2013-08-08) Change PaymentRequiredMixin to SubscriptionPaymentRequiredMixin Add subscription_payment_required function-based view decorator Added SubscriptionPaymentRedirectMiddleware Much nicer accounts view display Much improved subscription form display Payment plans can have decimals Payment plans can have custom images 0.1.3 (2013-08-7) Added account view Added Customer.get_or_create method Added djstripe_sync_customers management command sync file for all code that keeps things in sync with stripe Use client-side JavaScript to get history data asynchronously More user friendly action views 0.1.2 (2013-08-6) Admin working Better publish statement Fix dependencies 0.1.1 (2013-08-6) Ported internals from django-stripe-payments Began writing the views Travis-CI All tests passing on Python 2.7 and 3.3 All tests passing on Django 1.4 and 1.5 Began model cleanup Better form Provide better response from management commands 0.1.0 (2013-08-5) First release on PyPI.","title":"dj-stripe 0.x release notes"},{"location":"history/0_x/#dj-stripe-0x-release-notes","text":"","title":"dj-stripe 0.x release notes"},{"location":"history/0_x/#080-2015-12-30","text":"better plan ordering documentation (Thanks @cjrh) added a confirmation page when choosing a subscription (Thanks @chrissmejia, @areski) setup.py reverse dependency fix (#258/#268) (Thanks @ticosax) Dropped official support for Django 1.7 (no code changes were made) Python 3.5 support, Django 1.9.1 support Migration improvements (Thanks @michi88) Fixed \"Invoice matching query does not exist\" bug (#263) (Thanks @mthornhill) Fixed duplicate content in account view (Thanks @areski)","title":"0.8.0 (2015-12-30)"},{"location":"history/0_x/#070-2015-09-22","text":"dj-stripe now responds to the invoice.created event (Thanks @wahuneke) dj-stripe now cancels subscriptions and purges customers during sync if they were deleted from the stripe dashboard (Thanks @unformatt) dj-stripe now checks for an active stripe subscription in the update_plan_quantity call (Thanks @ctrengove) Event processing is now handled by \"event handlers\" - functions outside of models that respond to various event types and subtypes. Documentation on how to tie into the event handler system coming soon. (Thanks @wahuneke) Experimental Python 3.5 support Support for Django 1.6 and lower is now officially gone. Much, much more!","title":"0.7.0 (2015-09-22)"},{"location":"history/0_x/#060-2015-07-12","text":"Support for Django 1.6 and lower is now deprecated. Improved test harness now tests coverage and pep8 SubscribeFormView and ChangePlanView no longer populate self.error with form errors InvoiceItems.plan can now be null (as it is with individual charges), resolving #140 (Thanks @awechsler and @MichelleGlauser for help troubleshooting) Email templates are now packaged during distribution. sync_plans now takes an optional api_key 100% test coverage Stripe ID is now returned as part of each model's str method (Thanks @areski) Customer model now stores card expiration month and year (Thanks @jpadilla) Ability to extend subscriptions (Thanks @TigerDX) Support for plan heirarchies (Thanks @chrissmejia) Rest API endpoints for Subscriptions [contrib] (Thanks @philippeluickx) Admin interface search by email funtionality is removed (#221) (Thanks @jpadilla)","title":"0.6.0 (2015-07-12)"},{"location":"history/0_x/#050-2015-05-25","text":"Began deprecation of support for Django 1.6 and lower. Added formal support for Django 1.8. Removed the StripeSubscriptionSignupForm Removed djstripe.safe_settings . Settings are now all located in djstripe.settings DJSTRIPE_TRIAL_PERIOD_FOR_SUBSCRIBER_CALLBACK can no longer be a module string The sync_subscriber argument has been renamed from subscriber_model to subscriber Moved available currencies to the DJSTRIPE_CURRENCIES setting (Thanks @martinhill) Allow passing of extra parameters to stripe Charge API (Thanks @mthornhill) Support for all available arguments when syncing plans (Thanks @jamesbrobb) charge.refund() now returns the refunded charge object (Thanks @mthornhill) Charge model now has captured field and a capture method (Thanks @mthornhill) Subscription deleted webhook bugfix South migrations are now up to date (Thanks @Tyrdall)","title":"0.5.0 (2015-05-25)"},{"location":"history/0_x/#040-2015-04-05","text":"Formal Python 3.3+/Django 1.7 Support (including migrations) Removed Python 2.6 from Travis CI build. (Thanks @audreyr) Dropped Django 1.4 support. (Thanks @audreyr) Deprecated the djstripe.forms.StripeSubscriptionSignupForm . Making this form work easily with both dj-stripe and django-allauth required too much abstraction. It will be removed in the 0.5.0 release. Add the ability to add invoice items for a customer (Thanks @kavdev) Add the ability to use a custom customer model (Thanks @kavdev) Added setting to disable Invoice receipt emails (Thanks Chris Halpert) Enable proration when customer upgrades plan, and pass proration policy and cancellation at period end for upgrades in settings. (Thanks Yasmine Charif) Removed the redundant context processor. (Thanks @kavdev) Fixed create a token call in change_card.html (Thanks @dollydagr) Fix charge.dispute.closed typo. (Thanks @ipmb) Fix contributing docs formatting. (Thanks @audreyr) Fix subscription canceled_at_period_end field sync on plan upgrade (Thanks @nigma) Remove \"account\" bug in Middleware (Thanks @sromero84) Fix correct plan selection on subscription in subscribe_form template. (Thanks Yasmine Charif) Fix subscription status in account, _subscription_status, and cancel_subscription templates. (Thanks Yasmine Charif) Now using user.get_username() instead of user.username , to support custom User models. (Thanks @shvechikov) Update remaining DOM Ids for Bootstrap 3. (Thanks Yasmine Charif) Update publish command in setup.py. (Thanks @pydanny) Explicitly specify tox's virtual environment names. (Thanks @audreyr) Manually call django.setup() to populate apps registry. (Thanks @audreyr)","title":"0.4.0 (2015-04-05)"},{"location":"history/0_x/#035-2014-05-01","text":"Fixed djstripe_init_customers management command so it works with custom user models.","title":"0.3.5 (2014-05-01)"},{"location":"history/0_x/#034-2014-05-01","text":"Clarify documentation for redirects on app_name. If settings.DEBUG is True, then django-debug-toolbar is exempt from redirect to subscription form. Use collections.OrderedDict to ensure that plans are listed in order of price. Add ordereddict library to support Python 2.6 users. Switch from __unicode__ to __str__ methods on models to better support Python 3. Add python_2_unicode_compatible decorator to Models. Check for PY3 so the unicode(self.user) in models.Customer doesn't blow up in Python 3.","title":"0.3.4 (2014-05-01)"},{"location":"history/0_x/#033-2014-04-24","text":"Increased the extendability of the views by removing as many hard-coded URLs as possible and replacing them with success_url and other attributes/methods. Added single unit purchasing to the cookbook","title":"0.3.3 (2014-04-24)"},{"location":"history/0_x/#032-2014-01-16","text":"Made Yasmine Charif a core committer Take into account trial days in a subscription plan (Thanks Yasmine Charif) Correct invoice period end value (Thanks Yasmine Charif) Make plan cancellation and plan change consistently not prorating (Thanks Yasmine Charif) Fix circular import when ACCOUNT_SIGNUP_FORM_CLASS is defined (Thanks Dustin Farris) Add send e-mail receipt action in charges admin panel (Thanks Buddy Lindsay) Add created field to all ModelAdmins to help with internal auditing (Thanks Kulbir Singh)","title":"0.3.2 (2014-01-16)"},{"location":"history/0_x/#031-2013-11-14","text":"Cancellation fix (Thanks Yasmine Charif) Add setup.cfg for wheel generation (Thanks Charlie Denton)","title":"0.3.1 (2013-11-14)"},{"location":"history/0_x/#030-2013-11-12","text":"Fully tested against Django 1.6, 1.5, and 1.4 Fix boolean default issue in models (from now on they are all default to False ). Replace duplicated code with djstripe.utils.user_has_active_subscription .","title":"0.3.0 (2013-11-12)"},{"location":"history/0_x/#029-2013-09-06","text":"Cancellation added to views. Support for kwargs on charge and invoice fetching. def charge() now supports send_receipt flag, default to True. Fixed templates to work with Bootstrap 3.0.0 column design.","title":"0.2.9 (2013-09-06)"},{"location":"history/0_x/#028-2013-09-02","text":"Improved usage documentation. Corrected order of fields in StripeSubscriptionSignupForm. Corrected transaction history template layout. Updated models to take into account when settings.USE_TZ is disabled.","title":"0.2.8 (2013-09-02)"},{"location":"history/0_x/#027-2013-08-24","text":"Add handy rest_framework permission class. Fixing attribution for django-stripe-payments. Add new status to Invoice model.","title":"0.2.7 (2013-08-24)"},{"location":"history/0_x/#026-2013-08-20","text":"Changed name of division tag to djdiv. Added safe_setting.py module to handle edge cases when working with custom user models. Added cookbook page in the documentation.","title":"0.2.6 (2013-08-20)"},{"location":"history/0_x/#025-2013-08-18","text":"Fixed bug in initial checkout You can't purchase the same plan that you currently have.","title":"0.2.5 (2013-08-18)"},{"location":"history/0_x/#024-2013-08-18","text":"Recursive package finding.","title":"0.2.4 (2013-08-18)"},{"location":"history/0_x/#023-2013-08-16","text":"Fix packaging so all submodules are loaded","title":"0.2.3 (2013-08-16)"},{"location":"history/0_x/#022-2013-08-15","text":"Added Registration + Subscription form","title":"0.2.2 (2013-08-15)"},{"location":"history/0_x/#021-2013-08-12","text":"Fixed a bug on CurrentSubscription tests Improved usage documentation Added to migration from other tools documentation","title":"0.2.1 (2013-08-12)"},{"location":"history/0_x/#020-2013-08-12","text":"Cancellation of plans now works. Upgrades and downgrades of plans now work. Changing of cards now works. Added breadcrumbs to improve navigation. Improved installation instructions. Consolidation of test instructions. Minor improvement to django-stripe-payments documentation Added coverage.py to test process. Added south migrations. Fixed the subscription_payment_required function-based view decorator. Removed unnecessary django-crispy-forms","title":"0.2.0 (2013-08-12)"},{"location":"history/0_x/#017-2013-08-08","text":"Middleware excepts all of the djstripe namespaced URLs. This way people can pay.","title":"0.1.7 (2013-08-08)"},{"location":"history/0_x/#016-2013-08-08","text":"Fixed a couple template paths Fixed the manifest so we include html, images.","title":"0.1.6 (2013-08-08)"},{"location":"history/0_x/#015-2013-08-08","text":"Fixed the manifest so we include html, css, js, images.","title":"0.1.5 (2013-08-08)"},{"location":"history/0_x/#014-2013-08-08","text":"Change PaymentRequiredMixin to SubscriptionPaymentRequiredMixin Add subscription_payment_required function-based view decorator Added SubscriptionPaymentRedirectMiddleware Much nicer accounts view display Much improved subscription form display Payment plans can have decimals Payment plans can have custom images","title":"0.1.4 (2013-08-08)"},{"location":"history/0_x/#013-2013-08-7","text":"Added account view Added Customer.get_or_create method Added djstripe_sync_customers management command sync file for all code that keeps things in sync with stripe Use client-side JavaScript to get history data asynchronously More user friendly action views","title":"0.1.3 (2013-08-7)"},{"location":"history/0_x/#012-2013-08-6","text":"Admin working Better publish statement Fix dependencies","title":"0.1.2 (2013-08-6)"},{"location":"history/0_x/#011-2013-08-6","text":"Ported internals from django-stripe-payments Began writing the views Travis-CI All tests passing on Python 2.7 and 3.3 All tests passing on Django 1.4 and 1.5 Began model cleanup Better form Provide better response from management commands","title":"0.1.1 (2013-08-6)"},{"location":"history/0_x/#010-2013-08-5","text":"First release on PyPI.","title":"0.1.0 (2013-08-5)"},{"location":"history/1_x/","text":"dj-stripe 1.x release notes 1.2.4 (2019-02-27) This is a bugfix-only version: Allow billing_cycle_anchor argument when creating a subscription (#814) Fixup plan amount null with tier plans (#781) Update Cancel subscription view tests to match backport in f64af57 Implement Invoice._manipulate_stripe_object_hook for compatability with API 2018-11-08 (#771) Fix product webhook for type=\"good\" (#724) Add trial_from_plan, trial_period_days args to Customer.subscribe() (#709) 1.2.3 (2018-10-13) This is a bugfix-only version: Updated Subscription.cancel() for compatibility with Stripe 2018-08-23 (#723) 1.2.2 (2018-08-11) This is a bugfix-only version: Fixed an error with request.urlconf in some setups (#562) Always save text-type fields as empty strings in db instead of null (#713) Fix support for DJSTRIPE_SUBSCRIBER_MODEL_MIGRATION_DEPENDENCY (#707) Fix reactivate() with Stripe API 2018-02-28 and above 1.2.1 (2018-07-18) This is a bugfix-only version: Fixed various Python 2.7 compatibility issues Fixed issues with max_length of receipt_number Fixed various fields incorrectly marked as required Handle product webhook calls Fix compatibility with stripe-python 2.0.0 1.2.0 (2018-06-11) The dj-stripe 1.2.0 release resets all migrations. Do not upgrade to 1.2.0 directly from 1.0.1 or below. You must upgrade to 1.1.0 first. Please read the 1.1.0 release notes below for more information. 1.1.0 (2018-06-11) In dj-stripe 1.1.0, we made a lot of changes to models in order to bring the dj-stripe model state much closer to the upstream API objects. If you are a current user of dj-stripe, you will most likely have to make changes in order to upgrade. Please read the full changelog below. If you are having trouble upgrading, you may ask for help by filing an issue on GitHub . Migration reset The next version of dj-stripe, 1.2.0 , will reset all the migrations to 0001_initial . Migrations are currently in an unmaintainable state. What this means is you will not be able to upgrade directly to dj-stripe 1.2.0. You must go through 1.1.0 first, run ``manage.py migrate djstripe``, then upgrade to 1.2.0. Python 2.7 end-of-life dj-stripe 1.1.0 drops support for Django 1.10 and adds support for Django 2.0. Django 1.11+ and Python 2.7+ or 3.4+ are required. Support for Python versions older than 3.5, and Django versions older than 2.0, will be dropped in dj-stripe 2.0.0. Backwards-incompatible changes and deprecations Removal of polymorphic models The model architecture of dj-stripe has been simplified. Polymorphic models have been dropped and the old base StripeCustomer, StripeCharge, StripeInvoice, etc models have all been merged into the top-level Customer, Charge, Invoice, etc models. Importing those legacy models from djstripe.stripe_objects will yield the new ones. This is deprecated and support for this will be dropped in dj-stripe 2.0.0. Full support for Stripe Sources (Support for v3 stripe.js) Stripe sources ( src_XXXX ) are objects that can arbitrarily reference any of the payment method types that Stripe supports. However, the legacy Card object (with object IDs like card_XXXX or cc_XXXX ) is not a Source object, and cannot be turned into a Source object at this time. In order to support both Card and Source objects in ForeignKeys, a new model PaymentMethod has been devised (renamed to DjstripePaymentMethod in 2.0). That model can resolve into a Card, a Source, or a BankAccount object. The ``default_source`` attribute on ``Customer`` now refers to a ``PaymentMethod`` object . You will need to call .resolve() on it to get the Card or Source in question. References to Customer.sources expecting a queryset of Card objects should be updated to Customer.legacy_cards . The legacy StripeSource name refers to the Card model. This will be removed in dj-stripe 2.0.0. Update your references to either Card or Source . enums.SourceType has been renamed to enums.LegacySourceType . enums.SourceType now refers to the actual Stripe Source types enum. Core fields renamed The numeric id field has been renamed to djstripe_id . This avoids a clash with the upstream stripe id. Accessing .id is deprecated and **will reference the upstream stripe_id in dj-stripe 2.0.0 1.0.0 (2017-08-12) It's finally here! We've made significant changes to the codebase and are now compliant with stripe API version 2017-06-05 . I want to give a huge thanks to all of our contributors for their help in making this happen, especially Bill Huneke (@wahuneke) for his impressive design work and @jleclanche for really pushing this release along. I also want to welcome onboard two more maintainers, @jleclanche and @lskillen. They've stepped up and have graciously dedicated their resources to making dj-stripe such an amazing package. Almost all methods now mimic the parameters of those same methods in the stripe API. Note that some methods do not have some parameters implemented. This is intentional. That being said, expect all method signatures to be different than those in previous versions of dj-stripe. Finally, please note that there is still a bit of work ahead of us. Not everything in the Stripe API is currently supported by dj-stripe -- we're working on it. That said, v1.0.0 has been thoroughly tested and is verified stable in production applications. A few things to get excited for Multiple subscription support (finally) Multiple sources support (currently limited to Cards) Idempotency support (See #455, #460 for discussion -- big thanks to @jleclanche) Full model documentation Objects that come through webhooks are now tied to the API version set in dj-stripe. No more errors if dj-stripe falls behind the newest stripe API version. Any create/update action on an object automatically syncs the object. Concurrent LIVE and TEST mode support (Thanks to @jleclanche). Note that you'll run into issues if livemode isn't set on your existing customer objects. All choices are now enum-based (Thanks @jleclanche, See #520). Access them from the new djstripe.enums module. The ability to check against model property based choices will be deprecated in 1.1 Support for the Coupon model, and coupons on Customer objects. Support for the Payout/Transfer split from api version 2017-04-06 . What still needs to be done (in v1.1.0) Documentation . Our original documentation was not very helpful, but it covered the important bits. It will be very out of date after this update and will need to be rewritten. If you feel like helping, we could use all the help we can get to get this pushed out asap. Master sync re-write . This sounds scary, but really isn't. The current management methods run sync methods on Customer that aren't very helpful and are due for removal. My plan is to write something that first updates local data (via api_retrieve and sync_from_stripe_data ) and then pulls all objects from Stripe and populates the local database with any records that don't already exist there. You might be wondering, \"Why are they releasing this if there are only a few things left?\" Well, that thinking turned this into a two year release... Trust me, this is a good thing. Significant changes (mostly backwards-incompatible) Idempotency . #460 introduces idempotency keys and implements idempotency for Customer.get_or_create() . Idempotency will be enabled for all calls that need it. Improved Admin Interface . This is almost complete. See #451 and #452. Drop non-trivial endpoint views . We're dropping everything except the webhook endpoint and the subscription cancel endpoint. See #428. Drop support for sending receipts . Stripe now handles this for you. See #478. Drop support for plans as settings , including custom plan hierarchy (if you want this, write something custom) and the dynamic trial callback. We've decided to gut having plans as settings. Stripe should be your source of truth; create your plans there and sync them down manually. If you need to create plans locally for testing, etc., simply use the ORM to create Plan models. The sync rewrite will make this drop less annoying. Orphan Customer Sync . We will now sync Customer objects from Stripe even if they aren't linked to local subscriber objects. You can link up subscribers to those Customers manually. Concurrent Live and Test Mode . dj-stripe now supports test-mode and live-mode Customer objects concurrently. As a result, the User.customer One-to-One reverse-relationship is now the User.djstripe_customers RelatedManager. (Thanks @jleclanche) #440. You'll run into some dj-stripe check issues if you don't update your KEY settings accordingly. Check our GitHub issue tracker for help on this. SETTINGS The PLAN_CHOICES , PLAN_LIST , and PAYMENT_PLANS objects are removed. Use Plan.objects.all() instead. The plan_from_stripe_id function is removed. Use Plan.objects.get(stripe_id=) SYNCING sync_plans no longer takes an api_key sync methods no longer take a cu parameter All sync methods are now private. We're in the process of building a better syncing mechanism. UTILITIES dj-stripe decorators now take a plan argument. If you're passing in a custom test function to subscriber_passes_pay_test , be sure to account for this new argument. MIXINS The context provided by dj-stripe's mixins has changed. PaymentsContextMixin now provides STRIPE_PUBLIC_KEY and plans (changed to Plan.objects.all() ). SubscriptionMixin now provides customer and is_plans_plural . We've removed the SubscriptionPaymentRequiredMixin. Use @method_decorator(\"dispatch\", subscription_payment_required ) instead. MIDDLEWARE dj-stripe middleware doesn't support multiple subscriptions. SIGNALS Local custom signals are deprecated in favor of Stripe webhooks: cancelled -> WEBHOOK_SIGNALS[\"customer.subscription.deleted\"] card_changed -> WEBHOOK_SIGNALS[\"customer.source.updated\"] subscription_made -> WEBHOOK_SIGNALS[\"customer.subscription.created\"] WEBHOOK EVENTS The Event Handlers designed by @wahuneke are the new way to handle events that come through webhooks. Definitely take a look at event_handlers.py and webhooks.py . EXCEPTIONS SubscriptionUpdateFailure and SubscriptionCancellationFailure exceptions are removed. There should no longer be a case where they would have been useful. Catch native stripe errors in their place instead. MODELS CHARGE Charge.charge_created -> Charge.stripe_timestamp Charge.card_last_4 and Charge.card_kind are removed. Use Charge.source.last4 and Charge.source.brand (if the source is a Card) Charge.invoice is no longer a foreign key to the Invoice model. Invoice now has a OneToOne relationship with Charge . ( Charge.invoice will still work, but will no longer be represented in the database). CUSTOMER dj-stripe now supports test mode and live mode Customer objects concurrently (See #440). As a result, the <subscriber_model>.customer OneToOne reverse relationship is no longer a thing. You should now instead add a customer property to your subscriber model that checks whether you're in live or test mode (see djstripe.settings.STRIPE_LIVE_MODE as an example) and grabs the customer from <subscriber_model>.djstripe_customers with a simple livemode= filter. Customer no longer has a current_subscription property. We've added a subscription property that should suit your needs. With the advent of multiple subscriptions, the behavior of Customer.subscribe() has changed. Before, calling subscribe() when a customer was already subscribed to a plan would switch the customer to the new plan with an option to prorate. Now calling subscribe() simply subscribes that customer to a new plan in addition to it's current subsription. Use Subscription.update() to change a subscription's plan instead. Customer.cancel_subscription() is removed. Use Subscription.cancel() instead. The Customer.update_plan_quantity() method is removed. Use Subscription.update() instead. CustomerManager is now SubscriptionManager and works on the Subscription model instead of the Customer model. Customer.has_valid_card() is now Customer.has_valid_source() . Customer.update_card() now takes an id. If the id is not supplied, the default source is updated. Customer.stripe_customer property is removed. Use Customer.api_retrieve() instead. The at_period_end parameter of Customer.cancel_subscription() now actually follows the DJSTRIPE_PRORATION_POLICY setting. Customer.card_fingerprint , Customer.card_last_4 , Customer.card_kind , Customer.card_exp_month , Customer.card_exp_year are all removed. Check Customer.default_source (if it's a Card) or one of the sources in Customer.sources (again, if it's a Card) instead. The invoice_id parameter of Customer.add_invoice_item is now named invoice and can be either an Invoice object or the stripe_id of an Invoice. EVENT Event.kind -> Event.type Removed Event.validated_message . Just check if the event is valid no need to double check (we do that for you) TRANSFER Removed Transfer.update_status() Removed Transfer.event TransferChargeFee is removed. It hasn't been used in a while due to a broken API version. Use Transfer.fee_details instead. Any fields that were in Transfer.summary no longer exist and are therefore deprecated (unused but not removed from the database). Because of this, TransferManager now only aggregates total_sum INVOICE Invoice.attempts -> Invoice.attempt_count InvoiceItems are no longer created when Invoices are synced. You must now sync InvoiceItems directly. INVOICEITEM Removed InvoiceItem.line_type PLAN Plan no longer has a stripe_plan property. Use api_retrieve() instead. Plan.currency no longer uses choices. Use the get_supported_currency_choices() utility and create your own custom choices list instead. Plan interval choices are now in Plan.INTERVAL_TYPE_CHOICES SUBSCRIPTION Subscription.is_period_current() now checks for a current trial end if the current period has ended. This change means subscriptions extended with Subscription.extend() will now be seen as valid. MIGRATIONS We'll sync your current records with Stripe in a migration. It will take a while, but it's the only way we can ensure data integrity. There were some fields for which we needed to temporarily add placeholder defaults, so just make sure you have a customer with ID 1 and a plan with ID 1 and you shouldn't run into any issues (create dummy values for these if need be and delete them after the migration). BIG HUGE NOTE - DON'T OVERLOOK THIS Warning Subscription and InvoiceItem migration is not possible because old records don't have Stripe IDs (so we can't sync them). Our approach is to delete all local subscription and invoiceitem objects and re-sync them from Stripe. We 100% recommend you create a backup of your database before performing this upgrade. Other changes Postgres users now have access to the DJSTRIPE_USE_NATIVE_JSONFIELD setting. (Thanks @jleclanche) #517, #523 Charge receipts now take DJSTRIPE_SEND_INVOICE_RECEIPT_EMAILS into account (Thanks @r0fls) Clarified/modified installation documentation (Thanks @pydanny) Corrected and revised ANONYMOUS_USER_ERROR_MSG (Thanks @pydanny) Added fnmatching to SubscriptionPaymentMiddleware (Thanks @pydanny) SubscriptionPaymentMiddleware.process_request() functionality broken up into multiple methods, making local customizations easier (Thanks @pydanny) Fully qualified events are now supported by event handlers as strings e.g. 'customer.subscription.deleted' (Thanks @lskillen) #316 runtests now accepts positional arguments for declaring which tests to run (Thanks @lskillen) #317 It is now possible to reprocess events in both code and the admin interface (Thanks @lskillen) #318 The confirm page now checks that a valid card exists. (Thanks @scream4ik) #325 Added support for viewing upcoming invoices (Thanks @lskillen) #320 Event handler improvements and bugfixes (Thanks @lskillen) #321 API list() method bugfixes (Thanks @lskillen) #322 Added support for a custom webhook event handler (Thanks @lskillen) #323 Django REST Framework contrib package improvements (Thanks @aleccool213) #334 Added tax_percent to CreateSubscriptionSerializer (Thanks @aleccool213) #349 Fixed incorrectly assigned application_fee in Charge calls (Thanks @kronok) #382 Fixed bug caused by API change (Thanks @jessamynsmith) #353 Added inline documentation to pretty much everything and enforced docsytle via flake8 (Thanks @aleccool213) Fixed outdated method call in template (Thanks @kandoio) #391 Customer is correctly purged when subscriber is deleted, regardless of how the deletion happened (Thanks @lskillen) #396 Test webhooks are now properly captured and logged. No more bounced requests to Stripe! (Thanks @jameshiew) #408 CancelSubscriptionView redirect is now more flexible (Thanks @jleclanche) #418 Customer.sync_cards() (Thanks @jleclanche) #438 Many stability fixes, bugfixes, and code cleanup (Thanks @jleclanche) Support syncing canceled subscriptions (Thanks @jleclanche) #443 Improved admin interface (Thanks @jleclanche with @jameshiew) #451 Support concurrent TEST + LIVE API keys (Fix webhook event processing for both modes) (Thanks @jleclanche) #461 Added Stripe Dashboard link to admin change panel (Thanks @jleclanche) #465 Implemented Plan.amount_in_cents (Thanks @jleclanche) #466 Implemented Subscription.reactivate() (Thanks @jleclanche) #470 Added Plan.human_readable_price (Thanks @jleclanche) #498 (Re)attach the Subscriber when we find it's id attached to a customer on Customer sync (Thanks @jleclanche) #500 Made API version configurable (with dj-stripe recommended default) (Thanks @lskillen) #504","title":"dj-stripe 1.x release notes"},{"location":"history/1_x/#dj-stripe-1x-release-notes","text":"","title":"dj-stripe 1.x release notes"},{"location":"history/1_x/#124-2019-02-27","text":"This is a bugfix-only version: Allow billing_cycle_anchor argument when creating a subscription (#814) Fixup plan amount null with tier plans (#781) Update Cancel subscription view tests to match backport in f64af57 Implement Invoice._manipulate_stripe_object_hook for compatability with API 2018-11-08 (#771) Fix product webhook for type=\"good\" (#724) Add trial_from_plan, trial_period_days args to Customer.subscribe() (#709)","title":"1.2.4 (2019-02-27)"},{"location":"history/1_x/#123-2018-10-13","text":"This is a bugfix-only version: Updated Subscription.cancel() for compatibility with Stripe 2018-08-23 (#723)","title":"1.2.3 (2018-10-13)"},{"location":"history/1_x/#122-2018-08-11","text":"This is a bugfix-only version: Fixed an error with request.urlconf in some setups (#562) Always save text-type fields as empty strings in db instead of null (#713) Fix support for DJSTRIPE_SUBSCRIBER_MODEL_MIGRATION_DEPENDENCY (#707) Fix reactivate() with Stripe API 2018-02-28 and above","title":"1.2.2 (2018-08-11)"},{"location":"history/1_x/#121-2018-07-18","text":"This is a bugfix-only version: Fixed various Python 2.7 compatibility issues Fixed issues with max_length of receipt_number Fixed various fields incorrectly marked as required Handle product webhook calls Fix compatibility with stripe-python 2.0.0","title":"1.2.1 (2018-07-18)"},{"location":"history/1_x/#120-2018-06-11","text":"The dj-stripe 1.2.0 release resets all migrations. Do not upgrade to 1.2.0 directly from 1.0.1 or below. You must upgrade to 1.1.0 first. Please read the 1.1.0 release notes below for more information.","title":"1.2.0 (2018-06-11)"},{"location":"history/1_x/#110-2018-06-11","text":"In dj-stripe 1.1.0, we made a lot of changes to models in order to bring the dj-stripe model state much closer to the upstream API objects. If you are a current user of dj-stripe, you will most likely have to make changes in order to upgrade. Please read the full changelog below. If you are having trouble upgrading, you may ask for help by filing an issue on GitHub .","title":"1.1.0 (2018-06-11)"},{"location":"history/1_x/#migration-reset","text":"The next version of dj-stripe, 1.2.0 , will reset all the migrations to 0001_initial . Migrations are currently in an unmaintainable state. What this means is you will not be able to upgrade directly to dj-stripe 1.2.0. You must go through 1.1.0 first, run ``manage.py migrate djstripe``, then upgrade to 1.2.0.","title":"Migration reset"},{"location":"history/1_x/#python-27-end-of-life","text":"dj-stripe 1.1.0 drops support for Django 1.10 and adds support for Django 2.0. Django 1.11+ and Python 2.7+ or 3.4+ are required. Support for Python versions older than 3.5, and Django versions older than 2.0, will be dropped in dj-stripe 2.0.0.","title":"Python 2.7 end-of-life"},{"location":"history/1_x/#backwards-incompatible-changes-and-deprecations","text":"","title":"Backwards-incompatible changes and deprecations"},{"location":"history/1_x/#removal-of-polymorphic-models","text":"The model architecture of dj-stripe has been simplified. Polymorphic models have been dropped and the old base StripeCustomer, StripeCharge, StripeInvoice, etc models have all been merged into the top-level Customer, Charge, Invoice, etc models. Importing those legacy models from djstripe.stripe_objects will yield the new ones. This is deprecated and support for this will be dropped in dj-stripe 2.0.0.","title":"Removal of polymorphic models"},{"location":"history/1_x/#full-support-for-stripe-sources-support-for-v3-stripejs","text":"Stripe sources ( src_XXXX ) are objects that can arbitrarily reference any of the payment method types that Stripe supports. However, the legacy Card object (with object IDs like card_XXXX or cc_XXXX ) is not a Source object, and cannot be turned into a Source object at this time. In order to support both Card and Source objects in ForeignKeys, a new model PaymentMethod has been devised (renamed to DjstripePaymentMethod in 2.0). That model can resolve into a Card, a Source, or a BankAccount object. The ``default_source`` attribute on ``Customer`` now refers to a ``PaymentMethod`` object . You will need to call .resolve() on it to get the Card or Source in question. References to Customer.sources expecting a queryset of Card objects should be updated to Customer.legacy_cards . The legacy StripeSource name refers to the Card model. This will be removed in dj-stripe 2.0.0. Update your references to either Card or Source . enums.SourceType has been renamed to enums.LegacySourceType . enums.SourceType now refers to the actual Stripe Source types enum.","title":"Full support for Stripe Sources (Support for v3 stripe.js)"},{"location":"history/1_x/#core-fields-renamed","text":"The numeric id field has been renamed to djstripe_id . This avoids a clash with the upstream stripe id. Accessing .id is deprecated and **will reference the upstream stripe_id in dj-stripe 2.0.0","title":"Core fields renamed"},{"location":"history/1_x/#100-2017-08-12","text":"It's finally here! We've made significant changes to the codebase and are now compliant with stripe API version 2017-06-05 . I want to give a huge thanks to all of our contributors for their help in making this happen, especially Bill Huneke (@wahuneke) for his impressive design work and @jleclanche for really pushing this release along. I also want to welcome onboard two more maintainers, @jleclanche and @lskillen. They've stepped up and have graciously dedicated their resources to making dj-stripe such an amazing package. Almost all methods now mimic the parameters of those same methods in the stripe API. Note that some methods do not have some parameters implemented. This is intentional. That being said, expect all method signatures to be different than those in previous versions of dj-stripe. Finally, please note that there is still a bit of work ahead of us. Not everything in the Stripe API is currently supported by dj-stripe -- we're working on it. That said, v1.0.0 has been thoroughly tested and is verified stable in production applications.","title":"1.0.0 (2017-08-12)"},{"location":"history/1_x/#a-few-things-to-get-excited-for","text":"Multiple subscription support (finally) Multiple sources support (currently limited to Cards) Idempotency support (See #455, #460 for discussion -- big thanks to @jleclanche) Full model documentation Objects that come through webhooks are now tied to the API version set in dj-stripe. No more errors if dj-stripe falls behind the newest stripe API version. Any create/update action on an object automatically syncs the object. Concurrent LIVE and TEST mode support (Thanks to @jleclanche). Note that you'll run into issues if livemode isn't set on your existing customer objects. All choices are now enum-based (Thanks @jleclanche, See #520). Access them from the new djstripe.enums module. The ability to check against model property based choices will be deprecated in 1.1 Support for the Coupon model, and coupons on Customer objects. Support for the Payout/Transfer split from api version 2017-04-06 .","title":"A few things to get excited for"},{"location":"history/1_x/#what-still-needs-to-be-done-in-v110","text":"Documentation . Our original documentation was not very helpful, but it covered the important bits. It will be very out of date after this update and will need to be rewritten. If you feel like helping, we could use all the help we can get to get this pushed out asap. Master sync re-write . This sounds scary, but really isn't. The current management methods run sync methods on Customer that aren't very helpful and are due for removal. My plan is to write something that first updates local data (via api_retrieve and sync_from_stripe_data ) and then pulls all objects from Stripe and populates the local database with any records that don't already exist there. You might be wondering, \"Why are they releasing this if there are only a few things left?\" Well, that thinking turned this into a two year release... Trust me, this is a good thing.","title":"What still needs to be done (in v1.1.0)"},{"location":"history/1_x/#significant-changes-mostly-backwards-incompatible","text":"Idempotency . #460 introduces idempotency keys and implements idempotency for Customer.get_or_create() . Idempotency will be enabled for all calls that need it. Improved Admin Interface . This is almost complete. See #451 and #452. Drop non-trivial endpoint views . We're dropping everything except the webhook endpoint and the subscription cancel endpoint. See #428. Drop support for sending receipts . Stripe now handles this for you. See #478. Drop support for plans as settings , including custom plan hierarchy (if you want this, write something custom) and the dynamic trial callback. We've decided to gut having plans as settings. Stripe should be your source of truth; create your plans there and sync them down manually. If you need to create plans locally for testing, etc., simply use the ORM to create Plan models. The sync rewrite will make this drop less annoying. Orphan Customer Sync . We will now sync Customer objects from Stripe even if they aren't linked to local subscriber objects. You can link up subscribers to those Customers manually. Concurrent Live and Test Mode . dj-stripe now supports test-mode and live-mode Customer objects concurrently. As a result, the User.customer One-to-One reverse-relationship is now the User.djstripe_customers RelatedManager. (Thanks @jleclanche) #440. You'll run into some dj-stripe check issues if you don't update your KEY settings accordingly. Check our GitHub issue tracker for help on this.","title":"Significant changes (mostly backwards-incompatible)"},{"location":"history/1_x/#settings","text":"The PLAN_CHOICES , PLAN_LIST , and PAYMENT_PLANS objects are removed. Use Plan.objects.all() instead. The plan_from_stripe_id function is removed. Use Plan.objects.get(stripe_id=)","title":"SETTINGS"},{"location":"history/1_x/#syncing","text":"sync_plans no longer takes an api_key sync methods no longer take a cu parameter All sync methods are now private. We're in the process of building a better syncing mechanism.","title":"SYNCING"},{"location":"history/1_x/#utilities","text":"dj-stripe decorators now take a plan argument. If you're passing in a custom test function to subscriber_passes_pay_test , be sure to account for this new argument.","title":"UTILITIES"},{"location":"history/1_x/#mixins","text":"The context provided by dj-stripe's mixins has changed. PaymentsContextMixin now provides STRIPE_PUBLIC_KEY and plans (changed to Plan.objects.all() ). SubscriptionMixin now provides customer and is_plans_plural . We've removed the SubscriptionPaymentRequiredMixin. Use @method_decorator(\"dispatch\", subscription_payment_required ) instead.","title":"MIXINS"},{"location":"history/1_x/#middleware","text":"dj-stripe middleware doesn't support multiple subscriptions.","title":"MIDDLEWARE"},{"location":"history/1_x/#signals","text":"Local custom signals are deprecated in favor of Stripe webhooks: cancelled -> WEBHOOK_SIGNALS[\"customer.subscription.deleted\"] card_changed -> WEBHOOK_SIGNALS[\"customer.source.updated\"] subscription_made -> WEBHOOK_SIGNALS[\"customer.subscription.created\"]","title":"SIGNALS"},{"location":"history/1_x/#webhook-events","text":"The Event Handlers designed by @wahuneke are the new way to handle events that come through webhooks. Definitely take a look at event_handlers.py and webhooks.py .","title":"WEBHOOK EVENTS"},{"location":"history/1_x/#exceptions","text":"SubscriptionUpdateFailure and SubscriptionCancellationFailure exceptions are removed. There should no longer be a case where they would have been useful. Catch native stripe errors in their place instead.","title":"EXCEPTIONS"},{"location":"history/1_x/#models","text":"CHARGE Charge.charge_created -> Charge.stripe_timestamp Charge.card_last_4 and Charge.card_kind are removed. Use Charge.source.last4 and Charge.source.brand (if the source is a Card) Charge.invoice is no longer a foreign key to the Invoice model. Invoice now has a OneToOne relationship with Charge . ( Charge.invoice will still work, but will no longer be represented in the database). CUSTOMER dj-stripe now supports test mode and live mode Customer objects concurrently (See #440). As a result, the <subscriber_model>.customer OneToOne reverse relationship is no longer a thing. You should now instead add a customer property to your subscriber model that checks whether you're in live or test mode (see djstripe.settings.STRIPE_LIVE_MODE as an example) and grabs the customer from <subscriber_model>.djstripe_customers with a simple livemode= filter. Customer no longer has a current_subscription property. We've added a subscription property that should suit your needs. With the advent of multiple subscriptions, the behavior of Customer.subscribe() has changed. Before, calling subscribe() when a customer was already subscribed to a plan would switch the customer to the new plan with an option to prorate. Now calling subscribe() simply subscribes that customer to a new plan in addition to it's current subsription. Use Subscription.update() to change a subscription's plan instead. Customer.cancel_subscription() is removed. Use Subscription.cancel() instead. The Customer.update_plan_quantity() method is removed. Use Subscription.update() instead. CustomerManager is now SubscriptionManager and works on the Subscription model instead of the Customer model. Customer.has_valid_card() is now Customer.has_valid_source() . Customer.update_card() now takes an id. If the id is not supplied, the default source is updated. Customer.stripe_customer property is removed. Use Customer.api_retrieve() instead. The at_period_end parameter of Customer.cancel_subscription() now actually follows the DJSTRIPE_PRORATION_POLICY setting. Customer.card_fingerprint , Customer.card_last_4 , Customer.card_kind , Customer.card_exp_month , Customer.card_exp_year are all removed. Check Customer.default_source (if it's a Card) or one of the sources in Customer.sources (again, if it's a Card) instead. The invoice_id parameter of Customer.add_invoice_item is now named invoice and can be either an Invoice object or the stripe_id of an Invoice. EVENT Event.kind -> Event.type Removed Event.validated_message . Just check if the event is valid no need to double check (we do that for you) TRANSFER Removed Transfer.update_status() Removed Transfer.event TransferChargeFee is removed. It hasn't been used in a while due to a broken API version. Use Transfer.fee_details instead. Any fields that were in Transfer.summary no longer exist and are therefore deprecated (unused but not removed from the database). Because of this, TransferManager now only aggregates total_sum INVOICE Invoice.attempts -> Invoice.attempt_count InvoiceItems are no longer created when Invoices are synced. You must now sync InvoiceItems directly. INVOICEITEM Removed InvoiceItem.line_type PLAN Plan no longer has a stripe_plan property. Use api_retrieve() instead. Plan.currency no longer uses choices. Use the get_supported_currency_choices() utility and create your own custom choices list instead. Plan interval choices are now in Plan.INTERVAL_TYPE_CHOICES SUBSCRIPTION Subscription.is_period_current() now checks for a current trial end if the current period has ended. This change means subscriptions extended with Subscription.extend() will now be seen as valid.","title":"MODELS"},{"location":"history/1_x/#migrations","text":"We'll sync your current records with Stripe in a migration. It will take a while, but it's the only way we can ensure data integrity. There were some fields for which we needed to temporarily add placeholder defaults, so just make sure you have a customer with ID 1 and a plan with ID 1 and you shouldn't run into any issues (create dummy values for these if need be and delete them after the migration).","title":"MIGRATIONS"},{"location":"history/1_x/#big-huge-note-dont-overlook-this","text":"Warning Subscription and InvoiceItem migration is not possible because old records don't have Stripe IDs (so we can't sync them). Our approach is to delete all local subscription and invoiceitem objects and re-sync them from Stripe. We 100% recommend you create a backup of your database before performing this upgrade.","title":"BIG HUGE NOTE - DON'T OVERLOOK THIS"},{"location":"history/1_x/#other-changes","text":"Postgres users now have access to the DJSTRIPE_USE_NATIVE_JSONFIELD setting. (Thanks @jleclanche) #517, #523 Charge receipts now take DJSTRIPE_SEND_INVOICE_RECEIPT_EMAILS into account (Thanks @r0fls) Clarified/modified installation documentation (Thanks @pydanny) Corrected and revised ANONYMOUS_USER_ERROR_MSG (Thanks @pydanny) Added fnmatching to SubscriptionPaymentMiddleware (Thanks @pydanny) SubscriptionPaymentMiddleware.process_request() functionality broken up into multiple methods, making local customizations easier (Thanks @pydanny) Fully qualified events are now supported by event handlers as strings e.g. 'customer.subscription.deleted' (Thanks @lskillen) #316 runtests now accepts positional arguments for declaring which tests to run (Thanks @lskillen) #317 It is now possible to reprocess events in both code and the admin interface (Thanks @lskillen) #318 The confirm page now checks that a valid card exists. (Thanks @scream4ik) #325 Added support for viewing upcoming invoices (Thanks @lskillen) #320 Event handler improvements and bugfixes (Thanks @lskillen) #321 API list() method bugfixes (Thanks @lskillen) #322 Added support for a custom webhook event handler (Thanks @lskillen) #323 Django REST Framework contrib package improvements (Thanks @aleccool213) #334 Added tax_percent to CreateSubscriptionSerializer (Thanks @aleccool213) #349 Fixed incorrectly assigned application_fee in Charge calls (Thanks @kronok) #382 Fixed bug caused by API change (Thanks @jessamynsmith) #353 Added inline documentation to pretty much everything and enforced docsytle via flake8 (Thanks @aleccool213) Fixed outdated method call in template (Thanks @kandoio) #391 Customer is correctly purged when subscriber is deleted, regardless of how the deletion happened (Thanks @lskillen) #396 Test webhooks are now properly captured and logged. No more bounced requests to Stripe! (Thanks @jameshiew) #408 CancelSubscriptionView redirect is now more flexible (Thanks @jleclanche) #418 Customer.sync_cards() (Thanks @jleclanche) #438 Many stability fixes, bugfixes, and code cleanup (Thanks @jleclanche) Support syncing canceled subscriptions (Thanks @jleclanche) #443 Improved admin interface (Thanks @jleclanche with @jameshiew) #451 Support concurrent TEST + LIVE API keys (Fix webhook event processing for both modes) (Thanks @jleclanche) #461 Added Stripe Dashboard link to admin change panel (Thanks @jleclanche) #465 Implemented Plan.amount_in_cents (Thanks @jleclanche) #466 Implemented Subscription.reactivate() (Thanks @jleclanche) #470 Added Plan.human_readable_price (Thanks @jleclanche) #498 (Re)attach the Subscriber when we find it's id attached to a customer on Customer sync (Thanks @jleclanche) #500 Made API version configurable (with dj-stripe recommended default) (Thanks @lskillen) #504","title":"Other changes"},{"location":"history/2_4_0/","text":"dj-stripe 2.4.0 release notes (2020-11-19) Attention To upgrade to 2.4.0 from older versions of dj-stripe, scroll down to the Upgrade Guide . Introducing sponsorships and our first sponsor We're excited to introduce our Sponsorship tiers . Individuals may back dj-stripe to assist with development. Larger backers may choose one the paid support plans available to receive support on top of ensuring the long-term viability of the project! And this release was made possible by none other than\u2026 Stripe ! Our very first Gold sponsor. Their financial backing has allowed us to pour a lot of work that could not have otherwise happened. Release notes Support for Django 3.1 and Python 3.8. Minimum stripe-python version is now 2.48.0. Default Stripe API version is now 2020-08-27 . First-class support for the Price model, replacing Plans. Support multi-item subscriptions. Support for API keys in the database (see Managing Stripe API keys ). Support for syncing objects for multiple, different Stripe accounts. Use Django 3.1 native JSONField when available. The field djstripe_owner_account has been added to all Stripe models, and is automatically populated with the Account that owns the API key used to retrieve it. Support for subscription schedules (#899). Add support for Reporting categories and TaxIds Update many models to match latest version of the Stripe API. Fixed Account.get_default_account() for Restricted API Keys. Allow passing arbitrary arguments (any valid SDK argument) to the following methods: Customer.charge() Customer.subscribe() , Charge.capture() Subscription.update() New management command: djstripe_update_invoiceitem_ids . This command migrates InvoiceItems using Stripe's old IDs to the new ones. Hundreds of other bugfixes. New feature: in-database Stripe API keys Stripe API keys are now stored in the database, and are now editable in the admin. Warning By default, all keys are visible by anyone who has access to the dj-stripe administration. Why? As we work on supporting multiple Stripe accounts per instance, it is vital for dj-stripe to have a mechanism to store more than one Stripe API key. It also became obvious that we may want proper programmatic access to create and delete keys. Furthermore, API keys are a legitimate upstream Stripe object, and it is not unlikely the API may allow access to listing other API keys in the future, in which case we will want to move them to the database anyway. In the next release, we are planning to make WebhookEndpoints (and thus webhook secrets) manageable via the database as well. Do I need to change anything? Not at this time. The settings STRIPE_LIVE_SECRET_KEY and STRIPE_TEST_SECRET_KEY can still be used. Their values will however be automatically saved to the database at the earliest opportunity. What about public keys? Setting STRIPE_LIVE_PUBLIC_KEY and STRIPE_TEST_PUBLIC_KEY will be deprecated next release. You do not risk anything by leaving them in your settings: They are not used by Dj-Stripe outside of the Dj-Stripe mixins, which are now themselves deprecated. So you can safely leave them in your settings, or you can move them to the database as well (Keys beginning in pk_test_ and pk_live_ will be detected as publishable keys). Deprecated features Nobody likes features being removed. However, the last few releases we have had to remove features that were not core to what dj-stripe does, or simply poorly-maintained. To keep up with the trend, we are making three major deprecations this release: Creating Plans from the Django Admin is no longer supported The Plan model was special cased in various places, including being the only one which supported being created from the Django administration. This is no longer supported. We have plans to allow creating arbitrary Stripe objects from the Django Admin, but until it can be done consistently, we have decided to remove the feature for Plans (which are deprecated by Stripe anyway). The only object type you should be dealing with from the admin is the new APIKey model. Along with this, we are also deprecating the djstripe_sync_plans_from_stripe management command. You can instead use the djstripe_sync_models management command, which supports arbitrary models. Deprecating the REST API We are dropping all support for the REST API and will be fully removing it in 2.5.0. We're doing this because we wish to keep such an API separate from dj-stripe. Work has already started on a new project, and we will be sharing more details about it soon. If you're interested in helping out, please reach out on Github ! Deprecating djstripe.middleware.SubscriptionPaymentMiddleware Large parts of dj-stripe, including this middleware, were designed before Stripe's major revamps of the old Plan model into Prices, Products, and multi-plan subscriptions. The functionality offered by the middleware is no longer adequate, and building on top of it would not be particularly robust. We may bring similar functionality back in the future, but the middleware as it is is going away (as well as the undocumented djstripe.utils.subscriber_has_active_subscription utility function). If you want to keep the functionality for your project, you may wish to copy the latest version of the middleware . Deprecating djstripe.mixins This is being deprecated for similar reasons as the SubscriptionPaymentMiddleware. However, the mixins module was undocumented and never officially supported. Other deprecations The account field on Charge has been renamed to on_behalf_of , to be consistent with Stripe's upstream model. Note that this field is separate from djstripe_owner_account , which is set by dj-stripe itself to match the account of the API key used. Account.get_connected_account_from_token() is deprecated in favour of Account.get_or_retrieve_for_api_key() , which supports more than just Connect accounts. Customer.has_active_subscription() is deprecated in favour of Customer.is_subscribed_to() . Note that the former takes a plan as argument, whereas the latter takes a product as argument. The tax_percent attribute of Invoice is no longer populated and will be removed in 2.5.0. You may want to use Invoice.default_tax_rates instead, which uses the new TaxId functionality. Customer.business_vat_id is being deprecated in favour of using TaxId models directly. Breaking changes Rename PlanBillingScheme to BillingScheme. Remove Plan.update_name() and these previously-deprecated fields: Customer.business_vat_id Subscription.start Subscription.billing Upgrade Guide Before you upgrade to dj-stripe 2.4.0, we recommend upgrading to dj-stripe 2.3.0. Upgrading one major release at a time minimizes the risk of issues arising. Upgrading directly to 2.4.0 from dj-stripe versions older than 2.2.0 is unsupported. To upgrade dj-stripe, run pip install --upgrade dj-stripe==2.4.0 . Once installed, you can run manage.py migrate djstripe to migrate the database models. Attention If you are doing multiple major dj-stripe upgrades in a row, remember to run the migrate command after every upgrade. Skipping this step WILL cause errors. Note Migrating the database models may take a long time on databases with large amounts of customers. Settings changes A new mandatory setting DJSTRIPE_FOREIGN_KEY_TO_FIELD has been added. If you are upgrading from an older version, you need to set it to \"djstripe_id\" . Setting it to \"id\" will make dj-stripe use the Stripe IDs as foreign keys. Although this is recommended for new installations, there is currently no migration available for going from \"djstripe_id\" to \"id\" . For more information on this setting, see Settings .","title":"dj-stripe 2.4 release notes"},{"location":"history/2_4_0/#dj-stripe-240-release-notes-2020-11-19","text":"Attention To upgrade to 2.4.0 from older versions of dj-stripe, scroll down to the Upgrade Guide .","title":"dj-stripe 2.4.0 release notes (2020-11-19)"},{"location":"history/2_4_0/#introducing-sponsorships-and-our-first-sponsor","text":"We're excited to introduce our Sponsorship tiers . Individuals may back dj-stripe to assist with development. Larger backers may choose one the paid support plans available to receive support on top of ensuring the long-term viability of the project! And this release was made possible by none other than\u2026 Stripe ! Our very first Gold sponsor. Their financial backing has allowed us to pour a lot of work that could not have otherwise happened.","title":"Introducing sponsorships and our first sponsor"},{"location":"history/2_4_0/#release-notes","text":"Support for Django 3.1 and Python 3.8. Minimum stripe-python version is now 2.48.0. Default Stripe API version is now 2020-08-27 . First-class support for the Price model, replacing Plans. Support multi-item subscriptions. Support for API keys in the database (see Managing Stripe API keys ). Support for syncing objects for multiple, different Stripe accounts. Use Django 3.1 native JSONField when available. The field djstripe_owner_account has been added to all Stripe models, and is automatically populated with the Account that owns the API key used to retrieve it. Support for subscription schedules (#899). Add support for Reporting categories and TaxIds Update many models to match latest version of the Stripe API. Fixed Account.get_default_account() for Restricted API Keys. Allow passing arbitrary arguments (any valid SDK argument) to the following methods: Customer.charge() Customer.subscribe() , Charge.capture() Subscription.update() New management command: djstripe_update_invoiceitem_ids . This command migrates InvoiceItems using Stripe's old IDs to the new ones. Hundreds of other bugfixes.","title":"Release notes"},{"location":"history/2_4_0/#new-feature-in-database-stripe-api-keys","text":"Stripe API keys are now stored in the database, and are now editable in the admin. Warning By default, all keys are visible by anyone who has access to the dj-stripe administration.","title":"New feature: in-database Stripe API keys"},{"location":"history/2_4_0/#why","text":"As we work on supporting multiple Stripe accounts per instance, it is vital for dj-stripe to have a mechanism to store more than one Stripe API key. It also became obvious that we may want proper programmatic access to create and delete keys. Furthermore, API keys are a legitimate upstream Stripe object, and it is not unlikely the API may allow access to listing other API keys in the future, in which case we will want to move them to the database anyway. In the next release, we are planning to make WebhookEndpoints (and thus webhook secrets) manageable via the database as well.","title":"Why?"},{"location":"history/2_4_0/#do-i-need-to-change-anything","text":"Not at this time. The settings STRIPE_LIVE_SECRET_KEY and STRIPE_TEST_SECRET_KEY can still be used. Their values will however be automatically saved to the database at the earliest opportunity.","title":"Do I need to change anything?"},{"location":"history/2_4_0/#what-about-public-keys","text":"Setting STRIPE_LIVE_PUBLIC_KEY and STRIPE_TEST_PUBLIC_KEY will be deprecated next release. You do not risk anything by leaving them in your settings: They are not used by Dj-Stripe outside of the Dj-Stripe mixins, which are now themselves deprecated. So you can safely leave them in your settings, or you can move them to the database as well (Keys beginning in pk_test_ and pk_live_ will be detected as publishable keys).","title":"What about public keys?"},{"location":"history/2_4_0/#deprecated-features","text":"Nobody likes features being removed. However, the last few releases we have had to remove features that were not core to what dj-stripe does, or simply poorly-maintained. To keep up with the trend, we are making three major deprecations this release:","title":"Deprecated features"},{"location":"history/2_4_0/#creating-plans-from-the-django-admin-is-no-longer-supported","text":"The Plan model was special cased in various places, including being the only one which supported being created from the Django administration. This is no longer supported. We have plans to allow creating arbitrary Stripe objects from the Django Admin, but until it can be done consistently, we have decided to remove the feature for Plans (which are deprecated by Stripe anyway). The only object type you should be dealing with from the admin is the new APIKey model. Along with this, we are also deprecating the djstripe_sync_plans_from_stripe management command. You can instead use the djstripe_sync_models management command, which supports arbitrary models.","title":"Creating Plans from the Django Admin is no longer supported"},{"location":"history/2_4_0/#deprecating-the-rest-api","text":"We are dropping all support for the REST API and will be fully removing it in 2.5.0. We're doing this because we wish to keep such an API separate from dj-stripe. Work has already started on a new project, and we will be sharing more details about it soon. If you're interested in helping out, please reach out on Github !","title":"Deprecating the REST API"},{"location":"history/2_4_0/#deprecating-djstripemiddlewaresubscriptionpaymentmiddleware","text":"Large parts of dj-stripe, including this middleware, were designed before Stripe's major revamps of the old Plan model into Prices, Products, and multi-plan subscriptions. The functionality offered by the middleware is no longer adequate, and building on top of it would not be particularly robust. We may bring similar functionality back in the future, but the middleware as it is is going away (as well as the undocumented djstripe.utils.subscriber_has_active_subscription utility function). If you want to keep the functionality for your project, you may wish to copy the latest version of the middleware .","title":"Deprecating djstripe.middleware.SubscriptionPaymentMiddleware"},{"location":"history/2_4_0/#deprecating-djstripemixins","text":"This is being deprecated for similar reasons as the SubscriptionPaymentMiddleware. However, the mixins module was undocumented and never officially supported.","title":"Deprecating djstripe.mixins"},{"location":"history/2_4_0/#other-deprecations","text":"The account field on Charge has been renamed to on_behalf_of , to be consistent with Stripe's upstream model. Note that this field is separate from djstripe_owner_account , which is set by dj-stripe itself to match the account of the API key used. Account.get_connected_account_from_token() is deprecated in favour of Account.get_or_retrieve_for_api_key() , which supports more than just Connect accounts. Customer.has_active_subscription() is deprecated in favour of Customer.is_subscribed_to() . Note that the former takes a plan as argument, whereas the latter takes a product as argument. The tax_percent attribute of Invoice is no longer populated and will be removed in 2.5.0. You may want to use Invoice.default_tax_rates instead, which uses the new TaxId functionality. Customer.business_vat_id is being deprecated in favour of using TaxId models directly.","title":"Other deprecations"},{"location":"history/2_4_0/#breaking-changes","text":"Rename PlanBillingScheme to BillingScheme. Remove Plan.update_name() and these previously-deprecated fields: Customer.business_vat_id Subscription.start Subscription.billing","title":"Breaking changes"},{"location":"history/2_4_0/#upgrade-guide","text":"Before you upgrade to dj-stripe 2.4.0, we recommend upgrading to dj-stripe 2.3.0. Upgrading one major release at a time minimizes the risk of issues arising. Upgrading directly to 2.4.0 from dj-stripe versions older than 2.2.0 is unsupported. To upgrade dj-stripe, run pip install --upgrade dj-stripe==2.4.0 . Once installed, you can run manage.py migrate djstripe to migrate the database models. Attention If you are doing multiple major dj-stripe upgrades in a row, remember to run the migrate command after every upgrade. Skipping this step WILL cause errors. Note Migrating the database models may take a long time on databases with large amounts of customers.","title":"Upgrade Guide"},{"location":"history/2_4_0/#settings-changes","text":"A new mandatory setting DJSTRIPE_FOREIGN_KEY_TO_FIELD has been added. If you are upgrading from an older version, you need to set it to \"djstripe_id\" . Setting it to \"id\" will make dj-stripe use the Stripe IDs as foreign keys. Although this is recommended for new installations, there is currently no migration available for going from \"djstripe_id\" to \"id\" . For more information on this setting, see Settings .","title":"Settings changes"},{"location":"history/2_4_x/","text":"dj-stripe 2.4.4 release notes (2021-05-22) Fix syncing of tax IDs in management commands Set default_auto_field in migrations to prevent creation of extra migrations Misc test and documentation fixes dj-stripe 2.4.3 release notes (2021-02-08) Fix webhook error when processing events that contain a reference to a deleted payment method (such as a refund on a payment whose card has been detached or removed) Fix a couple of regressions in djstripe_sync_models management command. dj-stripe 2.4.2 release notes (2021-01-24) Release notes Fix error in Customer.add_card() due to Stripe's sources deprecation. (#1293) Fix Subscription.update() usage of the deprecated Stripe prorate argument. dj-stripe now explicitly uses proration_behavior , setting it to \"none\" when prorate is False , and \"create_prorations\" when prorate is True . dj-stripe 2.4.1 release notes (2020-11-29) Release notes Upgrade default Stripe API version to 2020-08-27 . Although we documented doing so in 2.4.0, it was not correctly set as such. This has been fixed for consistency. The Price model was incorrectly released with an amount_in_cents property, matching that of the Plan model. However, Price amounts are already in cent. The property has been removed, use unit_amount instead. Fix Price.human_readable_price calculation Fix non-blank nullable Charge fields Fix Price.tiers not being synced correctly with djstripe_sync_models (#1284) Fix sync model recursion loop (see #1288)","title":"dj-stripe 2.4.1 release notes"},{"location":"history/2_4_x/#dj-stripe-244-release-notes-2021-05-22","text":"Fix syncing of tax IDs in management commands Set default_auto_field in migrations to prevent creation of extra migrations Misc test and documentation fixes","title":"dj-stripe 2.4.4 release notes (2021-05-22)"},{"location":"history/2_4_x/#dj-stripe-243-release-notes-2021-02-08","text":"Fix webhook error when processing events that contain a reference to a deleted payment method (such as a refund on a payment whose card has been detached or removed) Fix a couple of regressions in djstripe_sync_models management command.","title":"dj-stripe 2.4.3 release notes (2021-02-08)"},{"location":"history/2_4_x/#dj-stripe-242-release-notes-2021-01-24","text":"","title":"dj-stripe 2.4.2 release notes (2021-01-24)"},{"location":"history/2_4_x/#release-notes","text":"Fix error in Customer.add_card() due to Stripe's sources deprecation. (#1293) Fix Subscription.update() usage of the deprecated Stripe prorate argument. dj-stripe now explicitly uses proration_behavior , setting it to \"none\" when prorate is False , and \"create_prorations\" when prorate is True .","title":"Release notes"},{"location":"history/2_4_x/#dj-stripe-241-release-notes-2020-11-29","text":"","title":"dj-stripe 2.4.1 release notes (2020-11-29)"},{"location":"history/2_4_x/#release-notes_1","text":"Upgrade default Stripe API version to 2020-08-27 . Although we documented doing so in 2.4.0, it was not correctly set as such. This has been fixed for consistency. The Price model was incorrectly released with an amount_in_cents property, matching that of the Plan model. However, Price amounts are already in cent. The property has been removed, use unit_amount instead. Fix Price.human_readable_price calculation Fix non-blank nullable Charge fields Fix Price.tiers not being synced correctly with djstripe_sync_models (#1284) Fix sync model recursion loop (see #1288)","title":"Release notes"},{"location":"history/2_5_0/","text":"dj-stripe 2.5.0 (2021-06-06) Attention It is not possible to upgrade to dj-stripe 2.5.0 from versions older than 2.2.2. To upgrade from an older version, first upgrade to dj-stripe 2.2.2 . Release notes Minimum Python version is now 3.6.2. Support for Python 3.9 and Django 3.2. In keeping with upstream's cycle, Django 3.0 is no longer officially supported. (Note that it will still work, because Django 2.2 LTS is still supported.) SQLite versions older than 3.26 are no longer supported. New models: FileLink, Mandate Cards and Bank Accounts are now visible in the admin interface. Lots of model sync fixes since 2.4.0. Deprecated features The FileUpload model has been renamed File , for consistency with Stripe's SDK. Although the old name is still supported, it will eventually be removed. Deprecate charge_immediately argument to Customer.subscribe() . It did not behave as expected on recent versions of Stripe. If you were using it set to charge_immediately=False , you can instead pass collection_method=\"send_invoice\" , which will send the Customer the invoice to manually pay, instead. Breaking changes When calling Customer.delete() in prior versions of dj-stripe, the Customer object would be deleted in the upstream API and the Customer object would be retained but with a date_purged attribute. This was the only model behaving this way, and it is no longer the case. If you wish to purge a customer like before, you may call Customer.purge() instead, though that method may be removed in future versions as well. Remove deprecated DRF integration ( djstripe.contrib.rest_framework ) Remove deprecated djstripe.decorators module Remove deprecated djstripe.middleware module Remove deprecated fields Account.business_vat_id and Subscription.tax_percent Remove deprecated method Account.get_connected_account_from_token() . Use Account.get_or_retrieve_for_api_key() instead. Remove deprecated Charge.account property. Use Charge.on_behalf_of instead. Remove deprecated Customer.has_active_subscription() method. Use Customer.is_subscribed_to(product) instead. FileUploadPurpose enum has been renamed FilePurpose . FileUploadType enum has been renamed FileType .","title":"dj-stripe 2.5 release notes"},{"location":"history/2_5_0/#dj-stripe-250-2021-06-06","text":"Attention It is not possible to upgrade to dj-stripe 2.5.0 from versions older than 2.2.2. To upgrade from an older version, first upgrade to dj-stripe 2.2.2 .","title":"dj-stripe 2.5.0 (2021-06-06)"},{"location":"history/2_5_0/#release-notes","text":"Minimum Python version is now 3.6.2. Support for Python 3.9 and Django 3.2. In keeping with upstream's cycle, Django 3.0 is no longer officially supported. (Note that it will still work, because Django 2.2 LTS is still supported.) SQLite versions older than 3.26 are no longer supported. New models: FileLink, Mandate Cards and Bank Accounts are now visible in the admin interface. Lots of model sync fixes since 2.4.0.","title":"Release notes"},{"location":"history/2_5_0/#deprecated-features","text":"The FileUpload model has been renamed File , for consistency with Stripe's SDK. Although the old name is still supported, it will eventually be removed. Deprecate charge_immediately argument to Customer.subscribe() . It did not behave as expected on recent versions of Stripe. If you were using it set to charge_immediately=False , you can instead pass collection_method=\"send_invoice\" , which will send the Customer the invoice to manually pay, instead.","title":"Deprecated features"},{"location":"history/2_5_0/#breaking-changes","text":"When calling Customer.delete() in prior versions of dj-stripe, the Customer object would be deleted in the upstream API and the Customer object would be retained but with a date_purged attribute. This was the only model behaving this way, and it is no longer the case. If you wish to purge a customer like before, you may call Customer.purge() instead, though that method may be removed in future versions as well. Remove deprecated DRF integration ( djstripe.contrib.rest_framework ) Remove deprecated djstripe.decorators module Remove deprecated djstripe.middleware module Remove deprecated fields Account.business_vat_id and Subscription.tax_percent Remove deprecated method Account.get_connected_account_from_token() . Use Account.get_or_retrieve_for_api_key() instead. Remove deprecated Charge.account property. Use Charge.on_behalf_of instead. Remove deprecated Customer.has_active_subscription() method. Use Customer.is_subscribed_to(product) instead. FileUploadPurpose enum has been renamed FilePurpose . FileUploadType enum has been renamed FileType .","title":"Breaking changes"},{"location":"history/2_5_x/","text":"dj-stripe 2.5.1 (2021-07-02) Release notes Fixed migration issue for new setups using custom DJSTRIPE_CUSTOMER_MODEL . Display correct JSON for JSONFields in the Django admin. Fix manual syncing of SubscriptionItem .","title":"dj-stripe 2.5.1 (2021-07-02)"},{"location":"history/2_5_x/#dj-stripe-251-2021-07-02","text":"","title":"dj-stripe 2.5.1 (2021-07-02)"},{"location":"history/2_5_x/#release-notes","text":"Fixed migration issue for new setups using custom DJSTRIPE_CUSTOMER_MODEL . Display correct JSON for JSONFields in the Django admin. Fix manual syncing of SubscriptionItem .","title":"Release notes"},{"location":"history/2_6_0/","text":"dj-stripe 2.6.0 (2022-01-XX) Attention It is not possible to upgrade to dj-stripe 2.6.0 from versions older than 2.3.0. To upgrade from an older version, first upgrade to dj-stripe 2.3.0 . Release highlights Support for Python 3.10 and Django 4.0. New models: Mandate , Payout , UsageRecordSummary , WebhookEndpoint (unused) Significant improvements and fixes to Stripe Connect features. Storing Stripe API keys by adding them to the Admin is now supported. This allows for use of multiple Stripe API keys (multiple Stripe accounts). Support for syncing Connect accounts via djstripe_sync_models . Deprecated features The use of the old jsonfield -based JSONField is deprecated and support for it will be dropped in dj-stripe 2.8.0. django.models.JSONField is available since Django 3.1.0. To switch to the newer JSONFields, set DJSTRIPE_USE_NATIVE_JSONFIELD to True . Set it to False to remain on the jsonfield -powered text-based fields. A manual migration is necessary to convert existing databases from text to json. The DJSTRIPE_PRORATION_POLICY setting is deprecated and will be ignored in 2.8. Specify proration_policy in the Subscription.update() method explicitly instead. Customer.can_charge() is now deprecated. This was a very misleading method which resulted in incorrect behaviour when Customers had multiple payment methods. It will be removed in dj-stripe 2.8.0. You can use Customer.payment_methods.all() instead. For similar reasons, Customer.has_valid_source() is deprecated and will be removed in dj-stripe 2.8.0. You can use Customer.sources.all() instead. Breaking changes Python 3.6 is no longer supported. The new minimum version of Python is 3.7.12. Django 2.2 and 3.1 are no longer supported. DJSTRIPE_USE_NATIVE_JSONFIELD now defaults to True . If you previously had it set to False , or did not have it set, you may want to explicitly set it to False in order to support a pre-existing database. A migration path will later be provided for this use case. The undocumented get_stripe_api_version() helper function has been removed. Settings for dj-stripe are now in djstripe.settings.djstripe_settings (as opposed to top-level in djstripe.settings ) Customer.subscribe() method no longer accepts positional arguments, only keywords. charge_immediately support in Customer.subscribe() has been removed (deprecated in 2.4). Set collection_method instead. The at_period_end argument to Subscription.cancel() now defaults to False , instead of the value of DJSTRIPE_PRORATION_POLICY . Other changes The Stripe Account that triggered an Event is now available on the field WebhookEventTrigger.stripe_trigger_account . Fixed recursive fetch/update loop errors in djstripe_sync_models . Migrations have been optimized and should be faster. dj-stripe now checks the apparent validity of API keys used and will raise InvalidStripeAPIKey if the API key looks completely incorrect. Customers can now be subscribed to multiple prices and/or plans by passing the items argument to Customer.subscribe() . Checkout Session metadata can be used to create/link a Stripe Customer to the Customer instance specified by the djstripe_settings.SUBSCRIBER_CUSTOMER_KEY .","title":"dj-stripe 2.6 release notes"},{"location":"history/2_6_0/#dj-stripe-260-2022-01-xx","text":"Attention It is not possible to upgrade to dj-stripe 2.6.0 from versions older than 2.3.0. To upgrade from an older version, first upgrade to dj-stripe 2.3.0 .","title":"dj-stripe 2.6.0 (2022-01-XX)"},{"location":"history/2_6_0/#release-highlights","text":"Support for Python 3.10 and Django 4.0. New models: Mandate , Payout , UsageRecordSummary , WebhookEndpoint (unused) Significant improvements and fixes to Stripe Connect features. Storing Stripe API keys by adding them to the Admin is now supported. This allows for use of multiple Stripe API keys (multiple Stripe accounts). Support for syncing Connect accounts via djstripe_sync_models .","title":"Release highlights"},{"location":"history/2_6_0/#deprecated-features","text":"The use of the old jsonfield -based JSONField is deprecated and support for it will be dropped in dj-stripe 2.8.0. django.models.JSONField is available since Django 3.1.0. To switch to the newer JSONFields, set DJSTRIPE_USE_NATIVE_JSONFIELD to True . Set it to False to remain on the jsonfield -powered text-based fields. A manual migration is necessary to convert existing databases from text to json. The DJSTRIPE_PRORATION_POLICY setting is deprecated and will be ignored in 2.8. Specify proration_policy in the Subscription.update() method explicitly instead. Customer.can_charge() is now deprecated. This was a very misleading method which resulted in incorrect behaviour when Customers had multiple payment methods. It will be removed in dj-stripe 2.8.0. You can use Customer.payment_methods.all() instead. For similar reasons, Customer.has_valid_source() is deprecated and will be removed in dj-stripe 2.8.0. You can use Customer.sources.all() instead.","title":"Deprecated features"},{"location":"history/2_6_0/#breaking-changes","text":"Python 3.6 is no longer supported. The new minimum version of Python is 3.7.12. Django 2.2 and 3.1 are no longer supported. DJSTRIPE_USE_NATIVE_JSONFIELD now defaults to True . If you previously had it set to False , or did not have it set, you may want to explicitly set it to False in order to support a pre-existing database. A migration path will later be provided for this use case. The undocumented get_stripe_api_version() helper function has been removed. Settings for dj-stripe are now in djstripe.settings.djstripe_settings (as opposed to top-level in djstripe.settings ) Customer.subscribe() method no longer accepts positional arguments, only keywords. charge_immediately support in Customer.subscribe() has been removed (deprecated in 2.4). Set collection_method instead. The at_period_end argument to Subscription.cancel() now defaults to False , instead of the value of DJSTRIPE_PRORATION_POLICY .","title":"Breaking changes"},{"location":"history/2_6_0/#other-changes","text":"The Stripe Account that triggered an Event is now available on the field WebhookEventTrigger.stripe_trigger_account . Fixed recursive fetch/update loop errors in djstripe_sync_models . Migrations have been optimized and should be faster. dj-stripe now checks the apparent validity of API keys used and will raise InvalidStripeAPIKey if the API key looks completely incorrect. Customers can now be subscribed to multiple prices and/or plans by passing the items argument to Customer.subscribe() . Checkout Session metadata can be used to create/link a Stripe Customer to the Customer instance specified by the djstripe_settings.SUBSCRIBER_CUSTOMER_KEY .","title":"Other changes"},{"location":"history/2_x/","text":"dj-stripe 2.0 ~ 2.3 release notes 2.3.0 (2020-04-19) The minimum version of Django is now 2.1, and Python 3.6. Changed JSONField dependency back to jsonfield from jsonfield2 (see Warning about safe uninstall of jsonfield2 on upgrade ). Fixed handling of TaxRate events (#1094). Fixed pagination issue in Invoice.sync_from_stripe_data (#1052). Fixed pagination issues in Subscription & Charge .sync_from_stripe_data (#1054). Tidyup _stripe_object_set_total_tax_amounts unique handling (#1139). Dropped previously-deprecated Invoice fields (see https://stripe.com/docs/upgrades#2018-11-08 ): .closed .forgiven .billing (renamed to .collection_method ) Dropped previously-deprecated enums.InvoiceStatus (#1020). Deprecated the following fields - will be removed in 2.4 (#1087): Subscription.billing (use .collection_method instead) Subscription.start (use .start_date instead) Subscription.tax_percent (use .default_tax_rates instead) Added Invoice.status and enums.InvoiceStatus (#1020). Added new Invoice fields (#1020, #1087): .discount .default_source .status Added new Subscription fields (#1087): .default_payment_method .default_source .next_pending_invoice_item_invoice .pending_invoice_item_interval .pending_update .start_date Warning about safe uninstall of jsonfield2 on upgrade Both jsonfield and jsonfield2 use the same import path, so if upgrading from dj-stripe\\~=2.2.0 in an existing virtualenv, be sure to uninstall jsonfield2 first. eg: # ensure jsonfield is uninstalled before we install jsonfield2 pip uninstall jsonfield2 -y && pip install \"dj-stripe>=2.3.0dev\" Otherwise, pip uninstall jsonfield2 will remove jsonfield's jsonfield module from site-packages , which would cause errors like ImportError: cannot import name 'JSONField' from 'jsonfield' (unknown location) If you have hit this ImportError already after upgrading, running this should resolve it: # remove both jsonfield packages before reinstall to fix ImportError: pip uninstall jsonfield jsonfield2 -y && pip install \"dj-stripe>=2.3.0\" Note that this is only necessary if upgrading from dj-stripe 2.2.x, which temporarily depended on jsonfield2. This process is not necessary if upgrading from an earlier version of dj-stripe. 2.2.2 (2020-01-20) This is a bugfix-only version: Fixed handling of TaxRate events (#1094). 2.2.1 (2020-01-14) This is a bugfix-only version: Fixed bad package build. 2.2.0 (2020-01-13) Changed JSONField dependency package from jsonfield to jsonfield2 , for Django 3 compatibility (see Warning about safe uninstall of jsonfield on upgrade ). Note that Django 2.1 requires jsonfield<3.1. Added support for Django 3.0 (requires jsonfield2>=3.0.3). Added support for python 3.8. Refactored UpcomingInvoice , so it's no longer a subclass of Invoice (to allow Invoice to use ManyToManyFields ). Dropped previously-deprecated Account fields (see https://stripe.com/docs/upgrades#2019-02-19 ): .business_name .business_primary_color .business_url (changed to a property) .debit_negative_balances .decline_charge_on .display_name .legal_entity .payout_schedule .payout_statement_descriptor .statement_descriptor .support_email .support_phone .support_url .timezone .verification Dropped previously-deprecated Account.business_logo property (renamed to .branding_icon ) Dropped previously-deprecated Customer.account_balance property (renamed to .balance ) Dropped previously-deprecated properties Invoice.application_fee , Invoice.date Dropped previously-deprecated enum PaymentMethodType (use DjstripePaymentMethodType instead) Renamed Invoice.billing to .collection_method (added deprecated property for the old name). Updated Invoice model to add missing fields. Added TaxRate model, and Invoice.default_tax_rates , InvoiceItem.tax_rates , Invoice.total_tax_amounts , Subscription.default_tax_rates , SubscriptionItem.tax_rates (#1027). Change urls.py to use the new style urls. Update forward relation fields in the admin to be raw id fields. Updated StripeQuantumCurrencyAmountField and StripeDecimalCurrencyAmountField to support Stripe Large Charges (#1045). Update event handling so customer.subscription.deleted updates subscriptions to status=\"canceled\" instead of deleting it from our database, to match Stripe's behaviour (#599). Added missing Refund.reason value, increases field width (#1075). Fixed Refund.status definition, reduces field width (#1076). Deprecated non-standard Invoice.status (renamed to Invoice.legacy_status ) to make way for the Stripe field (preparation for #1020). Warning about safe uninstall of jsonfield on upgrade Both jsonfield and jsonfield2 use the same import path, so if upgrading to dj-stripe>=2.2 in an existing virtualenv, be sure to uninstall jsonfield first. eg: # ensure jsonfield is uninstalled before we install jsonfield2 pip uninstall jsonfield -y && pip install \"dj-stripe>=2.2.0\" Otherwise, pip uninstall jsonfield will remove jsonfield2's jsonfield module from site-packages , which would cause errors like ImportError: cannot import name 'JSONField' from 'jsonfield' (unknown location) If you have hit this ImportError already after upgrading, running this should resolve it: # remove both jsonfield packages before reinstall to fix ImportError: pip uninstall jsonfield jsonfield2 -y && pip install \"dj-stripe>=2.2.0\" Note on usage of Stripe Elements JS See Integrating Stripe Elements for notes about usage of the Stripe Elements frontend JS library. In summary: If you haven't yet migrated to PaymentIntents, prefer stripe.createSource() to stripe.createToken() . 2.1.1 (2019-10-01) This is a bugfix-only release: Updated webhook signals list (#1000). Fixed issue syncing PaymentIntent with destination charge (#960). Fixed Customer.subscription and .valid_subscriptions() to ignore status=incomplete_expired (#1006). Fixed error on paymentmethod.detached event with card_xxx payment methods (#967). Added PaymentMethod.detach() (#943). Updated help_text on all currency fields to make it clear if they're holding integer cents ( StripeQuantumCurrencyAmountField ) or decimal dollar (or euro, pound etc) ( StripeDecimalCurrencyAmountField ) (#999) Documented our preferred Django model field types (#986) Upcoming migration of currency fields (storage as cents instead of dollars) Please be aware that we're looking at standardising our currency storage fields as integer quanta (cents) instead of Decimal (dollar) values, to match stripe. This is intended to be part of the 3.0 release, since it will involve some breaking changes. See #955 for details and discussion. 2.1.0 (2019-09-12) Dropped Django 2.0 support The Python stripe library minimum version is now 2.32.0 , also 2.36.0 is excluded due to a regression (#991). Dropped previously-deprecated Charge.fee_details property. Dropped previously-deprecated Transfer.fee_details property. Dropped previously-deprecated field_name parameter to sync_from_stripe_data Dropped previously-deprecated alias StripeObject of StripeModel Dropped previously-deprecated alias PaymentMethod of DjstripePaymentMethod Dropped previously-deprecated properties Charge.source_type and Charge.source_stripe_id enums.PaymentMethodType has been deprecated, use enums.DjstripePaymentMethodType Made SubscriptionItem.quantity nullable as per Plans with usage_type=\"metered\" (follow-up to #865) Added manage commands djstripe_sync_models and djstripe_process_events (#727, #89) Fixed issue with re-creating a customer after Customer.purge() (#916) Fixed sync of Customer Bank Accounts (#829) Fixed Subscription.is_status_temporarily_current() (#852) New models Payment Intent Setup Intent Payment Method Session Added fields to Customer model: address , invoice_prefix , invoice_settings , phone , preferred_locales , tax_exempt Changes from API 2018-11-08: Added Invoice.auto_advance , deprecated Invoice.closed and Invoice.forgiven , see https://stripe.com/docs/billing/migration/invoice-states#upgrade-checklist Changes from API 2019-02-19: Major changes to Account fields, see https://stripe.com/docs/upgrades#2019-02-19 , updated Account fields to match API 2019-02-19: Added Account.business_profile , .business_type , .company , .individual , .requirements , .settings Deprecated the existing fields, to be removed in 2.2 Special handling of the icon and logo fields: > - Renamed Account.business_logo to Account.branding_icon > (note that in Stripe's API Account.business_logo was renamed > to Account.settings.branding_icon , and > Account.business_logo_large (which we didn't have a field > for) was renamed to Account.settings.branding_logo ) > - Added deprecated property for Account.business_logo > - Added Account.branding_logo as a ForeignKey > - Populate Account.branding_icon and .branding_logo from the > new Account.settings.branding.icon and .logo Changes from API 2019-03-14: Renamed Invoice.application_fee to Invoice.application_fee_amount (added deprecated property for the old name) Removed Invoice.date , in place of Invoice.created (added deprecated property for the old name) Added Invoice.status_transitions Renamed Customer.account_balance to Customer.balance (added deprecated property for the old name) Renamed Customer.payment_methods to Customer.customer_payment_methods Added new SubscriptionStatus.incomplete and SubscriptionStatus.incomplete_expired statuses (#974) Added new BalanceTransactionType values (#983) Squashed dev migrations As per our migration policy , unreleased migrations on the master branch have been squashed. If you have been using the 2.1.0dev branch from master, you'll need to run the squashed migrations migrations before upgrading to >=2.1.0. The simplest way to do this is to pip install dj-stripe==2.1.0rc0 and migrate, alternatively check out the 2.1.0rc0 git tag. 2.0.5 (2019-09-12) This is a bugfix-only version: Avoid stripe==2.36.0 due to regression (#991) 2.0.4 (2019-09-09) This is a bugfix-only version: Fixed irreversible migration (#909) 2.0.3 (2019-06-11) This is a bugfix-only version: In _get_or_create_from_stripe_object , wrap create _create_from_stripe_object in transaction, fixes TransactionManagementError on race condition in webhook processing (#877, #903). 2.0.2 (2019-06-09) This is a bugfix-only version: Don't save event objects if the webhook processing fails (#832). Fixed IntegrityError when REMOTE_ADDR is an empty string. Deprecated field_name parameter to sync_from_stripe_data 2.0.1 (2019-04-29) This is a bugfix-only version: Fixed an error on invoiceitem.updated (#848). Handle test webhook properly in recent versions of Stripe API (#779). At some point 2018 Stripe silently changed the ID used for test events and evt_00000000000000 is not used anymore. Fixed OperationalError seen in migration 0003 on postgres (#850). Fixed issue with migration 0003 not being unapplied correctly (#882). Fixed missing SubscriptionItem.quantity on metered Plans (#865). Fixed Plan.create() (#870). 2.0.0 (2019-03-01) The Python stripe library minimum version is now 2.3.0 . PaymentMethod has been renamed to DjstripePaymentMethod (#841). An alias remains but will be removed in the next version. Dropped support for Django<2.0, Python<3.4. Dropped previously-deprecated stripe_objects module. Dropped previously-deprecated stripe_timestamp field. Dropped previously-deprecated Charge.receipt_number field. Dropped previously-deprecated StripeSource alias for Card Dropped previously-deprecated SubscriptionView , CancelSubscriptionView and CancelSubscriptionForm . Removed the default value from DJSTRIPE_SUBSCRIPTION_REDIRECT . All stripe_id fields have been renamed id . Charge.source_type has been deprecated. Use Charge.source.type . Charge.source_stripe_id has been deprecated. Use Charge.source.id . All deprecated Transfer fields (Stripe API 2017-04-06 and older), have been dropped. This includes date , destination_type ( type ), failure_code , failure_message , statement_descriptor and status . Fixed IntegrityError when REMOTE_ADDR is missing (#640). New models: ApplicationFee ApplicationFeeRefund BalanceTransaction CountrySpec ScheduledQuery SubscriptionItem TransferReversal UsageRecord The fee and fee_details attributes of both the Charge and Transfer objects are no longer stored in the database. Instead, they access their respective new balance_transaction foreign key. Note that fee_details has been deprecated on both models. The fraudulent attribute on Charge is now a property that checks the fraud_details field. Object key validity is now always enforced (#503). Customer.sources no longer refers to a Card queryset, but to a Source queryset. In order to correctly transition, you should change all your references to customer.sources to customer.legacy_cards instead. The legacy_cards attribute already exists in 1.2.0. Customer.sources_v3 is now named Customer.sources . A new property Customer.payment_methods is now available, which allows you to iterate over all of a customer's payment methods (sources then cards). Card.customer is now nullable and cards are no longer deleted when their corresponding customer is deleted (#654). Webhook signature verification is now available and is preferred. Set the DJSTRIPE_WEBHOOK_SECRET setting to your secret to start using it. StripeObject has been renamed StripeModel . An alias remains but will be removed in the next version. The metadata key used in the Customer object can now be configured by changing the DJSTRIPE_SUBSCRIBER_CUSTOMER_KEY setting. Setting this to None or an empty string now also disables the behaviour altogether. Text-type fields in dj-stripe will no longer ever be None. Instead, any falsy text field will return an empty string. Switched test runner to pytest-django StripeModel.sync_from_stripe_data() will now automatically retrieve related objects and populate foreign keys (#681) Added Coupon.name Added Transfer.balance_transaction Exceptions in webhooks are now re-raised as well as saved in the database (#833)","title":"dj-stripe 2.0 ~ 2.3 release notes"},{"location":"history/2_x/#dj-stripe-20-23-release-notes","text":"","title":"dj-stripe 2.0 ~ 2.3 release notes"},{"location":"history/2_x/#230-2020-04-19","text":"The minimum version of Django is now 2.1, and Python 3.6. Changed JSONField dependency back to jsonfield from jsonfield2 (see Warning about safe uninstall of jsonfield2 on upgrade ). Fixed handling of TaxRate events (#1094). Fixed pagination issue in Invoice.sync_from_stripe_data (#1052). Fixed pagination issues in Subscription & Charge .sync_from_stripe_data (#1054). Tidyup _stripe_object_set_total_tax_amounts unique handling (#1139). Dropped previously-deprecated Invoice fields (see https://stripe.com/docs/upgrades#2018-11-08 ): .closed .forgiven .billing (renamed to .collection_method ) Dropped previously-deprecated enums.InvoiceStatus (#1020). Deprecated the following fields - will be removed in 2.4 (#1087): Subscription.billing (use .collection_method instead) Subscription.start (use .start_date instead) Subscription.tax_percent (use .default_tax_rates instead) Added Invoice.status and enums.InvoiceStatus (#1020). Added new Invoice fields (#1020, #1087): .discount .default_source .status Added new Subscription fields (#1087): .default_payment_method .default_source .next_pending_invoice_item_invoice .pending_invoice_item_interval .pending_update .start_date","title":"2.3.0 (2020-04-19)"},{"location":"history/2_x/#warning-about-safe-uninstall-of-jsonfield2-on-upgrade","text":"Both jsonfield and jsonfield2 use the same import path, so if upgrading from dj-stripe\\~=2.2.0 in an existing virtualenv, be sure to uninstall jsonfield2 first. eg: # ensure jsonfield is uninstalled before we install jsonfield2 pip uninstall jsonfield2 -y && pip install \"dj-stripe>=2.3.0dev\" Otherwise, pip uninstall jsonfield2 will remove jsonfield's jsonfield module from site-packages , which would cause errors like ImportError: cannot import name 'JSONField' from 'jsonfield' (unknown location) If you have hit this ImportError already after upgrading, running this should resolve it: # remove both jsonfield packages before reinstall to fix ImportError: pip uninstall jsonfield jsonfield2 -y && pip install \"dj-stripe>=2.3.0\" Note that this is only necessary if upgrading from dj-stripe 2.2.x, which temporarily depended on jsonfield2. This process is not necessary if upgrading from an earlier version of dj-stripe.","title":"Warning about safe uninstall of jsonfield2 on upgrade"},{"location":"history/2_x/#222-2020-01-20","text":"This is a bugfix-only version: Fixed handling of TaxRate events (#1094).","title":"2.2.2 (2020-01-20)"},{"location":"history/2_x/#221-2020-01-14","text":"This is a bugfix-only version: Fixed bad package build.","title":"2.2.1 (2020-01-14)"},{"location":"history/2_x/#220-2020-01-13","text":"Changed JSONField dependency package from jsonfield to jsonfield2 , for Django 3 compatibility (see Warning about safe uninstall of jsonfield on upgrade ). Note that Django 2.1 requires jsonfield<3.1. Added support for Django 3.0 (requires jsonfield2>=3.0.3). Added support for python 3.8. Refactored UpcomingInvoice , so it's no longer a subclass of Invoice (to allow Invoice to use ManyToManyFields ). Dropped previously-deprecated Account fields (see https://stripe.com/docs/upgrades#2019-02-19 ): .business_name .business_primary_color .business_url (changed to a property) .debit_negative_balances .decline_charge_on .display_name .legal_entity .payout_schedule .payout_statement_descriptor .statement_descriptor .support_email .support_phone .support_url .timezone .verification Dropped previously-deprecated Account.business_logo property (renamed to .branding_icon ) Dropped previously-deprecated Customer.account_balance property (renamed to .balance ) Dropped previously-deprecated properties Invoice.application_fee , Invoice.date Dropped previously-deprecated enum PaymentMethodType (use DjstripePaymentMethodType instead) Renamed Invoice.billing to .collection_method (added deprecated property for the old name). Updated Invoice model to add missing fields. Added TaxRate model, and Invoice.default_tax_rates , InvoiceItem.tax_rates , Invoice.total_tax_amounts , Subscription.default_tax_rates , SubscriptionItem.tax_rates (#1027). Change urls.py to use the new style urls. Update forward relation fields in the admin to be raw id fields. Updated StripeQuantumCurrencyAmountField and StripeDecimalCurrencyAmountField to support Stripe Large Charges (#1045). Update event handling so customer.subscription.deleted updates subscriptions to status=\"canceled\" instead of deleting it from our database, to match Stripe's behaviour (#599). Added missing Refund.reason value, increases field width (#1075). Fixed Refund.status definition, reduces field width (#1076). Deprecated non-standard Invoice.status (renamed to Invoice.legacy_status ) to make way for the Stripe field (preparation for #1020).","title":"2.2.0 (2020-01-13)"},{"location":"history/2_x/#warning-about-safe-uninstall-of-jsonfield-on-upgrade","text":"Both jsonfield and jsonfield2 use the same import path, so if upgrading to dj-stripe>=2.2 in an existing virtualenv, be sure to uninstall jsonfield first. eg: # ensure jsonfield is uninstalled before we install jsonfield2 pip uninstall jsonfield -y && pip install \"dj-stripe>=2.2.0\" Otherwise, pip uninstall jsonfield will remove jsonfield2's jsonfield module from site-packages , which would cause errors like ImportError: cannot import name 'JSONField' from 'jsonfield' (unknown location) If you have hit this ImportError already after upgrading, running this should resolve it: # remove both jsonfield packages before reinstall to fix ImportError: pip uninstall jsonfield jsonfield2 -y && pip install \"dj-stripe>=2.2.0\"","title":"Warning about safe uninstall of jsonfield on upgrade"},{"location":"history/2_x/#note-on-usage-of-stripe-elements-js","text":"See Integrating Stripe Elements for notes about usage of the Stripe Elements frontend JS library. In summary: If you haven't yet migrated to PaymentIntents, prefer stripe.createSource() to stripe.createToken() .","title":"Note on usage of Stripe Elements JS"},{"location":"history/2_x/#211-2019-10-01","text":"This is a bugfix-only release: Updated webhook signals list (#1000). Fixed issue syncing PaymentIntent with destination charge (#960). Fixed Customer.subscription and .valid_subscriptions() to ignore status=incomplete_expired (#1006). Fixed error on paymentmethod.detached event with card_xxx payment methods (#967). Added PaymentMethod.detach() (#943). Updated help_text on all currency fields to make it clear if they're holding integer cents ( StripeQuantumCurrencyAmountField ) or decimal dollar (or euro, pound etc) ( StripeDecimalCurrencyAmountField ) (#999) Documented our preferred Django model field types (#986)","title":"2.1.1 (2019-10-01)"},{"location":"history/2_x/#upcoming-migration-of-currency-fields-storage-as-cents-instead-of-dollars","text":"Please be aware that we're looking at standardising our currency storage fields as integer quanta (cents) instead of Decimal (dollar) values, to match stripe. This is intended to be part of the 3.0 release, since it will involve some breaking changes. See #955 for details and discussion.","title":"Upcoming migration of currency fields (storage as cents instead of dollars)"},{"location":"history/2_x/#210-2019-09-12","text":"Dropped Django 2.0 support The Python stripe library minimum version is now 2.32.0 , also 2.36.0 is excluded due to a regression (#991). Dropped previously-deprecated Charge.fee_details property. Dropped previously-deprecated Transfer.fee_details property. Dropped previously-deprecated field_name parameter to sync_from_stripe_data Dropped previously-deprecated alias StripeObject of StripeModel Dropped previously-deprecated alias PaymentMethod of DjstripePaymentMethod Dropped previously-deprecated properties Charge.source_type and Charge.source_stripe_id enums.PaymentMethodType has been deprecated, use enums.DjstripePaymentMethodType Made SubscriptionItem.quantity nullable as per Plans with usage_type=\"metered\" (follow-up to #865) Added manage commands djstripe_sync_models and djstripe_process_events (#727, #89) Fixed issue with re-creating a customer after Customer.purge() (#916) Fixed sync of Customer Bank Accounts (#829) Fixed Subscription.is_status_temporarily_current() (#852) New models Payment Intent Setup Intent Payment Method Session Added fields to Customer model: address , invoice_prefix , invoice_settings , phone , preferred_locales , tax_exempt Changes from API 2018-11-08: Added Invoice.auto_advance , deprecated Invoice.closed and Invoice.forgiven , see https://stripe.com/docs/billing/migration/invoice-states#upgrade-checklist Changes from API 2019-02-19: Major changes to Account fields, see https://stripe.com/docs/upgrades#2019-02-19 , updated Account fields to match API 2019-02-19: Added Account.business_profile , .business_type , .company , .individual , .requirements , .settings Deprecated the existing fields, to be removed in 2.2 Special handling of the icon and logo fields: > - Renamed Account.business_logo to Account.branding_icon > (note that in Stripe's API Account.business_logo was renamed > to Account.settings.branding_icon , and > Account.business_logo_large (which we didn't have a field > for) was renamed to Account.settings.branding_logo ) > - Added deprecated property for Account.business_logo > - Added Account.branding_logo as a ForeignKey > - Populate Account.branding_icon and .branding_logo from the > new Account.settings.branding.icon and .logo Changes from API 2019-03-14: Renamed Invoice.application_fee to Invoice.application_fee_amount (added deprecated property for the old name) Removed Invoice.date , in place of Invoice.created (added deprecated property for the old name) Added Invoice.status_transitions Renamed Customer.account_balance to Customer.balance (added deprecated property for the old name) Renamed Customer.payment_methods to Customer.customer_payment_methods Added new SubscriptionStatus.incomplete and SubscriptionStatus.incomplete_expired statuses (#974) Added new BalanceTransactionType values (#983)","title":"2.1.0 (2019-09-12)"},{"location":"history/2_x/#squashed-dev-migrations","text":"As per our migration policy , unreleased migrations on the master branch have been squashed. If you have been using the 2.1.0dev branch from master, you'll need to run the squashed migrations migrations before upgrading to >=2.1.0. The simplest way to do this is to pip install dj-stripe==2.1.0rc0 and migrate, alternatively check out the 2.1.0rc0 git tag.","title":"Squashed dev migrations"},{"location":"history/2_x/#205-2019-09-12","text":"This is a bugfix-only version: Avoid stripe==2.36.0 due to regression (#991)","title":"2.0.5 (2019-09-12)"},{"location":"history/2_x/#204-2019-09-09","text":"This is a bugfix-only version: Fixed irreversible migration (#909)","title":"2.0.4 (2019-09-09)"},{"location":"history/2_x/#203-2019-06-11","text":"This is a bugfix-only version: In _get_or_create_from_stripe_object , wrap create _create_from_stripe_object in transaction, fixes TransactionManagementError on race condition in webhook processing (#877, #903).","title":"2.0.3 (2019-06-11)"},{"location":"history/2_x/#202-2019-06-09","text":"This is a bugfix-only version: Don't save event objects if the webhook processing fails (#832). Fixed IntegrityError when REMOTE_ADDR is an empty string. Deprecated field_name parameter to sync_from_stripe_data","title":"2.0.2 (2019-06-09)"},{"location":"history/2_x/#201-2019-04-29","text":"This is a bugfix-only version: Fixed an error on invoiceitem.updated (#848). Handle test webhook properly in recent versions of Stripe API (#779). At some point 2018 Stripe silently changed the ID used for test events and evt_00000000000000 is not used anymore. Fixed OperationalError seen in migration 0003 on postgres (#850). Fixed issue with migration 0003 not being unapplied correctly (#882). Fixed missing SubscriptionItem.quantity on metered Plans (#865). Fixed Plan.create() (#870).","title":"2.0.1 (2019-04-29)"},{"location":"history/2_x/#200-2019-03-01","text":"The Python stripe library minimum version is now 2.3.0 . PaymentMethod has been renamed to DjstripePaymentMethod (#841). An alias remains but will be removed in the next version. Dropped support for Django<2.0, Python<3.4. Dropped previously-deprecated stripe_objects module. Dropped previously-deprecated stripe_timestamp field. Dropped previously-deprecated Charge.receipt_number field. Dropped previously-deprecated StripeSource alias for Card Dropped previously-deprecated SubscriptionView , CancelSubscriptionView and CancelSubscriptionForm . Removed the default value from DJSTRIPE_SUBSCRIPTION_REDIRECT . All stripe_id fields have been renamed id . Charge.source_type has been deprecated. Use Charge.source.type . Charge.source_stripe_id has been deprecated. Use Charge.source.id . All deprecated Transfer fields (Stripe API 2017-04-06 and older), have been dropped. This includes date , destination_type ( type ), failure_code , failure_message , statement_descriptor and status . Fixed IntegrityError when REMOTE_ADDR is missing (#640). New models: ApplicationFee ApplicationFeeRefund BalanceTransaction CountrySpec ScheduledQuery SubscriptionItem TransferReversal UsageRecord The fee and fee_details attributes of both the Charge and Transfer objects are no longer stored in the database. Instead, they access their respective new balance_transaction foreign key. Note that fee_details has been deprecated on both models. The fraudulent attribute on Charge is now a property that checks the fraud_details field. Object key validity is now always enforced (#503). Customer.sources no longer refers to a Card queryset, but to a Source queryset. In order to correctly transition, you should change all your references to customer.sources to customer.legacy_cards instead. The legacy_cards attribute already exists in 1.2.0. Customer.sources_v3 is now named Customer.sources . A new property Customer.payment_methods is now available, which allows you to iterate over all of a customer's payment methods (sources then cards). Card.customer is now nullable and cards are no longer deleted when their corresponding customer is deleted (#654). Webhook signature verification is now available and is preferred. Set the DJSTRIPE_WEBHOOK_SECRET setting to your secret to start using it. StripeObject has been renamed StripeModel . An alias remains but will be removed in the next version. The metadata key used in the Customer object can now be configured by changing the DJSTRIPE_SUBSCRIBER_CUSTOMER_KEY setting. Setting this to None or an empty string now also disables the behaviour altogether. Text-type fields in dj-stripe will no longer ever be None. Instead, any falsy text field will return an empty string. Switched test runner to pytest-django StripeModel.sync_from_stripe_data() will now automatically retrieve related objects and populate foreign keys (#681) Added Coupon.name Added Transfer.balance_transaction Exceptions in webhooks are now re-raised as well as saved in the database (#833)","title":"2.0.0 (2019-03-01)"},{"location":"project/authors/","text":"Credits Maintainers Alexander Kavanaugh Jerome Leclanche Major Contributors John Carter Pablo Castellano Daniel Greenfeld Lee Skillen Contributors dj-stripe is brought to you by many more open source contributors. See the complete list on Github .","title":"Credits"},{"location":"project/authors/#credits","text":"","title":"Credits"},{"location":"project/authors/#maintainers","text":"Alexander Kavanaugh Jerome Leclanche","title":"Maintainers"},{"location":"project/authors/#major-contributors","text":"John Carter Pablo Castellano Daniel Greenfeld Lee Skillen","title":"Major Contributors"},{"location":"project/authors/#contributors","text":"dj-stripe is brought to you by many more open source contributors. See the complete list on Github .","title":"Contributors"},{"location":"project/contributing/","text":"Contributing Contributions are welcome, and they are greatly appreciated! Every little bit helps, and credit will always be given. You can contribute in many ways: Types of Contributions Report Bugs Report bugs at https://github.com/dj-stripe/dj-stripe/issues . If you are reporting a bug, please include: The version of python and Django you're running Detailed steps to reproduce the bug. Fix Bugs Look through the GitHub issues for bugs. Anything tagged with \"bug\" is open to whoever wants to implement it. Implement Features Look through the GitHub issues for features. Anything tagged with \"feature\" is open to whoever wants to implement it. Write Documentation dj-stripe could always use more documentation, whether as part of the official dj-stripe docs, in docstrings, or even on the web in blog posts, articles, and such. To see the project's documentation live, run the following command: mkdocs serve The documentation site will then be served on http://127.0.0.1:8000 . In case of any installation error In case you get the error that some plugin is not installed, please run: poetry install -E docs If you wish to just generate the documentation, you can replace serve with build , and the docs will be generated into the site/ folder. Submit Feedback The best way to send feedback is to file an issue at https://github.com/dj-stripe/dj-stripe/issues . If you are proposing a feature: Explain in detail how it would work. Keep the scope as narrow as possible, to make it easier to implement. Remember that this is a volunteer-driven project, and that contributions are welcome :) Contributor Discussion For questions regarding contributions to dj-stripe, another avenue is our Discord channel at https://discord.gg/UJY8fcc . Get Started! Ready to contribute? Here's how to set up local development. Fork dj-stripe on Github . Clone your fork locally: $ git clone git@github.com:your_name_here/dj-stripe.git Set up pre-commit : $ git init # A git repo is required to install pre-commit $ pre-commit install Set up your test database. If you're running tests using PostgreSQL: $ createdb djstripe or if you want to test vs sqlite (for convenience) or MySQL, they can be selected by setting this environment variable: $ export DJSTRIPE_TEST_DB_VENDOR = sqlite # or: export DJSTRIPE_TEST_DB_VENDOR=mysql For postgres and mysql, the database host,port,username and password can be set with environment variables, see tests/settings.py Install Poetry if you do not have it already. You can set up a virtual environment with: $ poetry install You can then, at any time, open a shell into that environment with: $ poetry shell When you're done making changes, check that your changes pass the tests. A quick test run can be done as follows: $ DJSTRIPE_TEST_DB_VENDOR = sqlite poetry run pytest --reuse-db You should also check that the tests pass with other python and Django versions with tox. pytest will output both command line and html coverage statistics and will warn you if your changes caused code coverage to drop.: $ pip install tox $ tox If your changes altered the models you may need to generate Django migrations: $ DJSTRIPE_TEST_DB_VENDOR = sqlite poetry run ./manage.py makemigrations Commit your changes and push your branch to GitHub: $ git add . $ git commit -m \"Your detailed description of your changes.\" $ git push Submit a pull request through the GitHub website. Congratulations, you're now a dj-stripe contributor! Have some \u2665 from us. Preferred Django Model Field Types When mapping from Stripe API field types to Django model fields, we try to follow Django best practises where practical. The following types should be preferred for fields that map to the Stripe API (which is almost all fields in our models). Strings Stripe API string fields have a default maximum length of 5,000 characters . In some cases a maximum length ( maxLength ) is specified in the Stripe OpenAPI schema . We follow Django's recommendation and avoid using null on string fields (which means we store \"\" for string fields that are null in stripe). Note that is enforced in the sync logic in StripeModel._stripe_object_to_record . For long string fields (eg above 255 characters) we prefer TextField over Charfield . Therefore the default type for string fields that don't have a maxLength specified in the Stripe OpenAPI schema should usually be: str_field = TextField(max_length=5000, default=\", blank=True, help_text=\"...\") Enumerations Fields that have a defined set of values can be implemented using StripeEnumField . Hash (dictionaries) Use the JSONField in djstripe.fields . Currency amounts Stripe handles all currency amounts as integer cents, we currently have a mixture of fields as integer cents and decimal (eg dollar, euro etc) values, but we are aiming to standardise on cents (see https://github.com/dj-stripe/dj-stripe/issues/955 ). All new currency amount fields should use StripeQuantumCurrencyAmountField . Dates and Datetimes The Stripe API uses an integer timestamp (seconds since the Unix epoch) for dates and datetimes. We store this as a datetime field, using StripeDateTimeField . Django Migration Policy Migrations are considered a breaking change, so it's not usually not acceptable to add a migration to a stable branch, it will be a new MAJOR.MINOR.0 release. A workaround to this in the case that the Stripe API data isn't compatible with out model (eg Stripe is sending null to a non-null field) is to implement the _manipulate_stripe_object_hook classmethod on the model. Avoid new migrations with non-schema changes If a code change produces a migration that doesn't alter the database schema (eg changing help_text ) then instead of adding a new migration you can edit the most recent migration that affects the field in question. e.g.: https://github.com/dj-stripe/dj-stripe/commit/e2762c38918a90f00c42ecf21187a920bd3a2087 Pull Request Guidelines Before you submit a pull request, check that it meets these guidelines: The pull request should include tests. The pull request must not drop code coverage below the current level. If the pull request adds functionality, the docs should be updated. Put your new functionality into a function with a docstring. If the pull request makes changes to a model, include Django migrations. The pull request should work for Python 3.6+. Check Github Actions and make sure that the tests pass for all supported Python versions. Code formatting: Make sure to install pre-commit to automatically run it on staged files or run manually with pre-commit run --all-files at the dj-stripe root to keep a consistent style.","title":"Contributing"},{"location":"project/contributing/#contributing","text":"Contributions are welcome, and they are greatly appreciated! Every little bit helps, and credit will always be given. You can contribute in many ways:","title":"Contributing"},{"location":"project/contributing/#types-of-contributions","text":"","title":"Types of Contributions"},{"location":"project/contributing/#report-bugs","text":"Report bugs at https://github.com/dj-stripe/dj-stripe/issues . If you are reporting a bug, please include: The version of python and Django you're running Detailed steps to reproduce the bug.","title":"Report Bugs"},{"location":"project/contributing/#fix-bugs","text":"Look through the GitHub issues for bugs. Anything tagged with \"bug\" is open to whoever wants to implement it.","title":"Fix Bugs"},{"location":"project/contributing/#implement-features","text":"Look through the GitHub issues for features. Anything tagged with \"feature\" is open to whoever wants to implement it.","title":"Implement Features"},{"location":"project/contributing/#write-documentation","text":"dj-stripe could always use more documentation, whether as part of the official dj-stripe docs, in docstrings, or even on the web in blog posts, articles, and such. To see the project's documentation live, run the following command: mkdocs serve The documentation site will then be served on http://127.0.0.1:8000 . In case of any installation error In case you get the error that some plugin is not installed, please run: poetry install -E docs If you wish to just generate the documentation, you can replace serve with build , and the docs will be generated into the site/ folder.","title":"Write Documentation"},{"location":"project/contributing/#submit-feedback","text":"The best way to send feedback is to file an issue at https://github.com/dj-stripe/dj-stripe/issues . If you are proposing a feature: Explain in detail how it would work. Keep the scope as narrow as possible, to make it easier to implement. Remember that this is a volunteer-driven project, and that contributions are welcome :)","title":"Submit Feedback"},{"location":"project/contributing/#contributor-discussion","text":"For questions regarding contributions to dj-stripe, another avenue is our Discord channel at https://discord.gg/UJY8fcc .","title":"Contributor Discussion"},{"location":"project/contributing/#get-started","text":"Ready to contribute? Here's how to set up local development. Fork dj-stripe on Github . Clone your fork locally: $ git clone git@github.com:your_name_here/dj-stripe.git Set up pre-commit : $ git init # A git repo is required to install pre-commit $ pre-commit install Set up your test database. If you're running tests using PostgreSQL: $ createdb djstripe or if you want to test vs sqlite (for convenience) or MySQL, they can be selected by setting this environment variable: $ export DJSTRIPE_TEST_DB_VENDOR = sqlite # or: export DJSTRIPE_TEST_DB_VENDOR=mysql For postgres and mysql, the database host,port,username and password can be set with environment variables, see tests/settings.py Install Poetry if you do not have it already. You can set up a virtual environment with: $ poetry install You can then, at any time, open a shell into that environment with: $ poetry shell When you're done making changes, check that your changes pass the tests. A quick test run can be done as follows: $ DJSTRIPE_TEST_DB_VENDOR = sqlite poetry run pytest --reuse-db You should also check that the tests pass with other python and Django versions with tox. pytest will output both command line and html coverage statistics and will warn you if your changes caused code coverage to drop.: $ pip install tox $ tox If your changes altered the models you may need to generate Django migrations: $ DJSTRIPE_TEST_DB_VENDOR = sqlite poetry run ./manage.py makemigrations Commit your changes and push your branch to GitHub: $ git add . $ git commit -m \"Your detailed description of your changes.\" $ git push Submit a pull request through the GitHub website. Congratulations, you're now a dj-stripe contributor! Have some \u2665 from us.","title":"Get Started!"},{"location":"project/contributing/#preferred-django-model-field-types","text":"When mapping from Stripe API field types to Django model fields, we try to follow Django best practises where practical. The following types should be preferred for fields that map to the Stripe API (which is almost all fields in our models).","title":"Preferred Django Model Field Types"},{"location":"project/contributing/#strings","text":"Stripe API string fields have a default maximum length of 5,000 characters . In some cases a maximum length ( maxLength ) is specified in the Stripe OpenAPI schema . We follow Django's recommendation and avoid using null on string fields (which means we store \"\" for string fields that are null in stripe). Note that is enforced in the sync logic in StripeModel._stripe_object_to_record . For long string fields (eg above 255 characters) we prefer TextField over Charfield . Therefore the default type for string fields that don't have a maxLength specified in the Stripe OpenAPI schema should usually be: str_field = TextField(max_length=5000, default=\", blank=True, help_text=\"...\")","title":"Strings"},{"location":"project/contributing/#enumerations","text":"Fields that have a defined set of values can be implemented using StripeEnumField .","title":"Enumerations"},{"location":"project/contributing/#hash-dictionaries","text":"Use the JSONField in djstripe.fields .","title":"Hash (dictionaries)"},{"location":"project/contributing/#currency-amounts","text":"Stripe handles all currency amounts as integer cents, we currently have a mixture of fields as integer cents and decimal (eg dollar, euro etc) values, but we are aiming to standardise on cents (see https://github.com/dj-stripe/dj-stripe/issues/955 ). All new currency amount fields should use StripeQuantumCurrencyAmountField .","title":"Currency amounts"},{"location":"project/contributing/#dates-and-datetimes","text":"The Stripe API uses an integer timestamp (seconds since the Unix epoch) for dates and datetimes. We store this as a datetime field, using StripeDateTimeField .","title":"Dates and Datetimes"},{"location":"project/contributing/#django-migration-policy","text":"Migrations are considered a breaking change, so it's not usually not acceptable to add a migration to a stable branch, it will be a new MAJOR.MINOR.0 release. A workaround to this in the case that the Stripe API data isn't compatible with out model (eg Stripe is sending null to a non-null field) is to implement the _manipulate_stripe_object_hook classmethod on the model.","title":"Django Migration Policy"},{"location":"project/contributing/#avoid-new-migrations-with-non-schema-changes","text":"If a code change produces a migration that doesn't alter the database schema (eg changing help_text ) then instead of adding a new migration you can edit the most recent migration that affects the field in question. e.g.: https://github.com/dj-stripe/dj-stripe/commit/e2762c38918a90f00c42ecf21187a920bd3a2087","title":"Avoid new migrations with non-schema changes"},{"location":"project/contributing/#pull-request-guidelines","text":"Before you submit a pull request, check that it meets these guidelines: The pull request should include tests. The pull request must not drop code coverage below the current level. If the pull request adds functionality, the docs should be updated. Put your new functionality into a function with a docstring. If the pull request makes changes to a model, include Django migrations. The pull request should work for Python 3.6+. Check Github Actions and make sure that the tests pass for all supported Python versions. Code formatting: Make sure to install pre-commit to automatically run it on staged files or run manually with pre-commit run --all-files at the dj-stripe root to keep a consistent style.","title":"Pull Request Guidelines"},{"location":"project/release_process/","text":"Release Process Note Before MAJOR or MINOR releases: Review deprecation notes (eg search for \"deprecated\") and remove deprecated features as appropriate Squash migrations (ONLY on unreleased migrations) - see below Squash migrations If there's more than one unreleased migration on master consider squashing them with squashmigrations , immediately before tagging the new release: Create a new squashed migration with ./manage.py squashmigrations (only squash migrations that have never been in a tagged release) Commit the squashed migration on master with a commit message like \"Squash x.y.0dev migrations\" (this will allow users who running master to safely upgrade, see note below about rc package) Then transition the squashed migration to a normal migration as per Django: Delete all the migration files it replaces Update all migrations that depend on the deleted migrations to depend on the squashed migration instead Remove the replaces attribute in the Migration class of the squashed migration (this is how Django tells that it is a squashed migration) Commit these changes to master with a message like \"Transition squashed migration to normal migration\" Then do the normal release process - bump version as another commit and tag the release See https://docs.djangoproject.com/en/dev/topics/migrations/#migration-squashing Tag + package squashed migrations as rc package (optional) As a convenience to users who are running master, an rc version can be created to package the squashed migration. To do this, immediately after the \"Squash x.y.0dev migrations\" commit, follow the steps below but with a x.y.0rc0 version to tag and package a rc version. Users who have been using the x.y.0dev code from master can then run the squashed migrations migrations before upgrading to >=x.y.0. The simplest way to do this is to pip install dj-stripe==x.y.0rc0 and migrate, or alternatively check out the x.y.0rc0 git tag and migrate. Prepare changes for the release commit Choose your version number (using https://semver.org/ ) if there's a new migration, it should be a MAJOR.0.0 or MAJOR.MINOR.0 version. Review and update HISTORY.md Add a section for this release version Set date on this release version Check that summary of feature/fixes is since the last release is up to date Update package version number in setup.cfg Review and update supported API version in README.md (this is the most recent Stripe account version tested against, not DEFAULT_STRIPE_API_VERSION ) git add to stage these changes Create signed release commit tag Note Before doing this you should have a GPG key set up on github If you don't have a GPG key already, one method is via https://keybase.io/ , and then add it to your github profile. Create a release tag with the above staged changes (where $VERSION is the version number to be released: $ git commit -m \"Release $VERSION \" $ git tag -fsm \"Release $VERSION \" $VERSION This can be expressed as a bash function as follows: git_release() { git commit -m \"Release $1\" && git tag -fsm \"Release $1\" $1; } Push the commit and tag: $ git push --follow-tags Update/create stable branch Push these changes to the appropriate stable/MAJOR.MINOR version branch (eg stable/2.0 ) if they're not already - note that this will trigger the readthedocs build Release on pypi See https://packaging.python.org/tutorials/packaging-projects/#generating-distribution-archives","title":"Release Process"},{"location":"project/release_process/#release-process","text":"Note Before MAJOR or MINOR releases: Review deprecation notes (eg search for \"deprecated\") and remove deprecated features as appropriate Squash migrations (ONLY on unreleased migrations) - see below","title":"Release Process"},{"location":"project/release_process/#squash-migrations","text":"If there's more than one unreleased migration on master consider squashing them with squashmigrations , immediately before tagging the new release: Create a new squashed migration with ./manage.py squashmigrations (only squash migrations that have never been in a tagged release) Commit the squashed migration on master with a commit message like \"Squash x.y.0dev migrations\" (this will allow users who running master to safely upgrade, see note below about rc package) Then transition the squashed migration to a normal migration as per Django: Delete all the migration files it replaces Update all migrations that depend on the deleted migrations to depend on the squashed migration instead Remove the replaces attribute in the Migration class of the squashed migration (this is how Django tells that it is a squashed migration) Commit these changes to master with a message like \"Transition squashed migration to normal migration\" Then do the normal release process - bump version as another commit and tag the release See https://docs.djangoproject.com/en/dev/topics/migrations/#migration-squashing","title":"Squash migrations"},{"location":"project/release_process/#tag-package-squashed-migrations-as-rc-package-optional","text":"As a convenience to users who are running master, an rc version can be created to package the squashed migration. To do this, immediately after the \"Squash x.y.0dev migrations\" commit, follow the steps below but with a x.y.0rc0 version to tag and package a rc version. Users who have been using the x.y.0dev code from master can then run the squashed migrations migrations before upgrading to >=x.y.0. The simplest way to do this is to pip install dj-stripe==x.y.0rc0 and migrate, or alternatively check out the x.y.0rc0 git tag and migrate.","title":"Tag + package squashed migrations as rc package (optional)"},{"location":"project/release_process/#prepare-changes-for-the-release-commit","text":"Choose your version number (using https://semver.org/ ) if there's a new migration, it should be a MAJOR.0.0 or MAJOR.MINOR.0 version. Review and update HISTORY.md Add a section for this release version Set date on this release version Check that summary of feature/fixes is since the last release is up to date Update package version number in setup.cfg Review and update supported API version in README.md (this is the most recent Stripe account version tested against, not DEFAULT_STRIPE_API_VERSION ) git add to stage these changes","title":"Prepare changes for the release commit"},{"location":"project/release_process/#create-signed-release-commit-tag","text":"Note Before doing this you should have a GPG key set up on github If you don't have a GPG key already, one method is via https://keybase.io/ , and then add it to your github profile. Create a release tag with the above staged changes (where $VERSION is the version number to be released: $ git commit -m \"Release $VERSION \" $ git tag -fsm \"Release $VERSION \" $VERSION This can be expressed as a bash function as follows: git_release() { git commit -m \"Release $1\" && git tag -fsm \"Release $1\" $1; } Push the commit and tag: $ git push --follow-tags","title":"Create signed release commit tag"},{"location":"project/release_process/#updatecreate-stable-branch","text":"Push these changes to the appropriate stable/MAJOR.MINOR version branch (eg stable/2.0 ) if they're not already - note that this will trigger the readthedocs build","title":"Update/create stable branch"},{"location":"project/release_process/#release-on-pypi","text":"See https://packaging.python.org/tutorials/packaging-projects/#generating-distribution-archives","title":"Release on pypi"},{"location":"project/sponsors/","text":"Sponsors Gold Sponsors This project is sponsored by none other than Stripe , since August 2020. We're thankful for their contribution, which has allowed us to greatly improve the project, increase QA and testing, and push forward with the dj-stripe 2.4.0 release. Silver Sponsors We do not currently have any Silver sponsors. Want to be the first?","title":"Sponsors"},{"location":"project/sponsors/#sponsors","text":"","title":"Sponsors"},{"location":"project/sponsors/#gold-sponsors","text":"This project is sponsored by none other than Stripe , since August 2020. We're thankful for their contribution, which has allowed us to greatly improve the project, increase QA and testing, and push forward with the dj-stripe 2.4.0 release.","title":"Gold Sponsors"},{"location":"project/sponsors/#silver-sponsors","text":"We do not currently have any Silver sponsors. Want to be the first?","title":"Silver Sponsors"},{"location":"project/support/","text":"Support Support plans dj-stripe offers paid support plans via Github Sponsors: https://github.com/sponsors/dj-stripe All issues and feature requests raised by corporate sponsors will be prioritized. Gold Sponsors also get a dedicated developer point of contact, to help with any questions, issues, or general inquiries relating to dj-stripe. Bug reports and feature requests Please report any issues you come across on the Github issue tracker . Do not hesitate to leave feedback and suggestions there as well. You may also ask usage questions on the issue tracker.","title":"Support"},{"location":"project/support/#support","text":"","title":"Support"},{"location":"project/support/#support-plans","text":"dj-stripe offers paid support plans via Github Sponsors: https://github.com/sponsors/dj-stripe All issues and feature requests raised by corporate sponsors will be prioritized. Gold Sponsors also get a dedicated developer point of contact, to help with any questions, issues, or general inquiries relating to dj-stripe.","title":"Support plans"},{"location":"project/support/#bug-reports-and-feature-requests","text":"Please report any issues you come across on the Github issue tracker . Do not hesitate to leave feedback and suggestions there as well. You may also ask usage questions on the issue tracker.","title":"Bug reports and feature requests"},{"location":"project/test_fixtures/","text":"Test Fixtures dj-stripe's unit tests rely on fixtures to represent Stripe API and webhook data. Rationale These fixtures are partly hand-coded and partly generated by creating objects in Stripe and then retrieved via the API. Each approach has pros and cons: Hand-coding the fixtures allows them to be crafted specifically for a test case. They can also be terse, and nested objects can be done by reference to avoid duplication. But maintaining or upgrading them is a painstaking manual process. Generating the fixtures via Stripe gives the big advantage that Stripe schema changes are automatically represented in the fixtures, which should allow us to upgrade dj-stripe's schema to match Stripe much more easily. This would be done by updating dj-stripe's targeted API version ( DEFAULT_STRIPE_API_VERSION ), regenerating the fixtures, and updating the model to match the fixture changes. The down side is it's tricky to regenerate fixture files without introducing big changes (eg to object ids) - the script does this by mapping a dummy id to various objects. Regenerating the test fixtures To regenerate the test fixtures (e.g. to populate the fixtures with new API fields from Stripe), do the following: (one time only) Create a new Stripe account called \"dj-stripe scratch\", with country set to United States. (we use US so the currency matches the existing fixtures matches, in the future it would be good to test for other countries). If you already had this account ready and want to start again from scratch, you can delete all of the test data via the button in Settings > Data https://dashboard.stripe.com/account/data Activate a virtualenv with the dj-stripe project (see Getting Started) Set the dj-stripe secret key environment variable to the secret key for this account ( export STRIPE_SECRET_KEY=sk_test_... ) Run the manage command to create the test objects in your stripe account if they don't already exist, and regenerate the local fixture files from them: $ ./manage.py regenerate_test_fixtures The command tries to avoid inconsequential changes to the fixtures (e.g the created timestamp) by restoring a whitelist of values from the existing fixtures. This functionality can be disabled by passing the parameter --update-sideeffect-fields .","title":"Test Fixtures"},{"location":"project/test_fixtures/#test-fixtures","text":"dj-stripe's unit tests rely on fixtures to represent Stripe API and webhook data.","title":"Test Fixtures"},{"location":"project/test_fixtures/#rationale","text":"These fixtures are partly hand-coded and partly generated by creating objects in Stripe and then retrieved via the API. Each approach has pros and cons: Hand-coding the fixtures allows them to be crafted specifically for a test case. They can also be terse, and nested objects can be done by reference to avoid duplication. But maintaining or upgrading them is a painstaking manual process. Generating the fixtures via Stripe gives the big advantage that Stripe schema changes are automatically represented in the fixtures, which should allow us to upgrade dj-stripe's schema to match Stripe much more easily. This would be done by updating dj-stripe's targeted API version ( DEFAULT_STRIPE_API_VERSION ), regenerating the fixtures, and updating the model to match the fixture changes. The down side is it's tricky to regenerate fixture files without introducing big changes (eg to object ids) - the script does this by mapping a dummy id to various objects.","title":"Rationale"},{"location":"project/test_fixtures/#regenerating-the-test-fixtures","text":"To regenerate the test fixtures (e.g. to populate the fixtures with new API fields from Stripe), do the following: (one time only) Create a new Stripe account called \"dj-stripe scratch\", with country set to United States. (we use US so the currency matches the existing fixtures matches, in the future it would be good to test for other countries). If you already had this account ready and want to start again from scratch, you can delete all of the test data via the button in Settings > Data https://dashboard.stripe.com/account/data Activate a virtualenv with the dj-stripe project (see Getting Started) Set the dj-stripe secret key environment variable to the secret key for this account ( export STRIPE_SECRET_KEY=sk_test_... ) Run the manage command to create the test objects in your stripe account if they don't already exist, and regenerate the local fixture files from them: $ ./manage.py regenerate_test_fixtures The command tries to avoid inconsequential changes to the fixtures (e.g the created timestamp) by restoring a whitelist of values from the existing fixtures. This functionality can be disabled by passing the parameter --update-sideeffect-fields .","title":"Regenerating the test fixtures"},{"location":"reference/context_managers/","text":"Context Managers dj-stripe Context Managers Functions djstripe . context_managers . stripe_temporary_api_version ( version , validate = True ) Temporarily replace the global api_version used in stripe API calls with the given value. The original value is restored as soon as context exits. Source code in djstripe/context_managers.py @contextmanager def stripe_temporary_api_version ( version , validate = True ): \"\"\" Temporarily replace the global api_version used in stripe API calls with the given value. The original value is restored as soon as context exits. \"\"\" old_version = djstripe_settings . STRIPE_API_VERSION try : djstripe_settings . set_stripe_api_version ( version , validate = validate ) yield finally : # Validation is bypassed since we're restoring a previous value. djstripe_settings . set_stripe_api_version ( old_version , validate = False )","title":"Context Managers"},{"location":"reference/context_managers/#context-managers","text":"dj-stripe Context Managers","title":"Context Managers"},{"location":"reference/context_managers/#djstripe.context_managers-functions","text":"","title":"Functions"},{"location":"reference/context_managers/#djstripe.context_managers.stripe_temporary_api_version","text":"Temporarily replace the global api_version used in stripe API calls with the given value. The original value is restored as soon as context exits. Source code in djstripe/context_managers.py @contextmanager def stripe_temporary_api_version ( version , validate = True ): \"\"\" Temporarily replace the global api_version used in stripe API calls with the given value. The original value is restored as soon as context exits. \"\"\" old_version = djstripe_settings . STRIPE_API_VERSION try : djstripe_settings . set_stripe_api_version ( version , validate = validate ) yield finally : # Validation is bypassed since we're restoring a previous value. djstripe_settings . set_stripe_api_version ( old_version , validate = False )","title":"stripe_temporary_api_version()"},{"location":"reference/enums/","text":"Enumerations Classes djstripe.enums.APIKeyType API Key Types (internal model only) djstripe . enums . APIKeyType . publishable djstripe . enums . APIKeyType . restricted djstripe . enums . APIKeyType . secret djstripe . enums . APIKeyType . humanize ( enum ) Source code in djstripe/enums.py def _human_enum_values ( enum ): return cls . __choices__ [ enum ] djstripe.enums.AccountType djstripe . enums . AccountType . custom djstripe . enums . AccountType . express djstripe . enums . AccountType . standard djstripe . enums . AccountType . humanize ( enum ) Source code in djstripe/enums.py def _human_enum_values ( enum ): return cls . __choices__ [ enum ] djstripe.enums.ApiErrorCode Charge failure error codes. https://stripe.com/docs/error-codes djstripe . enums . ApiErrorCode . account_already_exists djstripe . enums . ApiErrorCode . account_country_invalid_address djstripe . enums . ApiErrorCode . account_invalid djstripe . enums . ApiErrorCode . account_number_invalid djstripe . enums . ApiErrorCode . alipay_upgrade_required djstripe . enums . ApiErrorCode . amount_too_large djstripe . enums . ApiErrorCode . amount_too_small djstripe . enums . ApiErrorCode . api_key_expired djstripe . enums . ApiErrorCode . balance_insufficient djstripe . enums . ApiErrorCode . bank_account_exists djstripe . enums . ApiErrorCode . bank_account_unusable djstripe . enums . ApiErrorCode . bank_account_unverified djstripe . enums . ApiErrorCode . bitcoin_upgrade_required djstripe . enums . ApiErrorCode . card_declined djstripe . enums . ApiErrorCode . charge_already_captured djstripe . enums . ApiErrorCode . charge_already_refunded djstripe . enums . ApiErrorCode . charge_disputed djstripe . enums . ApiErrorCode . charge_exceeds_source_limit djstripe . enums . ApiErrorCode . charge_expired_for_capture djstripe . enums . ApiErrorCode . country_unsupported djstripe . enums . ApiErrorCode . coupon_expired djstripe . enums . ApiErrorCode . customer_max_subscriptions djstripe . enums . ApiErrorCode . email_invalid djstripe . enums . ApiErrorCode . expired_card djstripe . enums . ApiErrorCode . idempotency_key_in_use djstripe . enums . ApiErrorCode . incorrect_address djstripe . enums . ApiErrorCode . incorrect_cvc djstripe . enums . ApiErrorCode . incorrect_number djstripe . enums . ApiErrorCode . incorrect_zip djstripe . enums . ApiErrorCode . instant_payouts_unsupported djstripe . enums . ApiErrorCode . invalid_card_type djstripe . enums . ApiErrorCode . invalid_charge_amount djstripe . enums . ApiErrorCode . invalid_cvc djstripe . enums . ApiErrorCode . invalid_expiry_month djstripe . enums . ApiErrorCode . invalid_expiry_year djstripe . enums . ApiErrorCode . invalid_number djstripe . enums . ApiErrorCode . invalid_source_usage djstripe . enums . ApiErrorCode . invalid_swipe_data djstripe . enums . ApiErrorCode . invoice_no_customer_line_items djstripe . enums . ApiErrorCode . invoice_no_subscription_line_items djstripe . enums . ApiErrorCode . invoice_not_editable djstripe . enums . ApiErrorCode . invoice_upcoming_none djstripe . enums . ApiErrorCode . livemode_mismatch djstripe . enums . ApiErrorCode . missing djstripe . enums . ApiErrorCode . not_allowed_on_standard_account djstripe . enums . ApiErrorCode . order_creation_failed djstripe . enums . ApiErrorCode . order_required_settings djstripe . enums . ApiErrorCode . order_status_invalid djstripe . enums . ApiErrorCode . order_upstream_timeout djstripe . enums . ApiErrorCode . out_of_inventory djstripe . enums . ApiErrorCode . parameter_invalid_empty djstripe . enums . ApiErrorCode . parameter_invalid_integer djstripe . enums . ApiErrorCode . parameter_invalid_string_blank djstripe . enums . ApiErrorCode . parameter_invalid_string_empty djstripe . enums . ApiErrorCode . parameter_missing djstripe . enums . ApiErrorCode . parameter_unknown djstripe . enums . ApiErrorCode . parameters_exclusive djstripe . enums . ApiErrorCode . payment_intent_authentication_failure djstripe . enums . ApiErrorCode . payment_intent_incompatible_payment_method djstripe . enums . ApiErrorCode . payment_intent_invalid_parameter djstripe . enums . ApiErrorCode . payment_intent_payment_attempt_failed djstripe . enums . ApiErrorCode . payment_intent_unexpected_state djstripe . enums . ApiErrorCode . payment_method_unactivated djstripe . enums . ApiErrorCode . payment_method_unexpected_state djstripe . enums . ApiErrorCode . payouts_not_allowed djstripe . enums . ApiErrorCode . platform_api_key_expired djstripe . enums . ApiErrorCode . postal_code_invalid djstripe . enums . ApiErrorCode . processing_error djstripe . enums . ApiErrorCode . product_inactive djstripe . enums . ApiErrorCode . rate_limit djstripe . enums . ApiErrorCode . resource_already_exists djstripe . enums . ApiErrorCode . resource_missing djstripe . enums . ApiErrorCode . routing_number_invalid djstripe . enums . ApiErrorCode . secret_key_required djstripe . enums . ApiErrorCode . sepa_unsupported_account djstripe . enums . ApiErrorCode . shipping_calculation_failed djstripe . enums . ApiErrorCode . sku_inactive djstripe . enums . ApiErrorCode . state_unsupported djstripe . enums . ApiErrorCode . tax_id_invalid djstripe . enums . ApiErrorCode . taxes_calculation_failed djstripe . enums . ApiErrorCode . testmode_charges_only djstripe . enums . ApiErrorCode . tls_version_unsupported djstripe . enums . ApiErrorCode . token_already_used djstripe . enums . ApiErrorCode . token_in_use djstripe . enums . ApiErrorCode . transfers_not_allowed djstripe . enums . ApiErrorCode . upstream_order_creation_failed djstripe . enums . ApiErrorCode . url_invalid djstripe . enums . ApiErrorCode . humanize ( enum ) Source code in djstripe/enums.py def _human_enum_values ( enum ): return cls . __choices__ [ enum ] djstripe.enums.BalanceTransactionReportingCategory https://stripe.com/docs/reports/reporting-categories djstripe . enums . BalanceTransactionReportingCategory . advance djstripe . enums . BalanceTransactionReportingCategory . advance_funding djstripe . enums . BalanceTransactionReportingCategory . anticipation_repayment djstripe . enums . BalanceTransactionReportingCategory . charge djstripe . enums . BalanceTransactionReportingCategory . charge_failure djstripe . enums . BalanceTransactionReportingCategory . connect_collection_transfer djstripe . enums . BalanceTransactionReportingCategory . connect_reserved_funds djstripe . enums . BalanceTransactionReportingCategory . dispute djstripe . enums . BalanceTransactionReportingCategory . dispute_reversal djstripe . enums . BalanceTransactionReportingCategory . fee djstripe . enums . BalanceTransactionReportingCategory . issuing_authorization_hold djstripe . enums . BalanceTransactionReportingCategory . issuing_authorization_release djstripe . enums . BalanceTransactionReportingCategory . issuing_dispute djstripe . enums . BalanceTransactionReportingCategory . issuing_transaction djstripe . enums . BalanceTransactionReportingCategory . other_adjustment djstripe . enums . BalanceTransactionReportingCategory . partial_capture_reversal djstripe . enums . BalanceTransactionReportingCategory . payout djstripe . enums . BalanceTransactionReportingCategory . payout_reversal djstripe . enums . BalanceTransactionReportingCategory . platform_earning djstripe . enums . BalanceTransactionReportingCategory . platform_earning_refund djstripe . enums . BalanceTransactionReportingCategory . refund djstripe . enums . BalanceTransactionReportingCategory . refund_failure djstripe . enums . BalanceTransactionReportingCategory . risk_reserved_funds djstripe . enums . BalanceTransactionReportingCategory . tax djstripe . enums . BalanceTransactionReportingCategory . topup djstripe . enums . BalanceTransactionReportingCategory . topup_reversal djstripe . enums . BalanceTransactionReportingCategory . transfer djstripe . enums . BalanceTransactionReportingCategory . transfer_reversal djstripe . enums . BalanceTransactionReportingCategory . humanize ( enum ) Source code in djstripe/enums.py def _human_enum_values ( enum ): return cls . __choices__ [ enum ] djstripe.enums.BalanceTransactionStatus djstripe . enums . BalanceTransactionStatus . available djstripe . enums . BalanceTransactionStatus . pending djstripe . enums . BalanceTransactionStatus . humanize ( enum ) Source code in djstripe/enums.py def _human_enum_values ( enum ): return cls . __choices__ [ enum ] djstripe.enums.BalanceTransactionType djstripe . enums . BalanceTransactionType . adjustment djstripe . enums . BalanceTransactionType . advance djstripe . enums . BalanceTransactionType . advance_funding djstripe . enums . BalanceTransactionType . anticipation_repayment djstripe . enums . BalanceTransactionType . application_fee djstripe . enums . BalanceTransactionType . application_fee_refund djstripe . enums . BalanceTransactionType . balance_transfer_inbound djstripe . enums . BalanceTransactionType . balance_transfer_outbound djstripe . enums . BalanceTransactionType . charge djstripe . enums . BalanceTransactionType . connect_collection_transfer djstripe . enums . BalanceTransactionType . contribution djstripe . enums . BalanceTransactionType . issuing_authorization_hold djstripe . enums . BalanceTransactionType . issuing_authorization_release djstripe . enums . BalanceTransactionType . issuing_dispute djstripe . enums . BalanceTransactionType . issuing_transaction djstripe . enums . BalanceTransactionType . network_cost djstripe . enums . BalanceTransactionType . payment djstripe . enums . BalanceTransactionType . payment_failure_refund djstripe . enums . BalanceTransactionType . payment_refund djstripe . enums . BalanceTransactionType . payout djstripe . enums . BalanceTransactionType . payout_cancel djstripe . enums . BalanceTransactionType . payout_failure djstripe . enums . BalanceTransactionType . refund djstripe . enums . BalanceTransactionType . refund_failure djstripe . enums . BalanceTransactionType . reserve_transaction djstripe . enums . BalanceTransactionType . reserved_funds djstripe . enums . BalanceTransactionType . stripe_fee djstripe . enums . BalanceTransactionType . stripe_fx_fee djstripe . enums . BalanceTransactionType . tax_fee djstripe . enums . BalanceTransactionType . topup djstripe . enums . BalanceTransactionType . topup_reversal djstripe . enums . BalanceTransactionType . transfer djstripe . enums . BalanceTransactionType . transfer_cancel djstripe . enums . BalanceTransactionType . transfer_failure djstripe . enums . BalanceTransactionType . transfer_refund djstripe . enums . BalanceTransactionType . validation djstripe . enums . BalanceTransactionType . humanize ( enum ) Source code in djstripe/enums.py def _human_enum_values ( enum ): return cls . __choices__ [ enum ] djstripe.enums.BankAccountHolderType djstripe . enums . BankAccountHolderType . company djstripe . enums . BankAccountHolderType . individual djstripe . enums . BankAccountHolderType . humanize ( enum ) Source code in djstripe/enums.py def _human_enum_values ( enum ): return cls . __choices__ [ enum ] djstripe.enums.BankAccountStatus djstripe . enums . BankAccountStatus . errored djstripe . enums . BankAccountStatus . new djstripe . enums . BankAccountStatus . validated djstripe . enums . BankAccountStatus . verification_failed djstripe . enums . BankAccountStatus . verified djstripe . enums . BankAccountStatus . humanize ( enum ) Source code in djstripe/enums.py def _human_enum_values ( enum ): return cls . __choices__ [ enum ] djstripe.enums.BillingScheme djstripe . enums . BillingScheme . per_unit djstripe . enums . BillingScheme . tiered djstripe . enums . BillingScheme . humanize ( enum ) Source code in djstripe/enums.py def _human_enum_values ( enum ): return cls . __choices__ [ enum ] djstripe.enums.BusinessType djstripe . enums . BusinessType . company djstripe . enums . BusinessType . individual djstripe . enums . BusinessType . humanize ( enum ) Source code in djstripe/enums.py def _human_enum_values ( enum ): return cls . __choices__ [ enum ] djstripe.enums.CaptureMethod djstripe . enums . CaptureMethod . automatic djstripe . enums . CaptureMethod . manual djstripe . enums . CaptureMethod . humanize ( enum ) Source code in djstripe/enums.py def _human_enum_values ( enum ): return cls . __choices__ [ enum ] djstripe.enums.CardBrand djstripe . enums . CardBrand . AmericanExpress djstripe . enums . CardBrand . DinersClub djstripe . enums . CardBrand . Discover djstripe . enums . CardBrand . JCB djstripe . enums . CardBrand . MasterCard djstripe . enums . CardBrand . UnionPay djstripe . enums . CardBrand . Unknown djstripe . enums . CardBrand . Visa djstripe . enums . CardBrand . humanize ( enum ) Source code in djstripe/enums.py def _human_enum_values ( enum ): return cls . __choices__ [ enum ] djstripe.enums.CardCheckResult djstripe . enums . CardCheckResult . fail djstripe . enums . CardCheckResult . pass_ djstripe . enums . CardCheckResult . unavailable djstripe . enums . CardCheckResult . unchecked djstripe . enums . CardCheckResult . humanize ( enum ) Source code in djstripe/enums.py def _human_enum_values ( enum ): return cls . __choices__ [ enum ] djstripe.enums.CardFundingType djstripe . enums . CardFundingType . credit djstripe . enums . CardFundingType . debit djstripe . enums . CardFundingType . prepaid djstripe . enums . CardFundingType . unknown djstripe . enums . CardFundingType . humanize ( enum ) Source code in djstripe/enums.py def _human_enum_values ( enum ): return cls . __choices__ [ enum ] djstripe.enums.CardTokenizationMethod djstripe . enums . CardTokenizationMethod . android_pay djstripe . enums . CardTokenizationMethod . apple_pay djstripe . enums . CardTokenizationMethod . humanize ( enum ) Source code in djstripe/enums.py def _human_enum_values ( enum ): return cls . __choices__ [ enum ] djstripe.enums.ChargeStatus djstripe . enums . ChargeStatus . failed djstripe . enums . ChargeStatus . pending djstripe . enums . ChargeStatus . succeeded djstripe . enums . ChargeStatus . humanize ( enum ) Source code in djstripe/enums.py def _human_enum_values ( enum ): return cls . __choices__ [ enum ] djstripe.enums.ConfirmationMethod djstripe . enums . ConfirmationMethod . automatic djstripe . enums . ConfirmationMethod . manual djstripe . enums . ConfirmationMethod . humanize ( enum ) Source code in djstripe/enums.py def _human_enum_values ( enum ): return cls . __choices__ [ enum ] djstripe.enums.CouponDuration djstripe . enums . CouponDuration . forever djstripe . enums . CouponDuration . once djstripe . enums . CouponDuration . repeating djstripe . enums . CouponDuration . humanize ( enum ) Source code in djstripe/enums.py def _human_enum_values ( enum ): return cls . __choices__ [ enum ] djstripe.enums.CustomerTaxExempt djstripe . enums . CustomerTaxExempt . exempt djstripe . enums . CustomerTaxExempt . none djstripe . enums . CustomerTaxExempt . reverse djstripe . enums . CustomerTaxExempt . humanize ( enum ) Source code in djstripe/enums.py def _human_enum_values ( enum ): return cls . __choices__ [ enum ] djstripe.enums.DisputeReason djstripe . enums . DisputeReason . bank_cannot_process djstripe . enums . DisputeReason . credit_not_processed djstripe . enums . DisputeReason . customer_initiated djstripe . enums . DisputeReason . debit_not_authorized djstripe . enums . DisputeReason . duplicate djstripe . enums . DisputeReason . fraudulent djstripe . enums . DisputeReason . general djstripe . enums . DisputeReason . incorrect_account_details djstripe . enums . DisputeReason . insufficient_funds djstripe . enums . DisputeReason . product_not_received djstripe . enums . DisputeReason . product_unacceptable djstripe . enums . DisputeReason . subscription_canceled djstripe . enums . DisputeReason . unrecognized djstripe . enums . DisputeReason . humanize ( enum ) Source code in djstripe/enums.py def _human_enum_values ( enum ): return cls . __choices__ [ enum ] djstripe.enums.DisputeStatus djstripe . enums . DisputeStatus . charge_refunded djstripe . enums . DisputeStatus . lost djstripe . enums . DisputeStatus . needs_response djstripe . enums . DisputeStatus . under_review djstripe . enums . DisputeStatus . warning_closed djstripe . enums . DisputeStatus . warning_needs_response djstripe . enums . DisputeStatus . warning_under_review djstripe . enums . DisputeStatus . won djstripe . enums . DisputeStatus . humanize ( enum ) Source code in djstripe/enums.py def _human_enum_values ( enum ): return cls . __choices__ [ enum ] djstripe.enums.DjstripePaymentMethodType A djstripe-specific enum for the DjStripePaymentMethod model. djstripe . enums . DjstripePaymentMethodType . alipay_account djstripe . enums . DjstripePaymentMethodType . bank_account djstripe . enums . DjstripePaymentMethodType . card djstripe . enums . DjstripePaymentMethodType . source djstripe . enums . DjstripePaymentMethodType . humanize ( enum ) Source code in djstripe/enums.py def _human_enum_values ( enum ): return cls . __choices__ [ enum ] djstripe.enums.Enum djstripe . enums . Enum . humanize ( enum ) Source code in djstripe/enums.py def _human_enum_values ( enum ): return cls . __choices__ [ enum ] djstripe.enums.EnumMetaClass Methods djstripe . enums . EnumMetaClass . __init__ ( cls , name , bases , classdict ) special Source code in djstripe/enums.py def __init__ ( cls , name , bases , classdict ): def _human_enum_values ( enum ): return cls . __choices__ [ enum ] # add a class attribute cls . humanize = _human_enum_values djstripe . enums . EnumMetaClass . __new__ ( cls , name , bases , classdict ) special staticmethod Create and return a new object. See help(type) for accurate signature. Source code in djstripe/enums.py def __new__ ( cls , name , bases , classdict ): members = [] keys = {} choices = OrderedDict () for key , value in classdict . items (): if key . startswith ( \"__\" ): continue members . append ( key ) if isinstance ( value , tuple ): value , alias = value keys [ alias ] = key else : alias = None keys [ alias or key ] = key choices [ alias or key ] = value for k , v in keys . items (): classdict [ v ] = k classdict [ \"__choices__\" ] = choices classdict [ \"__members__\" ] = members # Note: Differences between Python 2.x and Python 3.x force us to # explicitly use unicode here, and to explicitly sort the list. In # Python 2.x, class members are unordered and so the ordering will # vary on different systems based on internal hashing. Without this # Django will continually require new no-op migrations. classdict [ \"choices\" ] = tuple ( ( str ( k ), str ( v )) for k , v in sorted ( choices . items (), key = operator . itemgetter ( 0 )) ) return type . __new__ ( cls , name , bases , classdict ) djstripe . enums . EnumMetaClass . __prepare__ ( name , bases ) classmethod special prepare () -> dict used to create the namespace for the class statement Source code in djstripe/enums.py @classmethod def __prepare__ ( cls , name , bases ): return OrderedDict () djstripe.enums.FilePurpose djstripe . enums . FilePurpose . account_requirement djstripe . enums . FilePurpose . additional_verification djstripe . enums . FilePurpose . business_icon djstripe . enums . FilePurpose . business_logo djstripe . enums . FilePurpose . customer_signature djstripe . enums . FilePurpose . dispute_evidence djstripe . enums . FilePurpose . document_provider_identity_document djstripe . enums . FilePurpose . finance_report_run djstripe . enums . FilePurpose . identity_document djstripe . enums . FilePurpose . identity_document_downloadable djstripe . enums . FilePurpose . invoice_statement djstripe . enums . FilePurpose . pci_document djstripe . enums . FilePurpose . selfie djstripe . enums . FilePurpose . sigma_scheduled_query djstripe . enums . FilePurpose . tax_document_user_upload djstripe . enums . FilePurpose . humanize ( enum ) Source code in djstripe/enums.py def _human_enum_values ( enum ): return cls . __choices__ [ enum ] djstripe.enums.FileType djstripe . enums . FileType . csv djstripe . enums . FileType . docx djstripe . enums . FileType . jpg djstripe . enums . FileType . pdf djstripe . enums . FileType . png djstripe . enums . FileType . xls djstripe . enums . FileType . xlsx djstripe . enums . FileType . humanize ( enum ) Source code in djstripe/enums.py def _human_enum_values ( enum ): return cls . __choices__ [ enum ] djstripe.enums.IntentStatus Status of Intents which apply both to PaymentIntents and SetupIntents. djstripe . enums . IntentStatus . canceled djstripe . enums . IntentStatus . processing djstripe . enums . IntentStatus . requires_action djstripe . enums . IntentStatus . requires_confirmation djstripe . enums . IntentStatus . requires_payment_method djstripe . enums . IntentStatus . humanize ( enum ) Source code in djstripe/enums.py def _human_enum_values ( enum ): return cls . __choices__ [ enum ] djstripe.enums.IntentUsage djstripe . enums . IntentUsage . off_session djstripe . enums . IntentUsage . on_session djstripe . enums . IntentUsage . humanize ( enum ) Source code in djstripe/enums.py def _human_enum_values ( enum ): return cls . __choices__ [ enum ] djstripe.enums.InvoiceBillingReason djstripe . enums . InvoiceBillingReason . manual djstripe . enums . InvoiceBillingReason . subscription djstripe . enums . InvoiceBillingReason . subscription_create djstripe . enums . InvoiceBillingReason . subscription_cycle djstripe . enums . InvoiceBillingReason . subscription_threshold djstripe . enums . InvoiceBillingReason . subscription_update djstripe . enums . InvoiceBillingReason . upcoming djstripe . enums . InvoiceBillingReason . humanize ( enum ) Source code in djstripe/enums.py def _human_enum_values ( enum ): return cls . __choices__ [ enum ] djstripe.enums.InvoiceCollectionMethod djstripe . enums . InvoiceCollectionMethod . charge_automatically djstripe . enums . InvoiceCollectionMethod . send_invoice djstripe . enums . InvoiceCollectionMethod . humanize ( enum ) Source code in djstripe/enums.py def _human_enum_values ( enum ): return cls . __choices__ [ enum ] djstripe.enums.InvoiceStatus djstripe . enums . InvoiceStatus . draft djstripe . enums . InvoiceStatus . open djstripe . enums . InvoiceStatus . paid djstripe . enums . InvoiceStatus . uncollectible djstripe . enums . InvoiceStatus . void djstripe . enums . InvoiceStatus . humanize ( enum ) Source code in djstripe/enums.py def _human_enum_values ( enum ): return cls . __choices__ [ enum ] djstripe.enums.LegacySourceType djstripe . enums . LegacySourceType . alipay_account djstripe . enums . LegacySourceType . bank_account djstripe . enums . LegacySourceType . bitcoin_receiver djstripe . enums . LegacySourceType . card djstripe . enums . LegacySourceType . humanize ( enum ) Source code in djstripe/enums.py def _human_enum_values ( enum ): return cls . __choices__ [ enum ] djstripe.enums.MandateStatus djstripe . enums . MandateStatus . active djstripe . enums . MandateStatus . inactive djstripe . enums . MandateStatus . pending djstripe . enums . MandateStatus . humanize ( enum ) Source code in djstripe/enums.py def _human_enum_values ( enum ): return cls . __choices__ [ enum ] djstripe.enums.MandateType djstripe . enums . MandateType . multi_use djstripe . enums . MandateType . single_use djstripe . enums . MandateType . humanize ( enum ) Source code in djstripe/enums.py def _human_enum_values ( enum ): return cls . __choices__ [ enum ] djstripe.enums.PaymentIntentCancellationReason djstripe . enums . PaymentIntentCancellationReason . abandoned djstripe . enums . PaymentIntentCancellationReason . automatic djstripe . enums . PaymentIntentCancellationReason . duplicate djstripe . enums . PaymentIntentCancellationReason . failed_invoice djstripe . enums . PaymentIntentCancellationReason . fraudulent djstripe . enums . PaymentIntentCancellationReason . requested_by_customer djstripe . enums . PaymentIntentCancellationReason . void_invoice djstripe . enums . PaymentIntentCancellationReason . humanize ( enum ) Source code in djstripe/enums.py def _human_enum_values ( enum ): return cls . __choices__ [ enum ] djstripe.enums.PaymentIntentStatus djstripe . enums . PaymentIntentStatus . canceled djstripe . enums . PaymentIntentStatus . processing djstripe . enums . PaymentIntentStatus . requires_action djstripe . enums . PaymentIntentStatus . requires_capture djstripe . enums . PaymentIntentStatus . requires_confirmation djstripe . enums . PaymentIntentStatus . requires_payment_method djstripe . enums . PaymentIntentStatus . succeeded djstripe . enums . PaymentIntentStatus . humanize ( enum ) Source code in djstripe/enums.py def _human_enum_values ( enum ): return cls . __choices__ [ enum ] djstripe.enums.PaymentMethodType djstripe . enums . PaymentMethodType . acss_debit djstripe . enums . PaymentMethodType . afterpay_clearpay djstripe . enums . PaymentMethodType . alipay djstripe . enums . PaymentMethodType . au_becs_debit djstripe . enums . PaymentMethodType . bacs_debit djstripe . enums . PaymentMethodType . bancontact djstripe . enums . PaymentMethodType . boleto djstripe . enums . PaymentMethodType . card djstripe . enums . PaymentMethodType . card_present djstripe . enums . PaymentMethodType . eps djstripe . enums . PaymentMethodType . fpx djstripe . enums . PaymentMethodType . giropay djstripe . enums . PaymentMethodType . grabpay djstripe . enums . PaymentMethodType . ideal djstripe . enums . PaymentMethodType . interac_present djstripe . enums . PaymentMethodType . klarna djstripe . enums . PaymentMethodType . oxxo djstripe . enums . PaymentMethodType . p24 djstripe . enums . PaymentMethodType . sepa_debit djstripe . enums . PaymentMethodType . sofort djstripe . enums . PaymentMethodType . wechat_pay djstripe . enums . PaymentMethodType . humanize ( enum ) Source code in djstripe/enums.py def _human_enum_values ( enum ): return cls . __choices__ [ enum ] djstripe.enums.PayoutFailureCode Payout failure error codes. https://stripe.com/docs/api#payout_failures djstripe . enums . PayoutFailureCode . account_closed djstripe . enums . PayoutFailureCode . account_frozen djstripe . enums . PayoutFailureCode . bank_account_restricted djstripe . enums . PayoutFailureCode . bank_ownership_changed djstripe . enums . PayoutFailureCode . could_not_process djstripe . enums . PayoutFailureCode . debit_not_authorized djstripe . enums . PayoutFailureCode . insufficient_funds djstripe . enums . PayoutFailureCode . invalid_account_number djstripe . enums . PayoutFailureCode . invalid_currency djstripe . enums . PayoutFailureCode . no_account djstripe . enums . PayoutFailureCode . unsupported_card djstripe . enums . PayoutFailureCode . humanize ( enum ) Source code in djstripe/enums.py def _human_enum_values ( enum ): return cls . __choices__ [ enum ] djstripe.enums.PayoutMethod djstripe . enums . PayoutMethod . instant djstripe . enums . PayoutMethod . standard djstripe . enums . PayoutMethod . humanize ( enum ) Source code in djstripe/enums.py def _human_enum_values ( enum ): return cls . __choices__ [ enum ] djstripe.enums.PayoutSourceType djstripe . enums . PayoutSourceType . bank_account djstripe . enums . PayoutSourceType . card djstripe . enums . PayoutSourceType . fpx djstripe . enums . PayoutSourceType . humanize ( enum ) Source code in djstripe/enums.py def _human_enum_values ( enum ): return cls . __choices__ [ enum ] djstripe.enums.PayoutStatus djstripe . enums . PayoutStatus . canceled djstripe . enums . PayoutStatus . failed djstripe . enums . PayoutStatus . in_transit djstripe . enums . PayoutStatus . paid djstripe . enums . PayoutStatus . pending djstripe . enums . PayoutStatus . humanize ( enum ) Source code in djstripe/enums.py def _human_enum_values ( enum ): return cls . __choices__ [ enum ] djstripe.enums.PayoutType djstripe . enums . PayoutType . bank_account djstripe . enums . PayoutType . card djstripe . enums . PayoutType . humanize ( enum ) Source code in djstripe/enums.py def _human_enum_values ( enum ): return cls . __choices__ [ enum ] djstripe.enums.PlanAggregateUsage djstripe . enums . PlanAggregateUsage . last_during_period djstripe . enums . PlanAggregateUsage . last_ever djstripe . enums . PlanAggregateUsage . max djstripe . enums . PlanAggregateUsage . sum djstripe . enums . PlanAggregateUsage . humanize ( enum ) Source code in djstripe/enums.py def _human_enum_values ( enum ): return cls . __choices__ [ enum ] djstripe.enums.PlanInterval djstripe . enums . PlanInterval . day djstripe . enums . PlanInterval . month djstripe . enums . PlanInterval . week djstripe . enums . PlanInterval . year djstripe . enums . PlanInterval . humanize ( enum ) Source code in djstripe/enums.py def _human_enum_values ( enum ): return cls . __choices__ [ enum ] djstripe.enums.PlanTiersMode djstripe . enums . PlanTiersMode . graduated djstripe . enums . PlanTiersMode . volume djstripe . enums . PlanTiersMode . humanize ( enum ) Source code in djstripe/enums.py def _human_enum_values ( enum ): return cls . __choices__ [ enum ] djstripe.enums.PlanUsageType djstripe . enums . PlanUsageType . licensed djstripe . enums . PlanUsageType . metered djstripe . enums . PlanUsageType . humanize ( enum ) Source code in djstripe/enums.py def _human_enum_values ( enum ): return cls . __choices__ [ enum ] djstripe.enums.PriceTiersMode djstripe . enums . PriceTiersMode . graduated djstripe . enums . PriceTiersMode . volume djstripe . enums . PriceTiersMode . humanize ( enum ) Source code in djstripe/enums.py def _human_enum_values ( enum ): return cls . __choices__ [ enum ] djstripe.enums.PriceType djstripe . enums . PriceType . one_time djstripe . enums . PriceType . recurring djstripe . enums . PriceType . humanize ( enum ) Source code in djstripe/enums.py def _human_enum_values ( enum ): return cls . __choices__ [ enum ] djstripe.enums.PriceUsageType djstripe . enums . PriceUsageType . licensed djstripe . enums . PriceUsageType . metered djstripe . enums . PriceUsageType . humanize ( enum ) Source code in djstripe/enums.py def _human_enum_values ( enum ): return cls . __choices__ [ enum ] djstripe.enums.ProductType djstripe . enums . ProductType . good djstripe . enums . ProductType . service djstripe . enums . ProductType . humanize ( enum ) Source code in djstripe/enums.py def _human_enum_values ( enum ): return cls . __choices__ [ enum ] djstripe.enums.RefundFailureReason djstripe . enums . RefundFailureReason . expired_or_canceled_card djstripe . enums . RefundFailureReason . lost_or_stolen_card djstripe . enums . RefundFailureReason . unknown djstripe . enums . RefundFailureReason . humanize ( enum ) Source code in djstripe/enums.py def _human_enum_values ( enum ): return cls . __choices__ [ enum ] djstripe.enums.RefundReason djstripe . enums . RefundReason . duplicate djstripe . enums . RefundReason . expired_uncaptured_charge djstripe . enums . RefundReason . fraudulent djstripe . enums . RefundReason . requested_by_customer djstripe . enums . RefundReason . humanize ( enum ) Source code in djstripe/enums.py def _human_enum_values ( enum ): return cls . __choices__ [ enum ] djstripe.enums.RefundStatus djstripe . enums . RefundStatus . canceled djstripe . enums . RefundStatus . failed djstripe . enums . RefundStatus . pending djstripe . enums . RefundStatus . succeeded djstripe . enums . RefundStatus . humanize ( enum ) Source code in djstripe/enums.py def _human_enum_values ( enum ): return cls . __choices__ [ enum ] djstripe.enums.ScheduledQueryRunStatus djstripe . enums . ScheduledQueryRunStatus . canceled djstripe . enums . ScheduledQueryRunStatus . failed djstripe . enums . ScheduledQueryRunStatus . timed_out djstripe . enums . ScheduledQueryRunStatus . humanize ( enum ) Source code in djstripe/enums.py def _human_enum_values ( enum ): return cls . __choices__ [ enum ] djstripe.enums.SessionBillingAddressCollection djstripe . enums . SessionBillingAddressCollection . auto djstripe . enums . SessionBillingAddressCollection . required djstripe . enums . SessionBillingAddressCollection . humanize ( enum ) Source code in djstripe/enums.py def _human_enum_values ( enum ): return cls . __choices__ [ enum ] djstripe.enums.SessionMode djstripe . enums . SessionMode . payment djstripe . enums . SessionMode . setup djstripe . enums . SessionMode . subscription djstripe . enums . SessionMode . humanize ( enum ) Source code in djstripe/enums.py def _human_enum_values ( enum ): return cls . __choices__ [ enum ] djstripe.enums.SetupIntentCancellationReason djstripe . enums . SetupIntentCancellationReason . abandoned djstripe . enums . SetupIntentCancellationReason . duplicate djstripe . enums . SetupIntentCancellationReason . requested_by_customer djstripe . enums . SetupIntentCancellationReason . humanize ( enum ) Source code in djstripe/enums.py def _human_enum_values ( enum ): return cls . __choices__ [ enum ] djstripe.enums.SetupIntentStatus djstripe . enums . SetupIntentStatus . canceled djstripe . enums . SetupIntentStatus . processing djstripe . enums . SetupIntentStatus . requires_action djstripe . enums . SetupIntentStatus . requires_confirmation djstripe . enums . SetupIntentStatus . requires_payment_method djstripe . enums . SetupIntentStatus . succeeded djstripe . enums . SetupIntentStatus . humanize ( enum ) Source code in djstripe/enums.py def _human_enum_values ( enum ): return cls . __choices__ [ enum ] djstripe.enums.SourceCodeVerificationStatus djstripe . enums . SourceCodeVerificationStatus . failed djstripe . enums . SourceCodeVerificationStatus . pending djstripe . enums . SourceCodeVerificationStatus . succeeded djstripe . enums . SourceCodeVerificationStatus . humanize ( enum ) Source code in djstripe/enums.py def _human_enum_values ( enum ): return cls . __choices__ [ enum ] djstripe.enums.SourceFlow djstripe . enums . SourceFlow . code_verification djstripe . enums . SourceFlow . none djstripe . enums . SourceFlow . receiver djstripe . enums . SourceFlow . redirect djstripe . enums . SourceFlow . humanize ( enum ) Source code in djstripe/enums.py def _human_enum_values ( enum ): return cls . __choices__ [ enum ] djstripe.enums.SourceRedirectFailureReason djstripe . enums . SourceRedirectFailureReason . declined djstripe . enums . SourceRedirectFailureReason . processing_error djstripe . enums . SourceRedirectFailureReason . user_abort djstripe . enums . SourceRedirectFailureReason . humanize ( enum ) Source code in djstripe/enums.py def _human_enum_values ( enum ): return cls . __choices__ [ enum ] djstripe.enums.SourceRedirectStatus djstripe . enums . SourceRedirectStatus . failed djstripe . enums . SourceRedirectStatus . not_required djstripe . enums . SourceRedirectStatus . pending djstripe . enums . SourceRedirectStatus . succeeded djstripe . enums . SourceRedirectStatus . humanize ( enum ) Source code in djstripe/enums.py def _human_enum_values ( enum ): return cls . __choices__ [ enum ] djstripe.enums.SourceStatus djstripe . enums . SourceStatus . canceled djstripe . enums . SourceStatus . chargeable djstripe . enums . SourceStatus . consumed djstripe . enums . SourceStatus . failed djstripe . enums . SourceStatus . pending djstripe . enums . SourceStatus . humanize ( enum ) Source code in djstripe/enums.py def _human_enum_values ( enum ): return cls . __choices__ [ enum ] djstripe.enums.SourceType djstripe . enums . SourceType . ach_credit_transfer djstripe . enums . SourceType . ach_debit djstripe . enums . SourceType . acss_debit djstripe . enums . SourceType . alipay djstripe . enums . SourceType . au_becs_debit djstripe . enums . SourceType . bancontact djstripe . enums . SourceType . bitcoin djstripe . enums . SourceType . card djstripe . enums . SourceType . card_present djstripe . enums . SourceType . eps djstripe . enums . SourceType . giropay djstripe . enums . SourceType . ideal djstripe . enums . SourceType . klarna djstripe . enums . SourceType . multibanco djstripe . enums . SourceType . p24 djstripe . enums . SourceType . paper_check djstripe . enums . SourceType . sepa_credit_transfer djstripe . enums . SourceType . sepa_debit djstripe . enums . SourceType . sofort djstripe . enums . SourceType . three_d_secure djstripe . enums . SourceType . wechat djstripe . enums . SourceType . humanize ( enum ) Source code in djstripe/enums.py def _human_enum_values ( enum ): return cls . __choices__ [ enum ] djstripe.enums.SourceUsage djstripe . enums . SourceUsage . reusable djstripe . enums . SourceUsage . single_use djstripe . enums . SourceUsage . humanize ( enum ) Source code in djstripe/enums.py def _human_enum_values ( enum ): return cls . __choices__ [ enum ] djstripe.enums.SubmitTypeStatus djstripe . enums . SubmitTypeStatus . auto djstripe . enums . SubmitTypeStatus . book djstripe . enums . SubmitTypeStatus . donate djstripe . enums . SubmitTypeStatus . pay djstripe . enums . SubmitTypeStatus . humanize ( enum ) Source code in djstripe/enums.py def _human_enum_values ( enum ): return cls . __choices__ [ enum ] djstripe.enums.SubscriptionScheduleEndBehavior djstripe . enums . SubscriptionScheduleEndBehavior . cancel djstripe . enums . SubscriptionScheduleEndBehavior . release djstripe . enums . SubscriptionScheduleEndBehavior . humanize ( enum ) Source code in djstripe/enums.py def _human_enum_values ( enum ): return cls . __choices__ [ enum ] djstripe.enums.SubscriptionScheduleStatus djstripe . enums . SubscriptionScheduleStatus . active djstripe . enums . SubscriptionScheduleStatus . canceled djstripe . enums . SubscriptionScheduleStatus . completed djstripe . enums . SubscriptionScheduleStatus . not_started djstripe . enums . SubscriptionScheduleStatus . released djstripe . enums . SubscriptionScheduleStatus . humanize ( enum ) Source code in djstripe/enums.py def _human_enum_values ( enum ): return cls . __choices__ [ enum ] djstripe.enums.SubscriptionStatus djstripe . enums . SubscriptionStatus . active djstripe . enums . SubscriptionStatus . canceled djstripe . enums . SubscriptionStatus . incomplete djstripe . enums . SubscriptionStatus . incomplete_expired djstripe . enums . SubscriptionStatus . past_due djstripe . enums . SubscriptionStatus . trialing djstripe . enums . SubscriptionStatus . unpaid djstripe . enums . SubscriptionStatus . humanize ( enum ) Source code in djstripe/enums.py def _human_enum_values ( enum ): return cls . __choices__ [ enum ] djstripe.enums.TaxIdType djstripe . enums . TaxIdType . ae_trn djstripe . enums . TaxIdType . au_abn djstripe . enums . TaxIdType . br_cnp djstripe . enums . TaxIdType . br_cpf djstripe . enums . TaxIdType . ca_bn djstripe . enums . TaxIdType . ca_qst djstripe . enums . TaxIdType . ch_vat djstripe . enums . TaxIdType . cl_tin djstripe . enums . TaxIdType . es_cif djstripe . enums . TaxIdType . eu_vat djstripe . enums . TaxIdType . hk_br djstripe . enums . TaxIdType . id_npw djstripe . enums . TaxIdType . in_gst djstripe . enums . TaxIdType . jp_cn djstripe . enums . TaxIdType . jp_rn djstripe . enums . TaxIdType . kr_brn djstripe . enums . TaxIdType . li_uid djstripe . enums . TaxIdType . mx_rfc djstripe . enums . TaxIdType . my_frp djstripe . enums . TaxIdType . my_itn djstripe . enums . TaxIdType . my_sst djstripe . enums . TaxIdType . no_vat djstripe . enums . TaxIdType . nz_gst djstripe . enums . TaxIdType . ru_inn djstripe . enums . TaxIdType . ru_kpp djstripe . enums . TaxIdType . sa_vat djstripe . enums . TaxIdType . sg_gst djstripe . enums . TaxIdType . sg_uen djstripe . enums . TaxIdType . th_vat djstripe . enums . TaxIdType . tw_vat djstripe . enums . TaxIdType . unknown djstripe . enums . TaxIdType . us_ein djstripe . enums . TaxIdType . za_vat djstripe . enums . TaxIdType . humanize ( enum ) Source code in djstripe/enums.py def _human_enum_values ( enum ): return cls . __choices__ [ enum ] djstripe.enums.UsageAction djstripe . enums . UsageAction . increment djstripe . enums . UsageAction . set djstripe . enums . UsageAction . humanize ( enum ) Source code in djstripe/enums.py def _human_enum_values ( enum ): return cls . __choices__ [ enum ] djstripe.enums.WebhookEndpointStatus djstripe . enums . WebhookEndpointStatus . disabled djstripe . enums . WebhookEndpointStatus . enabled djstripe . enums . WebhookEndpointStatus . humanize ( enum ) Source code in djstripe/enums.py def _human_enum_values ( enum ): return cls . __choices__ [ enum ]","title":"Enumerations"},{"location":"reference/enums/#enumerations","text":"","title":"Enumerations"},{"location":"reference/enums/#djstripe.enums-classes","text":"","title":"Classes"},{"location":"reference/enums/#djstripe.enums.APIKeyType","text":"API Key Types (internal model only)","title":"APIKeyType"},{"location":"reference/enums/#djstripe.enums.APIKeyType.publishable","text":"","title":"publishable"},{"location":"reference/enums/#djstripe.enums.APIKeyType.restricted","text":"","title":"restricted"},{"location":"reference/enums/#djstripe.enums.APIKeyType.secret","text":"","title":"secret"},{"location":"reference/enums/#djstripe.enums.APIKeyType.humanize","text":"Source code in djstripe/enums.py def _human_enum_values ( enum ): return cls . __choices__ [ enum ]","title":"humanize()"},{"location":"reference/enums/#djstripe.enums.AccountType","text":"","title":"AccountType"},{"location":"reference/enums/#djstripe.enums.AccountType.custom","text":"","title":"custom"},{"location":"reference/enums/#djstripe.enums.AccountType.express","text":"","title":"express"},{"location":"reference/enums/#djstripe.enums.AccountType.standard","text":"","title":"standard"},{"location":"reference/enums/#djstripe.enums.AccountType.humanize","text":"Source code in djstripe/enums.py def _human_enum_values ( enum ): return cls . __choices__ [ enum ]","title":"humanize()"},{"location":"reference/enums/#djstripe.enums.ApiErrorCode","text":"Charge failure error codes. https://stripe.com/docs/error-codes","title":"ApiErrorCode"},{"location":"reference/enums/#djstripe.enums.ApiErrorCode.account_already_exists","text":"","title":"account_already_exists"},{"location":"reference/enums/#djstripe.enums.ApiErrorCode.account_country_invalid_address","text":"","title":"account_country_invalid_address"},{"location":"reference/enums/#djstripe.enums.ApiErrorCode.account_invalid","text":"","title":"account_invalid"},{"location":"reference/enums/#djstripe.enums.ApiErrorCode.account_number_invalid","text":"","title":"account_number_invalid"},{"location":"reference/enums/#djstripe.enums.ApiErrorCode.alipay_upgrade_required","text":"","title":"alipay_upgrade_required"},{"location":"reference/enums/#djstripe.enums.ApiErrorCode.amount_too_large","text":"","title":"amount_too_large"},{"location":"reference/enums/#djstripe.enums.ApiErrorCode.amount_too_small","text":"","title":"amount_too_small"},{"location":"reference/enums/#djstripe.enums.ApiErrorCode.api_key_expired","text":"","title":"api_key_expired"},{"location":"reference/enums/#djstripe.enums.ApiErrorCode.balance_insufficient","text":"","title":"balance_insufficient"},{"location":"reference/enums/#djstripe.enums.ApiErrorCode.bank_account_exists","text":"","title":"bank_account_exists"},{"location":"reference/enums/#djstripe.enums.ApiErrorCode.bank_account_unusable","text":"","title":"bank_account_unusable"},{"location":"reference/enums/#djstripe.enums.ApiErrorCode.bank_account_unverified","text":"","title":"bank_account_unverified"},{"location":"reference/enums/#djstripe.enums.ApiErrorCode.bitcoin_upgrade_required","text":"","title":"bitcoin_upgrade_required"},{"location":"reference/enums/#djstripe.enums.ApiErrorCode.card_declined","text":"","title":"card_declined"},{"location":"reference/enums/#djstripe.enums.ApiErrorCode.charge_already_captured","text":"","title":"charge_already_captured"},{"location":"reference/enums/#djstripe.enums.ApiErrorCode.charge_already_refunded","text":"","title":"charge_already_refunded"},{"location":"reference/enums/#djstripe.enums.ApiErrorCode.charge_disputed","text":"","title":"charge_disputed"},{"location":"reference/enums/#djstripe.enums.ApiErrorCode.charge_exceeds_source_limit","text":"","title":"charge_exceeds_source_limit"},{"location":"reference/enums/#djstripe.enums.ApiErrorCode.charge_expired_for_capture","text":"","title":"charge_expired_for_capture"},{"location":"reference/enums/#djstripe.enums.ApiErrorCode.country_unsupported","text":"","title":"country_unsupported"},{"location":"reference/enums/#djstripe.enums.ApiErrorCode.coupon_expired","text":"","title":"coupon_expired"},{"location":"reference/enums/#djstripe.enums.ApiErrorCode.customer_max_subscriptions","text":"","title":"customer_max_subscriptions"},{"location":"reference/enums/#djstripe.enums.ApiErrorCode.email_invalid","text":"","title":"email_invalid"},{"location":"reference/enums/#djstripe.enums.ApiErrorCode.expired_card","text":"","title":"expired_card"},{"location":"reference/enums/#djstripe.enums.ApiErrorCode.idempotency_key_in_use","text":"","title":"idempotency_key_in_use"},{"location":"reference/enums/#djstripe.enums.ApiErrorCode.incorrect_address","text":"","title":"incorrect_address"},{"location":"reference/enums/#djstripe.enums.ApiErrorCode.incorrect_cvc","text":"","title":"incorrect_cvc"},{"location":"reference/enums/#djstripe.enums.ApiErrorCode.incorrect_number","text":"","title":"incorrect_number"},{"location":"reference/enums/#djstripe.enums.ApiErrorCode.incorrect_zip","text":"","title":"incorrect_zip"},{"location":"reference/enums/#djstripe.enums.ApiErrorCode.instant_payouts_unsupported","text":"","title":"instant_payouts_unsupported"},{"location":"reference/enums/#djstripe.enums.ApiErrorCode.invalid_card_type","text":"","title":"invalid_card_type"},{"location":"reference/enums/#djstripe.enums.ApiErrorCode.invalid_charge_amount","text":"","title":"invalid_charge_amount"},{"location":"reference/enums/#djstripe.enums.ApiErrorCode.invalid_cvc","text":"","title":"invalid_cvc"},{"location":"reference/enums/#djstripe.enums.ApiErrorCode.invalid_expiry_month","text":"","title":"invalid_expiry_month"},{"location":"reference/enums/#djstripe.enums.ApiErrorCode.invalid_expiry_year","text":"","title":"invalid_expiry_year"},{"location":"reference/enums/#djstripe.enums.ApiErrorCode.invalid_number","text":"","title":"invalid_number"},{"location":"reference/enums/#djstripe.enums.ApiErrorCode.invalid_source_usage","text":"","title":"invalid_source_usage"},{"location":"reference/enums/#djstripe.enums.ApiErrorCode.invalid_swipe_data","text":"","title":"invalid_swipe_data"},{"location":"reference/enums/#djstripe.enums.ApiErrorCode.invoice_no_customer_line_items","text":"","title":"invoice_no_customer_line_items"},{"location":"reference/enums/#djstripe.enums.ApiErrorCode.invoice_no_subscription_line_items","text":"","title":"invoice_no_subscription_line_items"},{"location":"reference/enums/#djstripe.enums.ApiErrorCode.invoice_not_editable","text":"","title":"invoice_not_editable"},{"location":"reference/enums/#djstripe.enums.ApiErrorCode.invoice_upcoming_none","text":"","title":"invoice_upcoming_none"},{"location":"reference/enums/#djstripe.enums.ApiErrorCode.livemode_mismatch","text":"","title":"livemode_mismatch"},{"location":"reference/enums/#djstripe.enums.ApiErrorCode.missing","text":"","title":"missing"},{"location":"reference/enums/#djstripe.enums.ApiErrorCode.not_allowed_on_standard_account","text":"","title":"not_allowed_on_standard_account"},{"location":"reference/enums/#djstripe.enums.ApiErrorCode.order_creation_failed","text":"","title":"order_creation_failed"},{"location":"reference/enums/#djstripe.enums.ApiErrorCode.order_required_settings","text":"","title":"order_required_settings"},{"location":"reference/enums/#djstripe.enums.ApiErrorCode.order_status_invalid","text":"","title":"order_status_invalid"},{"location":"reference/enums/#djstripe.enums.ApiErrorCode.order_upstream_timeout","text":"","title":"order_upstream_timeout"},{"location":"reference/enums/#djstripe.enums.ApiErrorCode.out_of_inventory","text":"","title":"out_of_inventory"},{"location":"reference/enums/#djstripe.enums.ApiErrorCode.parameter_invalid_empty","text":"","title":"parameter_invalid_empty"},{"location":"reference/enums/#djstripe.enums.ApiErrorCode.parameter_invalid_integer","text":"","title":"parameter_invalid_integer"},{"location":"reference/enums/#djstripe.enums.ApiErrorCode.parameter_invalid_string_blank","text":"","title":"parameter_invalid_string_blank"},{"location":"reference/enums/#djstripe.enums.ApiErrorCode.parameter_invalid_string_empty","text":"","title":"parameter_invalid_string_empty"},{"location":"reference/enums/#djstripe.enums.ApiErrorCode.parameter_missing","text":"","title":"parameter_missing"},{"location":"reference/enums/#djstripe.enums.ApiErrorCode.parameter_unknown","text":"","title":"parameter_unknown"},{"location":"reference/enums/#djstripe.enums.ApiErrorCode.parameters_exclusive","text":"","title":"parameters_exclusive"},{"location":"reference/enums/#djstripe.enums.ApiErrorCode.payment_intent_authentication_failure","text":"","title":"payment_intent_authentication_failure"},{"location":"reference/enums/#djstripe.enums.ApiErrorCode.payment_intent_incompatible_payment_method","text":"","title":"payment_intent_incompatible_payment_method"},{"location":"reference/enums/#djstripe.enums.ApiErrorCode.payment_intent_invalid_parameter","text":"","title":"payment_intent_invalid_parameter"},{"location":"reference/enums/#djstripe.enums.ApiErrorCode.payment_intent_payment_attempt_failed","text":"","title":"payment_intent_payment_attempt_failed"},{"location":"reference/enums/#djstripe.enums.ApiErrorCode.payment_intent_unexpected_state","text":"","title":"payment_intent_unexpected_state"},{"location":"reference/enums/#djstripe.enums.ApiErrorCode.payment_method_unactivated","text":"","title":"payment_method_unactivated"},{"location":"reference/enums/#djstripe.enums.ApiErrorCode.payment_method_unexpected_state","text":"","title":"payment_method_unexpected_state"},{"location":"reference/enums/#djstripe.enums.ApiErrorCode.payouts_not_allowed","text":"","title":"payouts_not_allowed"},{"location":"reference/enums/#djstripe.enums.ApiErrorCode.platform_api_key_expired","text":"","title":"platform_api_key_expired"},{"location":"reference/enums/#djstripe.enums.ApiErrorCode.postal_code_invalid","text":"","title":"postal_code_invalid"},{"location":"reference/enums/#djstripe.enums.ApiErrorCode.processing_error","text":"","title":"processing_error"},{"location":"reference/enums/#djstripe.enums.ApiErrorCode.product_inactive","text":"","title":"product_inactive"},{"location":"reference/enums/#djstripe.enums.ApiErrorCode.rate_limit","text":"","title":"rate_limit"},{"location":"reference/enums/#djstripe.enums.ApiErrorCode.resource_already_exists","text":"","title":"resource_already_exists"},{"location":"reference/enums/#djstripe.enums.ApiErrorCode.resource_missing","text":"","title":"resource_missing"},{"location":"reference/enums/#djstripe.enums.ApiErrorCode.routing_number_invalid","text":"","title":"routing_number_invalid"},{"location":"reference/enums/#djstripe.enums.ApiErrorCode.secret_key_required","text":"","title":"secret_key_required"},{"location":"reference/enums/#djstripe.enums.ApiErrorCode.sepa_unsupported_account","text":"","title":"sepa_unsupported_account"},{"location":"reference/enums/#djstripe.enums.ApiErrorCode.shipping_calculation_failed","text":"","title":"shipping_calculation_failed"},{"location":"reference/enums/#djstripe.enums.ApiErrorCode.sku_inactive","text":"","title":"sku_inactive"},{"location":"reference/enums/#djstripe.enums.ApiErrorCode.state_unsupported","text":"","title":"state_unsupported"},{"location":"reference/enums/#djstripe.enums.ApiErrorCode.tax_id_invalid","text":"","title":"tax_id_invalid"},{"location":"reference/enums/#djstripe.enums.ApiErrorCode.taxes_calculation_failed","text":"","title":"taxes_calculation_failed"},{"location":"reference/enums/#djstripe.enums.ApiErrorCode.testmode_charges_only","text":"","title":"testmode_charges_only"},{"location":"reference/enums/#djstripe.enums.ApiErrorCode.tls_version_unsupported","text":"","title":"tls_version_unsupported"},{"location":"reference/enums/#djstripe.enums.ApiErrorCode.token_already_used","text":"","title":"token_already_used"},{"location":"reference/enums/#djstripe.enums.ApiErrorCode.token_in_use","text":"","title":"token_in_use"},{"location":"reference/enums/#djstripe.enums.ApiErrorCode.transfers_not_allowed","text":"","title":"transfers_not_allowed"},{"location":"reference/enums/#djstripe.enums.ApiErrorCode.upstream_order_creation_failed","text":"","title":"upstream_order_creation_failed"},{"location":"reference/enums/#djstripe.enums.ApiErrorCode.url_invalid","text":"","title":"url_invalid"},{"location":"reference/enums/#djstripe.enums.ApiErrorCode.humanize","text":"Source code in djstripe/enums.py def _human_enum_values ( enum ): return cls . __choices__ [ enum ]","title":"humanize()"},{"location":"reference/enums/#djstripe.enums.BalanceTransactionReportingCategory","text":"https://stripe.com/docs/reports/reporting-categories","title":"BalanceTransactionReportingCategory"},{"location":"reference/enums/#djstripe.enums.BalanceTransactionReportingCategory.advance","text":"","title":"advance"},{"location":"reference/enums/#djstripe.enums.BalanceTransactionReportingCategory.advance_funding","text":"","title":"advance_funding"},{"location":"reference/enums/#djstripe.enums.BalanceTransactionReportingCategory.anticipation_repayment","text":"","title":"anticipation_repayment"},{"location":"reference/enums/#djstripe.enums.BalanceTransactionReportingCategory.charge","text":"","title":"charge"},{"location":"reference/enums/#djstripe.enums.BalanceTransactionReportingCategory.charge_failure","text":"","title":"charge_failure"},{"location":"reference/enums/#djstripe.enums.BalanceTransactionReportingCategory.connect_collection_transfer","text":"","title":"connect_collection_transfer"},{"location":"reference/enums/#djstripe.enums.BalanceTransactionReportingCategory.connect_reserved_funds","text":"","title":"connect_reserved_funds"},{"location":"reference/enums/#djstripe.enums.BalanceTransactionReportingCategory.dispute","text":"","title":"dispute"},{"location":"reference/enums/#djstripe.enums.BalanceTransactionReportingCategory.dispute_reversal","text":"","title":"dispute_reversal"},{"location":"reference/enums/#djstripe.enums.BalanceTransactionReportingCategory.fee","text":"","title":"fee"},{"location":"reference/enums/#djstripe.enums.BalanceTransactionReportingCategory.issuing_authorization_hold","text":"","title":"issuing_authorization_hold"},{"location":"reference/enums/#djstripe.enums.BalanceTransactionReportingCategory.issuing_authorization_release","text":"","title":"issuing_authorization_release"},{"location":"reference/enums/#djstripe.enums.BalanceTransactionReportingCategory.issuing_dispute","text":"","title":"issuing_dispute"},{"location":"reference/enums/#djstripe.enums.BalanceTransactionReportingCategory.issuing_transaction","text":"","title":"issuing_transaction"},{"location":"reference/enums/#djstripe.enums.BalanceTransactionReportingCategory.other_adjustment","text":"","title":"other_adjustment"},{"location":"reference/enums/#djstripe.enums.BalanceTransactionReportingCategory.partial_capture_reversal","text":"","title":"partial_capture_reversal"},{"location":"reference/enums/#djstripe.enums.BalanceTransactionReportingCategory.payout","text":"","title":"payout"},{"location":"reference/enums/#djstripe.enums.BalanceTransactionReportingCategory.payout_reversal","text":"","title":"payout_reversal"},{"location":"reference/enums/#djstripe.enums.BalanceTransactionReportingCategory.platform_earning","text":"","title":"platform_earning"},{"location":"reference/enums/#djstripe.enums.BalanceTransactionReportingCategory.platform_earning_refund","text":"","title":"platform_earning_refund"},{"location":"reference/enums/#djstripe.enums.BalanceTransactionReportingCategory.refund","text":"","title":"refund"},{"location":"reference/enums/#djstripe.enums.BalanceTransactionReportingCategory.refund_failure","text":"","title":"refund_failure"},{"location":"reference/enums/#djstripe.enums.BalanceTransactionReportingCategory.risk_reserved_funds","text":"","title":"risk_reserved_funds"},{"location":"reference/enums/#djstripe.enums.BalanceTransactionReportingCategory.tax","text":"","title":"tax"},{"location":"reference/enums/#djstripe.enums.BalanceTransactionReportingCategory.topup","text":"","title":"topup"},{"location":"reference/enums/#djstripe.enums.BalanceTransactionReportingCategory.topup_reversal","text":"","title":"topup_reversal"},{"location":"reference/enums/#djstripe.enums.BalanceTransactionReportingCategory.transfer","text":"","title":"transfer"},{"location":"reference/enums/#djstripe.enums.BalanceTransactionReportingCategory.transfer_reversal","text":"","title":"transfer_reversal"},{"location":"reference/enums/#djstripe.enums.BalanceTransactionReportingCategory.humanize","text":"Source code in djstripe/enums.py def _human_enum_values ( enum ): return cls . __choices__ [ enum ]","title":"humanize()"},{"location":"reference/enums/#djstripe.enums.BalanceTransactionStatus","text":"","title":"BalanceTransactionStatus"},{"location":"reference/enums/#djstripe.enums.BalanceTransactionStatus.available","text":"","title":"available"},{"location":"reference/enums/#djstripe.enums.BalanceTransactionStatus.pending","text":"","title":"pending"},{"location":"reference/enums/#djstripe.enums.BalanceTransactionStatus.humanize","text":"Source code in djstripe/enums.py def _human_enum_values ( enum ): return cls . __choices__ [ enum ]","title":"humanize()"},{"location":"reference/enums/#djstripe.enums.BalanceTransactionType","text":"","title":"BalanceTransactionType"},{"location":"reference/enums/#djstripe.enums.BalanceTransactionType.adjustment","text":"","title":"adjustment"},{"location":"reference/enums/#djstripe.enums.BalanceTransactionType.advance","text":"","title":"advance"},{"location":"reference/enums/#djstripe.enums.BalanceTransactionType.advance_funding","text":"","title":"advance_funding"},{"location":"reference/enums/#djstripe.enums.BalanceTransactionType.anticipation_repayment","text":"","title":"anticipation_repayment"},{"location":"reference/enums/#djstripe.enums.BalanceTransactionType.application_fee","text":"","title":"application_fee"},{"location":"reference/enums/#djstripe.enums.BalanceTransactionType.application_fee_refund","text":"","title":"application_fee_refund"},{"location":"reference/enums/#djstripe.enums.BalanceTransactionType.balance_transfer_inbound","text":"","title":"balance_transfer_inbound"},{"location":"reference/enums/#djstripe.enums.BalanceTransactionType.balance_transfer_outbound","text":"","title":"balance_transfer_outbound"},{"location":"reference/enums/#djstripe.enums.BalanceTransactionType.charge","text":"","title":"charge"},{"location":"reference/enums/#djstripe.enums.BalanceTransactionType.connect_collection_transfer","text":"","title":"connect_collection_transfer"},{"location":"reference/enums/#djstripe.enums.BalanceTransactionType.contribution","text":"","title":"contribution"},{"location":"reference/enums/#djstripe.enums.BalanceTransactionType.issuing_authorization_hold","text":"","title":"issuing_authorization_hold"},{"location":"reference/enums/#djstripe.enums.BalanceTransactionType.issuing_authorization_release","text":"","title":"issuing_authorization_release"},{"location":"reference/enums/#djstripe.enums.BalanceTransactionType.issuing_dispute","text":"","title":"issuing_dispute"},{"location":"reference/enums/#djstripe.enums.BalanceTransactionType.issuing_transaction","text":"","title":"issuing_transaction"},{"location":"reference/enums/#djstripe.enums.BalanceTransactionType.network_cost","text":"","title":"network_cost"},{"location":"reference/enums/#djstripe.enums.BalanceTransactionType.payment","text":"","title":"payment"},{"location":"reference/enums/#djstripe.enums.BalanceTransactionType.payment_failure_refund","text":"","title":"payment_failure_refund"},{"location":"reference/enums/#djstripe.enums.BalanceTransactionType.payment_refund","text":"","title":"payment_refund"},{"location":"reference/enums/#djstripe.enums.BalanceTransactionType.payout","text":"","title":"payout"},{"location":"reference/enums/#djstripe.enums.BalanceTransactionType.payout_cancel","text":"","title":"payout_cancel"},{"location":"reference/enums/#djstripe.enums.BalanceTransactionType.payout_failure","text":"","title":"payout_failure"},{"location":"reference/enums/#djstripe.enums.BalanceTransactionType.refund","text":"","title":"refund"},{"location":"reference/enums/#djstripe.enums.BalanceTransactionType.refund_failure","text":"","title":"refund_failure"},{"location":"reference/enums/#djstripe.enums.BalanceTransactionType.reserve_transaction","text":"","title":"reserve_transaction"},{"location":"reference/enums/#djstripe.enums.BalanceTransactionType.reserved_funds","text":"","title":"reserved_funds"},{"location":"reference/enums/#djstripe.enums.BalanceTransactionType.stripe_fee","text":"","title":"stripe_fee"},{"location":"reference/enums/#djstripe.enums.BalanceTransactionType.stripe_fx_fee","text":"","title":"stripe_fx_fee"},{"location":"reference/enums/#djstripe.enums.BalanceTransactionType.tax_fee","text":"","title":"tax_fee"},{"location":"reference/enums/#djstripe.enums.BalanceTransactionType.topup","text":"","title":"topup"},{"location":"reference/enums/#djstripe.enums.BalanceTransactionType.topup_reversal","text":"","title":"topup_reversal"},{"location":"reference/enums/#djstripe.enums.BalanceTransactionType.transfer","text":"","title":"transfer"},{"location":"reference/enums/#djstripe.enums.BalanceTransactionType.transfer_cancel","text":"","title":"transfer_cancel"},{"location":"reference/enums/#djstripe.enums.BalanceTransactionType.transfer_failure","text":"","title":"transfer_failure"},{"location":"reference/enums/#djstripe.enums.BalanceTransactionType.transfer_refund","text":"","title":"transfer_refund"},{"location":"reference/enums/#djstripe.enums.BalanceTransactionType.validation","text":"","title":"validation"},{"location":"reference/enums/#djstripe.enums.BalanceTransactionType.humanize","text":"Source code in djstripe/enums.py def _human_enum_values ( enum ): return cls . __choices__ [ enum ]","title":"humanize()"},{"location":"reference/enums/#djstripe.enums.BankAccountHolderType","text":"","title":"BankAccountHolderType"},{"location":"reference/enums/#djstripe.enums.BankAccountHolderType.company","text":"","title":"company"},{"location":"reference/enums/#djstripe.enums.BankAccountHolderType.individual","text":"","title":"individual"},{"location":"reference/enums/#djstripe.enums.BankAccountHolderType.humanize","text":"Source code in djstripe/enums.py def _human_enum_values ( enum ): return cls . __choices__ [ enum ]","title":"humanize()"},{"location":"reference/enums/#djstripe.enums.BankAccountStatus","text":"","title":"BankAccountStatus"},{"location":"reference/enums/#djstripe.enums.BankAccountStatus.errored","text":"","title":"errored"},{"location":"reference/enums/#djstripe.enums.BankAccountStatus.new","text":"","title":"new"},{"location":"reference/enums/#djstripe.enums.BankAccountStatus.validated","text":"","title":"validated"},{"location":"reference/enums/#djstripe.enums.BankAccountStatus.verification_failed","text":"","title":"verification_failed"},{"location":"reference/enums/#djstripe.enums.BankAccountStatus.verified","text":"","title":"verified"},{"location":"reference/enums/#djstripe.enums.BankAccountStatus.humanize","text":"Source code in djstripe/enums.py def _human_enum_values ( enum ): return cls . __choices__ [ enum ]","title":"humanize()"},{"location":"reference/enums/#djstripe.enums.BillingScheme","text":"","title":"BillingScheme"},{"location":"reference/enums/#djstripe.enums.BillingScheme.per_unit","text":"","title":"per_unit"},{"location":"reference/enums/#djstripe.enums.BillingScheme.tiered","text":"","title":"tiered"},{"location":"reference/enums/#djstripe.enums.BillingScheme.humanize","text":"Source code in djstripe/enums.py def _human_enum_values ( enum ): return cls . __choices__ [ enum ]","title":"humanize()"},{"location":"reference/enums/#djstripe.enums.BusinessType","text":"","title":"BusinessType"},{"location":"reference/enums/#djstripe.enums.BusinessType.company","text":"","title":"company"},{"location":"reference/enums/#djstripe.enums.BusinessType.individual","text":"","title":"individual"},{"location":"reference/enums/#djstripe.enums.BusinessType.humanize","text":"Source code in djstripe/enums.py def _human_enum_values ( enum ): return cls . __choices__ [ enum ]","title":"humanize()"},{"location":"reference/enums/#djstripe.enums.CaptureMethod","text":"","title":"CaptureMethod"},{"location":"reference/enums/#djstripe.enums.CaptureMethod.automatic","text":"","title":"automatic"},{"location":"reference/enums/#djstripe.enums.CaptureMethod.manual","text":"","title":"manual"},{"location":"reference/enums/#djstripe.enums.CaptureMethod.humanize","text":"Source code in djstripe/enums.py def _human_enum_values ( enum ): return cls . __choices__ [ enum ]","title":"humanize()"},{"location":"reference/enums/#djstripe.enums.CardBrand","text":"","title":"CardBrand"},{"location":"reference/enums/#djstripe.enums.CardBrand.AmericanExpress","text":"","title":"AmericanExpress"},{"location":"reference/enums/#djstripe.enums.CardBrand.DinersClub","text":"","title":"DinersClub"},{"location":"reference/enums/#djstripe.enums.CardBrand.Discover","text":"","title":"Discover"},{"location":"reference/enums/#djstripe.enums.CardBrand.JCB","text":"","title":"JCB"},{"location":"reference/enums/#djstripe.enums.CardBrand.MasterCard","text":"","title":"MasterCard"},{"location":"reference/enums/#djstripe.enums.CardBrand.UnionPay","text":"","title":"UnionPay"},{"location":"reference/enums/#djstripe.enums.CardBrand.Unknown","text":"","title":"Unknown"},{"location":"reference/enums/#djstripe.enums.CardBrand.Visa","text":"","title":"Visa"},{"location":"reference/enums/#djstripe.enums.CardBrand.humanize","text":"Source code in djstripe/enums.py def _human_enum_values ( enum ): return cls . __choices__ [ enum ]","title":"humanize()"},{"location":"reference/enums/#djstripe.enums.CardCheckResult","text":"","title":"CardCheckResult"},{"location":"reference/enums/#djstripe.enums.CardCheckResult.fail","text":"","title":"fail"},{"location":"reference/enums/#djstripe.enums.CardCheckResult.pass_","text":"","title":"pass_"},{"location":"reference/enums/#djstripe.enums.CardCheckResult.unavailable","text":"","title":"unavailable"},{"location":"reference/enums/#djstripe.enums.CardCheckResult.unchecked","text":"","title":"unchecked"},{"location":"reference/enums/#djstripe.enums.CardCheckResult.humanize","text":"Source code in djstripe/enums.py def _human_enum_values ( enum ): return cls . __choices__ [ enum ]","title":"humanize()"},{"location":"reference/enums/#djstripe.enums.CardFundingType","text":"","title":"CardFundingType"},{"location":"reference/enums/#djstripe.enums.CardFundingType.credit","text":"","title":"credit"},{"location":"reference/enums/#djstripe.enums.CardFundingType.debit","text":"","title":"debit"},{"location":"reference/enums/#djstripe.enums.CardFundingType.prepaid","text":"","title":"prepaid"},{"location":"reference/enums/#djstripe.enums.CardFundingType.unknown","text":"","title":"unknown"},{"location":"reference/enums/#djstripe.enums.CardFundingType.humanize","text":"Source code in djstripe/enums.py def _human_enum_values ( enum ): return cls . __choices__ [ enum ]","title":"humanize()"},{"location":"reference/enums/#djstripe.enums.CardTokenizationMethod","text":"","title":"CardTokenizationMethod"},{"location":"reference/enums/#djstripe.enums.CardTokenizationMethod.android_pay","text":"","title":"android_pay"},{"location":"reference/enums/#djstripe.enums.CardTokenizationMethod.apple_pay","text":"","title":"apple_pay"},{"location":"reference/enums/#djstripe.enums.CardTokenizationMethod.humanize","text":"Source code in djstripe/enums.py def _human_enum_values ( enum ): return cls . __choices__ [ enum ]","title":"humanize()"},{"location":"reference/enums/#djstripe.enums.ChargeStatus","text":"","title":"ChargeStatus"},{"location":"reference/enums/#djstripe.enums.ChargeStatus.failed","text":"","title":"failed"},{"location":"reference/enums/#djstripe.enums.ChargeStatus.pending","text":"","title":"pending"},{"location":"reference/enums/#djstripe.enums.ChargeStatus.succeeded","text":"","title":"succeeded"},{"location":"reference/enums/#djstripe.enums.ChargeStatus.humanize","text":"Source code in djstripe/enums.py def _human_enum_values ( enum ): return cls . __choices__ [ enum ]","title":"humanize()"},{"location":"reference/enums/#djstripe.enums.ConfirmationMethod","text":"","title":"ConfirmationMethod"},{"location":"reference/enums/#djstripe.enums.ConfirmationMethod.automatic","text":"","title":"automatic"},{"location":"reference/enums/#djstripe.enums.ConfirmationMethod.manual","text":"","title":"manual"},{"location":"reference/enums/#djstripe.enums.ConfirmationMethod.humanize","text":"Source code in djstripe/enums.py def _human_enum_values ( enum ): return cls . __choices__ [ enum ]","title":"humanize()"},{"location":"reference/enums/#djstripe.enums.CouponDuration","text":"","title":"CouponDuration"},{"location":"reference/enums/#djstripe.enums.CouponDuration.forever","text":"","title":"forever"},{"location":"reference/enums/#djstripe.enums.CouponDuration.once","text":"","title":"once"},{"location":"reference/enums/#djstripe.enums.CouponDuration.repeating","text":"","title":"repeating"},{"location":"reference/enums/#djstripe.enums.CouponDuration.humanize","text":"Source code in djstripe/enums.py def _human_enum_values ( enum ): return cls . __choices__ [ enum ]","title":"humanize()"},{"location":"reference/enums/#djstripe.enums.CustomerTaxExempt","text":"","title":"CustomerTaxExempt"},{"location":"reference/enums/#djstripe.enums.CustomerTaxExempt.exempt","text":"","title":"exempt"},{"location":"reference/enums/#djstripe.enums.CustomerTaxExempt.none","text":"","title":"none"},{"location":"reference/enums/#djstripe.enums.CustomerTaxExempt.reverse","text":"","title":"reverse"},{"location":"reference/enums/#djstripe.enums.CustomerTaxExempt.humanize","text":"Source code in djstripe/enums.py def _human_enum_values ( enum ): return cls . __choices__ [ enum ]","title":"humanize()"},{"location":"reference/enums/#djstripe.enums.DisputeReason","text":"","title":"DisputeReason"},{"location":"reference/enums/#djstripe.enums.DisputeReason.bank_cannot_process","text":"","title":"bank_cannot_process"},{"location":"reference/enums/#djstripe.enums.DisputeReason.credit_not_processed","text":"","title":"credit_not_processed"},{"location":"reference/enums/#djstripe.enums.DisputeReason.customer_initiated","text":"","title":"customer_initiated"},{"location":"reference/enums/#djstripe.enums.DisputeReason.debit_not_authorized","text":"","title":"debit_not_authorized"},{"location":"reference/enums/#djstripe.enums.DisputeReason.duplicate","text":"","title":"duplicate"},{"location":"reference/enums/#djstripe.enums.DisputeReason.fraudulent","text":"","title":"fraudulent"},{"location":"reference/enums/#djstripe.enums.DisputeReason.general","text":"","title":"general"},{"location":"reference/enums/#djstripe.enums.DisputeReason.incorrect_account_details","text":"","title":"incorrect_account_details"},{"location":"reference/enums/#djstripe.enums.DisputeReason.insufficient_funds","text":"","title":"insufficient_funds"},{"location":"reference/enums/#djstripe.enums.DisputeReason.product_not_received","text":"","title":"product_not_received"},{"location":"reference/enums/#djstripe.enums.DisputeReason.product_unacceptable","text":"","title":"product_unacceptable"},{"location":"reference/enums/#djstripe.enums.DisputeReason.subscription_canceled","text":"","title":"subscription_canceled"},{"location":"reference/enums/#djstripe.enums.DisputeReason.unrecognized","text":"","title":"unrecognized"},{"location":"reference/enums/#djstripe.enums.DisputeReason.humanize","text":"Source code in djstripe/enums.py def _human_enum_values ( enum ): return cls . __choices__ [ enum ]","title":"humanize()"},{"location":"reference/enums/#djstripe.enums.DisputeStatus","text":"","title":"DisputeStatus"},{"location":"reference/enums/#djstripe.enums.DisputeStatus.charge_refunded","text":"","title":"charge_refunded"},{"location":"reference/enums/#djstripe.enums.DisputeStatus.lost","text":"","title":"lost"},{"location":"reference/enums/#djstripe.enums.DisputeStatus.needs_response","text":"","title":"needs_response"},{"location":"reference/enums/#djstripe.enums.DisputeStatus.under_review","text":"","title":"under_review"},{"location":"reference/enums/#djstripe.enums.DisputeStatus.warning_closed","text":"","title":"warning_closed"},{"location":"reference/enums/#djstripe.enums.DisputeStatus.warning_needs_response","text":"","title":"warning_needs_response"},{"location":"reference/enums/#djstripe.enums.DisputeStatus.warning_under_review","text":"","title":"warning_under_review"},{"location":"reference/enums/#djstripe.enums.DisputeStatus.won","text":"","title":"won"},{"location":"reference/enums/#djstripe.enums.DisputeStatus.humanize","text":"Source code in djstripe/enums.py def _human_enum_values ( enum ): return cls . __choices__ [ enum ]","title":"humanize()"},{"location":"reference/enums/#djstripe.enums.DjstripePaymentMethodType","text":"A djstripe-specific enum for the DjStripePaymentMethod model.","title":"DjstripePaymentMethodType"},{"location":"reference/enums/#djstripe.enums.DjstripePaymentMethodType.alipay_account","text":"","title":"alipay_account"},{"location":"reference/enums/#djstripe.enums.DjstripePaymentMethodType.bank_account","text":"","title":"bank_account"},{"location":"reference/enums/#djstripe.enums.DjstripePaymentMethodType.card","text":"","title":"card"},{"location":"reference/enums/#djstripe.enums.DjstripePaymentMethodType.source","text":"","title":"source"},{"location":"reference/enums/#djstripe.enums.DjstripePaymentMethodType.humanize","text":"Source code in djstripe/enums.py def _human_enum_values ( enum ): return cls . __choices__ [ enum ]","title":"humanize()"},{"location":"reference/enums/#djstripe.enums.Enum","text":"","title":"Enum"},{"location":"reference/enums/#djstripe.enums.Enum.humanize","text":"Source code in djstripe/enums.py def _human_enum_values ( enum ): return cls . __choices__ [ enum ]","title":"humanize()"},{"location":"reference/enums/#djstripe.enums.EnumMetaClass","text":"","title":"EnumMetaClass"},{"location":"reference/enums/#djstripe.enums.EnumMetaClass-methods","text":"","title":"Methods"},{"location":"reference/enums/#djstripe.enums.EnumMetaClass.__init__","text":"Source code in djstripe/enums.py def __init__ ( cls , name , bases , classdict ): def _human_enum_values ( enum ): return cls . __choices__ [ enum ] # add a class attribute cls . humanize = _human_enum_values","title":"__init__()"},{"location":"reference/enums/#djstripe.enums.EnumMetaClass.__new__","text":"Create and return a new object. See help(type) for accurate signature. Source code in djstripe/enums.py def __new__ ( cls , name , bases , classdict ): members = [] keys = {} choices = OrderedDict () for key , value in classdict . items (): if key . startswith ( \"__\" ): continue members . append ( key ) if isinstance ( value , tuple ): value , alias = value keys [ alias ] = key else : alias = None keys [ alias or key ] = key choices [ alias or key ] = value for k , v in keys . items (): classdict [ v ] = k classdict [ \"__choices__\" ] = choices classdict [ \"__members__\" ] = members # Note: Differences between Python 2.x and Python 3.x force us to # explicitly use unicode here, and to explicitly sort the list. In # Python 2.x, class members are unordered and so the ordering will # vary on different systems based on internal hashing. Without this # Django will continually require new no-op migrations. classdict [ \"choices\" ] = tuple ( ( str ( k ), str ( v )) for k , v in sorted ( choices . items (), key = operator . itemgetter ( 0 )) ) return type . __new__ ( cls , name , bases , classdict )","title":"__new__()"},{"location":"reference/enums/#djstripe.enums.EnumMetaClass.__prepare__","text":"prepare () -> dict used to create the namespace for the class statement Source code in djstripe/enums.py @classmethod def __prepare__ ( cls , name , bases ): return OrderedDict ()","title":"__prepare__()"},{"location":"reference/enums/#djstripe.enums.FilePurpose","text":"","title":"FilePurpose"},{"location":"reference/enums/#djstripe.enums.FilePurpose.account_requirement","text":"","title":"account_requirement"},{"location":"reference/enums/#djstripe.enums.FilePurpose.additional_verification","text":"","title":"additional_verification"},{"location":"reference/enums/#djstripe.enums.FilePurpose.business_icon","text":"","title":"business_icon"},{"location":"reference/enums/#djstripe.enums.FilePurpose.business_logo","text":"","title":"business_logo"},{"location":"reference/enums/#djstripe.enums.FilePurpose.customer_signature","text":"","title":"customer_signature"},{"location":"reference/enums/#djstripe.enums.FilePurpose.dispute_evidence","text":"","title":"dispute_evidence"},{"location":"reference/enums/#djstripe.enums.FilePurpose.document_provider_identity_document","text":"","title":"document_provider_identity_document"},{"location":"reference/enums/#djstripe.enums.FilePurpose.finance_report_run","text":"","title":"finance_report_run"},{"location":"reference/enums/#djstripe.enums.FilePurpose.identity_document","text":"","title":"identity_document"},{"location":"reference/enums/#djstripe.enums.FilePurpose.identity_document_downloadable","text":"","title":"identity_document_downloadable"},{"location":"reference/enums/#djstripe.enums.FilePurpose.invoice_statement","text":"","title":"invoice_statement"},{"location":"reference/enums/#djstripe.enums.FilePurpose.pci_document","text":"","title":"pci_document"},{"location":"reference/enums/#djstripe.enums.FilePurpose.selfie","text":"","title":"selfie"},{"location":"reference/enums/#djstripe.enums.FilePurpose.sigma_scheduled_query","text":"","title":"sigma_scheduled_query"},{"location":"reference/enums/#djstripe.enums.FilePurpose.tax_document_user_upload","text":"","title":"tax_document_user_upload"},{"location":"reference/enums/#djstripe.enums.FilePurpose.humanize","text":"Source code in djstripe/enums.py def _human_enum_values ( enum ): return cls . __choices__ [ enum ]","title":"humanize()"},{"location":"reference/enums/#djstripe.enums.FileType","text":"","title":"FileType"},{"location":"reference/enums/#djstripe.enums.FileType.csv","text":"","title":"csv"},{"location":"reference/enums/#djstripe.enums.FileType.docx","text":"","title":"docx"},{"location":"reference/enums/#djstripe.enums.FileType.jpg","text":"","title":"jpg"},{"location":"reference/enums/#djstripe.enums.FileType.pdf","text":"","title":"pdf"},{"location":"reference/enums/#djstripe.enums.FileType.png","text":"","title":"png"},{"location":"reference/enums/#djstripe.enums.FileType.xls","text":"","title":"xls"},{"location":"reference/enums/#djstripe.enums.FileType.xlsx","text":"","title":"xlsx"},{"location":"reference/enums/#djstripe.enums.FileType.humanize","text":"Source code in djstripe/enums.py def _human_enum_values ( enum ): return cls . __choices__ [ enum ]","title":"humanize()"},{"location":"reference/enums/#djstripe.enums.IntentStatus","text":"Status of Intents which apply both to PaymentIntents and SetupIntents.","title":"IntentStatus"},{"location":"reference/enums/#djstripe.enums.IntentStatus.canceled","text":"","title":"canceled"},{"location":"reference/enums/#djstripe.enums.IntentStatus.processing","text":"","title":"processing"},{"location":"reference/enums/#djstripe.enums.IntentStatus.requires_action","text":"","title":"requires_action"},{"location":"reference/enums/#djstripe.enums.IntentStatus.requires_confirmation","text":"","title":"requires_confirmation"},{"location":"reference/enums/#djstripe.enums.IntentStatus.requires_payment_method","text":"","title":"requires_payment_method"},{"location":"reference/enums/#djstripe.enums.IntentStatus.humanize","text":"Source code in djstripe/enums.py def _human_enum_values ( enum ): return cls . __choices__ [ enum ]","title":"humanize()"},{"location":"reference/enums/#djstripe.enums.IntentUsage","text":"","title":"IntentUsage"},{"location":"reference/enums/#djstripe.enums.IntentUsage.off_session","text":"","title":"off_session"},{"location":"reference/enums/#djstripe.enums.IntentUsage.on_session","text":"","title":"on_session"},{"location":"reference/enums/#djstripe.enums.IntentUsage.humanize","text":"Source code in djstripe/enums.py def _human_enum_values ( enum ): return cls . __choices__ [ enum ]","title":"humanize()"},{"location":"reference/enums/#djstripe.enums.InvoiceBillingReason","text":"","title":"InvoiceBillingReason"},{"location":"reference/enums/#djstripe.enums.InvoiceBillingReason.manual","text":"","title":"manual"},{"location":"reference/enums/#djstripe.enums.InvoiceBillingReason.subscription","text":"","title":"subscription"},{"location":"reference/enums/#djstripe.enums.InvoiceBillingReason.subscription_create","text":"","title":"subscription_create"},{"location":"reference/enums/#djstripe.enums.InvoiceBillingReason.subscription_cycle","text":"","title":"subscription_cycle"},{"location":"reference/enums/#djstripe.enums.InvoiceBillingReason.subscription_threshold","text":"","title":"subscription_threshold"},{"location":"reference/enums/#djstripe.enums.InvoiceBillingReason.subscription_update","text":"","title":"subscription_update"},{"location":"reference/enums/#djstripe.enums.InvoiceBillingReason.upcoming","text":"","title":"upcoming"},{"location":"reference/enums/#djstripe.enums.InvoiceBillingReason.humanize","text":"Source code in djstripe/enums.py def _human_enum_values ( enum ): return cls . __choices__ [ enum ]","title":"humanize()"},{"location":"reference/enums/#djstripe.enums.InvoiceCollectionMethod","text":"","title":"InvoiceCollectionMethod"},{"location":"reference/enums/#djstripe.enums.InvoiceCollectionMethod.charge_automatically","text":"","title":"charge_automatically"},{"location":"reference/enums/#djstripe.enums.InvoiceCollectionMethod.send_invoice","text":"","title":"send_invoice"},{"location":"reference/enums/#djstripe.enums.InvoiceCollectionMethod.humanize","text":"Source code in djstripe/enums.py def _human_enum_values ( enum ): return cls . __choices__ [ enum ]","title":"humanize()"},{"location":"reference/enums/#djstripe.enums.InvoiceStatus","text":"","title":"InvoiceStatus"},{"location":"reference/enums/#djstripe.enums.InvoiceStatus.draft","text":"","title":"draft"},{"location":"reference/enums/#djstripe.enums.InvoiceStatus.open","text":"","title":"open"},{"location":"reference/enums/#djstripe.enums.InvoiceStatus.paid","text":"","title":"paid"},{"location":"reference/enums/#djstripe.enums.InvoiceStatus.uncollectible","text":"","title":"uncollectible"},{"location":"reference/enums/#djstripe.enums.InvoiceStatus.void","text":"","title":"void"},{"location":"reference/enums/#djstripe.enums.InvoiceStatus.humanize","text":"Source code in djstripe/enums.py def _human_enum_values ( enum ): return cls . __choices__ [ enum ]","title":"humanize()"},{"location":"reference/enums/#djstripe.enums.LegacySourceType","text":"","title":"LegacySourceType"},{"location":"reference/enums/#djstripe.enums.LegacySourceType.alipay_account","text":"","title":"alipay_account"},{"location":"reference/enums/#djstripe.enums.LegacySourceType.bank_account","text":"","title":"bank_account"},{"location":"reference/enums/#djstripe.enums.LegacySourceType.bitcoin_receiver","text":"","title":"bitcoin_receiver"},{"location":"reference/enums/#djstripe.enums.LegacySourceType.card","text":"","title":"card"},{"location":"reference/enums/#djstripe.enums.LegacySourceType.humanize","text":"Source code in djstripe/enums.py def _human_enum_values ( enum ): return cls . __choices__ [ enum ]","title":"humanize()"},{"location":"reference/enums/#djstripe.enums.MandateStatus","text":"","title":"MandateStatus"},{"location":"reference/enums/#djstripe.enums.MandateStatus.active","text":"","title":"active"},{"location":"reference/enums/#djstripe.enums.MandateStatus.inactive","text":"","title":"inactive"},{"location":"reference/enums/#djstripe.enums.MandateStatus.pending","text":"","title":"pending"},{"location":"reference/enums/#djstripe.enums.MandateStatus.humanize","text":"Source code in djstripe/enums.py def _human_enum_values ( enum ): return cls . __choices__ [ enum ]","title":"humanize()"},{"location":"reference/enums/#djstripe.enums.MandateType","text":"","title":"MandateType"},{"location":"reference/enums/#djstripe.enums.MandateType.multi_use","text":"","title":"multi_use"},{"location":"reference/enums/#djstripe.enums.MandateType.single_use","text":"","title":"single_use"},{"location":"reference/enums/#djstripe.enums.MandateType.humanize","text":"Source code in djstripe/enums.py def _human_enum_values ( enum ): return cls . __choices__ [ enum ]","title":"humanize()"},{"location":"reference/enums/#djstripe.enums.PaymentIntentCancellationReason","text":"","title":"PaymentIntentCancellationReason"},{"location":"reference/enums/#djstripe.enums.PaymentIntentCancellationReason.abandoned","text":"","title":"abandoned"},{"location":"reference/enums/#djstripe.enums.PaymentIntentCancellationReason.automatic","text":"","title":"automatic"},{"location":"reference/enums/#djstripe.enums.PaymentIntentCancellationReason.duplicate","text":"","title":"duplicate"},{"location":"reference/enums/#djstripe.enums.PaymentIntentCancellationReason.failed_invoice","text":"","title":"failed_invoice"},{"location":"reference/enums/#djstripe.enums.PaymentIntentCancellationReason.fraudulent","text":"","title":"fraudulent"},{"location":"reference/enums/#djstripe.enums.PaymentIntentCancellationReason.requested_by_customer","text":"","title":"requested_by_customer"},{"location":"reference/enums/#djstripe.enums.PaymentIntentCancellationReason.void_invoice","text":"","title":"void_invoice"},{"location":"reference/enums/#djstripe.enums.PaymentIntentCancellationReason.humanize","text":"Source code in djstripe/enums.py def _human_enum_values ( enum ): return cls . __choices__ [ enum ]","title":"humanize()"},{"location":"reference/enums/#djstripe.enums.PaymentIntentStatus","text":"","title":"PaymentIntentStatus"},{"location":"reference/enums/#djstripe.enums.PaymentIntentStatus.canceled","text":"","title":"canceled"},{"location":"reference/enums/#djstripe.enums.PaymentIntentStatus.processing","text":"","title":"processing"},{"location":"reference/enums/#djstripe.enums.PaymentIntentStatus.requires_action","text":"","title":"requires_action"},{"location":"reference/enums/#djstripe.enums.PaymentIntentStatus.requires_capture","text":"","title":"requires_capture"},{"location":"reference/enums/#djstripe.enums.PaymentIntentStatus.requires_confirmation","text":"","title":"requires_confirmation"},{"location":"reference/enums/#djstripe.enums.PaymentIntentStatus.requires_payment_method","text":"","title":"requires_payment_method"},{"location":"reference/enums/#djstripe.enums.PaymentIntentStatus.succeeded","text":"","title":"succeeded"},{"location":"reference/enums/#djstripe.enums.PaymentIntentStatus.humanize","text":"Source code in djstripe/enums.py def _human_enum_values ( enum ): return cls . __choices__ [ enum ]","title":"humanize()"},{"location":"reference/enums/#djstripe.enums.PaymentMethodType","text":"","title":"PaymentMethodType"},{"location":"reference/enums/#djstripe.enums.PaymentMethodType.acss_debit","text":"","title":"acss_debit"},{"location":"reference/enums/#djstripe.enums.PaymentMethodType.afterpay_clearpay","text":"","title":"afterpay_clearpay"},{"location":"reference/enums/#djstripe.enums.PaymentMethodType.alipay","text":"","title":"alipay"},{"location":"reference/enums/#djstripe.enums.PaymentMethodType.au_becs_debit","text":"","title":"au_becs_debit"},{"location":"reference/enums/#djstripe.enums.PaymentMethodType.bacs_debit","text":"","title":"bacs_debit"},{"location":"reference/enums/#djstripe.enums.PaymentMethodType.bancontact","text":"","title":"bancontact"},{"location":"reference/enums/#djstripe.enums.PaymentMethodType.boleto","text":"","title":"boleto"},{"location":"reference/enums/#djstripe.enums.PaymentMethodType.card","text":"","title":"card"},{"location":"reference/enums/#djstripe.enums.PaymentMethodType.card_present","text":"","title":"card_present"},{"location":"reference/enums/#djstripe.enums.PaymentMethodType.eps","text":"","title":"eps"},{"location":"reference/enums/#djstripe.enums.PaymentMethodType.fpx","text":"","title":"fpx"},{"location":"reference/enums/#djstripe.enums.PaymentMethodType.giropay","text":"","title":"giropay"},{"location":"reference/enums/#djstripe.enums.PaymentMethodType.grabpay","text":"","title":"grabpay"},{"location":"reference/enums/#djstripe.enums.PaymentMethodType.ideal","text":"","title":"ideal"},{"location":"reference/enums/#djstripe.enums.PaymentMethodType.interac_present","text":"","title":"interac_present"},{"location":"reference/enums/#djstripe.enums.PaymentMethodType.klarna","text":"","title":"klarna"},{"location":"reference/enums/#djstripe.enums.PaymentMethodType.oxxo","text":"","title":"oxxo"},{"location":"reference/enums/#djstripe.enums.PaymentMethodType.p24","text":"","title":"p24"},{"location":"reference/enums/#djstripe.enums.PaymentMethodType.sepa_debit","text":"","title":"sepa_debit"},{"location":"reference/enums/#djstripe.enums.PaymentMethodType.sofort","text":"","title":"sofort"},{"location":"reference/enums/#djstripe.enums.PaymentMethodType.wechat_pay","text":"","title":"wechat_pay"},{"location":"reference/enums/#djstripe.enums.PaymentMethodType.humanize","text":"Source code in djstripe/enums.py def _human_enum_values ( enum ): return cls . __choices__ [ enum ]","title":"humanize()"},{"location":"reference/enums/#djstripe.enums.PayoutFailureCode","text":"Payout failure error codes. https://stripe.com/docs/api#payout_failures","title":"PayoutFailureCode"},{"location":"reference/enums/#djstripe.enums.PayoutFailureCode.account_closed","text":"","title":"account_closed"},{"location":"reference/enums/#djstripe.enums.PayoutFailureCode.account_frozen","text":"","title":"account_frozen"},{"location":"reference/enums/#djstripe.enums.PayoutFailureCode.bank_account_restricted","text":"","title":"bank_account_restricted"},{"location":"reference/enums/#djstripe.enums.PayoutFailureCode.bank_ownership_changed","text":"","title":"bank_ownership_changed"},{"location":"reference/enums/#djstripe.enums.PayoutFailureCode.could_not_process","text":"","title":"could_not_process"},{"location":"reference/enums/#djstripe.enums.PayoutFailureCode.debit_not_authorized","text":"","title":"debit_not_authorized"},{"location":"reference/enums/#djstripe.enums.PayoutFailureCode.insufficient_funds","text":"","title":"insufficient_funds"},{"location":"reference/enums/#djstripe.enums.PayoutFailureCode.invalid_account_number","text":"","title":"invalid_account_number"},{"location":"reference/enums/#djstripe.enums.PayoutFailureCode.invalid_currency","text":"","title":"invalid_currency"},{"location":"reference/enums/#djstripe.enums.PayoutFailureCode.no_account","text":"","title":"no_account"},{"location":"reference/enums/#djstripe.enums.PayoutFailureCode.unsupported_card","text":"","title":"unsupported_card"},{"location":"reference/enums/#djstripe.enums.PayoutFailureCode.humanize","text":"Source code in djstripe/enums.py def _human_enum_values ( enum ): return cls . __choices__ [ enum ]","title":"humanize()"},{"location":"reference/enums/#djstripe.enums.PayoutMethod","text":"","title":"PayoutMethod"},{"location":"reference/enums/#djstripe.enums.PayoutMethod.instant","text":"","title":"instant"},{"location":"reference/enums/#djstripe.enums.PayoutMethod.standard","text":"","title":"standard"},{"location":"reference/enums/#djstripe.enums.PayoutMethod.humanize","text":"Source code in djstripe/enums.py def _human_enum_values ( enum ): return cls . __choices__ [ enum ]","title":"humanize()"},{"location":"reference/enums/#djstripe.enums.PayoutSourceType","text":"","title":"PayoutSourceType"},{"location":"reference/enums/#djstripe.enums.PayoutSourceType.bank_account","text":"","title":"bank_account"},{"location":"reference/enums/#djstripe.enums.PayoutSourceType.card","text":"","title":"card"},{"location":"reference/enums/#djstripe.enums.PayoutSourceType.fpx","text":"","title":"fpx"},{"location":"reference/enums/#djstripe.enums.PayoutSourceType.humanize","text":"Source code in djstripe/enums.py def _human_enum_values ( enum ): return cls . __choices__ [ enum ]","title":"humanize()"},{"location":"reference/enums/#djstripe.enums.PayoutStatus","text":"","title":"PayoutStatus"},{"location":"reference/enums/#djstripe.enums.PayoutStatus.canceled","text":"","title":"canceled"},{"location":"reference/enums/#djstripe.enums.PayoutStatus.failed","text":"","title":"failed"},{"location":"reference/enums/#djstripe.enums.PayoutStatus.in_transit","text":"","title":"in_transit"},{"location":"reference/enums/#djstripe.enums.PayoutStatus.paid","text":"","title":"paid"},{"location":"reference/enums/#djstripe.enums.PayoutStatus.pending","text":"","title":"pending"},{"location":"reference/enums/#djstripe.enums.PayoutStatus.humanize","text":"Source code in djstripe/enums.py def _human_enum_values ( enum ): return cls . __choices__ [ enum ]","title":"humanize()"},{"location":"reference/enums/#djstripe.enums.PayoutType","text":"","title":"PayoutType"},{"location":"reference/enums/#djstripe.enums.PayoutType.bank_account","text":"","title":"bank_account"},{"location":"reference/enums/#djstripe.enums.PayoutType.card","text":"","title":"card"},{"location":"reference/enums/#djstripe.enums.PayoutType.humanize","text":"Source code in djstripe/enums.py def _human_enum_values ( enum ): return cls . __choices__ [ enum ]","title":"humanize()"},{"location":"reference/enums/#djstripe.enums.PlanAggregateUsage","text":"","title":"PlanAggregateUsage"},{"location":"reference/enums/#djstripe.enums.PlanAggregateUsage.last_during_period","text":"","title":"last_during_period"},{"location":"reference/enums/#djstripe.enums.PlanAggregateUsage.last_ever","text":"","title":"last_ever"},{"location":"reference/enums/#djstripe.enums.PlanAggregateUsage.max","text":"","title":"max"},{"location":"reference/enums/#djstripe.enums.PlanAggregateUsage.sum","text":"","title":"sum"},{"location":"reference/enums/#djstripe.enums.PlanAggregateUsage.humanize","text":"Source code in djstripe/enums.py def _human_enum_values ( enum ): return cls . __choices__ [ enum ]","title":"humanize()"},{"location":"reference/enums/#djstripe.enums.PlanInterval","text":"","title":"PlanInterval"},{"location":"reference/enums/#djstripe.enums.PlanInterval.day","text":"","title":"day"},{"location":"reference/enums/#djstripe.enums.PlanInterval.month","text":"","title":"month"},{"location":"reference/enums/#djstripe.enums.PlanInterval.week","text":"","title":"week"},{"location":"reference/enums/#djstripe.enums.PlanInterval.year","text":"","title":"year"},{"location":"reference/enums/#djstripe.enums.PlanInterval.humanize","text":"Source code in djstripe/enums.py def _human_enum_values ( enum ): return cls . __choices__ [ enum ]","title":"humanize()"},{"location":"reference/enums/#djstripe.enums.PlanTiersMode","text":"","title":"PlanTiersMode"},{"location":"reference/enums/#djstripe.enums.PlanTiersMode.graduated","text":"","title":"graduated"},{"location":"reference/enums/#djstripe.enums.PlanTiersMode.volume","text":"","title":"volume"},{"location":"reference/enums/#djstripe.enums.PlanTiersMode.humanize","text":"Source code in djstripe/enums.py def _human_enum_values ( enum ): return cls . __choices__ [ enum ]","title":"humanize()"},{"location":"reference/enums/#djstripe.enums.PlanUsageType","text":"","title":"PlanUsageType"},{"location":"reference/enums/#djstripe.enums.PlanUsageType.licensed","text":"","title":"licensed"},{"location":"reference/enums/#djstripe.enums.PlanUsageType.metered","text":"","title":"metered"},{"location":"reference/enums/#djstripe.enums.PlanUsageType.humanize","text":"Source code in djstripe/enums.py def _human_enum_values ( enum ): return cls . __choices__ [ enum ]","title":"humanize()"},{"location":"reference/enums/#djstripe.enums.PriceTiersMode","text":"","title":"PriceTiersMode"},{"location":"reference/enums/#djstripe.enums.PriceTiersMode.graduated","text":"","title":"graduated"},{"location":"reference/enums/#djstripe.enums.PriceTiersMode.volume","text":"","title":"volume"},{"location":"reference/enums/#djstripe.enums.PriceTiersMode.humanize","text":"Source code in djstripe/enums.py def _human_enum_values ( enum ): return cls . __choices__ [ enum ]","title":"humanize()"},{"location":"reference/enums/#djstripe.enums.PriceType","text":"","title":"PriceType"},{"location":"reference/enums/#djstripe.enums.PriceType.one_time","text":"","title":"one_time"},{"location":"reference/enums/#djstripe.enums.PriceType.recurring","text":"","title":"recurring"},{"location":"reference/enums/#djstripe.enums.PriceType.humanize","text":"Source code in djstripe/enums.py def _human_enum_values ( enum ): return cls . __choices__ [ enum ]","title":"humanize()"},{"location":"reference/enums/#djstripe.enums.PriceUsageType","text":"","title":"PriceUsageType"},{"location":"reference/enums/#djstripe.enums.PriceUsageType.licensed","text":"","title":"licensed"},{"location":"reference/enums/#djstripe.enums.PriceUsageType.metered","text":"","title":"metered"},{"location":"reference/enums/#djstripe.enums.PriceUsageType.humanize","text":"Source code in djstripe/enums.py def _human_enum_values ( enum ): return cls . __choices__ [ enum ]","title":"humanize()"},{"location":"reference/enums/#djstripe.enums.ProductType","text":"","title":"ProductType"},{"location":"reference/enums/#djstripe.enums.ProductType.good","text":"","title":"good"},{"location":"reference/enums/#djstripe.enums.ProductType.service","text":"","title":"service"},{"location":"reference/enums/#djstripe.enums.ProductType.humanize","text":"Source code in djstripe/enums.py def _human_enum_values ( enum ): return cls . __choices__ [ enum ]","title":"humanize()"},{"location":"reference/enums/#djstripe.enums.RefundFailureReason","text":"","title":"RefundFailureReason"},{"location":"reference/enums/#djstripe.enums.RefundFailureReason.expired_or_canceled_card","text":"","title":"expired_or_canceled_card"},{"location":"reference/enums/#djstripe.enums.RefundFailureReason.lost_or_stolen_card","text":"","title":"lost_or_stolen_card"},{"location":"reference/enums/#djstripe.enums.RefundFailureReason.unknown","text":"","title":"unknown"},{"location":"reference/enums/#djstripe.enums.RefundFailureReason.humanize","text":"Source code in djstripe/enums.py def _human_enum_values ( enum ): return cls . __choices__ [ enum ]","title":"humanize()"},{"location":"reference/enums/#djstripe.enums.RefundReason","text":"","title":"RefundReason"},{"location":"reference/enums/#djstripe.enums.RefundReason.duplicate","text":"","title":"duplicate"},{"location":"reference/enums/#djstripe.enums.RefundReason.expired_uncaptured_charge","text":"","title":"expired_uncaptured_charge"},{"location":"reference/enums/#djstripe.enums.RefundReason.fraudulent","text":"","title":"fraudulent"},{"location":"reference/enums/#djstripe.enums.RefundReason.requested_by_customer","text":"","title":"requested_by_customer"},{"location":"reference/enums/#djstripe.enums.RefundReason.humanize","text":"Source code in djstripe/enums.py def _human_enum_values ( enum ): return cls . __choices__ [ enum ]","title":"humanize()"},{"location":"reference/enums/#djstripe.enums.RefundStatus","text":"","title":"RefundStatus"},{"location":"reference/enums/#djstripe.enums.RefundStatus.canceled","text":"","title":"canceled"},{"location":"reference/enums/#djstripe.enums.RefundStatus.failed","text":"","title":"failed"},{"location":"reference/enums/#djstripe.enums.RefundStatus.pending","text":"","title":"pending"},{"location":"reference/enums/#djstripe.enums.RefundStatus.succeeded","text":"","title":"succeeded"},{"location":"reference/enums/#djstripe.enums.RefundStatus.humanize","text":"Source code in djstripe/enums.py def _human_enum_values ( enum ): return cls . __choices__ [ enum ]","title":"humanize()"},{"location":"reference/enums/#djstripe.enums.ScheduledQueryRunStatus","text":"","title":"ScheduledQueryRunStatus"},{"location":"reference/enums/#djstripe.enums.ScheduledQueryRunStatus.canceled","text":"","title":"canceled"},{"location":"reference/enums/#djstripe.enums.ScheduledQueryRunStatus.failed","text":"","title":"failed"},{"location":"reference/enums/#djstripe.enums.ScheduledQueryRunStatus.timed_out","text":"","title":"timed_out"},{"location":"reference/enums/#djstripe.enums.ScheduledQueryRunStatus.humanize","text":"Source code in djstripe/enums.py def _human_enum_values ( enum ): return cls . __choices__ [ enum ]","title":"humanize()"},{"location":"reference/enums/#djstripe.enums.SessionBillingAddressCollection","text":"","title":"SessionBillingAddressCollection"},{"location":"reference/enums/#djstripe.enums.SessionBillingAddressCollection.auto","text":"","title":"auto"},{"location":"reference/enums/#djstripe.enums.SessionBillingAddressCollection.required","text":"","title":"required"},{"location":"reference/enums/#djstripe.enums.SessionBillingAddressCollection.humanize","text":"Source code in djstripe/enums.py def _human_enum_values ( enum ): return cls . __choices__ [ enum ]","title":"humanize()"},{"location":"reference/enums/#djstripe.enums.SessionMode","text":"","title":"SessionMode"},{"location":"reference/enums/#djstripe.enums.SessionMode.payment","text":"","title":"payment"},{"location":"reference/enums/#djstripe.enums.SessionMode.setup","text":"","title":"setup"},{"location":"reference/enums/#djstripe.enums.SessionMode.subscription","text":"","title":"subscription"},{"location":"reference/enums/#djstripe.enums.SessionMode.humanize","text":"Source code in djstripe/enums.py def _human_enum_values ( enum ): return cls . __choices__ [ enum ]","title":"humanize()"},{"location":"reference/enums/#djstripe.enums.SetupIntentCancellationReason","text":"","title":"SetupIntentCancellationReason"},{"location":"reference/enums/#djstripe.enums.SetupIntentCancellationReason.abandoned","text":"","title":"abandoned"},{"location":"reference/enums/#djstripe.enums.SetupIntentCancellationReason.duplicate","text":"","title":"duplicate"},{"location":"reference/enums/#djstripe.enums.SetupIntentCancellationReason.requested_by_customer","text":"","title":"requested_by_customer"},{"location":"reference/enums/#djstripe.enums.SetupIntentCancellationReason.humanize","text":"Source code in djstripe/enums.py def _human_enum_values ( enum ): return cls . __choices__ [ enum ]","title":"humanize()"},{"location":"reference/enums/#djstripe.enums.SetupIntentStatus","text":"","title":"SetupIntentStatus"},{"location":"reference/enums/#djstripe.enums.SetupIntentStatus.canceled","text":"","title":"canceled"},{"location":"reference/enums/#djstripe.enums.SetupIntentStatus.processing","text":"","title":"processing"},{"location":"reference/enums/#djstripe.enums.SetupIntentStatus.requires_action","text":"","title":"requires_action"},{"location":"reference/enums/#djstripe.enums.SetupIntentStatus.requires_confirmation","text":"","title":"requires_confirmation"},{"location":"reference/enums/#djstripe.enums.SetupIntentStatus.requires_payment_method","text":"","title":"requires_payment_method"},{"location":"reference/enums/#djstripe.enums.SetupIntentStatus.succeeded","text":"","title":"succeeded"},{"location":"reference/enums/#djstripe.enums.SetupIntentStatus.humanize","text":"Source code in djstripe/enums.py def _human_enum_values ( enum ): return cls . __choices__ [ enum ]","title":"humanize()"},{"location":"reference/enums/#djstripe.enums.SourceCodeVerificationStatus","text":"","title":"SourceCodeVerificationStatus"},{"location":"reference/enums/#djstripe.enums.SourceCodeVerificationStatus.failed","text":"","title":"failed"},{"location":"reference/enums/#djstripe.enums.SourceCodeVerificationStatus.pending","text":"","title":"pending"},{"location":"reference/enums/#djstripe.enums.SourceCodeVerificationStatus.succeeded","text":"","title":"succeeded"},{"location":"reference/enums/#djstripe.enums.SourceCodeVerificationStatus.humanize","text":"Source code in djstripe/enums.py def _human_enum_values ( enum ): return cls . __choices__ [ enum ]","title":"humanize()"},{"location":"reference/enums/#djstripe.enums.SourceFlow","text":"","title":"SourceFlow"},{"location":"reference/enums/#djstripe.enums.SourceFlow.code_verification","text":"","title":"code_verification"},{"location":"reference/enums/#djstripe.enums.SourceFlow.none","text":"","title":"none"},{"location":"reference/enums/#djstripe.enums.SourceFlow.receiver","text":"","title":"receiver"},{"location":"reference/enums/#djstripe.enums.SourceFlow.redirect","text":"","title":"redirect"},{"location":"reference/enums/#djstripe.enums.SourceFlow.humanize","text":"Source code in djstripe/enums.py def _human_enum_values ( enum ): return cls . __choices__ [ enum ]","title":"humanize()"},{"location":"reference/enums/#djstripe.enums.SourceRedirectFailureReason","text":"","title":"SourceRedirectFailureReason"},{"location":"reference/enums/#djstripe.enums.SourceRedirectFailureReason.declined","text":"","title":"declined"},{"location":"reference/enums/#djstripe.enums.SourceRedirectFailureReason.processing_error","text":"","title":"processing_error"},{"location":"reference/enums/#djstripe.enums.SourceRedirectFailureReason.user_abort","text":"","title":"user_abort"},{"location":"reference/enums/#djstripe.enums.SourceRedirectFailureReason.humanize","text":"Source code in djstripe/enums.py def _human_enum_values ( enum ): return cls . __choices__ [ enum ]","title":"humanize()"},{"location":"reference/enums/#djstripe.enums.SourceRedirectStatus","text":"","title":"SourceRedirectStatus"},{"location":"reference/enums/#djstripe.enums.SourceRedirectStatus.failed","text":"","title":"failed"},{"location":"reference/enums/#djstripe.enums.SourceRedirectStatus.not_required","text":"","title":"not_required"},{"location":"reference/enums/#djstripe.enums.SourceRedirectStatus.pending","text":"","title":"pending"},{"location":"reference/enums/#djstripe.enums.SourceRedirectStatus.succeeded","text":"","title":"succeeded"},{"location":"reference/enums/#djstripe.enums.SourceRedirectStatus.humanize","text":"Source code in djstripe/enums.py def _human_enum_values ( enum ): return cls . __choices__ [ enum ]","title":"humanize()"},{"location":"reference/enums/#djstripe.enums.SourceStatus","text":"","title":"SourceStatus"},{"location":"reference/enums/#djstripe.enums.SourceStatus.canceled","text":"","title":"canceled"},{"location":"reference/enums/#djstripe.enums.SourceStatus.chargeable","text":"","title":"chargeable"},{"location":"reference/enums/#djstripe.enums.SourceStatus.consumed","text":"","title":"consumed"},{"location":"reference/enums/#djstripe.enums.SourceStatus.failed","text":"","title":"failed"},{"location":"reference/enums/#djstripe.enums.SourceStatus.pending","text":"","title":"pending"},{"location":"reference/enums/#djstripe.enums.SourceStatus.humanize","text":"Source code in djstripe/enums.py def _human_enum_values ( enum ): return cls . __choices__ [ enum ]","title":"humanize()"},{"location":"reference/enums/#djstripe.enums.SourceType","text":"","title":"SourceType"},{"location":"reference/enums/#djstripe.enums.SourceType.ach_credit_transfer","text":"","title":"ach_credit_transfer"},{"location":"reference/enums/#djstripe.enums.SourceType.ach_debit","text":"","title":"ach_debit"},{"location":"reference/enums/#djstripe.enums.SourceType.acss_debit","text":"","title":"acss_debit"},{"location":"reference/enums/#djstripe.enums.SourceType.alipay","text":"","title":"alipay"},{"location":"reference/enums/#djstripe.enums.SourceType.au_becs_debit","text":"","title":"au_becs_debit"},{"location":"reference/enums/#djstripe.enums.SourceType.bancontact","text":"","title":"bancontact"},{"location":"reference/enums/#djstripe.enums.SourceType.bitcoin","text":"","title":"bitcoin"},{"location":"reference/enums/#djstripe.enums.SourceType.card","text":"","title":"card"},{"location":"reference/enums/#djstripe.enums.SourceType.card_present","text":"","title":"card_present"},{"location":"reference/enums/#djstripe.enums.SourceType.eps","text":"","title":"eps"},{"location":"reference/enums/#djstripe.enums.SourceType.giropay","text":"","title":"giropay"},{"location":"reference/enums/#djstripe.enums.SourceType.ideal","text":"","title":"ideal"},{"location":"reference/enums/#djstripe.enums.SourceType.klarna","text":"","title":"klarna"},{"location":"reference/enums/#djstripe.enums.SourceType.multibanco","text":"","title":"multibanco"},{"location":"reference/enums/#djstripe.enums.SourceType.p24","text":"","title":"p24"},{"location":"reference/enums/#djstripe.enums.SourceType.paper_check","text":"","title":"paper_check"},{"location":"reference/enums/#djstripe.enums.SourceType.sepa_credit_transfer","text":"","title":"sepa_credit_transfer"},{"location":"reference/enums/#djstripe.enums.SourceType.sepa_debit","text":"","title":"sepa_debit"},{"location":"reference/enums/#djstripe.enums.SourceType.sofort","text":"","title":"sofort"},{"location":"reference/enums/#djstripe.enums.SourceType.three_d_secure","text":"","title":"three_d_secure"},{"location":"reference/enums/#djstripe.enums.SourceType.wechat","text":"","title":"wechat"},{"location":"reference/enums/#djstripe.enums.SourceType.humanize","text":"Source code in djstripe/enums.py def _human_enum_values ( enum ): return cls . __choices__ [ enum ]","title":"humanize()"},{"location":"reference/enums/#djstripe.enums.SourceUsage","text":"","title":"SourceUsage"},{"location":"reference/enums/#djstripe.enums.SourceUsage.reusable","text":"","title":"reusable"},{"location":"reference/enums/#djstripe.enums.SourceUsage.single_use","text":"","title":"single_use"},{"location":"reference/enums/#djstripe.enums.SourceUsage.humanize","text":"Source code in djstripe/enums.py def _human_enum_values ( enum ): return cls . __choices__ [ enum ]","title":"humanize()"},{"location":"reference/enums/#djstripe.enums.SubmitTypeStatus","text":"","title":"SubmitTypeStatus"},{"location":"reference/enums/#djstripe.enums.SubmitTypeStatus.auto","text":"","title":"auto"},{"location":"reference/enums/#djstripe.enums.SubmitTypeStatus.book","text":"","title":"book"},{"location":"reference/enums/#djstripe.enums.SubmitTypeStatus.donate","text":"","title":"donate"},{"location":"reference/enums/#djstripe.enums.SubmitTypeStatus.pay","text":"","title":"pay"},{"location":"reference/enums/#djstripe.enums.SubmitTypeStatus.humanize","text":"Source code in djstripe/enums.py def _human_enum_values ( enum ): return cls . __choices__ [ enum ]","title":"humanize()"},{"location":"reference/enums/#djstripe.enums.SubscriptionScheduleEndBehavior","text":"","title":"SubscriptionScheduleEndBehavior"},{"location":"reference/enums/#djstripe.enums.SubscriptionScheduleEndBehavior.cancel","text":"","title":"cancel"},{"location":"reference/enums/#djstripe.enums.SubscriptionScheduleEndBehavior.release","text":"","title":"release"},{"location":"reference/enums/#djstripe.enums.SubscriptionScheduleEndBehavior.humanize","text":"Source code in djstripe/enums.py def _human_enum_values ( enum ): return cls . __choices__ [ enum ]","title":"humanize()"},{"location":"reference/enums/#djstripe.enums.SubscriptionScheduleStatus","text":"","title":"SubscriptionScheduleStatus"},{"location":"reference/enums/#djstripe.enums.SubscriptionScheduleStatus.active","text":"","title":"active"},{"location":"reference/enums/#djstripe.enums.SubscriptionScheduleStatus.canceled","text":"","title":"canceled"},{"location":"reference/enums/#djstripe.enums.SubscriptionScheduleStatus.completed","text":"","title":"completed"},{"location":"reference/enums/#djstripe.enums.SubscriptionScheduleStatus.not_started","text":"","title":"not_started"},{"location":"reference/enums/#djstripe.enums.SubscriptionScheduleStatus.released","text":"","title":"released"},{"location":"reference/enums/#djstripe.enums.SubscriptionScheduleStatus.humanize","text":"Source code in djstripe/enums.py def _human_enum_values ( enum ): return cls . __choices__ [ enum ]","title":"humanize()"},{"location":"reference/enums/#djstripe.enums.SubscriptionStatus","text":"","title":"SubscriptionStatus"},{"location":"reference/enums/#djstripe.enums.SubscriptionStatus.active","text":"","title":"active"},{"location":"reference/enums/#djstripe.enums.SubscriptionStatus.canceled","text":"","title":"canceled"},{"location":"reference/enums/#djstripe.enums.SubscriptionStatus.incomplete","text":"","title":"incomplete"},{"location":"reference/enums/#djstripe.enums.SubscriptionStatus.incomplete_expired","text":"","title":"incomplete_expired"},{"location":"reference/enums/#djstripe.enums.SubscriptionStatus.past_due","text":"","title":"past_due"},{"location":"reference/enums/#djstripe.enums.SubscriptionStatus.trialing","text":"","title":"trialing"},{"location":"reference/enums/#djstripe.enums.SubscriptionStatus.unpaid","text":"","title":"unpaid"},{"location":"reference/enums/#djstripe.enums.SubscriptionStatus.humanize","text":"Source code in djstripe/enums.py def _human_enum_values ( enum ): return cls . __choices__ [ enum ]","title":"humanize()"},{"location":"reference/enums/#djstripe.enums.TaxIdType","text":"","title":"TaxIdType"},{"location":"reference/enums/#djstripe.enums.TaxIdType.ae_trn","text":"","title":"ae_trn"},{"location":"reference/enums/#djstripe.enums.TaxIdType.au_abn","text":"","title":"au_abn"},{"location":"reference/enums/#djstripe.enums.TaxIdType.br_cnp","text":"","title":"br_cnp"},{"location":"reference/enums/#djstripe.enums.TaxIdType.br_cpf","text":"","title":"br_cpf"},{"location":"reference/enums/#djstripe.enums.TaxIdType.ca_bn","text":"","title":"ca_bn"},{"location":"reference/enums/#djstripe.enums.TaxIdType.ca_qst","text":"","title":"ca_qst"},{"location":"reference/enums/#djstripe.enums.TaxIdType.ch_vat","text":"","title":"ch_vat"},{"location":"reference/enums/#djstripe.enums.TaxIdType.cl_tin","text":"","title":"cl_tin"},{"location":"reference/enums/#djstripe.enums.TaxIdType.es_cif","text":"","title":"es_cif"},{"location":"reference/enums/#djstripe.enums.TaxIdType.eu_vat","text":"","title":"eu_vat"},{"location":"reference/enums/#djstripe.enums.TaxIdType.hk_br","text":"","title":"hk_br"},{"location":"reference/enums/#djstripe.enums.TaxIdType.id_npw","text":"","title":"id_npw"},{"location":"reference/enums/#djstripe.enums.TaxIdType.in_gst","text":"","title":"in_gst"},{"location":"reference/enums/#djstripe.enums.TaxIdType.jp_cn","text":"","title":"jp_cn"},{"location":"reference/enums/#djstripe.enums.TaxIdType.jp_rn","text":"","title":"jp_rn"},{"location":"reference/enums/#djstripe.enums.TaxIdType.kr_brn","text":"","title":"kr_brn"},{"location":"reference/enums/#djstripe.enums.TaxIdType.li_uid","text":"","title":"li_uid"},{"location":"reference/enums/#djstripe.enums.TaxIdType.mx_rfc","text":"","title":"mx_rfc"},{"location":"reference/enums/#djstripe.enums.TaxIdType.my_frp","text":"","title":"my_frp"},{"location":"reference/enums/#djstripe.enums.TaxIdType.my_itn","text":"","title":"my_itn"},{"location":"reference/enums/#djstripe.enums.TaxIdType.my_sst","text":"","title":"my_sst"},{"location":"reference/enums/#djstripe.enums.TaxIdType.no_vat","text":"","title":"no_vat"},{"location":"reference/enums/#djstripe.enums.TaxIdType.nz_gst","text":"","title":"nz_gst"},{"location":"reference/enums/#djstripe.enums.TaxIdType.ru_inn","text":"","title":"ru_inn"},{"location":"reference/enums/#djstripe.enums.TaxIdType.ru_kpp","text":"","title":"ru_kpp"},{"location":"reference/enums/#djstripe.enums.TaxIdType.sa_vat","text":"","title":"sa_vat"},{"location":"reference/enums/#djstripe.enums.TaxIdType.sg_gst","text":"","title":"sg_gst"},{"location":"reference/enums/#djstripe.enums.TaxIdType.sg_uen","text":"","title":"sg_uen"},{"location":"reference/enums/#djstripe.enums.TaxIdType.th_vat","text":"","title":"th_vat"},{"location":"reference/enums/#djstripe.enums.TaxIdType.tw_vat","text":"","title":"tw_vat"},{"location":"reference/enums/#djstripe.enums.TaxIdType.unknown","text":"","title":"unknown"},{"location":"reference/enums/#djstripe.enums.TaxIdType.us_ein","text":"","title":"us_ein"},{"location":"reference/enums/#djstripe.enums.TaxIdType.za_vat","text":"","title":"za_vat"},{"location":"reference/enums/#djstripe.enums.TaxIdType.humanize","text":"Source code in djstripe/enums.py def _human_enum_values ( enum ): return cls . __choices__ [ enum ]","title":"humanize()"},{"location":"reference/enums/#djstripe.enums.UsageAction","text":"","title":"UsageAction"},{"location":"reference/enums/#djstripe.enums.UsageAction.increment","text":"","title":"increment"},{"location":"reference/enums/#djstripe.enums.UsageAction.set","text":"","title":"set"},{"location":"reference/enums/#djstripe.enums.UsageAction.humanize","text":"Source code in djstripe/enums.py def _human_enum_values ( enum ): return cls . __choices__ [ enum ]","title":"humanize()"},{"location":"reference/enums/#djstripe.enums.WebhookEndpointStatus","text":"","title":"WebhookEndpointStatus"},{"location":"reference/enums/#djstripe.enums.WebhookEndpointStatus.disabled","text":"","title":"disabled"},{"location":"reference/enums/#djstripe.enums.WebhookEndpointStatus.enabled","text":"","title":"enabled"},{"location":"reference/enums/#djstripe.enums.WebhookEndpointStatus.humanize","text":"Source code in djstripe/enums.py def _human_enum_values ( enum ): return cls . __choices__ [ enum ]","title":"humanize()"},{"location":"reference/managers/","text":"Managers dj-stripe model managers Classes djstripe.managers.ChargeManager Manager used by models.Charge. Methods djstripe . managers . ChargeManager . during ( self , year , month ) Return Charges between a certain time range based on created . Source code in djstripe/managers.py def during ( self , year , month ): \"\"\"Return Charges between a certain time range based on `created`.\"\"\" return self . filter ( created__year = year , created__month = month ) djstripe . managers . ChargeManager . paid_totals_for ( self , year , month ) Return paid Charges during a certain year, month with total amount, fee and refunded annotated. Source code in djstripe/managers.py def paid_totals_for ( self , year , month ): \"\"\" Return paid Charges during a certain year, month with total amount, fee and refunded annotated. \"\"\" return ( self . during ( year , month ) . filter ( paid = True ) . aggregate ( total_amount = models . Sum ( \"amount\" ), total_refunded = models . Sum ( \"amount_refunded\" ), ) ) djstripe.managers.StripeModelManager Manager used in StripeModel. djstripe.managers.SubscriptionManager Manager used in models.Subscription. Methods djstripe . managers . SubscriptionManager . active ( self ) Return active Subscriptions. Source code in djstripe/managers.py def active ( self ): \"\"\"Return active Subscriptions.\"\"\" return self . filter ( status = \"active\" ) djstripe . managers . SubscriptionManager . active_plan_summary ( self ) Return active Subscriptions with plan counts annotated. Source code in djstripe/managers.py def active_plan_summary ( self ): \"\"\"Return active Subscriptions with plan counts annotated.\"\"\" return ( self . active () . values ( \"plan\" ) . order_by () . annotate ( count = models . Count ( \"plan\" )) ) djstripe . managers . SubscriptionManager . canceled ( self ) Return canceled Subscriptions. Source code in djstripe/managers.py def canceled ( self ): \"\"\"Return canceled Subscriptions.\"\"\" return self . filter ( status = \"canceled\" ) djstripe . managers . SubscriptionManager . canceled_during ( self , year , month ) Return Subscriptions canceled during a certain time range. Source code in djstripe/managers.py def canceled_during ( self , year , month ): \"\"\"Return Subscriptions canceled during a certain time range.\"\"\" return self . canceled () . filter ( canceled_at__year = year , canceled_at__month = month ) djstripe . managers . SubscriptionManager . canceled_plan_summary_for ( self , year , month ) Return Subscriptions canceled within a time range with plan counts annotated. Source code in djstripe/managers.py def canceled_plan_summary_for ( self , year , month ): \"\"\" Return Subscriptions canceled within a time range with plan counts annotated. \"\"\" return ( self . canceled_during ( year , month ) . values ( \"plan\" ) . order_by () . annotate ( count = models . Count ( \"plan\" )) ) djstripe . managers . SubscriptionManager . churn ( self ) Return number of canceled Subscriptions divided by active Subscriptions. Source code in djstripe/managers.py def churn ( self ): \"\"\"Return number of canceled Subscriptions divided by active Subscriptions.\"\"\" canceled = self . canceled () . count () active = self . active () . count () return decimal . Decimal ( str ( canceled )) / decimal . Decimal ( str ( active )) djstripe . managers . SubscriptionManager . started_during ( self , year , month ) Return Subscriptions not in trial status between a certain time range. Source code in djstripe/managers.py def started_during ( self , year , month ): \"\"\"Return Subscriptions not in trial status between a certain time range.\"\"\" return self . exclude ( status = \"trialing\" ) . filter ( start_date__year = year , start_date__month = month ) djstripe . managers . SubscriptionManager . started_plan_summary_for ( self , year , month ) Return started_during Subscriptions with plan counts annotated. Source code in djstripe/managers.py def started_plan_summary_for ( self , year , month ): \"\"\"Return started_during Subscriptions with plan counts annotated.\"\"\" return ( self . started_during ( year , month ) . values ( \"plan\" ) . order_by () . annotate ( count = models . Count ( \"plan\" )) ) djstripe.managers.TransferManager Manager used by models.Transfer. Methods djstripe . managers . TransferManager . during ( self , year , month ) Return Transfers between a certain time range. Source code in djstripe/managers.py def during ( self , year , month ): \"\"\"Return Transfers between a certain time range.\"\"\" return self . filter ( created__year = year , created__month = month ) djstripe . managers . TransferManager . paid_totals_for ( self , year , month ) Return paid Transfers during a certain year, month with total amounts annotated. Source code in djstripe/managers.py def paid_totals_for ( self , year , month ): \"\"\" Return paid Transfers during a certain year, month with total amounts annotated. \"\"\" return self . during ( year , month ) . aggregate ( total_amount = models . Sum ( \"amount\" ))","title":"Managers"},{"location":"reference/managers/#managers","text":"dj-stripe model managers","title":"Managers"},{"location":"reference/managers/#djstripe.managers-classes","text":"","title":"Classes"},{"location":"reference/managers/#djstripe.managers.ChargeManager","text":"Manager used by models.Charge.","title":"ChargeManager"},{"location":"reference/managers/#djstripe.managers.ChargeManager-methods","text":"","title":"Methods"},{"location":"reference/managers/#djstripe.managers.ChargeManager.during","text":"Return Charges between a certain time range based on created . Source code in djstripe/managers.py def during ( self , year , month ): \"\"\"Return Charges between a certain time range based on `created`.\"\"\" return self . filter ( created__year = year , created__month = month )","title":"during()"},{"location":"reference/managers/#djstripe.managers.ChargeManager.paid_totals_for","text":"Return paid Charges during a certain year, month with total amount, fee and refunded annotated. Source code in djstripe/managers.py def paid_totals_for ( self , year , month ): \"\"\" Return paid Charges during a certain year, month with total amount, fee and refunded annotated. \"\"\" return ( self . during ( year , month ) . filter ( paid = True ) . aggregate ( total_amount = models . Sum ( \"amount\" ), total_refunded = models . Sum ( \"amount_refunded\" ), ) )","title":"paid_totals_for()"},{"location":"reference/managers/#djstripe.managers.StripeModelManager","text":"Manager used in StripeModel.","title":"StripeModelManager"},{"location":"reference/managers/#djstripe.managers.SubscriptionManager","text":"Manager used in models.Subscription.","title":"SubscriptionManager"},{"location":"reference/managers/#djstripe.managers.SubscriptionManager-methods","text":"","title":"Methods"},{"location":"reference/managers/#djstripe.managers.SubscriptionManager.active","text":"Return active Subscriptions. Source code in djstripe/managers.py def active ( self ): \"\"\"Return active Subscriptions.\"\"\" return self . filter ( status = \"active\" )","title":"active()"},{"location":"reference/managers/#djstripe.managers.SubscriptionManager.active_plan_summary","text":"Return active Subscriptions with plan counts annotated. Source code in djstripe/managers.py def active_plan_summary ( self ): \"\"\"Return active Subscriptions with plan counts annotated.\"\"\" return ( self . active () . values ( \"plan\" ) . order_by () . annotate ( count = models . Count ( \"plan\" )) )","title":"active_plan_summary()"},{"location":"reference/managers/#djstripe.managers.SubscriptionManager.canceled","text":"Return canceled Subscriptions. Source code in djstripe/managers.py def canceled ( self ): \"\"\"Return canceled Subscriptions.\"\"\" return self . filter ( status = \"canceled\" )","title":"canceled()"},{"location":"reference/managers/#djstripe.managers.SubscriptionManager.canceled_during","text":"Return Subscriptions canceled during a certain time range. Source code in djstripe/managers.py def canceled_during ( self , year , month ): \"\"\"Return Subscriptions canceled during a certain time range.\"\"\" return self . canceled () . filter ( canceled_at__year = year , canceled_at__month = month )","title":"canceled_during()"},{"location":"reference/managers/#djstripe.managers.SubscriptionManager.canceled_plan_summary_for","text":"Return Subscriptions canceled within a time range with plan counts annotated. Source code in djstripe/managers.py def canceled_plan_summary_for ( self , year , month ): \"\"\" Return Subscriptions canceled within a time range with plan counts annotated. \"\"\" return ( self . canceled_during ( year , month ) . values ( \"plan\" ) . order_by () . annotate ( count = models . Count ( \"plan\" )) )","title":"canceled_plan_summary_for()"},{"location":"reference/managers/#djstripe.managers.SubscriptionManager.churn","text":"Return number of canceled Subscriptions divided by active Subscriptions. Source code in djstripe/managers.py def churn ( self ): \"\"\"Return number of canceled Subscriptions divided by active Subscriptions.\"\"\" canceled = self . canceled () . count () active = self . active () . count () return decimal . Decimal ( str ( canceled )) / decimal . Decimal ( str ( active ))","title":"churn()"},{"location":"reference/managers/#djstripe.managers.SubscriptionManager.started_during","text":"Return Subscriptions not in trial status between a certain time range. Source code in djstripe/managers.py def started_during ( self , year , month ): \"\"\"Return Subscriptions not in trial status between a certain time range.\"\"\" return self . exclude ( status = \"trialing\" ) . filter ( start_date__year = year , start_date__month = month )","title":"started_during()"},{"location":"reference/managers/#djstripe.managers.SubscriptionManager.started_plan_summary_for","text":"Return started_during Subscriptions with plan counts annotated. Source code in djstripe/managers.py def started_plan_summary_for ( self , year , month ): \"\"\"Return started_during Subscriptions with plan counts annotated.\"\"\" return ( self . started_during ( year , month ) . values ( \"plan\" ) . order_by () . annotate ( count = models . Count ( \"plan\" )) )","title":"started_plan_summary_for()"},{"location":"reference/managers/#djstripe.managers.TransferManager","text":"Manager used by models.Transfer.","title":"TransferManager"},{"location":"reference/managers/#djstripe.managers.TransferManager-methods","text":"","title":"Methods"},{"location":"reference/managers/#djstripe.managers.TransferManager.during","text":"Return Transfers between a certain time range. Source code in djstripe/managers.py def during ( self , year , month ): \"\"\"Return Transfers between a certain time range.\"\"\" return self . filter ( created__year = year , created__month = month )","title":"during()"},{"location":"reference/managers/#djstripe.managers.TransferManager.paid_totals_for","text":"Return paid Transfers during a certain year, month with total amounts annotated. Source code in djstripe/managers.py def paid_totals_for ( self , year , month ): \"\"\" Return paid Transfers during a certain year, month with total amounts annotated. \"\"\" return self . during ( year , month ) . aggregate ( total_amount = models . Sum ( \"amount\" ))","title":"paid_totals_for()"},{"location":"reference/models/","text":"Models Models hold the bulk of the functionality included in the dj-stripe package. Each model is tied closely to its corresponding object in the stripe dashboard. Fields that are not implemented for each model have a short reason behind the decision in the docstring for each model. Core Resources Classes djstripe.models.core.BalanceTransaction A single transaction that updates the Stripe balance. Stripe documentation: https://stripe.com/docs/api#balance_transaction_object djstripe . models . core . BalanceTransaction . amount djstripe . models . core . BalanceTransaction . available_on djstripe . models . core . BalanceTransaction . currency djstripe . models . core . BalanceTransaction . djstripe_owner_account : Optional [ djstripe . fields . StripeForeignKey ] djstripe . models . core . BalanceTransaction . exchange_rate djstripe . models . core . BalanceTransaction . fee djstripe . models . core . BalanceTransaction . fee_details djstripe . models . core . BalanceTransaction . net djstripe . models . core . BalanceTransaction . reporting_category djstripe . models . core . BalanceTransaction . source djstripe . models . core . BalanceTransaction . status djstripe . models . core . BalanceTransaction . type djstripe.models.core.BalanceTransaction.DoesNotExist djstripe.models.core.BalanceTransaction.MultipleObjectsReturned djstripe.models.core.BalanceTransaction.stripe_class Methods djstripe . models . core . BalanceTransaction . __str__ ( self ) special Source code in djstripe/models/core.py def __str__ ( self ): return f \" { self . human_readable_amount } ( { enums . BalanceTransactionStatus . humanize ( self . status ) } )\" djstripe . models . core . BalanceTransaction . get_next_by_available_on ( self , * , field =< djstripe . fields . StripeDateTimeField : available_on > , is_next = True , ** kwargs ) Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . core . BalanceTransaction . get_next_by_djstripe_created ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_created > , is_next = True , ** kwargs ) Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . core . BalanceTransaction . get_next_by_djstripe_updated ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_updated > , is_next = True , ** kwargs ) Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . core . BalanceTransaction . get_previous_by_available_on ( self , * , field =< djstripe . fields . StripeDateTimeField : available_on > , is_next = False , ** kwargs ) Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . core . BalanceTransaction . get_previous_by_djstripe_created ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_created > , is_next = False , ** kwargs ) Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . core . BalanceTransaction . get_previous_by_djstripe_updated ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_updated > , is_next = False , ** kwargs ) Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . core . BalanceTransaction . get_reporting_category_display ( self , * , field =< djstripe . fields . StripeEnumField : reporting_category > ) Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . core . BalanceTransaction . get_source_class ( self ) Source code in djstripe/models/core.py def get_source_class ( self ): try : return apps . get_model ( \"djstripe\" , self . type ) except LookupError : raise djstripe . models . core . BalanceTransaction . get_source_instance ( self ) Source code in djstripe/models/core.py def get_source_instance ( self ): return self . get_source_class () . objects . get ( id = self . source ) djstripe . models . core . BalanceTransaction . get_status_display ( self , * , field =< djstripe . fields . StripeEnumField : status > ) Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . core . BalanceTransaction . get_stripe_dashboard_url ( self ) Get the stripe dashboard url for this object. Source code in djstripe/models/core.py def get_stripe_dashboard_url ( self ): return self . get_source_instance () . get_stripe_dashboard_url () djstripe . models . core . BalanceTransaction . get_type_display ( self , * , field =< djstripe . fields . StripeEnumField : type > ) Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe.models.core.Charge To charge a credit or a debit card, you create a charge object. You can retrieve and refund individual charges as well as list all charges. Charges are identified by a unique random ID. Stripe documentation: https://stripe.com/docs/api?lang=python#charges djstripe . models . core . Charge . amount djstripe . models . core . Charge . amount_captured djstripe . models . core . Charge . amount_refunded djstripe . models . core . Charge . application djstripe . models . core . Charge . application_fee djstripe . models . core . Charge . application_fee_amount djstripe . models . core . Charge . balance_transaction djstripe . models . core . Charge . billing_details djstripe . models . core . Charge . calculated_statement_descriptor djstripe . models . core . Charge . captured djstripe . models . core . Charge . currency djstripe . models . core . Charge . customer djstripe . models . core . Charge . dispute djstripe . models . core . Charge . disputed djstripe . models . core . Charge . djstripe_owner_account : Optional [ djstripe . fields . StripeForeignKey ] djstripe . models . core . Charge . expand_fields : List [ str ] djstripe . models . core . Charge . failure_code djstripe . models . core . Charge . failure_message djstripe . models . core . Charge . fee property readonly djstripe . models . core . Charge . fraud_details djstripe . models . core . Charge . fraudulent : bool property readonly djstripe . models . core . Charge . human_readable_status : str property readonly djstripe . models . core . Charge . invoice djstripe . models . core . Charge . objects djstripe . models . core . Charge . on_behalf_of djstripe . models . core . Charge . outcome djstripe . models . core . Charge . paid djstripe . models . core . Charge . payment_intent djstripe . models . core . Charge . payment_method djstripe . models . core . Charge . payment_method_details djstripe . models . core . Charge . receipt_email djstripe . models . core . Charge . receipt_number djstripe . models . core . Charge . receipt_url djstripe . models . core . Charge . refunded djstripe . models . core . Charge . shipping djstripe . models . core . Charge . source djstripe . models . core . Charge . source_transfer djstripe . models . core . Charge . statement_descriptor djstripe . models . core . Charge . statement_descriptor_suffix djstripe . models . core . Charge . status djstripe . models . core . Charge . stripe_dashboard_item_name djstripe . models . core . Charge . transfer djstripe . models . core . Charge . transfer_data djstripe . models . core . Charge . transfer_group djstripe.models.core.Charge.DoesNotExist djstripe.models.core.Charge.MultipleObjectsReturned djstripe.models.core.Charge.stripe_class djstripe . models . core . Charge . stripe_class . OBJECT_NAME djstripe . models . core . Charge . stripe_class . capture ( self , idempotency_key = None , ** params ) Source code in djstripe/models/core.py def capture ( self , idempotency_key = None , ** params ): url = self . instance_url () + \"/capture\" headers = util . populate_headers ( idempotency_key ) self . refresh_from ( self . request ( \"post\" , url , params , headers )) return self djstripe . models . core . Charge . stripe_class . close_dispute ( self , idempotency_key = None , ** params ) Source code in djstripe/models/core.py def close_dispute ( self , idempotency_key = None , ** params ): requestor = api_requestor . APIRequestor ( self . api_key , api_version = self . stripe_version , account = self . stripe_account , ) url = self . instance_url () + \"/dispute/close\" headers = util . populate_headers ( idempotency_key ) response , api_key = requestor . request ( \"post\" , url , params , headers ) self . refresh_from ({ \"dispute\" : response }, api_key , True ) return self . dispute djstripe . models . core . Charge . stripe_class . mark_as_fraudulent ( self , idempotency_key = None ) Source code in djstripe/models/core.py def mark_as_fraudulent ( self , idempotency_key = None ): params = { \"fraud_details\" : { \"user_report\" : \"fraudulent\" }} url = self . instance_url () headers = util . populate_headers ( idempotency_key ) self . refresh_from ( self . request ( \"post\" , url , params , headers )) return self djstripe . models . core . Charge . stripe_class . mark_as_safe ( self , idempotency_key = None ) Source code in djstripe/models/core.py def mark_as_safe ( self , idempotency_key = None ): params = { \"fraud_details\" : { \"user_report\" : \"safe\" }} url = self . instance_url () headers = util . populate_headers ( idempotency_key ) self . refresh_from ( self . request ( \"post\" , url , params , headers )) return self djstripe . models . core . Charge . stripe_class . refund ( self , idempotency_key = None , ** params ) Source code in djstripe/models/core.py def refund ( self , idempotency_key = None , ** params ): url = self . instance_url () + \"/refund\" headers = util . populate_headers ( idempotency_key ) self . refresh_from ( self . request ( \"post\" , url , params , headers )) return self djstripe . models . core . Charge . stripe_class . update_dispute ( self , idempotency_key = None , ** params ) Source code in djstripe/models/core.py def update_dispute ( self , idempotency_key = None , ** params ): requestor = api_requestor . APIRequestor ( self . api_key , api_version = self . stripe_version , account = self . stripe_account , ) url = self . instance_url () + \"/dispute\" headers = util . populate_headers ( idempotency_key ) response , api_key = requestor . request ( \"post\" , url , params , headers ) self . refresh_from ({ \"dispute\" : response }, api_key , True ) return self . dispute Methods djstripe . models . core . Charge . __str__ ( self ) special Source code in djstripe/models/core.py def __str__ ( self ): amount = self . human_readable_amount status = self . human_readable_status return \" {amount} ( {status} )\" . format ( amount = amount , status = status ) djstripe . models . core . Charge . capture ( self , ** kwargs ) Capture the payment of an existing, uncaptured, charge. This is the second half of the two-step payment flow, where first you created a charge with the capture option set to False. See https://stripe.com/docs/api#capture_charge Source code in djstripe/models/core.py def capture ( self , ** kwargs ) -> \"Charge\" : \"\"\" Capture the payment of an existing, uncaptured, charge. This is the second half of the two-step payment flow, where first you created a charge with the capture option set to False. See https://stripe.com/docs/api#capture_charge \"\"\" captured_charge = self . api_retrieve () . capture ( ** kwargs ) return self . __class__ . sync_from_stripe_data ( captured_charge ) djstripe . models . core . Charge . get_failure_code_display ( self , * , field =< djstripe . fields . StripeEnumField : failure_code > ) Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . core . Charge . get_next_by_djstripe_created ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_created > , is_next = True , ** kwargs ) Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . core . Charge . get_next_by_djstripe_updated ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_updated > , is_next = True , ** kwargs ) Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . core . Charge . get_previous_by_djstripe_created ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_created > , is_next = False , ** kwargs ) Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . core . Charge . get_previous_by_djstripe_updated ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_updated > , is_next = False , ** kwargs ) Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . core . Charge . get_status_display ( self , * , field =< djstripe . fields . StripeEnumField : status > ) Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . core . Charge . refund ( self , amount = None , reason = None ) Initiate a refund. Returns the charge object. :param amount: A positive decimal amount representing how much of this charge to refund. If amount is not provided, then this will be a full refund. Can only refund up to the unrefunded amount remaining of the charge. :param reason: String indicating the reason for the refund. If set, possible values are duplicate , fraudulent , and requested_by_customer . Specifying fraudulent as the reason when you believe the charge to be fraudulent will help Stripe improve their fraud detection algorithms. Source code in djstripe/models/core.py def refund ( self , amount : Decimal = None , reason : str = None ) -> \"Charge\" : \"\"\" Initiate a refund. Returns the charge object. :param amount: A positive decimal amount representing how much of this charge to refund. If amount is not provided, then this will be a full refund. Can only refund up to the unrefunded amount remaining of the charge. :param reason: String indicating the reason for the refund. If set, possible values are ``duplicate``, ``fraudulent``, and ``requested_by_customer``. Specifying ``fraudulent`` as the reason when you believe the charge to be fraudulent will help Stripe improve their fraud detection algorithms. \"\"\" charge_obj = self . api_retrieve () . refund ( amount = self . _calculate_refund_amount ( amount = amount ), reason = reason ) return self . __class__ . sync_from_stripe_data ( charge_obj ) djstripe.models.core.Customer Customer objects allow you to perform recurring charges and track multiple charges that are associated with the same customer. Stripe documentation: https://stripe.com/docs/api?lang=python#customers Attributes djstripe . models . core . Customer . active_subscriptions property readonly Returns active subscriptions (subscriptions with an active status that end in the future). djstripe . models . core . Customer . address djstripe . models . core . Customer . balance djstripe . models . core . Customer . coupon djstripe . models . core . Customer . coupon_end djstripe . models . core . Customer . coupon_start djstripe . models . core . Customer . credits property readonly The customer is considered to have credits if their balance is below 0. djstripe . models . core . Customer . currency djstripe . models . core . Customer . customer_payment_methods property readonly An iterable of all of the customer's payment methods (sources, then legacy cards) djstripe . models . core . Customer . date_purged djstripe . models . core . Customer . default_payment_method djstripe . models . core . Customer . default_source djstripe . models . core . Customer . deleted djstripe . models . core . Customer . delinquent djstripe . models . core . Customer . djstripe_owner_account : Optional [ djstripe . fields . StripeForeignKey ] djstripe . models . core . Customer . email djstripe . models . core . Customer . expand_fields : List [ str ] djstripe . models . core . Customer . invoice_prefix djstripe . models . core . Customer . invoice_settings djstripe . models . core . Customer . name djstripe . models . core . Customer . pending_charges property readonly The customer is considered to have pending charges if their balance is above 0. djstripe . models . core . Customer . phone djstripe . models . core . Customer . preferred_locales djstripe . models . core . Customer . shipping djstripe . models . core . Customer . stripe_dashboard_item_name djstripe . models . core . Customer . subscriber djstripe . models . core . Customer . subscription property readonly Shortcut to get this customer's subscription. :returns: None if the customer has no subscriptions, the subscription if the customer has a subscription. :raises MultipleSubscriptionException: Raised if the customer has multiple subscriptions. In this case, use Customer.subscriptions instead. djstripe . models . core . Customer . tax_exempt djstripe . models . core . Customer . valid_subscriptions property readonly Returns this customer's valid subscriptions (subscriptions that aren't canceled or incomplete_expired). djstripe.models.core.Customer.DoesNotExist djstripe.models.core.Customer.MultipleObjectsReturned djstripe.models.core.Customer.stripe_class djstripe . models . core . Customer . stripe_class . OBJECT_NAME djstripe . models . core . Customer . stripe_class . balance_transactions_request ( method , url , api_key = None , idempotency_key = None , stripe_version = None , stripe_account = None , ** params ) classmethod Source code in djstripe/models/core.py def nested_resource_request ( cls , method , url , api_key = None , idempotency_key = None , stripe_version = None , stripe_account = None , ** params ): requestor = api_requestor . APIRequestor ( api_key , api_version = stripe_version , account = stripe_account ) headers = util . populate_headers ( idempotency_key ) response , api_key = requestor . request ( method , url , params , headers ) return util . convert_to_stripe_object ( response , api_key , stripe_version , stripe_account ) djstripe . models . core . Customer . stripe_class . balance_transactions_url ( id , nested_id = None ) classmethod Source code in djstripe/models/core.py def nested_resource_url ( cls , id , nested_id = None ): url = \" %s / %s / %s \" % ( cls . class_url (), quote_plus ( id ), quote_plus ( path ), ) if nested_id is not None : url += \"/ %s \" % quote_plus ( nested_id ) return url djstripe . models . core . Customer . stripe_class . create_balance_transaction ( id , ** params ) classmethod Source code in djstripe/models/core.py def create_nested_resource ( cls , id , ** params ): url = getattr ( cls , resource_url_method )( id ) return getattr ( cls , resource_request_method )( \"post\" , url , ** params ) djstripe . models . core . Customer . stripe_class . create_source ( id , ** params ) classmethod Source code in djstripe/models/core.py def create_nested_resource ( cls , id , ** params ): url = getattr ( cls , resource_url_method )( id ) return getattr ( cls , resource_request_method )( \"post\" , url , ** params ) djstripe . models . core . Customer . stripe_class . create_tax_id ( id , ** params ) classmethod Source code in djstripe/models/core.py def create_nested_resource ( cls , id , ** params ): url = getattr ( cls , resource_url_method )( id ) return getattr ( cls , resource_request_method )( \"post\" , url , ** params ) djstripe . models . core . Customer . stripe_class . delete_discount ( self , ** params ) Source code in djstripe/models/core.py def delete_discount ( self , ** params ): requestor = api_requestor . APIRequestor ( self . api_key , api_version = self . stripe_version , account = self . stripe_account , ) url = self . instance_url () + \"/discount\" _ , api_key = requestor . request ( \"delete\" , url , params ) self . refresh_from ({ \"discount\" : None }, api_key , True ) djstripe . models . core . Customer . stripe_class . delete_source ( id , nested_id , ** params ) classmethod Source code in djstripe/models/core.py def delete_nested_resource ( cls , id , nested_id , ** params ): url = getattr ( cls , resource_url_method )( id , nested_id ) return getattr ( cls , resource_request_method )( \"delete\" , url , ** params ) djstripe . models . core . Customer . stripe_class . delete_tax_id ( id , nested_id , ** params ) classmethod Source code in djstripe/models/core.py def delete_nested_resource ( cls , id , nested_id , ** params ): url = getattr ( cls , resource_url_method )( id , nested_id ) return getattr ( cls , resource_request_method )( \"delete\" , url , ** params ) djstripe . models . core . Customer . stripe_class . list_balance_transactions ( id , ** params ) classmethod Source code in djstripe/models/core.py def list_nested_resources ( cls , id , ** params ): url = getattr ( cls , resource_url_method )( id ) return getattr ( cls , resource_request_method )( \"get\" , url , ** params ) djstripe . models . core . Customer . stripe_class . list_payment_methods ( self , idempotency_key = None , ** params ) Source code in djstripe/models/core.py def list_payment_methods ( self , idempotency_key = None , ** params ): url = self . instance_url () + \"/payment_methods\" headers = util . populate_headers ( idempotency_key ) resp = self . request ( \"get\" , url , params , headers ) stripe_object = util . convert_to_stripe_object ( resp ) stripe_object . _retrieve_params = params return stripe_object djstripe . models . core . Customer . stripe_class . list_sources ( id , ** params ) classmethod Source code in djstripe/models/core.py def list_nested_resources ( cls , id , ** params ): url = getattr ( cls , resource_url_method )( id ) return getattr ( cls , resource_request_method )( \"get\" , url , ** params ) djstripe . models . core . Customer . stripe_class . list_tax_ids ( id , ** params ) classmethod Source code in djstripe/models/core.py def list_nested_resources ( cls , id , ** params ): url = getattr ( cls , resource_url_method )( id ) return getattr ( cls , resource_request_method )( \"get\" , url , ** params ) djstripe . models . core . Customer . stripe_class . modify_balance_transaction ( id , nested_id , ** params ) classmethod Source code in djstripe/models/core.py def modify_nested_resource ( cls , id , nested_id , ** params ): url = getattr ( cls , resource_url_method )( id , nested_id ) return getattr ( cls , resource_request_method )( \"post\" , url , ** params ) djstripe . models . core . Customer . stripe_class . modify_source ( id , nested_id , ** params ) classmethod Source code in djstripe/models/core.py def modify_nested_resource ( cls , id , nested_id , ** params ): url = getattr ( cls , resource_url_method )( id , nested_id ) return getattr ( cls , resource_request_method )( \"post\" , url , ** params ) djstripe . models . core . Customer . stripe_class . retrieve_balance_transaction ( id , nested_id , ** params ) classmethod Source code in djstripe/models/core.py def retrieve_nested_resource ( cls , id , nested_id , ** params ): url = getattr ( cls , resource_url_method )( id , nested_id ) return getattr ( cls , resource_request_method )( \"get\" , url , ** params ) djstripe . models . core . Customer . stripe_class . retrieve_source ( id , nested_id , ** params ) classmethod Source code in djstripe/models/core.py def retrieve_nested_resource ( cls , id , nested_id , ** params ): url = getattr ( cls , resource_url_method )( id , nested_id ) return getattr ( cls , resource_request_method )( \"get\" , url , ** params ) djstripe . models . core . Customer . stripe_class . retrieve_tax_id ( id , nested_id , ** params ) classmethod Source code in djstripe/models/core.py def retrieve_nested_resource ( cls , id , nested_id , ** params ): url = getattr ( cls , resource_url_method )( id , nested_id ) return getattr ( cls , resource_request_method )( \"get\" , url , ** params ) djstripe . models . core . Customer . stripe_class . sources_request ( method , url , api_key = None , idempotency_key = None , stripe_version = None , stripe_account = None , ** params ) classmethod Source code in djstripe/models/core.py def nested_resource_request ( cls , method , url , api_key = None , idempotency_key = None , stripe_version = None , stripe_account = None , ** params ): requestor = api_requestor . APIRequestor ( api_key , api_version = stripe_version , account = stripe_account ) headers = util . populate_headers ( idempotency_key ) response , api_key = requestor . request ( method , url , params , headers ) return util . convert_to_stripe_object ( response , api_key , stripe_version , stripe_account ) djstripe . models . core . Customer . stripe_class . sources_url ( id , nested_id = None ) classmethod Source code in djstripe/models/core.py def nested_resource_url ( cls , id , nested_id = None ): url = \" %s / %s / %s \" % ( cls . class_url (), quote_plus ( id ), quote_plus ( path ), ) if nested_id is not None : url += \"/ %s \" % quote_plus ( nested_id ) return url djstripe . models . core . Customer . stripe_class . tax_ids_request ( method , url , api_key = None , idempotency_key = None , stripe_version = None , stripe_account = None , ** params ) classmethod Source code in djstripe/models/core.py def nested_resource_request ( cls , method , url , api_key = None , idempotency_key = None , stripe_version = None , stripe_account = None , ** params ): requestor = api_requestor . APIRequestor ( api_key , api_version = stripe_version , account = stripe_account ) headers = util . populate_headers ( idempotency_key ) response , api_key = requestor . request ( method , url , params , headers ) return util . convert_to_stripe_object ( response , api_key , stripe_version , stripe_account ) djstripe . models . core . Customer . stripe_class . tax_ids_url ( id , nested_id = None ) classmethod Source code in djstripe/models/core.py def nested_resource_url ( cls , id , nested_id = None ): url = \" %s / %s / %s \" % ( cls . class_url (), quote_plus ( id ), quote_plus ( path ), ) if nested_id is not None : url += \"/ %s \" % quote_plus ( nested_id ) return url Methods djstripe . models . core . Customer . __str__ ( self ) special Source code in djstripe/models/core.py def __str__ ( self ): if self . subscriber : return str ( self . subscriber ) return self . name or self . description or self . id djstripe . models . core . Customer . add_card ( self , source , set_default = True ) Adds a card to this customer's account. :param source: Either a token, like the ones returned by our Stripe.js, or a dictionary containing a user's credit card details. Stripe will automatically validate the card. :type source: string, dict :param set_default: Whether or not to set the source as the customer's default source :type set_default: boolean Source code in djstripe/models/core.py def add_card ( self , source , set_default = True ): \"\"\" Adds a card to this customer's account. :param source: Either a token, like the ones returned by our Stripe.js, or a dictionary containing a user's credit card details. Stripe will automatically validate the card. :type source: string, dict :param set_default: Whether or not to set the source as the customer's default source :type set_default: boolean \"\"\" from .payment_methods import DjstripePaymentMethod stripe_customer = self . api_retrieve () new_stripe_payment_method = stripe_customer . sources . create ( source = source ) if set_default : stripe_customer . default_source = new_stripe_payment_method [ \"id\" ] stripe_customer . save () new_payment_method = DjstripePaymentMethod . from_stripe_object ( new_stripe_payment_method ) # Change the default source if set_default : self . default_source = new_payment_method self . save () return new_payment_method . resolve () djstripe . models . core . Customer . add_coupon ( self , coupon , idempotency_key = None ) Add a coupon to a Customer. The coupon can be a Coupon object, or a valid Stripe Coupon ID. Source code in djstripe/models/core.py def add_coupon ( self , coupon , idempotency_key = None ): \"\"\" Add a coupon to a Customer. The coupon can be a Coupon object, or a valid Stripe Coupon ID. \"\"\" if isinstance ( coupon , StripeModel ): coupon = coupon . id stripe_customer = self . api_retrieve () stripe_customer [ \"coupon\" ] = coupon stripe_customer . save ( idempotency_key = idempotency_key ) return self . __class__ . sync_from_stripe_data ( stripe_customer ) djstripe . models . core . Customer . add_invoice_item ( self , amount , currency , description = None , discountable = None , invoice = None , metadata = None , subscription = None ) Adds an arbitrary charge or credit to the customer's upcoming invoice. Different than creating a charge. Charges are separate bills that get processed immediately. Invoice items are appended to the customer's next invoice. This is extremely useful when adding surcharges to subscriptions. :param amount: The amount to charge. :type amount: Decimal. Precision is 2; anything more will be ignored. :param currency: 3-letter ISO code for currency :type currency: string :param description: An arbitrary string. :type description: string :param discountable: Controls whether discounts apply to this invoice item. Defaults to False for prorations or negative invoice items, and True for all other invoice items. :type discountable: boolean :param invoice: An existing invoice to add this invoice item to. When left blank, the invoice item will be added to the next upcoming scheduled invoice. Use this when adding invoice items in response to an invoice.created webhook. You cannot add an invoice item to an invoice that has already been paid, attempted or closed. :type invoice: Invoice or string (invoice ID) :param metadata: A set of key/value pairs useful for storing additional information. :type metadata: dict :param subscription: A subscription to add this invoice item to. When left blank, the invoice item will be be added to the next upcoming scheduled invoice. When set, scheduled invoices for subscriptions other than the specified subscription will ignore the invoice item. Use this when you want to express that an invoice item has been accrued within the context of a particular subscription. :type subscription: Subscription or string (subscription ID) .. Notes: .. if you're using Customer.add_invoice_item() instead of .. Customer.add_invoice_item() , invoice and subscriptions .. can only be strings Source code in djstripe/models/core.py def add_invoice_item ( self , amount , currency , description = None , discountable = None , invoice = None , metadata = None , subscription = None , ): \"\"\" Adds an arbitrary charge or credit to the customer's upcoming invoice. Different than creating a charge. Charges are separate bills that get processed immediately. Invoice items are appended to the customer's next invoice. This is extremely useful when adding surcharges to subscriptions. :param amount: The amount to charge. :type amount: Decimal. Precision is 2; anything more will be ignored. :param currency: 3-letter ISO code for currency :type currency: string :param description: An arbitrary string. :type description: string :param discountable: Controls whether discounts apply to this invoice item. Defaults to False for prorations or negative invoice items, and True for all other invoice items. :type discountable: boolean :param invoice: An existing invoice to add this invoice item to. When left blank, the invoice item will be added to the next upcoming \\ scheduled invoice. \\ Use this when adding invoice items in response to an \\ ``invoice.created`` webhook. You cannot add an invoice \\ item to an invoice that has already been paid, attempted or closed. :type invoice: Invoice or string (invoice ID) :param metadata: A set of key/value pairs useful for storing additional information. :type metadata: dict :param subscription: A subscription to add this invoice item to. When left blank, the invoice item will be be added to the next upcoming \\ scheduled invoice. When set, scheduled invoices for subscriptions other \\ than the specified subscription will ignore the invoice item. \\ Use this when you want to express that an invoice item has been accrued \\ within the context of a particular subscription. :type subscription: Subscription or string (subscription ID) .. Notes: .. if you're using ``Customer.add_invoice_item()`` instead of .. ``Customer.add_invoice_item()``, ``invoice`` and ``subscriptions`` .. can only be strings \"\"\" from .billing import InvoiceItem if not isinstance ( amount , Decimal ): raise ValueError ( \"You must supply a decimal value representing dollars.\" ) # Convert Invoice to id if invoice is not None and isinstance ( invoice , StripeModel ): invoice = invoice . id # Convert Subscription to id if subscription is not None and isinstance ( subscription , StripeModel ): subscription = subscription . id stripe_invoiceitem = InvoiceItem . _api_create ( amount = int ( amount * 100 ), # Convert dollars into cents currency = currency , customer = self . id , description = description , discountable = discountable , invoice = invoice , metadata = metadata , subscription = subscription , ) return InvoiceItem . sync_from_stripe_data ( stripe_invoiceitem ) djstripe . models . core . Customer . add_payment_method ( self , payment_method , set_default = True ) Adds an already existing payment method to this customer's account :param payment_method: PaymentMethod to be attached to the customer :type payment_method: str, PaymentMethod :param set_default: If true, this will be set as the default_payment_method :type set_default: bool :rtype: PaymentMethod Source code in djstripe/models/core.py def add_payment_method ( self , payment_method , set_default = True ): \"\"\" Adds an already existing payment method to this customer's account :param payment_method: PaymentMethod to be attached to the customer :type payment_method: str, PaymentMethod :param set_default: If true, this will be set as the default_payment_method :type set_default: bool :rtype: PaymentMethod \"\"\" from .payment_methods import PaymentMethod stripe_customer = self . api_retrieve () payment_method = PaymentMethod . attach ( payment_method , stripe_customer ) if set_default : stripe_customer [ \"invoice_settings\" ][ \"default_payment_method\" ] = payment_method . id stripe_customer . save () # Refresh self from the stripe customer, this should have two effects: # 1) sets self.default_payment_method (we rely on logic in # Customer._manipulate_stripe_object_hook to do this) # 2) updates self.invoice_settings.default_payment_methods self . sync_from_stripe_data ( stripe_customer ) self . refresh_from_db () return payment_method djstripe . models . core . Customer . can_charge ( self ) Determines if this customer is able to be charged. Source code in djstripe/models/core.py def can_charge ( self ): \"\"\"Determines if this customer is able to be charged.\"\"\" warnings . warn ( \"Customer.can_charge() is misleading and deprecated, will be removed in dj-stripe 2.8. \" \"Look at Customer.payment_methods.all() instead.\" , DeprecationWarning , ) return ( self . has_valid_source () or self . default_payment_method is not None ) and self . date_purged is None djstripe . models . core . Customer . charge ( self , amount , * , application_fee = None , source = None , ** kwargs ) Creates a charge for this customer. :param amount: The amount to charge. :type amount: Decimal. Precision is 2; anything more will be ignored. :param source: The source to use for this charge. Must be a source attributed to this customer. If None, the customer's default source is used. Can be either the id of the source or the source object itself. :type source: string, Source Source code in djstripe/models/core.py def charge ( self , amount : Decimal , * , application_fee : Decimal = None , source : Union [ str , StripeModel ] = None , ** kwargs , ) -> Charge : \"\"\" Creates a charge for this customer. :param amount: The amount to charge. :type amount: Decimal. Precision is 2; anything more will be ignored. :param source: The source to use for this charge. Must be a source attributed to this customer. If None, the customer's default source is used. Can be either the id of the source or the source object itself. :type source: string, Source \"\"\" if not isinstance ( amount , Decimal ): raise ValueError ( \"You must supply a decimal value representing dollars.\" ) # Convert Source to id if source and isinstance ( source , StripeModel ): source = source . id stripe_charge = Charge . _api_create ( customer = self . id , amount = int ( amount * 100 ), # Convert dollars into cents application_fee = int ( application_fee * 100 ) if application_fee else None , # Convert dollars into cents source = source , ** kwargs , ) return Charge . sync_from_stripe_data ( stripe_charge ) djstripe . models . core . Customer . create ( subscriber , idempotency_key = None , stripe_account = None ) classmethod Source code in djstripe/models/core.py @classmethod def create ( cls , subscriber , idempotency_key = None , stripe_account = None ): metadata = {} subscriber_key = djstripe_settings . SUBSCRIBER_CUSTOMER_KEY if subscriber_key not in ( \"\" , None ): metadata [ subscriber_key ] = subscriber . pk stripe_customer = cls . _api_create ( email = subscriber . email , idempotency_key = idempotency_key , metadata = metadata , stripe_account = stripe_account , ) customer , created = Customer . objects . get_or_create ( id = stripe_customer [ \"id\" ], defaults = { \"subscriber\" : subscriber , \"livemode\" : stripe_customer [ \"livemode\" ], \"balance\" : stripe_customer . get ( \"balance\" , 0 ), \"delinquent\" : stripe_customer . get ( \"delinquent\" , False ), }, ) return customer djstripe . models . core . Customer . get_next_by_djstripe_created ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_created > , is_next = True , ** kwargs ) Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . core . Customer . get_next_by_djstripe_updated ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_updated > , is_next = True , ** kwargs ) Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . core . Customer . get_or_create ( subscriber , livemode = False , stripe_account = None ) classmethod Get or create a dj-stripe customer. :param subscriber: The subscriber model instance for which to get or create a customer. :type subscriber: User :param livemode: Whether to get the subscriber in live or test mode. :type livemode: bool Source code in djstripe/models/core.py @classmethod def get_or_create ( cls , subscriber , livemode = djstripe_settings . STRIPE_LIVE_MODE , stripe_account = None , ): \"\"\" Get or create a dj-stripe customer. :param subscriber: The subscriber model instance for which to get or create a customer. :type subscriber: User :param livemode: Whether to get the subscriber in live or test mode. :type livemode: bool \"\"\" try : return Customer . objects . get ( subscriber = subscriber , livemode = livemode ), False except Customer . DoesNotExist : action = \"create: {} \" . format ( subscriber . pk ) idempotency_key = djstripe_settings . get_idempotency_key ( \"customer\" , action , livemode ) return ( cls . create ( subscriber , idempotency_key = idempotency_key , stripe_account = stripe_account , ), True , ) djstripe . models . core . Customer . get_previous_by_djstripe_created ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_created > , is_next = False , ** kwargs ) Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . core . Customer . get_previous_by_djstripe_updated ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_updated > , is_next = False , ** kwargs ) Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . core . Customer . get_tax_exempt_display ( self , * , field =< djstripe . fields . StripeEnumField : tax_exempt > ) Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . core . Customer . has_any_active_subscription ( self ) Checks to see if this customer has an active subscription to any plan. :returns: True if there exists an active subscription, False otherwise. Source code in djstripe/models/core.py def has_any_active_subscription ( self ): \"\"\" Checks to see if this customer has an active subscription to any plan. :returns: True if there exists an active subscription, False otherwise. \"\"\" return len ( self . _get_valid_subscriptions ()) != 0 djstripe . models . core . Customer . has_valid_source ( self ) Check whether the customer has a valid payment source. Source code in djstripe/models/core.py def has_valid_source ( self ): \"\"\"Check whether the customer has a valid payment source.\"\"\" warnings . warn ( \"Customer.has_valid_source() is deprecated and will be removed in dj-stripe 2.8. \" \"Use `Customer.default_source is not None` instead.\" , DeprecationWarning , ) return self . default_source is not None djstripe . models . core . Customer . is_subscribed_to ( self , product ) Checks to see if this customer has an active subscription to the given product. :param product: The product for which to check for an active subscription. :type product: Product or string (product ID) :returns: True if there exists an active subscription, False otherwise. Source code in djstripe/models/core.py def is_subscribed_to ( self , product : Union [ Product , str ]) -> bool : \"\"\" Checks to see if this customer has an active subscription to the given product. :param product: The product for which to check for an active subscription. :type product: Product or string (product ID) :returns: True if there exists an active subscription, False otherwise. \"\"\" if isinstance ( product , StripeModel ): product = product . id for subscription in self . _get_valid_subscriptions (): for item in subscription . items . all (): if item . price and item . price . product . id == product : return True return False djstripe . models . core . Customer . purge ( self ) Customers are soft deleted as deleted customers are still accessible by the Stripe API and sync for all RelatedModels would fail Source code in djstripe/models/core.py def purge ( self ): \"\"\"Customers are soft deleted as deleted customers are still accessible by the Stripe API and sync for all RelatedModels would fail\"\"\" try : self . _api_delete () except InvalidRequestError as exc : if \"No such customer:\" in str ( exc ): # The exception was thrown because the stripe customer was already # deleted on the stripe side, ignore the exception pass else : # The exception was raised for another reason, re-raise it raise # toggle the deleted flag on Customer to indicate it has been # deleted upstream in Stripe self . deleted = True if self . subscriber : # Delete the idempotency key used by Customer.create() # So re-creating a customer for this subscriber before the key expires # doesn't return the older Customer data idempotency_key_action = \"customer:create: {} \" . format ( self . subscriber . pk ) IdempotencyKey . objects . filter ( action = idempotency_key_action ) . delete () self . subscriber = None # Remove sources self . default_source = None for source in self . legacy_cards . all (): source . remove () for source in self . sources . all (): source . detach () self . date_purged = timezone . now () self . save () djstripe . models . core . Customer . retry_unpaid_invoices ( self ) Attempt to retry collecting payment on the customer's unpaid invoices. Source code in djstripe/models/core.py def retry_unpaid_invoices ( self ): \"\"\"Attempt to retry collecting payment on the customer's unpaid invoices.\"\"\" self . _sync_invoices () for invoice in self . invoices . filter ( auto_advance = True ) . exclude ( status = \"paid\" ): try : invoice . retry () # Always retry unpaid invoices except InvalidRequestError as exc : if str ( exc ) != \"Invoice is already paid\" : raise djstripe . models . core . Customer . send_invoice ( self ) Pay and send the customer's latest invoice. :returns: True if an invoice was able to be created and paid, False otherwise (typically if there was nothing to invoice). Source code in djstripe/models/core.py def send_invoice ( self ): \"\"\" Pay and send the customer's latest invoice. :returns: True if an invoice was able to be created and paid, False otherwise (typically if there was nothing to invoice). \"\"\" from .billing import Invoice try : invoice = Invoice . _api_create ( customer = self . id ) invoice . pay () return True except InvalidRequestError : # TODO: Check this for a more # specific error message. return False # There was nothing to invoice djstripe . models . core . Customer . subscribe ( self , * , items = None , price = None , plan = None , ** kwargs ) Subscribes this customer to all the prices or plans in the items dict (Recommended). :param items: A list of up to 20 subscription items, each with an attached price :type list: :param items: A dictionary of Plan (or Plan ID) or Price (or Price ID) :type dict: The price or plan to which to subscribe the customer. :param price: The price to which to subscribe the customer. :type price: Price or string (price ID) :param plan: The plan to which to subscribe the customer. :type plan: Plan or string (plan ID) Source code in djstripe/models/core.py def subscribe ( self , * , items = None , price = None , plan = None , ** kwargs ): \"\"\" Subscribes this customer to all the prices or plans in the items dict (Recommended). :param items: A list of up to 20 subscription items, each with an attached price :type list: :param items: A dictionary of Plan (or Plan ID) or Price (or Price ID) :type dict: The price or plan to which to subscribe the customer. :param price: The price to which to subscribe the customer. :type price: Price or string (price ID) :param plan: The plan to which to subscribe the customer. :type plan: Plan or string (plan ID) \"\"\" from .billing import Subscription if ( items and price ) or ( items and plan ) or ( price and plan ): raise TypeError ( \"Please define only one of items, price or plan arguments.\" ) if items is None : _items = [{ \"price\" : price }] else : _items = [] for item in items : price = item . get ( \"price\" , \"\" ) plan = item . get ( \"plan\" , \"\" ) price , kwargs = _sanitise_price ( price , plan , ** kwargs ) if \"price\" in item : _items . append ({ \"price\" : price }) if \"plan\" in item : _items . append ({ \"plan\" : price }) stripe_subscription = Subscription . _api_create ( items = _items , customer = self . id , ** kwargs ) Subscription . sync_from_stripe_data ( stripe_subscription ) djstripe . models . core . Customer . upcoming_invoice ( self , ** kwargs ) Gets the upcoming preview invoice (singular) for this customer. See Invoice.upcoming() <#djstripe.Invoice.upcoming> __. The customer argument to the upcoming() call is automatically set by this method. Source code in djstripe/models/core.py def upcoming_invoice ( self , ** kwargs ): \"\"\"Gets the upcoming preview invoice (singular) for this customer. See `Invoice.upcoming() <#djstripe.Invoice.upcoming>`__. The ``customer`` argument to the ``upcoming()`` call is automatically set by this method. \"\"\" from .billing import Invoice kwargs [ \"customer\" ] = self return Invoice . upcoming ( ** kwargs ) djstripe.models.core.Dispute A dispute occurs when a customer questions your charge with their card issuer. When this happens, you're given the opportunity to respond to the dispute with evidence that shows that the charge is legitimate Stripe documentation: https://stripe.com/docs/api#disputes djstripe . models . core . Dispute . amount djstripe . models . core . Dispute . balance_transaction djstripe . models . core . Dispute . balance_transactions djstripe . models . core . Dispute . charge djstripe . models . core . Dispute . currency djstripe . models . core . Dispute . djstripe_owner_account : Optional [ djstripe . fields . StripeForeignKey ] djstripe . models . core . Dispute . evidence djstripe . models . core . Dispute . evidence_details djstripe . models . core . Dispute . is_charge_refundable djstripe . models . core . Dispute . payment_intent djstripe . models . core . Dispute . reason djstripe . models . core . Dispute . status djstripe . models . core . Dispute . stripe_dashboard_item_name djstripe.models.core.Dispute.DoesNotExist djstripe.models.core.Dispute.MultipleObjectsReturned djstripe.models.core.Dispute.stripe_class djstripe . models . core . Dispute . stripe_class . OBJECT_NAME djstripe . models . core . Dispute . stripe_class . close ( self , idempotency_key = None , ** params ) Source code in djstripe/models/core.py def close ( self , idempotency_key = None , ** params ): url = self . instance_url () + \"/close\" headers = util . populate_headers ( idempotency_key ) self . refresh_from ( self . request ( \"post\" , url , params , headers )) return self djstripe . models . core . Dispute . __str__ ( self ) special Source code in djstripe/models/core.py def __str__ ( self ): return f \" { self . human_readable_amount } ( { enums . DisputeStatus . humanize ( self . status ) } ) \" djstripe . models . core . Dispute . get_next_by_djstripe_created ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_created > , is_next = True , ** kwargs ) Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . core . Dispute . get_next_by_djstripe_updated ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_updated > , is_next = True , ** kwargs ) Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . core . Dispute . get_previous_by_djstripe_created ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_created > , is_next = False , ** kwargs ) Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . core . Dispute . get_previous_by_djstripe_updated ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_updated > , is_next = False , ** kwargs ) Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . core . Dispute . get_reason_display ( self , * , field =< djstripe . fields . StripeEnumField : reason > ) Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . core . Dispute . get_status_display ( self , * , field =< djstripe . fields . StripeEnumField : status > ) Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe.models.core.Event Events are Stripe's way of letting you know when something interesting happens in your account. When an interesting event occurs, a new Event object is created and POSTed to the configured webhook URL if the Event type matches. Stripe documentation: https://stripe.com/docs/api/events djstripe . models . core . Event . api_version djstripe . models . core . Event . customer property readonly djstripe . models . core . Event . data djstripe . models . core . Event . djstripe_owner_account : Optional [ djstripe . fields . StripeForeignKey ] djstripe . models . core . Event . idempotency_key djstripe . models . core . Event . request_id djstripe . models . core . Event . stripe_dashboard_item_name djstripe . models . core . Event . type djstripe.models.core.Event.DoesNotExist djstripe.models.core.Event.MultipleObjectsReturned djstripe.models.core.Event.stripe_class Methods djstripe . models . core . Event . __str__ ( self ) special Source code in djstripe/models/core.py def __str__ ( self ): return f \"type= { self . type } , id= { self . id } \" djstripe . models . core . Event . get_next_by_djstripe_created ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_created > , is_next = True , ** kwargs ) Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . core . Event . get_next_by_djstripe_updated ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_updated > , is_next = True , ** kwargs ) Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . core . Event . get_previous_by_djstripe_created ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_created > , is_next = False , ** kwargs ) Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . core . Event . get_previous_by_djstripe_updated ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_updated > , is_next = False , ** kwargs ) Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . core . Event . invoke_webhook_handlers ( self ) Invokes any webhook handlers that have been registered for this event based on event type or event sub-type. See event handlers registered in the djstripe.event_handlers module (or handlers registered in djstripe plugins or contrib packages). Source code in djstripe/models/core.py def invoke_webhook_handlers ( self ): \"\"\" Invokes any webhook handlers that have been registered for this event based on event type or event sub-type. See event handlers registered in the ``djstripe.event_handlers`` module (or handlers registered in djstripe plugins or contrib packages). \"\"\" webhooks . call_handlers ( event = self ) signal = WEBHOOK_SIGNALS . get ( self . type ) if signal : return signal . send ( sender = Event , event = self ) djstripe . models . core . Event . process ( data ) classmethod Source code in djstripe/models/core.py @classmethod def process ( cls , data ): qs = cls . objects . filter ( id = data [ \"id\" ]) if qs . exists (): return qs . first () # Rollback any DB operations in the case of failure so # we will retry creating and processing the event the # next time the webhook fires. with transaction . atomic (): # process the event and create an Event Object ret = cls . _create_from_stripe_object ( data ) ret . invoke_webhook_handlers () return ret djstripe.models.core.File Stripe documentation: https://stripe.com/docs/api/files djstripe . models . core . File . djstripe_owner_account : Optional [ djstripe . fields . StripeForeignKey ] djstripe . models . core . File . filename djstripe . models . core . File . purpose djstripe . models . core . File . size djstripe . models . core . File . type djstripe . models . core . File . url djstripe.models.core.File.DoesNotExist djstripe.models.core.File.MultipleObjectsReturned djstripe.models.core.File.stripe_class djstripe . models . core . File . stripe_class . OBJECT_NAME djstripe . models . core . File . stripe_class . OBJECT_NAME_ALT djstripe . models . core . File . stripe_class . class_url () classmethod Source code in djstripe/models/core.py @classmethod def class_url ( cls ): return \"/v1/files\" djstripe . models . core . File . stripe_class . create ( api_key = None , api_version = None , stripe_version = None , stripe_account = None , ** params ) classmethod Source code in djstripe/models/core.py @classmethod def create ( # 'api_version' is deprecated, please use 'stripe_version' cls , api_key = None , api_version = None , stripe_version = None , stripe_account = None , ** params ): version = api_version or stripe_version requestor = api_requestor . APIRequestor ( api_key , api_base = stripe . upload_api_base , api_version = version , account = stripe_account , ) url = cls . class_url () supplied_headers = { \"Content-Type\" : \"multipart/form-data\" } response , api_key = requestor . request ( \"post\" , url , params = params , headers = supplied_headers ) return util . convert_to_stripe_object ( response , api_key , version , stripe_account ) Methods djstripe . models . core . File . __str__ ( self ) special Source code in djstripe/models/core.py def __str__ ( self ): return f \" { self . filename } , { enums . FilePurpose . humanize ( self . purpose ) } \" djstripe . models . core . File . get_next_by_djstripe_created ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_created > , is_next = True , ** kwargs ) Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . core . File . get_next_by_djstripe_updated ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_updated > , is_next = True , ** kwargs ) Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . core . File . get_previous_by_djstripe_created ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_created > , is_next = False , ** kwargs ) Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . core . File . get_previous_by_djstripe_updated ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_updated > , is_next = False , ** kwargs ) Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . core . File . get_purpose_display ( self , * , field =< djstripe . fields . StripeEnumField : purpose > ) Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . core . File . get_type_display ( self , * , field =< djstripe . fields . StripeEnumField : type > ) Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . core . File . is_valid_object ( data ) classmethod Returns whether the data is a valid object for the class Source code in djstripe/models/core.py @classmethod def is_valid_object ( cls , data ): return \"object\" in data and data [ \"object\" ] in ( \"file\" , \"file_upload\" ) djstripe.models.core.FileLink Stripe documentation: https://stripe.com/docs/api/file_links djstripe . models . core . FileLink . djstripe_owner_account : Optional [ djstripe . fields . StripeForeignKey ] djstripe . models . core . FileLink . expires_at djstripe . models . core . FileLink . file djstripe . models . core . FileLink . url djstripe.models.core.FileLink.DoesNotExist djstripe.models.core.FileLink.MultipleObjectsReturned djstripe.models.core.FileLink.stripe_class djstripe . models . core . FileLink . __str__ ( self ) special Source code in djstripe/models/core.py def __str__ ( self ): return f \" { self . file . filename } , { self . url } \" djstripe . models . core . FileLink . get_next_by_djstripe_created ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_created > , is_next = True , ** kwargs ) Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . core . FileLink . get_next_by_djstripe_updated ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_updated > , is_next = True , ** kwargs ) Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . core . FileLink . get_previous_by_djstripe_created ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_created > , is_next = False , ** kwargs ) Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . core . FileLink . get_previous_by_djstripe_updated ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_updated > , is_next = False , ** kwargs ) Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe.models.core.FileUpload Stripe documentation: https://stripe.com/docs/api/files djstripe . models . core . FileUpload . djstripe_owner_account : Optional [ djstripe . fields . StripeForeignKey ] djstripe . models . core . FileUpload . filename djstripe . models . core . FileUpload . purpose djstripe . models . core . FileUpload . size djstripe . models . core . FileUpload . type djstripe . models . core . FileUpload . url djstripe.models.core.FileUpload.DoesNotExist djstripe.models.core.FileUpload.MultipleObjectsReturned djstripe.models.core.FileUpload.stripe_class djstripe . models . core . FileUpload . stripe_class . OBJECT_NAME djstripe . models . core . FileUpload . stripe_class . OBJECT_NAME_ALT djstripe . models . core . FileUpload . stripe_class . class_url () classmethod Source code in djstripe/models/core.py @classmethod def class_url ( cls ): return \"/v1/files\" djstripe . models . core . FileUpload . stripe_class . create ( api_key = None , api_version = None , stripe_version = None , stripe_account = None , ** params ) classmethod Source code in djstripe/models/core.py @classmethod def create ( # 'api_version' is deprecated, please use 'stripe_version' cls , api_key = None , api_version = None , stripe_version = None , stripe_account = None , ** params ): version = api_version or stripe_version requestor = api_requestor . APIRequestor ( api_key , api_base = stripe . upload_api_base , api_version = version , account = stripe_account , ) url = cls . class_url () supplied_headers = { \"Content-Type\" : \"multipart/form-data\" } response , api_key = requestor . request ( \"post\" , url , params = params , headers = supplied_headers ) return util . convert_to_stripe_object ( response , api_key , version , stripe_account ) Methods djstripe . models . core . FileUpload . __str__ ( self ) special Source code in djstripe/models/core.py def __str__ ( self ): return f \" { self . filename } , { enums . FilePurpose . humanize ( self . purpose ) } \" djstripe . models . core . FileUpload . get_next_by_djstripe_created ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_created > , is_next = True , ** kwargs ) Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . core . FileUpload . get_next_by_djstripe_updated ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_updated > , is_next = True , ** kwargs ) Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . core . FileUpload . get_previous_by_djstripe_created ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_created > , is_next = False , ** kwargs ) Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . core . FileUpload . get_previous_by_djstripe_updated ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_updated > , is_next = False , ** kwargs ) Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . core . FileUpload . get_purpose_display ( self , * , field =< djstripe . fields . StripeEnumField : purpose > ) Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . core . FileUpload . get_type_display ( self , * , field =< djstripe . fields . StripeEnumField : type > ) Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . core . FileUpload . is_valid_object ( data ) classmethod Returns whether the data is a valid object for the class Source code in djstripe/models/core.py @classmethod def is_valid_object ( cls , data ): return \"object\" in data and data [ \"object\" ] in ( \"file\" , \"file_upload\" ) djstripe.models.core.Mandate https://stripe.com/docs/api/mandates djstripe . models . core . Mandate . customer_acceptance djstripe . models . core . Mandate . djstripe_owner_account : Optional [ djstripe . fields . StripeForeignKey ] djstripe . models . core . Mandate . multi_use djstripe . models . core . Mandate . payment_method djstripe . models . core . Mandate . payment_method_details djstripe . models . core . Mandate . single_use djstripe . models . core . Mandate . status djstripe . models . core . Mandate . type djstripe.models.core.Mandate.DoesNotExist djstripe.models.core.Mandate.MultipleObjectsReturned djstripe.models.core.Mandate.stripe_class djstripe . models . core . Mandate . get_next_by_djstripe_created ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_created > , is_next = True , ** kwargs ) Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . core . Mandate . get_next_by_djstripe_updated ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_updated > , is_next = True , ** kwargs ) Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . core . Mandate . get_previous_by_djstripe_created ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_created > , is_next = False , ** kwargs ) Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . core . Mandate . get_previous_by_djstripe_updated ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_updated > , is_next = False , ** kwargs ) Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . core . Mandate . get_status_display ( self , * , field =< djstripe . fields . StripeEnumField : status > ) Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . core . Mandate . get_type_display ( self , * , field =< djstripe . fields . StripeEnumField : type > ) Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe.models.core.PaymentIntent Stripe documentation: https://stripe.com/docs/api#payment_intents djstripe . models . core . PaymentIntent . amount djstripe . models . core . PaymentIntent . amount_capturable djstripe . models . core . PaymentIntent . amount_received djstripe . models . core . PaymentIntent . canceled_at djstripe . models . core . PaymentIntent . cancellation_reason djstripe . models . core . PaymentIntent . capture_method djstripe . models . core . PaymentIntent . client_secret djstripe . models . core . PaymentIntent . confirmation_method djstripe . models . core . PaymentIntent . currency djstripe . models . core . PaymentIntent . customer djstripe . models . core . PaymentIntent . djstripe_owner_account : Optional [ djstripe . fields . StripeForeignKey ] djstripe . models . core . PaymentIntent . last_payment_error djstripe . models . core . PaymentIntent . next_action djstripe . models . core . PaymentIntent . on_behalf_of djstripe . models . core . PaymentIntent . payment_method djstripe . models . core . PaymentIntent . payment_method_types djstripe . models . core . PaymentIntent . receipt_email djstripe . models . core . PaymentIntent . setup_future_usage djstripe . models . core . PaymentIntent . shipping djstripe . models . core . PaymentIntent . statement_descriptor djstripe . models . core . PaymentIntent . status djstripe . models . core . PaymentIntent . stripe_dashboard_item_name djstripe . models . core . PaymentIntent . transfer_data djstripe . models . core . PaymentIntent . transfer_group djstripe.models.core.PaymentIntent.DoesNotExist djstripe.models.core.PaymentIntent.MultipleObjectsReturned djstripe.models.core.PaymentIntent.stripe_class djstripe . models . core . PaymentIntent . stripe_class . OBJECT_NAME djstripe . models . core . PaymentIntent . stripe_class . cancel ( self , idempotency_key = None , ** params ) Source code in djstripe/models/core.py def cancel ( self , idempotency_key = None , ** params ): url = self . instance_url () + \"/cancel\" headers = util . populate_headers ( idempotency_key ) self . refresh_from ( self . request ( \"post\" , url , params , headers )) return self djstripe . models . core . PaymentIntent . stripe_class . capture ( self , idempotency_key = None , ** params ) Source code in djstripe/models/core.py def capture ( self , idempotency_key = None , ** params ): url = self . instance_url () + \"/capture\" headers = util . populate_headers ( idempotency_key ) self . refresh_from ( self . request ( \"post\" , url , params , headers )) return self djstripe . models . core . PaymentIntent . stripe_class . confirm ( self , idempotency_key = None , ** params ) Source code in djstripe/models/core.py def confirm ( self , idempotency_key = None , ** params ): url = self . instance_url () + \"/confirm\" headers = util . populate_headers ( idempotency_key ) self . refresh_from ( self . request ( \"post\" , url , params , headers )) return self Methods djstripe . models . core . PaymentIntent . __str__ ( self ) special Source code in djstripe/models/core.py def __str__ ( self ): account = self . on_behalf_of customer = self . customer if account and customer : return ( f \" { self . human_readable_amount } ( { enums . PaymentIntentStatus . humanize ( self . status ) } ) \" f \"for { account } \" f \"by { customer } \" ) if account : return f \" { self . human_readable_amount } for { account } . { enums . PaymentIntentStatus . humanize ( self . status ) } \" if customer : return f \" { self . human_readable_amount } by { customer } . { enums . PaymentIntentStatus . humanize ( self . status ) } \" return f \" { self . human_readable_amount } ( { enums . PaymentIntentStatus . humanize ( self . status ) } )\" djstripe . models . core . PaymentIntent . get_cancellation_reason_display ( self , * , field =< djstripe . fields . StripeEnumField : cancellation_reason > ) Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . core . PaymentIntent . get_capture_method_display ( self , * , field =< djstripe . fields . StripeEnumField : capture_method > ) Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . core . PaymentIntent . get_confirmation_method_display ( self , * , field =< djstripe . fields . StripeEnumField : confirmation_method > ) Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . core . PaymentIntent . get_next_by_djstripe_created ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_created > , is_next = True , ** kwargs ) Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . core . PaymentIntent . get_next_by_djstripe_updated ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_updated > , is_next = True , ** kwargs ) Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . core . PaymentIntent . get_previous_by_djstripe_created ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_created > , is_next = False , ** kwargs ) Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . core . PaymentIntent . get_previous_by_djstripe_updated ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_updated > , is_next = False , ** kwargs ) Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . core . PaymentIntent . get_setup_future_usage_display ( self , * , field =< djstripe . fields . StripeEnumField : setup_future_usage > ) Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . core . PaymentIntent . get_status_display ( self , * , field =< djstripe . fields . StripeEnumField : status > ) Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . core . PaymentIntent . update ( self , api_key = None , ** kwargs ) Call the stripe API's modify operation for this model :param api_key: The api key to use for this request. Defaults to djstripe_settings.STRIPE_SECRET_KEY. :type api_key: string Source code in djstripe/models/core.py def update ( self , api_key = None , ** kwargs ): \"\"\" Call the stripe API's modify operation for this model :param api_key: The api key to use for this request. Defaults to djstripe_settings.STRIPE_SECRET_KEY. :type api_key: string \"\"\" api_key = api_key or self . default_api_key response = self . api_retrieve ( api_key = api_key ) return response . modify ( response . stripe_id , api_key = api_key , ** kwargs ) djstripe.models.core.Payout A Payout object is created when you receive funds from Stripe, or when you initiate a payout to either a bank account or debit card of a connected Stripe account. Stripe documentation: https://stripe.com/docs/api#payouts djstripe . models . core . Payout . amount djstripe . models . core . Payout . arrival_date djstripe . models . core . Payout . automatic djstripe . models . core . Payout . balance_transaction djstripe . models . core . Payout . currency djstripe . models . core . Payout . destination djstripe . models . core . Payout . djstripe_owner_account : Optional [ djstripe . fields . StripeForeignKey ] djstripe . models . core . Payout . expand_fields : List [ str ] djstripe . models . core . Payout . failure_balance_transaction djstripe . models . core . Payout . failure_code djstripe . models . core . Payout . failure_message djstripe . models . core . Payout . method djstripe . models . core . Payout . source_type djstripe . models . core . Payout . statement_descriptor djstripe . models . core . Payout . status djstripe . models . core . Payout . stripe_dashboard_item_name djstripe . models . core . Payout . type djstripe.models.core.Payout.DoesNotExist djstripe.models.core.Payout.MultipleObjectsReturned djstripe.models.core.Payout.stripe_class djstripe . models . core . Payout . stripe_class . OBJECT_NAME djstripe . models . core . Payout . stripe_class . cancel ( self , idempotency_key = None , ** params ) Source code in djstripe/models/core.py def cancel ( self , idempotency_key = None , ** params ): url = self . instance_url () + \"/cancel\" headers = util . populate_headers ( idempotency_key ) self . refresh_from ( self . request ( \"post\" , url , params , headers )) return self djstripe . models . core . Payout . stripe_class . reverse ( self , idempotency_key = None , ** params ) Source code in djstripe/models/core.py def reverse ( self , idempotency_key = None , ** params ): url = self . instance_url () + \"/reverse\" headers = util . populate_headers ( idempotency_key ) self . refresh_from ( self . request ( \"post\" , url , params , headers )) return self djstripe . models . core . Payout . __str__ ( self ) special Source code in djstripe/models/core.py def __str__ ( self ): return f \" { self . amount } ( { enums . PayoutStatus . humanize ( self . status ) } )\" djstripe . models . core . Payout . get_failure_code_display ( self , * , field =< djstripe . fields . StripeEnumField : failure_code > ) Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . core . Payout . get_method_display ( self , * , field =< djstripe . fields . StripeEnumField : method > ) Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . core . Payout . get_next_by_arrival_date ( self , * , field =< djstripe . fields . StripeDateTimeField : arrival_date > , is_next = True , ** kwargs ) Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . core . Payout . get_next_by_djstripe_created ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_created > , is_next = True , ** kwargs ) Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . core . Payout . get_next_by_djstripe_updated ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_updated > , is_next = True , ** kwargs ) Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . core . Payout . get_previous_by_arrival_date ( self , * , field =< djstripe . fields . StripeDateTimeField : arrival_date > , is_next = False , ** kwargs ) Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . core . Payout . get_previous_by_djstripe_created ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_created > , is_next = False , ** kwargs ) Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . core . Payout . get_previous_by_djstripe_updated ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_updated > , is_next = False , ** kwargs ) Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . core . Payout . get_source_type_display ( self , * , field =< djstripe . fields . StripeEnumField : source_type > ) Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . core . Payout . get_status_display ( self , * , field =< djstripe . fields . StripeEnumField : status > ) Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . core . Payout . get_type_display ( self , * , field =< djstripe . fields . StripeEnumField : type > ) Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe.models.core.Price Prices define the unit cost, currency, and (optional) billing cycle for both recurring and one-time purchases of products. Price and Plan objects are the same, but use a different representation. Creating a recurring Price in Stripe also makes a Plan available, and vice versa. This is not the case for a Price with interval=one_time. Price objects are a more recent API representation, support more features and its usage is encouraged instead of Plan objects. Stripe documentation: - https://stripe.com/docs/api/prices - https://stripe.com/docs/billing/prices-guide djstripe . models . core . Price . active djstripe . models . core . Price . billing_scheme djstripe . models . core . Price . currency djstripe . models . core . Price . djstripe_owner_account : Optional [ djstripe . fields . StripeForeignKey ] djstripe . models . core . Price . expand_fields : List [ str ] djstripe . models . core . Price . human_readable_price property readonly djstripe . models . core . Price . lookup_key djstripe . models . core . Price . nickname djstripe . models . core . Price . product djstripe . models . core . Price . recurring djstripe . models . core . Price . stripe_dashboard_item_name djstripe . models . core . Price . tiers djstripe . models . core . Price . tiers_mode djstripe . models . core . Price . transform_quantity djstripe . models . core . Price . type djstripe . models . core . Price . unit_amount djstripe . models . core . Price . unit_amount_decimal djstripe.models.core.Price.DoesNotExist djstripe.models.core.Price.MultipleObjectsReturned djstripe.models.core.Price.stripe_class Methods djstripe . models . core . Price . __str__ ( self ) special Source code in djstripe/models/core.py def __str__ ( self ): from .billing import Subscription subscriptions = Subscription . objects . filter ( plan__id = self . id ) . count () if self . recurring : return f \" { self . human_readable_price } for { self . product . name } ( { subscriptions } subscriptions)\" return f \" { self . human_readable_price } for { self . product . name } \" djstripe . models . core . Price . create ( ** kwargs ) classmethod Source code in djstripe/models/core.py @classmethod def create ( cls , ** kwargs ): # A few minor things are changed in the api-version of the create call api_kwargs = dict ( kwargs ) api_kwargs [ \"unit_amount\" ] = int ( api_kwargs [ \"unit_amount\" ] * 100 ) if isinstance ( api_kwargs . get ( \"product\" ), StripeModel ): api_kwargs [ \"product\" ] = api_kwargs [ \"product\" ] . id stripe_price = cls . _api_create ( ** api_kwargs ) price = cls . sync_from_stripe_data ( stripe_price ) return price djstripe . models . core . Price . get_billing_scheme_display ( self , * , field =< djstripe . fields . StripeEnumField : billing_scheme > ) Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . core . Price . get_next_by_djstripe_created ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_created > , is_next = True , ** kwargs ) Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . core . Price . get_next_by_djstripe_updated ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_updated > , is_next = True , ** kwargs ) Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . core . Price . get_or_create ( ** kwargs ) classmethod Get or create a Price. Source code in djstripe/models/core.py @classmethod def get_or_create ( cls , ** kwargs ): \"\"\"Get or create a Price.\"\"\" try : return Price . objects . get ( id = kwargs [ \"id\" ]), False except Price . DoesNotExist : return cls . create ( ** kwargs ), True djstripe . models . core . Price . get_previous_by_djstripe_created ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_created > , is_next = False , ** kwargs ) Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . core . Price . get_previous_by_djstripe_updated ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_updated > , is_next = False , ** kwargs ) Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . core . Price . get_tiers_mode_display ( self , * , field =< djstripe . fields . StripeEnumField : tiers_mode > ) Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . core . Price . get_type_display ( self , * , field =< djstripe . fields . StripeEnumField : type > ) Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe.models.core.Product Stripe documentation: - https://stripe.com/docs/api#products djstripe . models . core . Product . active djstripe . models . core . Product . attributes djstripe . models . core . Product . caption djstripe . models . core . Product . deactivate_on djstripe . models . core . Product . djstripe_owner_account : Optional [ djstripe . fields . StripeForeignKey ] djstripe . models . core . Product . images djstripe . models . core . Product . name djstripe . models . core . Product . package_dimensions djstripe . models . core . Product . shippable djstripe . models . core . Product . statement_descriptor djstripe . models . core . Product . stripe_dashboard_item_name djstripe . models . core . Product . type djstripe . models . core . Product . unit_label djstripe . models . core . Product . url djstripe.models.core.Product.DoesNotExist djstripe.models.core.Product.MultipleObjectsReturned djstripe.models.core.Product.stripe_class djstripe . models . core . Product . __str__ ( self ) special Source code in djstripe/models/core.py def __str__ ( self ): # 1 product can have 1 or more than 1 related price price_qs = Price . objects . filter ( product__id = self . id ) price_count = price_qs . count () if price_count > 1 : return f \" { self . name } ( { price_count } prices)\" elif price_count == 1 : return f \" { self . name } ( { price_qs [ 0 ] . human_readable_price } )\" else : return self . name djstripe . models . core . Product . get_next_by_djstripe_created ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_created > , is_next = True , ** kwargs ) Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . core . Product . get_next_by_djstripe_updated ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_updated > , is_next = True , ** kwargs ) Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . core . Product . get_previous_by_djstripe_created ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_created > , is_next = False , ** kwargs ) Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . core . Product . get_previous_by_djstripe_updated ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_updated > , is_next = False , ** kwargs ) Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . core . Product . get_type_display ( self , * , field =< djstripe . fields . StripeEnumField : type > ) Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe.models.core.Refund Stripe documentation: https://stripe.com/docs/api#refund_object djstripe . models . core . Refund . amount djstripe . models . core . Refund . balance_transaction djstripe . models . core . Refund . charge djstripe . models . core . Refund . currency djstripe . models . core . Refund . djstripe_owner_account : Optional [ djstripe . fields . StripeForeignKey ] djstripe . models . core . Refund . failure_balance_transaction djstripe . models . core . Refund . failure_reason djstripe . models . core . Refund . reason djstripe . models . core . Refund . receipt_number djstripe . models . core . Refund . status djstripe.models.core.Refund.DoesNotExist djstripe.models.core.Refund.MultipleObjectsReturned djstripe.models.core.Refund.stripe_class Methods djstripe . models . core . Refund . __str__ ( self ) special Source code in djstripe/models/core.py def __str__ ( self ): return ( f \" { self . human_readable_amount } ( { enums . RefundStatus . humanize ( self . status ) } )\" ) djstripe . models . core . Refund . get_failure_reason_display ( self , * , field =< djstripe . fields . StripeEnumField : failure_reason > ) Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . core . Refund . get_next_by_djstripe_created ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_created > , is_next = True , ** kwargs ) Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . core . Refund . get_next_by_djstripe_updated ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_updated > , is_next = True , ** kwargs ) Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . core . Refund . get_previous_by_djstripe_created ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_created > , is_next = False , ** kwargs ) Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . core . Refund . get_previous_by_djstripe_updated ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_updated > , is_next = False , ** kwargs ) Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . core . Refund . get_reason_display ( self , * , field =< djstripe . fields . StripeEnumField : reason > ) Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . core . Refund . get_status_display ( self , * , field =< djstripe . fields . StripeEnumField : status > ) Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . core . Refund . get_stripe_dashboard_url ( self ) Get the stripe dashboard url for this object. Source code in djstripe/models/core.py def get_stripe_dashboard_url ( self ): return self . charge . get_stripe_dashboard_url () djstripe.models.core.SetupIntent A SetupIntent guides you through the process of setting up a customer's payment credentials for future payments. For example, you could use a SetupIntent to set up your customer's card without immediately collecting a payment. Later, you can use PaymentIntents to drive the payment flow. NOTE: You should not maintain long-lived, unconfirmed SetupIntents. For security purposes, SetupIntents older than 24 hours may no longer be valid. Stripe documentation: https://stripe.com/docs/api#setup_intents djstripe . models . core . SetupIntent . application djstripe . models . core . SetupIntent . cancellation_reason djstripe . models . core . SetupIntent . client_secret djstripe . models . core . SetupIntent . customer djstripe . models . core . SetupIntent . djstripe_owner_account : Optional [ djstripe . fields . StripeForeignKey ] djstripe . models . core . SetupIntent . last_setup_error djstripe . models . core . SetupIntent . next_action djstripe . models . core . SetupIntent . on_behalf_of djstripe . models . core . SetupIntent . payment_method djstripe . models . core . SetupIntent . payment_method_types djstripe . models . core . SetupIntent . status djstripe . models . core . SetupIntent . usage djstripe.models.core.SetupIntent.DoesNotExist djstripe.models.core.SetupIntent.MultipleObjectsReturned djstripe.models.core.SetupIntent.stripe_class djstripe . models . core . SetupIntent . stripe_class . OBJECT_NAME djstripe . models . core . SetupIntent . stripe_class . cancel ( self , idempotency_key = None , ** params ) Source code in djstripe/models/core.py def cancel ( self , idempotency_key = None , ** params ): url = self . instance_url () + \"/cancel\" headers = util . populate_headers ( idempotency_key ) self . refresh_from ( self . request ( \"post\" , url , params , headers )) return self djstripe . models . core . SetupIntent . stripe_class . confirm ( self , idempotency_key = None , ** params ) Source code in djstripe/models/core.py def confirm ( self , idempotency_key = None , ** params ): url = self . instance_url () + \"/confirm\" headers = util . populate_headers ( idempotency_key ) self . refresh_from ( self . request ( \"post\" , url , params , headers )) return self djstripe . models . core . SetupIntent . __str__ ( self ) special Source code in djstripe/models/core.py def __str__ ( self ): account = self . on_behalf_of customer = self . customer if account and customer : return ( f \" { self . payment_method } ( { enums . SetupIntentStatus . humanize ( self . status ) } ) \" f \"for { account } \" f \"by { customer } \" ) if account : return f \" { self . payment_method } for { account } . { enums . SetupIntentStatus . humanize ( self . status ) } \" if customer : return f \" { self . payment_method } by { customer } . { enums . SetupIntentStatus . humanize ( self . status ) } \" return ( f \" { self . payment_method } ( { enums . SetupIntentStatus . humanize ( self . status ) } )\" ) djstripe . models . core . SetupIntent . get_cancellation_reason_display ( self , * , field =< djstripe . fields . StripeEnumField : cancellation_reason > ) Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . core . SetupIntent . get_next_by_djstripe_created ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_created > , is_next = True , ** kwargs ) Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . core . SetupIntent . get_next_by_djstripe_updated ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_updated > , is_next = True , ** kwargs ) Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . core . SetupIntent . get_previous_by_djstripe_created ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_created > , is_next = False , ** kwargs ) Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . core . SetupIntent . get_previous_by_djstripe_updated ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_updated > , is_next = False , ** kwargs ) Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . core . SetupIntent . get_status_display ( self , * , field =< djstripe . fields . StripeEnumField : status > ) Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . core . SetupIntent . get_usage_display ( self , * , field =< djstripe . fields . StripeEnumField : usage > ) Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) Payment Methods Classes djstripe.models.payment_methods.BankAccount BankAccount(djstripe_created, djstripe_updated, djstripe_id, id, djstripe_owner_account, livemode, created, metadata, description, account, account_holder_name, account_holder_type, bank_name, country, currency, customer, default_for_currency, fingerprint, last4, routing_number, status) djstripe . models . payment_methods . BankAccount . account : Optional [ djstripe . fields . StripeForeignKey ] djstripe . models . payment_methods . BankAccount . account_holder_name djstripe . models . payment_methods . BankAccount . account_holder_type djstripe . models . payment_methods . BankAccount . bank_name djstripe . models . payment_methods . BankAccount . country djstripe . models . payment_methods . BankAccount . currency djstripe . models . payment_methods . BankAccount . customer : Optional [ djstripe . fields . StripeForeignKey ] djstripe . models . payment_methods . BankAccount . default_for_currency djstripe . models . payment_methods . BankAccount . djstripe_owner_account : Optional [ djstripe . fields . StripeForeignKey ] djstripe . models . payment_methods . BankAccount . fingerprint djstripe . models . payment_methods . BankAccount . human_readable_status property readonly djstripe . models . payment_methods . BankAccount . last4 djstripe . models . payment_methods . BankAccount . routing_number djstripe . models . payment_methods . BankAccount . status djstripe.models.payment_methods.BankAccount.DoesNotExist djstripe.models.payment_methods.BankAccount.MultipleObjectsReturned djstripe.models.payment_methods.BankAccount.stripe_class djstripe . models . payment_methods . BankAccount . stripe_class . OBJECT_NAME djstripe . models . payment_methods . BankAccount . stripe_class . instance_url ( self ) Source code in djstripe/models/payment_methods.py def instance_url ( self ): token = util . utf8 ( self . id ) extn = quote_plus ( token ) if hasattr ( self , \"customer\" ): customer = util . utf8 ( self . customer ) base = Customer . class_url () owner_extn = quote_plus ( customer ) class_base = \"sources\" elif hasattr ( self , \"account\" ): account = util . utf8 ( self . account ) base = Account . class_url () owner_extn = quote_plus ( account ) class_base = \"external_accounts\" else : raise error . InvalidRequestError ( \"Could not determine whether bank_account_id %s is \" \"attached to a customer or an account.\" % token , \"id\" , ) return \" %s / %s / %s / %s \" % ( base , owner_extn , class_base , extn ) djstripe . models . payment_methods . BankAccount . stripe_class . modify ( sid , ** params ) classmethod Source code in djstripe/models/payment_methods.py @classmethod def modify ( cls , sid , ** params ): raise NotImplementedError ( \"Can't modify a bank account without a customer or account ID. \" \"Call save on customer.sources.retrieve('bank_account_id') or \" \"account.external_accounts.retrieve('bank_account_id') instead.\" ) djstripe . models . payment_methods . BankAccount . stripe_class . retrieve ( id , api_key = None , stripe_version = None , stripe_account = None , ** params ) classmethod Source code in djstripe/models/payment_methods.py @classmethod def retrieve ( cls , id , api_key = None , stripe_version = None , stripe_account = None , ** params ): raise NotImplementedError ( \"Can't retrieve a bank account without a customer or account ID. \" \"Use customer.sources.retrieve('bank_account_id') or \" \"account.external_accounts.retrieve('bank_account_id') instead.\" ) Methods djstripe . models . payment_methods . BankAccount . __str__ ( self ) special Source code in djstripe/models/payment_methods.py def __str__ ( self ): default = False # prefer to show it by customer format if present if self . customer : default_source = self . customer . default_source default_payment_method = self . customer . default_payment_method if ( default_payment_method and self . id == default_payment_method . id ) or ( default_source and self . id == default_source . id ): # current card is the default payment method or source default = True customer_template = f \" { self . bank_name } { self . routing_number } ( { self . human_readable_status } ) { 'Default' if default else '' } { self . currency } \" return customer_template default = getattr ( self , \"default_for_currency\" , False ) account_template = f \" { self . bank_name } { self . currency } { 'Default' if default else '' } { self . routing_number } { self . last4 } \" return account_template djstripe . models . payment_methods . BankAccount . api_retrieve ( self , ** kwargs ) Call the stripe API's retrieve operation for this model. :param api_key: The api key to use for this request. Defaults to djstripe_settings.STRIPE_SECRET_KEY. :type api_key: string :param stripe_account: The optional connected account for which this request is being made. :type stripe_account: string Source code in djstripe/models/payment_methods.py def api_retrieve ( self , ** kwargs ): if not self . customer and not self . account : raise NotImplementedError ( \"Can't retrieve a bank account without a customer or account object.\" ) return super () . api_retrieve ( ** kwargs ) djstripe . models . payment_methods . BankAccount . get_account_holder_type_display ( self , * , field =< djstripe . fields . StripeEnumField : account_holder_type > ) Source code in djstripe/models/payment_methods.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . payment_methods . BankAccount . get_next_by_djstripe_created ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_created > , is_next = True , ** kwargs ) Source code in djstripe/models/payment_methods.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . payment_methods . BankAccount . get_next_by_djstripe_updated ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_updated > , is_next = True , ** kwargs ) Source code in djstripe/models/payment_methods.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . payment_methods . BankAccount . get_previous_by_djstripe_created ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_created > , is_next = False , ** kwargs ) Source code in djstripe/models/payment_methods.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . payment_methods . BankAccount . get_previous_by_djstripe_updated ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_updated > , is_next = False , ** kwargs ) Source code in djstripe/models/payment_methods.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . payment_methods . BankAccount . get_status_display ( self , * , field =< djstripe . fields . StripeEnumField : status > ) Source code in djstripe/models/payment_methods.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe.models.payment_methods.Card You can store multiple cards on a customer in order to charge the customer later. This is a legacy model which only applies to the \"v2\" Stripe API (eg. Checkout.js). You should strive to use the Stripe \"v3\" API (eg. Stripe Elements). Also see: https://stripe.com/docs/stripe-js/elements/migrating When using Elements, you will not be using Card objects. Instead, you will use Source objects. A Source object of type \"card\" is equivalent to a Card object. However, Card objects cannot be converted into Source objects by Stripe at this time. Stripe documentation: https://stripe.com/docs/api?lang=python#cards djstripe . models . payment_methods . Card . account : Optional [ djstripe . fields . StripeForeignKey ] djstripe . models . payment_methods . Card . address_city djstripe . models . payment_methods . Card . address_country djstripe . models . payment_methods . Card . address_line1 djstripe . models . payment_methods . Card . address_line1_check djstripe . models . payment_methods . Card . address_line2 djstripe . models . payment_methods . Card . address_state djstripe . models . payment_methods . Card . address_zip djstripe . models . payment_methods . Card . address_zip_check djstripe . models . payment_methods . Card . brand djstripe . models . payment_methods . Card . country djstripe . models . payment_methods . Card . customer : Optional [ djstripe . fields . StripeForeignKey ] djstripe . models . payment_methods . Card . cvc_check djstripe . models . payment_methods . Card . default_for_currency djstripe . models . payment_methods . Card . djstripe_owner_account : Optional [ djstripe . fields . StripeForeignKey ] djstripe . models . payment_methods . Card . dynamic_last4 djstripe . models . payment_methods . Card . exp_month djstripe . models . payment_methods . Card . exp_year djstripe . models . payment_methods . Card . fingerprint djstripe . models . payment_methods . Card . funding djstripe . models . payment_methods . Card . last4 djstripe . models . payment_methods . Card . name djstripe . models . payment_methods . Card . tokenization_method djstripe.models.payment_methods.Card.DoesNotExist djstripe.models.payment_methods.Card.MultipleObjectsReturned djstripe.models.payment_methods.Card.stripe_class djstripe . models . payment_methods . Card . stripe_class . OBJECT_NAME djstripe . models . payment_methods . Card . stripe_class . instance_url ( self ) Source code in djstripe/models/payment_methods.py def instance_url ( self ): token = util . utf8 ( self . id ) extn = quote_plus ( token ) if hasattr ( self , \"customer\" ): customer = util . utf8 ( self . customer ) base = Customer . class_url () owner_extn = quote_plus ( customer ) class_base = \"sources\" elif hasattr ( self , \"recipient\" ): recipient = util . utf8 ( self . recipient ) base = Recipient . class_url () owner_extn = quote_plus ( recipient ) class_base = \"cards\" elif hasattr ( self , \"account\" ): account = util . utf8 ( self . account ) base = Account . class_url () owner_extn = quote_plus ( account ) class_base = \"external_accounts\" else : raise error . InvalidRequestError ( \"Could not determine whether card_id %s is \" \"attached to a customer, recipient, or \" \"account.\" % token , \"id\" , ) return \" %s / %s / %s / %s \" % ( base , owner_extn , class_base , extn ) djstripe . models . payment_methods . Card . stripe_class . modify ( sid , ** params ) classmethod Source code in djstripe/models/payment_methods.py @classmethod def modify ( cls , sid , ** params ): raise NotImplementedError ( \"Can't modify a card without a customer, recipient or account \" \"ID. Call save on customer.sources.retrieve('card_id'), \" \"recipient.cards.retrieve('card_id'), or \" \"account.external_accounts.retrieve('card_id') instead.\" ) djstripe . models . payment_methods . Card . stripe_class . retrieve ( id , api_key = None , stripe_version = None , stripe_account = None , ** params ) classmethod Source code in djstripe/models/payment_methods.py @classmethod def retrieve ( cls , id , api_key = None , stripe_version = None , stripe_account = None , ** params ): raise NotImplementedError ( \"Can't retrieve a card without a customer, recipient or account \" \"ID. Use customer.sources.retrieve('card_id'), \" \"recipient.cards.retrieve('card_id'), or \" \"account.external_accounts.retrieve('card_id') instead.\" ) Methods djstripe . models . payment_methods . Card . __str__ ( self ) special Source code in djstripe/models/payment_methods.py def __str__ ( self ): default = False # prefer to show it by customer format if present if self . customer : default_source = self . customer . default_source default_payment_method = self . customer . default_payment_method if ( default_payment_method and self . id == default_payment_method . id ) or ( default_source and self . id == default_source . id ): # current card is the default payment method or source default = True customer_template = f \" { enums . CardBrand . humanize ( self . brand ) } { self . last4 } { 'Default' if default else '' } Expires { self . exp_month } { self . exp_year } \" return customer_template elif self . account : default = getattr ( self , \"default_for_currency\" , False ) account_template = f \" { enums . CardBrand . humanize ( self . brand ) } { self . account . default_currency } { 'Default' if default else '' } { self . last4 } \" return account_template djstripe . models . payment_methods . Card . create_token ( number , exp_month , exp_year , cvc , api_key = 'sk_test_XXXXXXXXXXXXXXXXXXXXXXXXX' , ** kwargs ) classmethod Creates a single use token that wraps the details of a credit card. This token can be used in place of a credit card dictionary with any API method. These tokens can only be used once: by creating a new charge object, or attaching them to a customer. (Source: https://stripe.com/docs/api?lang=python#create_card_token) :param number: The card number without any separators (no spaces) :param exp_month: The card's expiration month. (two digits) :param exp_year: The card's expiration year. (four digits) :param cvc: Card security code. :param api_key: The API key to use Source code in djstripe/models/payment_methods.py @classmethod def create_token ( cls , number : str , exp_month : int , exp_year : int , cvc : str , api_key : str = djstripe_settings . STRIPE_SECRET_KEY , ** kwargs , ) -> stripe . Token : \"\"\" Creates a single use token that wraps the details of a credit card. This token can be used in place of a credit card dictionary with any API method. These tokens can only be used once: by creating a new charge object, or attaching them to a customer. (Source: https://stripe.com/docs/api?lang=python#create_card_token) :param number: The card number without any separators (no spaces) :param exp_month: The card's expiration month. (two digits) :param exp_year: The card's expiration year. (four digits) :param cvc: Card security code. :param api_key: The API key to use \"\"\" card = { \"number\" : number , \"exp_month\" : exp_month , \"exp_year\" : exp_year , \"cvc\" : cvc , } card . update ( kwargs ) return stripe . Token . create ( api_key = api_key , card = card ) djstripe . models . payment_methods . Card . get_address_line1_check_display ( self , * , field =< djstripe . fields . StripeEnumField : address_line1_check > ) Source code in djstripe/models/payment_methods.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . payment_methods . Card . get_address_zip_check_display ( self , * , field =< djstripe . fields . StripeEnumField : address_zip_check > ) Source code in djstripe/models/payment_methods.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . payment_methods . Card . get_brand_display ( self , * , field =< djstripe . fields . StripeEnumField : brand > ) Source code in djstripe/models/payment_methods.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . payment_methods . Card . get_cvc_check_display ( self , * , field =< djstripe . fields . StripeEnumField : cvc_check > ) Source code in djstripe/models/payment_methods.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . payment_methods . Card . get_funding_display ( self , * , field =< djstripe . fields . StripeEnumField : funding > ) Source code in djstripe/models/payment_methods.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . payment_methods . Card . get_next_by_djstripe_created ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_created > , is_next = True , ** kwargs ) Source code in djstripe/models/payment_methods.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . payment_methods . Card . get_next_by_djstripe_updated ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_updated > , is_next = True , ** kwargs ) Source code in djstripe/models/payment_methods.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . payment_methods . Card . get_previous_by_djstripe_created ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_created > , is_next = False , ** kwargs ) Source code in djstripe/models/payment_methods.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . payment_methods . Card . get_previous_by_djstripe_updated ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_updated > , is_next = False , ** kwargs ) Source code in djstripe/models/payment_methods.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . payment_methods . Card . get_tokenization_method_display ( self , * , field =< djstripe . fields . StripeEnumField : tokenization_method > ) Source code in djstripe/models/payment_methods.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe.models.payment_methods.PaymentMethod Stripe documentation: https://stripe.com/docs/api#payment_methods djstripe . models . payment_methods . PaymentMethod . acss_debit djstripe . models . payment_methods . PaymentMethod . afterpay_clearpay djstripe . models . payment_methods . PaymentMethod . alipay djstripe . models . payment_methods . PaymentMethod . au_becs_debit djstripe . models . payment_methods . PaymentMethod . bacs_debit djstripe . models . payment_methods . PaymentMethod . bancontact djstripe . models . payment_methods . PaymentMethod . billing_details djstripe . models . payment_methods . PaymentMethod . boleto djstripe . models . payment_methods . PaymentMethod . card djstripe . models . payment_methods . PaymentMethod . card_present djstripe . models . payment_methods . PaymentMethod . customer djstripe . models . payment_methods . PaymentMethod . description djstripe . models . payment_methods . PaymentMethod . djstripe_owner_account : Optional [ djstripe . fields . StripeForeignKey ] djstripe . models . payment_methods . PaymentMethod . eps djstripe . models . payment_methods . PaymentMethod . fpx djstripe . models . payment_methods . PaymentMethod . giropay djstripe . models . payment_methods . PaymentMethod . grabpay djstripe . models . payment_methods . PaymentMethod . ideal djstripe . models . payment_methods . PaymentMethod . interac_present djstripe . models . payment_methods . PaymentMethod . oxxo djstripe . models . payment_methods . PaymentMethod . p24 djstripe . models . payment_methods . PaymentMethod . sepa_debit djstripe . models . payment_methods . PaymentMethod . sofort djstripe . models . payment_methods . PaymentMethod . type djstripe . models . payment_methods . PaymentMethod . wechat_pay djstripe.models.payment_methods.PaymentMethod.DoesNotExist djstripe.models.payment_methods.PaymentMethod.MultipleObjectsReturned djstripe.models.payment_methods.PaymentMethod.stripe_class djstripe . models . payment_methods . PaymentMethod . stripe_class . OBJECT_NAME djstripe . models . payment_methods . PaymentMethod . stripe_class . _cls_attach ( sid , ** params ) classmethod private Source code in djstripe/models/payment_methods.py def custom_method_request ( cls , sid , ** params ): url = \" %s / %s / %s \" % ( cls . class_url (), quote_plus ( util . utf8 ( sid )), http_path , ) obj = cls . _static_request ( http_verb , url , ** params ) # For list objects, we have to attach the parameters so that they # can be referenced in auto-pagination and ensure consistency. if \"object\" in obj and obj . object == \"list\" : obj . _retrieve_params = params return obj djstripe . models . payment_methods . PaymentMethod . stripe_class . _cls_detach ( sid , ** params ) classmethod private Source code in djstripe/models/payment_methods.py def custom_method_request ( cls , sid , ** params ): url = \" %s / %s / %s \" % ( cls . class_url (), quote_plus ( util . utf8 ( sid )), http_path , ) obj = cls . _static_request ( http_verb , url , ** params ) # For list objects, we have to attach the parameters so that they # can be referenced in auto-pagination and ensure consistency. if \"object\" in obj and obj . object == \"list\" : obj . _retrieve_params = params return obj djstripe . models . payment_methods . PaymentMethod . stripe_class . attach ( self , idempotency_key = None , ** params ) Source code in djstripe/models/payment_methods.py def attach ( self , idempotency_key = None , ** params ): url = self . instance_url () + \"/attach\" headers = util . populate_headers ( idempotency_key ) self . refresh_from ( self . request ( \"post\" , url , params , headers )) return self djstripe . models . payment_methods . PaymentMethod . stripe_class . detach ( self , idempotency_key = None , ** params ) Source code in djstripe/models/payment_methods.py def detach ( self , idempotency_key = None , ** params ): url = self . instance_url () + \"/detach\" headers = util . populate_headers ( idempotency_key ) self . refresh_from ( self . request ( \"post\" , url , params , headers )) return self Methods djstripe . models . payment_methods . PaymentMethod . __str__ ( self ) special Source code in djstripe/models/payment_methods.py def __str__ ( self ): if self . customer : return f \" { enums . PaymentMethodType . humanize ( self . type ) } for { self . customer } \" return f \" { enums . PaymentMethodType . humanize ( self . type ) } is not associated with any customer\" djstripe . models . payment_methods . PaymentMethod . _attach_objects_hook ( self , cls , data , current_ids = None ) private Gets called by this object's create and sync methods just before save. Use this to populate fields before the model is saved. :param cls: The target class for the instantiated object. :param data: The data dictionary received from the Stripe API. :type data: dict :param current_ids: stripe ids of objects that are currently being processed :type current_ids: set Source code in djstripe/models/payment_methods.py def _attach_objects_hook ( self , cls , data , current_ids = None ): customer = None # \"customer\" key could be like \"cus_6lsBvm5rJ0zyHc\" or {\"id\": \"cus_6lsBvm5rJ0zyHc\"} customer_id = get_id_from_stripe_data ( data . get ( \"customer\" )) if current_ids is None or customer_id not in current_ids : customer = cls . _stripe_object_to_customer ( target_cls = Customer , data = data , current_ids = current_ids ) if customer : self . customer = customer else : self . customer = None djstripe . models . payment_methods . PaymentMethod . attach ( payment_method , customer , api_key = 'sk_test_XXXXXXXXXXXXXXXXXXXXXXXXX' ) classmethod Attach a payment method to a customer Source code in djstripe/models/payment_methods.py @classmethod def attach ( cls , payment_method : Union [ str , \"PaymentMethod\" ], customer : Union [ str , Customer ], api_key : str = djstripe_settings . STRIPE_SECRET_KEY , ) -> \"PaymentMethod\" : \"\"\" Attach a payment method to a customer \"\"\" if isinstance ( payment_method , StripeModel ): payment_method = payment_method . id if isinstance ( customer , StripeModel ): customer = customer . id extra_kwargs = {} if not isinstance ( payment_method , stripe . PaymentMethod ): # send api_key if we're not passing in a Stripe object # avoids \"Received unknown parameter: api_key\" since api uses the # key cached in the Stripe object extra_kwargs = { \"api_key\" : api_key } stripe_payment_method = stripe . PaymentMethod . attach ( payment_method , customer = customer , ** extra_kwargs ) return cls . sync_from_stripe_data ( stripe_payment_method ) djstripe . models . payment_methods . PaymentMethod . detach ( self ) Detach the payment method from its customer. :return: Returns true if the payment method was newly detached, false if it was already detached :rtype: bool Source code in djstripe/models/payment_methods.py def detach ( self ): \"\"\" Detach the payment method from its customer. :return: Returns true if the payment method was newly detached, \\ false if it was already detached :rtype: bool \"\"\" # Find customers that use this customers = Customer . objects . filter ( default_payment_method = self ) . all () changed = True # special handling is needed for legacy \"card\"-type PaymentMethods, # since detaching them deletes them within Stripe. # see https://github.com/dj-stripe/dj-stripe/pull/967 is_legacy_card = self . id . startswith ( \"card_\" ) try : self . sync_from_stripe_data ( self . api_retrieve () . detach ()) # resync customer to update .default_payment_method and # .invoice_settings.default_payment_method for customer in customers : Customer . sync_from_stripe_data ( customer . api_retrieve ()) except ( InvalidRequestError ,): # The source was already detached. Resyncing. if self . pk and not is_legacy_card : self . sync_from_stripe_data ( self . api_retrieve ()) changed = False if self . pk : if is_legacy_card : self . delete () else : self . refresh_from_db () return changed djstripe . models . payment_methods . PaymentMethod . get_next_by_djstripe_created ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_created > , is_next = True , ** kwargs ) Source code in djstripe/models/payment_methods.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . payment_methods . PaymentMethod . get_next_by_djstripe_updated ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_updated > , is_next = True , ** kwargs ) Source code in djstripe/models/payment_methods.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . payment_methods . PaymentMethod . get_previous_by_djstripe_created ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_created > , is_next = False , ** kwargs ) Source code in djstripe/models/payment_methods.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . payment_methods . PaymentMethod . get_previous_by_djstripe_updated ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_updated > , is_next = False , ** kwargs ) Source code in djstripe/models/payment_methods.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . payment_methods . PaymentMethod . get_type_display ( self , * , field =< djstripe . fields . StripeEnumField : type > ) Source code in djstripe/models/payment_methods.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe.models.payment_methods.Source Stripe documentation: https://stripe.com/docs/api#sources djstripe . models . payment_methods . Source . amount djstripe . models . payment_methods . Source . client_secret djstripe . models . payment_methods . Source . code_verification djstripe . models . payment_methods . Source . currency djstripe . models . payment_methods . Source . customer djstripe . models . payment_methods . Source . djstripe_owner_account : Optional [ djstripe . fields . StripeForeignKey ] djstripe . models . payment_methods . Source . flow djstripe . models . payment_methods . Source . owner djstripe . models . payment_methods . Source . receiver djstripe . models . payment_methods . Source . redirect djstripe . models . payment_methods . Source . source_data djstripe . models . payment_methods . Source . statement_descriptor djstripe . models . payment_methods . Source . status djstripe . models . payment_methods . Source . stripe_dashboard_item_name djstripe . models . payment_methods . Source . type djstripe . models . payment_methods . Source . usage Classes djstripe.models.payment_methods.Source.DoesNotExist djstripe.models.payment_methods.Source.MultipleObjectsReturned djstripe.models.payment_methods.Source.stripe_class djstripe . models . payment_methods . Source . stripe_class . OBJECT_NAME Methods djstripe . models . payment_methods . Source . stripe_class . detach ( self , idempotency_key = None , ** params ) Source code in djstripe/models/payment_methods.py def detach ( self , idempotency_key = None , ** params ): token = util . utf8 ( self . id ) if hasattr ( self , \"customer\" ) and self . customer : extn = quote_plus ( token ) customer = util . utf8 ( self . customer ) base = Customer . class_url () owner_extn = quote_plus ( customer ) url = \" %s / %s /sources/ %s \" % ( base , owner_extn , extn ) headers = util . populate_headers ( idempotency_key ) self . refresh_from ( self . request ( \"delete\" , url , params , headers )) return self else : raise error . InvalidRequestError ( \"Source %s does not appear to be currently attached \" \"to a customer object.\" % token , \"id\" , ) djstripe . models . payment_methods . Source . stripe_class . list_source_transactions ( id , ** params ) classmethod Source code in djstripe/models/payment_methods.py def list_nested_resources ( cls , id , ** params ): url = getattr ( cls , resource_url_method )( id ) return getattr ( cls , resource_request_method )( \"get\" , url , ** params ) djstripe . models . payment_methods . Source . stripe_class . source_transactions ( self , ** params ) source_transactions is deprecated, use Source.list_source_transactions instead. Source code in djstripe/models/payment_methods.py def source_transactions ( self , ** params ): \"\"\"source_transactions is deprecated, use Source.list_source_transactions instead.\"\"\" return self . request ( \"get\" , self . instance_url () + \"/source_transactions\" , params ) djstripe . models . payment_methods . Source . stripe_class . source_transactions_request ( method , url , api_key = None , idempotency_key = None , stripe_version = None , stripe_account = None , ** params ) classmethod Source code in djstripe/models/payment_methods.py def nested_resource_request ( cls , method , url , api_key = None , idempotency_key = None , stripe_version = None , stripe_account = None , ** params ): requestor = api_requestor . APIRequestor ( api_key , api_version = stripe_version , account = stripe_account ) headers = util . populate_headers ( idempotency_key ) response , api_key = requestor . request ( method , url , params , headers ) return util . convert_to_stripe_object ( response , api_key , stripe_version , stripe_account ) djstripe . models . payment_methods . Source . stripe_class . source_transactions_url ( id , nested_id = None ) classmethod Source code in djstripe/models/payment_methods.py def nested_resource_url ( cls , id , nested_id = None ): url = \" %s / %s / %s \" % ( cls . class_url (), quote_plus ( id ), quote_plus ( path ), ) if nested_id is not None : url += \"/ %s \" % quote_plus ( nested_id ) return url Methods djstripe . models . payment_methods . Source . __str__ ( self ) special Source code in djstripe/models/payment_methods.py def __str__ ( self ): return f \" { self . type } { self . id } \" djstripe . models . payment_methods . Source . _attach_objects_hook ( self , cls , data , current_ids = None ) private Gets called by this object's create and sync methods just before save. Use this to populate fields before the model is saved. :param cls: The target class for the instantiated object. :param data: The data dictionary received from the Stripe API. :type data: dict :param current_ids: stripe ids of objects that are currently being processed :type current_ids: set Source code in djstripe/models/payment_methods.py def _attach_objects_hook ( self , cls , data , current_ids = None ): customer = None # \"customer\" key could be like \"cus_6lsBvm5rJ0zyHc\" or {\"id\": \"cus_6lsBvm5rJ0zyHc\"} customer_id = get_id_from_stripe_data ( data . get ( \"customer\" )) if current_ids is None or customer_id not in current_ids : customer = cls . _stripe_object_to_customer ( target_cls = Customer , data = data , current_ids = current_ids ) if customer : self . customer = customer else : self . customer = None djstripe . models . payment_methods . Source . _manipulate_stripe_object_hook ( data ) classmethod private Gets called by this object's stripe object conversion method just before conversion. Use this to populate custom fields in a StripeModel from stripe data. Source code in djstripe/models/payment_methods.py @classmethod def _manipulate_stripe_object_hook ( cls , data ): # The source_data dict is an alias of all the source types data [ \"source_data\" ] = data [ data [ \"type\" ]] return data djstripe . models . payment_methods . Source . detach ( self ) Detach the source from its customer. Source code in djstripe/models/payment_methods.py def detach ( self ) -> bool : \"\"\" Detach the source from its customer. \"\"\" # First, wipe default source on all customers that use this. Customer . objects . filter ( default_source = self . id ) . update ( default_source = None ) try : # TODO - we could use the return value of sync_from_stripe_data # or call its internals - self._sync/_attach_objects_hook etc here # to update `self` at this point? self . sync_from_stripe_data ( self . api_retrieve () . detach ()) return True except ( InvalidRequestError , NotImplementedError ): # The source was already detached. Resyncing. # NotImplementedError is an artifact of stripe-python<2.0 # https://github.com/stripe/stripe-python/issues/376 self . sync_from_stripe_data ( self . api_retrieve ()) return False djstripe . models . payment_methods . Source . get_flow_display ( self , * , field =< djstripe . fields . StripeEnumField : flow > ) Source code in djstripe/models/payment_methods.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . payment_methods . Source . get_next_by_djstripe_created ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_created > , is_next = True , ** kwargs ) Source code in djstripe/models/payment_methods.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . payment_methods . Source . get_next_by_djstripe_updated ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_updated > , is_next = True , ** kwargs ) Source code in djstripe/models/payment_methods.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . payment_methods . Source . get_previous_by_djstripe_created ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_created > , is_next = False , ** kwargs ) Source code in djstripe/models/payment_methods.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . payment_methods . Source . get_previous_by_djstripe_updated ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_updated > , is_next = False , ** kwargs ) Source code in djstripe/models/payment_methods.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . payment_methods . Source . get_status_display ( self , * , field =< djstripe . fields . StripeEnumField : status > ) Source code in djstripe/models/payment_methods.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . payment_methods . Source . get_type_display ( self , * , field =< djstripe . fields . StripeEnumField : type > ) Source code in djstripe/models/payment_methods.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . payment_methods . Source . get_usage_display ( self , * , field =< djstripe . fields . StripeEnumField : usage > ) Source code in djstripe/models/payment_methods.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) Billing Classes djstripe.models.billing.Coupon A coupon contains information about a percent-off or amount-off discount you might want to apply to a customer. Coupons may be applied to invoices or orders. Coupons do not work with conventional one-off charges. Stripe documentation: https://stripe.com/docs/api/coupons djstripe . models . billing . Coupon . amount_off djstripe . models . billing . Coupon . currency djstripe . models . billing . Coupon . djstripe_owner_account : Optional [ djstripe . fields . StripeForeignKey ] djstripe . models . billing . Coupon . duration djstripe . models . billing . Coupon . duration_in_months djstripe . models . billing . Coupon . human_readable property readonly djstripe . models . billing . Coupon . human_readable_amount property readonly djstripe . models . billing . Coupon . max_redemptions djstripe . models . billing . Coupon . name djstripe . models . billing . Coupon . percent_off djstripe . models . billing . Coupon . redeem_by djstripe . models . billing . Coupon . stripe_dashboard_item_name djstripe . models . billing . Coupon . times_redeemed djstripe.models.billing.Coupon.DoesNotExist djstripe.models.billing.Coupon.MultipleObjectsReturned djstripe.models.billing.Coupon.stripe_class djstripe . models . billing . Coupon . __str__ ( self ) special Source code in djstripe/models/billing.py def __str__ ( self ): if self . name : return self . name return self . human_readable djstripe . models . billing . Coupon . get_duration_display ( self , * , field =< djstripe . fields . StripeEnumField : duration > ) Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . billing . Coupon . get_next_by_djstripe_created ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_created > , is_next = True , ** kwargs ) Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . billing . Coupon . get_next_by_djstripe_updated ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_updated > , is_next = True , ** kwargs ) Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . billing . Coupon . get_previous_by_djstripe_created ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_created > , is_next = False , ** kwargs ) Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . billing . Coupon . get_previous_by_djstripe_updated ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_updated > , is_next = False , ** kwargs ) Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe.models.billing.Invoice Invoices are statements of what a customer owes for a particular billing period, including subscriptions, invoice items, and any automatic proration adjustments if necessary. Once an invoice is created, payment is automatically attempted. Note that the payment, while automatic, does not happen exactly at the time of invoice creation. If you have configured webhooks, the invoice will wait until one hour after the last webhook is successfully sent (or the last webhook times out after failing). Any customer credit on the account is applied before determining how much is due for that invoice (the amount that will be actually charged). If the amount due for the invoice is less than 50 cents (the minimum for a charge), we add the amount to the customer's running account balance to be added to the next invoice. If this amount is negative, it will act as a credit to offset the next invoice. Note that the customer account balance does not include unpaid invoices; it only includes balances that need to be taken into account when calculating the amount due for the next invoice. Stripe documentation: https://stripe.com/docs/api?lang=python#invoices djstripe . models . billing . Invoice . charge djstripe . models . billing . Invoice . customer djstripe . models . billing . Invoice . default_payment_method djstripe . models . billing . Invoice . default_source djstripe . models . billing . Invoice . default_tax_rates djstripe . models . billing . Invoice . djstripe_owner_account : Optional [ djstripe . fields . StripeForeignKey ] djstripe . models . billing . Invoice . payment_intent djstripe . models . billing . Invoice . subscription djstripe.models.billing.Invoice.DoesNotExist djstripe.models.billing.Invoice.MultipleObjectsReturned Methods djstripe . models . billing . Invoice . _attach_objects_post_save_hook ( self , cls , data , pending_relations = None ) private Gets called by this object's create and sync methods just after save. Use this to populate fields after the model is saved. :param cls: The target class for the instantiated object. :param data: The data dictionary received from the Stripe API. :type data: dict Source code in djstripe/models/billing.py def _attach_objects_post_save_hook ( self , cls , data , pending_relations = None ): super () . _attach_objects_post_save_hook ( cls , data , pending_relations = pending_relations ) self . default_tax_rates . set ( cls . _stripe_object_to_default_tax_rates ( target_cls = TaxRate , data = data ) ) cls . _stripe_object_set_total_tax_amounts ( target_cls = DjstripeInvoiceTotalTaxAmount , data = data , instance = self ) djstripe . models . billing . Invoice . get_billing_reason_display ( self , * , field =< djstripe . fields . StripeEnumField : billing_reason > ) Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . billing . Invoice . get_collection_method_display ( self , * , field =< djstripe . fields . StripeEnumField : collection_method > ) Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . billing . Invoice . get_customer_tax_exempt_display ( self , * , field =< djstripe . fields . StripeEnumField : customer_tax_exempt > ) Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . billing . Invoice . get_next_by_djstripe_created ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_created > , is_next = True , ** kwargs ) Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . billing . Invoice . get_next_by_djstripe_updated ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_updated > , is_next = True , ** kwargs ) Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . billing . Invoice . get_next_by_period_end ( self , * , field =< djstripe . fields . StripeDateTimeField : period_end > , is_next = True , ** kwargs ) Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . billing . Invoice . get_next_by_period_start ( self , * , field =< djstripe . fields . StripeDateTimeField : period_start > , is_next = True , ** kwargs ) Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . billing . Invoice . get_previous_by_djstripe_created ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_created > , is_next = False , ** kwargs ) Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . billing . Invoice . get_previous_by_djstripe_updated ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_updated > , is_next = False , ** kwargs ) Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . billing . Invoice . get_previous_by_period_end ( self , * , field =< djstripe . fields . StripeDateTimeField : period_end > , is_next = False , ** kwargs ) Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . billing . Invoice . get_previous_by_period_start ( self , * , field =< djstripe . fields . StripeDateTimeField : period_start > , is_next = False , ** kwargs ) Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . billing . Invoice . get_status_display ( self , * , field =< djstripe . fields . StripeEnumField : status > ) Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe.models.billing.InvoiceItem Sometimes you want to add a charge or credit to a customer but only actually charge the customer's card at the end of a regular billing cycle. This is useful for combining several charges to minimize per-transaction fees or having Stripe tabulate your usage-based billing totals. Stripe documentation: https://stripe.com/docs/api?lang=python#invoiceitems djstripe . models . billing . InvoiceItem . amount djstripe . models . billing . InvoiceItem . currency djstripe . models . billing . InvoiceItem . customer djstripe . models . billing . InvoiceItem . date djstripe . models . billing . InvoiceItem . discountable djstripe . models . billing . InvoiceItem . djstripe_owner_account : Optional [ djstripe . fields . StripeForeignKey ] djstripe . models . billing . InvoiceItem . invoice djstripe . models . billing . InvoiceItem . period djstripe . models . billing . InvoiceItem . period_end djstripe . models . billing . InvoiceItem . period_start djstripe . models . billing . InvoiceItem . plan djstripe . models . billing . InvoiceItem . price djstripe . models . billing . InvoiceItem . proration djstripe . models . billing . InvoiceItem . quantity djstripe . models . billing . InvoiceItem . subscription djstripe . models . billing . InvoiceItem . tax_rates djstripe . models . billing . InvoiceItem . unit_amount djstripe . models . billing . InvoiceItem . unit_amount_decimal djstripe.models.billing.InvoiceItem.DoesNotExist djstripe.models.billing.InvoiceItem.MultipleObjectsReturned djstripe.models.billing.InvoiceItem.stripe_class Methods djstripe . models . billing . InvoiceItem . __str__ ( self ) special Source code in djstripe/models/billing.py def __str__ ( self ): return self . description djstripe . models . billing . InvoiceItem . _attach_objects_post_save_hook ( self , cls , data , pending_relations = None ) private Gets called by this object's create and sync methods just after save. Use this to populate fields after the model is saved. :param cls: The target class for the instantiated object. :param data: The data dictionary received from the Stripe API. :type data: dict Source code in djstripe/models/billing.py def _attach_objects_post_save_hook ( self , cls , data , pending_relations = None ): super () . _attach_objects_post_save_hook ( cls , data , pending_relations = pending_relations ) if self . pk : # only call .set() on saved instance (ie don't on items of UpcomingInvoice) self . tax_rates . set ( cls . _stripe_object_to_tax_rates ( target_cls = TaxRate , data = data ) ) djstripe . models . billing . InvoiceItem . _manipulate_stripe_object_hook ( data ) classmethod private Gets called by this object's stripe object conversion method just before conversion. Use this to populate custom fields in a StripeModel from stripe data. Source code in djstripe/models/billing.py @classmethod def _manipulate_stripe_object_hook ( cls , data ): data [ \"period_start\" ] = data [ \"period\" ][ \"start\" ] data [ \"period_end\" ] = data [ \"period\" ][ \"end\" ] return data djstripe . models . billing . InvoiceItem . api_retrieve ( self , * args , ** kwargs ) Call the stripe API's retrieve operation for this model. :param api_key: The api key to use for this request. Defaults to djstripe_settings.STRIPE_SECRET_KEY. :type api_key: string :param stripe_account: The optional connected account for which this request is being made. :type stripe_account: string Source code in djstripe/models/billing.py def api_retrieve ( self , * args , ** kwargs ): if \"-il_\" in self . id : warnings . warn ( f \"Attempting to retrieve InvoiceItem with id= { self . id !r} \" \" will most likely fail. \" \"Run manage.py djstripe_update_invoiceitem_ids if this is a problem.\" ) return super () . api_retrieve ( * args , ** kwargs ) djstripe . models . billing . InvoiceItem . get_next_by_date ( self , * , field =< djstripe . fields . StripeDateTimeField : date > , is_next = True , ** kwargs ) Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . billing . InvoiceItem . get_next_by_djstripe_created ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_created > , is_next = True , ** kwargs ) Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . billing . InvoiceItem . get_next_by_djstripe_updated ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_updated > , is_next = True , ** kwargs ) Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . billing . InvoiceItem . get_next_by_period_end ( self , * , field =< djstripe . fields . StripeDateTimeField : period_end > , is_next = True , ** kwargs ) Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . billing . InvoiceItem . get_next_by_period_start ( self , * , field =< djstripe . fields . StripeDateTimeField : period_start > , is_next = True , ** kwargs ) Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . billing . InvoiceItem . get_previous_by_date ( self , * , field =< djstripe . fields . StripeDateTimeField : date > , is_next = False , ** kwargs ) Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . billing . InvoiceItem . get_previous_by_djstripe_created ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_created > , is_next = False , ** kwargs ) Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . billing . InvoiceItem . get_previous_by_djstripe_updated ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_updated > , is_next = False , ** kwargs ) Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . billing . InvoiceItem . get_previous_by_period_end ( self , * , field =< djstripe . fields . StripeDateTimeField : period_end > , is_next = False , ** kwargs ) Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . billing . InvoiceItem . get_previous_by_period_start ( self , * , field =< djstripe . fields . StripeDateTimeField : period_start > , is_next = False , ** kwargs ) Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . billing . InvoiceItem . get_stripe_dashboard_url ( self ) Get the stripe dashboard url for this object. Source code in djstripe/models/billing.py def get_stripe_dashboard_url ( self ): return self . invoice . get_stripe_dashboard_url () djstripe . models . billing . InvoiceItem . is_valid_object ( data ) classmethod Returns whether the data is a valid object for the class Source code in djstripe/models/billing.py @classmethod def is_valid_object ( cls , data ): return \"object\" in data and data [ \"object\" ] in ( \"invoiceitem\" , \"line_item\" ) djstripe.models.billing.Plan A subscription plan contains the pricing information for different products and feature levels on your site. Stripe documentation: https://stripe.com/docs/api/plans NOTE: The Stripe Plans API has been deprecated in favor of the Prices API. You may want to upgrade to use the Price model instead of the Plan model. djstripe . models . billing . Plan . active djstripe . models . billing . Plan . aggregate_usage djstripe . models . billing . Plan . amount djstripe . models . billing . Plan . amount_decimal djstripe . models . billing . Plan . amount_in_cents property readonly djstripe . models . billing . Plan . billing_scheme djstripe . models . billing . Plan . currency djstripe . models . billing . Plan . djstripe_owner_account : Optional [ djstripe . fields . StripeForeignKey ] djstripe . models . billing . Plan . expand_fields : List [ str ] djstripe . models . billing . Plan . human_readable_price property readonly djstripe . models . billing . Plan . interval djstripe . models . billing . Plan . interval_count djstripe . models . billing . Plan . nickname djstripe . models . billing . Plan . product djstripe . models . billing . Plan . stripe_dashboard_item_name djstripe . models . billing . Plan . tiers djstripe . models . billing . Plan . tiers_mode djstripe . models . billing . Plan . transform_usage djstripe . models . billing . Plan . trial_period_days djstripe . models . billing . Plan . usage_type djstripe.models.billing.Plan.DoesNotExist djstripe.models.billing.Plan.MultipleObjectsReturned djstripe.models.billing.Plan.stripe_class Methods djstripe . models . billing . Plan . __str__ ( self ) special Source code in djstripe/models/billing.py def __str__ ( self ): from .billing import Subscription subscriptions = Subscription . objects . filter ( plan__id = self . id ) . count () if self . product and self . product . name : return f \" { self . human_readable_price } for { self . product . name } ( { subscriptions } subscriptions)\" return f \" { self . human_readable_price } ( { subscriptions } subscriptions)\" djstripe . models . billing . Plan . create ( ** kwargs ) classmethod Source code in djstripe/models/billing.py @classmethod def create ( cls , ** kwargs ): # A few minor things are changed in the api-version of the create call api_kwargs = dict ( kwargs ) api_kwargs [ \"amount\" ] = int ( api_kwargs [ \"amount\" ] * 100 ) if isinstance ( api_kwargs . get ( \"product\" ), StripeModel ): api_kwargs [ \"product\" ] = api_kwargs [ \"product\" ] . id stripe_plan = cls . _api_create ( ** api_kwargs ) plan = cls . sync_from_stripe_data ( stripe_plan ) return plan djstripe . models . billing . Plan . get_aggregate_usage_display ( self , * , field =< djstripe . fields . StripeEnumField : aggregate_usage > ) Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . billing . Plan . get_billing_scheme_display ( self , * , field =< djstripe . fields . StripeEnumField : billing_scheme > ) Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . billing . Plan . get_interval_display ( self , * , field =< djstripe . fields . StripeEnumField : interval > ) Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . billing . Plan . get_next_by_djstripe_created ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_created > , is_next = True , ** kwargs ) Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . billing . Plan . get_next_by_djstripe_updated ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_updated > , is_next = True , ** kwargs ) Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . billing . Plan . get_or_create ( ** kwargs ) classmethod Get or create a Plan. Source code in djstripe/models/billing.py @classmethod def get_or_create ( cls , ** kwargs ): \"\"\"Get or create a Plan.\"\"\" try : return Plan . objects . get ( id = kwargs [ \"id\" ]), False except Plan . DoesNotExist : return cls . create ( ** kwargs ), True djstripe . models . billing . Plan . get_previous_by_djstripe_created ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_created > , is_next = False , ** kwargs ) Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . billing . Plan . get_previous_by_djstripe_updated ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_updated > , is_next = False , ** kwargs ) Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . billing . Plan . get_tiers_mode_display ( self , * , field =< djstripe . fields . StripeEnumField : tiers_mode > ) Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . billing . Plan . get_usage_type_display ( self , * , field =< djstripe . fields . StripeEnumField : usage_type > ) Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe.models.billing.Subscription Subscriptions allow you to charge a customer's card on a recurring basis. A subscription ties a customer to a particular plan you've created. A subscription still in its trial period is trialing and moves to active when the trial period is over. When payment to renew the subscription fails, the subscription becomes past_due . After Stripe has exhausted all payment retry attempts, the subscription ends up with a status of either canceled or unpaid depending on your retry settings. Note that when a subscription has a status of unpaid , no subsequent invoices will be attempted (invoices will be created, but then immediately automatically closed. Additionally, updating customer card details will not lead to Stripe retrying the latest invoice.). After receiving updated card details from a customer, you may choose to reopen and pay their closed invoices. Stripe documentation: https://stripe.com/docs/api?lang=python#subscriptions djstripe . models . billing . Subscription . application_fee_percent djstripe . models . billing . Subscription . billing_cycle_anchor djstripe . models . billing . Subscription . billing_thresholds djstripe . models . billing . Subscription . cancel_at djstripe . models . billing . Subscription . cancel_at_period_end djstripe . models . billing . Subscription . canceled_at djstripe . models . billing . Subscription . collection_method djstripe . models . billing . Subscription . current_period_end djstripe . models . billing . Subscription . current_period_start djstripe . models . billing . Subscription . customer djstripe . models . billing . Subscription . days_until_due djstripe . models . billing . Subscription . default_payment_method djstripe . models . billing . Subscription . default_source djstripe . models . billing . Subscription . default_tax_rates djstripe . models . billing . Subscription . discount djstripe . models . billing . Subscription . djstripe_owner_account : Optional [ djstripe . fields . StripeForeignKey ] djstripe . models . billing . Subscription . ended_at djstripe . models . billing . Subscription . latest_invoice djstripe . models . billing . Subscription . next_pending_invoice_item_invoice djstripe . models . billing . Subscription . objects djstripe . models . billing . Subscription . pending_invoice_item_interval djstripe . models . billing . Subscription . pending_setup_intent djstripe . models . billing . Subscription . pending_update djstripe . models . billing . Subscription . plan djstripe . models . billing . Subscription . quantity djstripe . models . billing . Subscription . schedule djstripe . models . billing . Subscription . start_date djstripe . models . billing . Subscription . status djstripe . models . billing . Subscription . stripe_dashboard_item_name djstripe . models . billing . Subscription . trial_end djstripe . models . billing . Subscription . trial_start djstripe.models.billing.Subscription.DoesNotExist djstripe.models.billing.Subscription.MultipleObjectsReturned djstripe.models.billing.Subscription.stripe_class djstripe . models . billing . Subscription . stripe_class . OBJECT_NAME djstripe . models . billing . Subscription . stripe_class . _cls_delete_discount ( sid , ** params ) classmethod private Source code in djstripe/models/billing.py def custom_method_request ( cls , sid , ** params ): url = \" %s / %s / %s \" % ( cls . class_url (), quote_plus ( util . utf8 ( sid )), http_path , ) obj = cls . _static_request ( http_verb , url , ** params ) # For list objects, we have to attach the parameters so that they # can be referenced in auto-pagination and ensure consistency. if \"object\" in obj and obj . object == \"list\" : obj . _retrieve_params = params return obj djstripe . models . billing . Subscription . stripe_class . delete_discount ( self , ** params ) Source code in djstripe/models/billing.py def delete_discount ( self , ** params ): requestor = api_requestor . APIRequestor ( self . api_key , api_version = self . stripe_version , account = self . stripe_account , ) url = self . instance_url () + \"/discount\" _ , api_key = requestor . request ( \"delete\" , url , params ) self . refresh_from ({ \"discount\" : None }, api_key , True ) Methods djstripe . models . billing . Subscription . __str__ ( self ) special Source code in djstripe/models/billing.py def __str__ ( self ): subscriptions_lst = self . customer . _get_valid_subscriptions () products_lst = [ subscription . plan . product . name for subscription in subscriptions_lst if subscription and subscription . plan ] return f \" { self . customer } on { ' and ' . join ( products_lst ) } \" djstripe . models . billing . Subscription . _attach_objects_post_save_hook ( self , cls , data , pending_relations = None ) private Gets called by this object's create and sync methods just after save. Use this to populate fields after the model is saved. :param cls: The target class for the instantiated object. :param data: The data dictionary received from the Stripe API. :type data: dict Source code in djstripe/models/billing.py def _attach_objects_post_save_hook ( self , cls , data , pending_relations = None ): super () . _attach_objects_post_save_hook ( cls , data , pending_relations = pending_relations ) cls . _stripe_object_to_subscription_items ( target_cls = SubscriptionItem , data = data , subscription = self ) self . default_tax_rates . set ( cls . _stripe_object_to_default_tax_rates ( target_cls = TaxRate , data = data ) ) djstripe . models . billing . Subscription . cancel ( self , at_period_end = False ) Cancels this subscription. If you set the at_period_end parameter to true, the subscription will remain active until the end of the period, at which point it will be canceled and not renewed. By default, the subscription is terminated immediately. In either case, the customer will not be charged again for the subscription. Note, however, that any pending invoice items that you've created will still be charged for at the end of the period unless manually deleted. If you've set the subscription to cancel at period end, any pending prorations will also be left in place and collected at the end of the period, but if the subscription is set to cancel immediately, pending prorations will be removed. By default, all unpaid invoices for the customer will be closed upon subscription cancellation. We do this in order to prevent unexpected payment retries once the customer has canceled a subscription. However, you can reopen the invoices manually after subscription cancellation to have us proceed with automatic retries, or you could even re-attempt payment yourself on all unpaid invoices before allowing the customer to cancel the subscription at all. :param at_period_end: A flag that if set to true will delay the cancellation of the subscription until the end of the current period. Default is False. :type at_period_end: boolean .. important:: If a subscription is canceled during a trial period, the at_period_end flag will be overridden to False so that the trial ends immediately and the customer's card isn't charged. Source code in djstripe/models/billing.py def cancel ( self , at_period_end : bool = False ): \"\"\" Cancels this subscription. If you set the at_period_end parameter to true, the subscription will remain active until the end of the period, at which point it will be canceled and not renewed. By default, the subscription is terminated immediately. In either case, the customer will not be charged again for the subscription. Note, however, that any pending invoice items that you've created will still be charged for at the end of the period unless manually deleted. If you've set the subscription to cancel at period end, any pending prorations will also be left in place and collected at the end of the period, but if the subscription is set to cancel immediately, pending prorations will be removed. By default, all unpaid invoices for the customer will be closed upon subscription cancellation. We do this in order to prevent unexpected payment retries once the customer has canceled a subscription. However, you can reopen the invoices manually after subscription cancellation to have us proceed with automatic retries, or you could even re-attempt payment yourself on all unpaid invoices before allowing the customer to cancel the subscription at all. :param at_period_end: A flag that if set to true will delay the cancellation \\ of the subscription until the end of the current period. Default is False. :type at_period_end: boolean .. important:: If a subscription is canceled during a trial period, \\ the ``at_period_end`` flag will be overridden to False so that the trial ends \\ immediately and the customer's card isn't charged. \"\"\" # If plan has trial days and customer cancels before # trial period ends, then end subscription now, # i.e. at_period_end=False if self . trial_end and self . trial_end > timezone . now (): at_period_end = False if at_period_end : stripe_subscription = self . _api_update ( cancel_at_period_end = True ) else : try : stripe_subscription = self . _api_delete () except InvalidRequestError as exc : if \"No such subscription:\" in str ( exc ): # cancel() works by deleting the subscription. The object still # exists in Stripe however, and can still be retrieved. # If the subscription was already canceled (status=canceled), # that api_retrieve() call will fail with \"No such subscription\". # However, this may also happen if the subscription legitimately # does not exist, in which case the following line will re-raise. stripe_subscription = self . api_retrieve () else : raise return Subscription . sync_from_stripe_data ( stripe_subscription ) djstripe . models . billing . Subscription . extend ( self , delta ) Extends this subscription by the provided delta. :param delta: The timedelta by which to extend this subscription. :type delta: timedelta Source code in djstripe/models/billing.py def extend ( self , delta ): \"\"\" Extends this subscription by the provided delta. :param delta: The timedelta by which to extend this subscription. :type delta: timedelta \"\"\" if delta . total_seconds () < 0 : raise ValueError ( \"delta must be a positive timedelta.\" ) if self . trial_end is not None and self . trial_end > timezone . now (): period_end = self . trial_end else : period_end = self . current_period_end period_end += delta return self . update ( proration_behavior = \"none\" , trial_end = period_end ) djstripe . models . billing . Subscription . get_collection_method_display ( self , * , field =< djstripe . fields . StripeEnumField : collection_method > ) Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . billing . Subscription . get_next_by_current_period_end ( self , * , field =< djstripe . fields . StripeDateTimeField : current_period_end > , is_next = True , ** kwargs ) Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . billing . Subscription . get_next_by_current_period_start ( self , * , field =< djstripe . fields . StripeDateTimeField : current_period_start > , is_next = True , ** kwargs ) Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . billing . Subscription . get_next_by_djstripe_created ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_created > , is_next = True , ** kwargs ) Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . billing . Subscription . get_next_by_djstripe_updated ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_updated > , is_next = True , ** kwargs ) Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . billing . Subscription . get_previous_by_current_period_end ( self , * , field =< djstripe . fields . StripeDateTimeField : current_period_end > , is_next = False , ** kwargs ) Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . billing . Subscription . get_previous_by_current_period_start ( self , * , field =< djstripe . fields . StripeDateTimeField : current_period_start > , is_next = False , ** kwargs ) Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . billing . Subscription . get_previous_by_djstripe_created ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_created > , is_next = False , ** kwargs ) Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . billing . Subscription . get_previous_by_djstripe_updated ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_updated > , is_next = False , ** kwargs ) Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . billing . Subscription . get_status_display ( self , * , field =< djstripe . fields . StripeEnumField : status > ) Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . billing . Subscription . is_period_current ( self ) Returns True if this subscription's period is current, false otherwise. Source code in djstripe/models/billing.py def is_period_current ( self ): \"\"\" Returns True if this subscription's period is current, false otherwise. \"\"\" return self . current_period_end > timezone . now () or ( self . trial_end and self . trial_end > timezone . now () ) djstripe . models . billing . Subscription . is_status_current ( self ) Returns True if this subscription's status is current (active or trialing), false otherwise. Source code in djstripe/models/billing.py def is_status_current ( self ): \"\"\" Returns True if this subscription's status is current (active or trialing), false otherwise. \"\"\" return self . status in [ \"trialing\" , \"active\" ] djstripe . models . billing . Subscription . is_status_temporarily_current ( self ) A status is temporarily current when the subscription is canceled with the at_period_end flag. The subscription is still active, but is technically canceled and we're just waiting for it to run out. You could use this method to give customers limited service after they've canceled. For example, a video on demand service could only allow customers to download their libraries and do nothing else when their subscription is temporarily current. Source code in djstripe/models/billing.py def is_status_temporarily_current ( self ): \"\"\" A status is temporarily current when the subscription is canceled with the ``at_period_end`` flag. The subscription is still active, but is technically canceled and we're just waiting for it to run out. You could use this method to give customers limited service after they've canceled. For example, a video on demand service could only allow customers to download their libraries and do nothing else when their subscription is temporarily current. \"\"\" return ( self . canceled_at and self . cancel_at_period_end and timezone . now () < self . current_period_end ) djstripe . models . billing . Subscription . is_valid ( self ) Returns True if this subscription's status and period are current, false otherwise. Source code in djstripe/models/billing.py def is_valid ( self ): \"\"\" Returns True if this subscription's status and period are current, false otherwise. \"\"\" if not self . is_status_current (): return False if not self . is_period_current (): return False return True djstripe . models . billing . Subscription . reactivate ( self ) Reactivates this subscription. If a customer's subscription is canceled with at_period_end set to True and it has not yet reached the end of the billing period, it can be reactivated. Subscriptions canceled immediately cannot be reactivated. (Source: https://stripe.com/docs/billing/subscriptions/cancel) .. warning:: Reactivating a fully canceled Subscription will fail silently. Be sure to check the returned Subscription's status. Source code in djstripe/models/billing.py def reactivate ( self ): \"\"\" Reactivates this subscription. If a customer's subscription is canceled with ``at_period_end`` set to True and it has not yet reached the end of the billing period, it can be reactivated. Subscriptions canceled immediately cannot be reactivated. (Source: https://stripe.com/docs/billing/subscriptions/cancel) .. warning:: Reactivating a fully canceled Subscription will fail silently. \\ Be sure to check the returned Subscription's status. \"\"\" stripe_subscription = self . api_retrieve () stripe_subscription . plan = self . plan . id stripe_subscription . cancel_at_period_end = False return Subscription . sync_from_stripe_data ( stripe_subscription . save ()) djstripe . models . billing . Subscription . update ( self , plan = None , prorate = None , ** kwargs ) See Customer.subscribe() <#djstripe.models.Customer.subscribe> __ :param plan: The plan to which to subscribe the customer. :type plan: Plan or string (plan ID) .. important:: Updating a subscription by changing the plan or quantity creates a new Subscription in Stripe (and dj-stripe). Source code in djstripe/models/billing.py def update ( self , plan : Union [ StripeModel , str ] = None , prorate : bool = None , ** kwargs , ): \"\"\" See `Customer.subscribe() <#djstripe.models.Customer.subscribe>`__ :param plan: The plan to which to subscribe the customer. :type plan: Plan or string (plan ID) .. important:: Updating a subscription by changing the plan or quantity \\ creates a new ``Subscription`` in \\ Stripe (and dj-stripe). \"\"\" # Convert Plan to id if plan is not None and isinstance ( plan , StripeModel ): plan = plan . id # In short: We used to have a `prorate` argument which defaulted to # a DJSTRIPE_PRORATION_POLICY setting. # This is overly complex and specific, so we are dropping support for this. # To override it, you can pass `proration_behavior`. # If instead you pass `prorate`, we will transform it until dj-stripe 2.8. # If you have DJSTRIPE_PRORATION_POLICY set, we will default to it for now. # In 2.8, we will ignore both of those and let Stripe figure it out. # Stripe's default proration policy is specified here: # https://stripe.com/docs/billing/subscriptions/prorations if \"proration_behavior\" not in kwargs : if prorate is not None : warnings . warn ( \"The `prorate` parameter to Subscription.update() is deprecated \" \"by Stripe. Use `proration_behavior` instead. \\n \" \"Read more: \" \"https://stripe.com/docs/billing/subscriptions/prorations\" ) else : prorate = djstripe_settings . PRORATION_POLICY if prorate is not None : warnings . warn ( \"The `DJSTRIPE_PRORATION_POLICY` setting is deprecated and will \" \"be ignored in dj-stripe 2.8. \" \"Specify `proration_behavior` instead.\" ) else : prorate = False if prorate : kwargs . setdefault ( \"proration_behavior\" , \"create_prorations\" ) else : kwargs . setdefault ( \"proration_behavior\" , \"none\" ) elif prorate is not None : raise TypeError ( \"`prorate` argument must not be set when `proration_behavior` is specified\" ) stripe_subscription = self . _api_update ( plan = plan , ** kwargs ) return Subscription . sync_from_stripe_data ( stripe_subscription ) djstripe.models.billing.SubscriptionItem Subscription items allow you to create customer subscriptions with more than one plan, making it easy to represent complex billing relationships. Stripe documentation: https://stripe.com/docs/api#subscription_items djstripe . models . billing . SubscriptionItem . billing_thresholds djstripe . models . billing . SubscriptionItem . djstripe_owner_account : Optional [ djstripe . fields . StripeForeignKey ] djstripe . models . billing . SubscriptionItem . plan djstripe . models . billing . SubscriptionItem . price djstripe . models . billing . SubscriptionItem . quantity djstripe . models . billing . SubscriptionItem . subscription djstripe . models . billing . SubscriptionItem . tax_rates Classes djstripe.models.billing.SubscriptionItem.DoesNotExist djstripe.models.billing.SubscriptionItem.MultipleObjectsReturned djstripe.models.billing.SubscriptionItem.stripe_class djstripe . models . billing . SubscriptionItem . stripe_class . OBJECT_NAME Methods djstripe . models . billing . SubscriptionItem . stripe_class . create_usage_record ( id , ** params ) classmethod Source code in djstripe/models/billing.py def create_nested_resource ( cls , id , ** params ): url = getattr ( cls , resource_url_method )( id ) return getattr ( cls , resource_request_method )( \"post\" , url , ** params ) djstripe . models . billing . SubscriptionItem . stripe_class . list_usage_record_summaries ( id , ** params ) classmethod Source code in djstripe/models/billing.py def list_nested_resources ( cls , id , ** params ): url = getattr ( cls , resource_url_method )( id ) return getattr ( cls , resource_request_method )( \"get\" , url , ** params ) djstripe . models . billing . SubscriptionItem . stripe_class . usage_record_summaries ( self , ** params ) usage_record_summaries is deprecated, use SubscriptionItem.list_usage_record_summaries instead. Source code in djstripe/models/billing.py def usage_record_summaries ( self , ** params ): \"\"\"usage_record_summaries is deprecated, use SubscriptionItem.list_usage_record_summaries instead.\"\"\" return self . request ( \"get\" , self . instance_url () + \"/usage_record_summaries\" , params ) djstripe . models . billing . SubscriptionItem . stripe_class . usage_record_summarys_request ( method , url , api_key = None , idempotency_key = None , stripe_version = None , stripe_account = None , ** params ) classmethod Source code in djstripe/models/billing.py def nested_resource_request ( cls , method , url , api_key = None , idempotency_key = None , stripe_version = None , stripe_account = None , ** params ): requestor = api_requestor . APIRequestor ( api_key , api_version = stripe_version , account = stripe_account ) headers = util . populate_headers ( idempotency_key ) response , api_key = requestor . request ( method , url , params , headers ) return util . convert_to_stripe_object ( response , api_key , stripe_version , stripe_account ) djstripe . models . billing . SubscriptionItem . stripe_class . usage_record_summarys_url ( id , nested_id = None ) classmethod Source code in djstripe/models/billing.py def nested_resource_url ( cls , id , nested_id = None ): url = \" %s / %s / %s \" % ( cls . class_url (), quote_plus ( id ), quote_plus ( path ), ) if nested_id is not None : url += \"/ %s \" % quote_plus ( nested_id ) return url djstripe . models . billing . SubscriptionItem . stripe_class . usage_records_request ( method , url , api_key = None , idempotency_key = None , stripe_version = None , stripe_account = None , ** params ) classmethod Source code in djstripe/models/billing.py def nested_resource_request ( cls , method , url , api_key = None , idempotency_key = None , stripe_version = None , stripe_account = None , ** params ): requestor = api_requestor . APIRequestor ( api_key , api_version = stripe_version , account = stripe_account ) headers = util . populate_headers ( idempotency_key ) response , api_key = requestor . request ( method , url , params , headers ) return util . convert_to_stripe_object ( response , api_key , stripe_version , stripe_account ) djstripe . models . billing . SubscriptionItem . stripe_class . usage_records_url ( id , nested_id = None ) classmethod Source code in djstripe/models/billing.py def nested_resource_url ( cls , id , nested_id = None ): url = \" %s / %s / %s \" % ( cls . class_url (), quote_plus ( id ), quote_plus ( path ), ) if nested_id is not None : url += \"/ %s \" % quote_plus ( nested_id ) return url Methods djstripe . models . billing . SubscriptionItem . _attach_objects_post_save_hook ( self , cls , data , pending_relations = None ) private Gets called by this object's create and sync methods just after save. Use this to populate fields after the model is saved. :param cls: The target class for the instantiated object. :param data: The data dictionary received from the Stripe API. :type data: dict Source code in djstripe/models/billing.py def _attach_objects_post_save_hook ( self , cls , data , pending_relations = None ): super () . _attach_objects_post_save_hook ( cls , data , pending_relations = pending_relations ) self . tax_rates . set ( cls . _stripe_object_to_tax_rates ( target_cls = TaxRate , data = data ) ) djstripe . models . billing . SubscriptionItem . get_next_by_djstripe_created ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_created > , is_next = True , ** kwargs ) Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . billing . SubscriptionItem . get_next_by_djstripe_updated ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_updated > , is_next = True , ** kwargs ) Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . billing . SubscriptionItem . get_previous_by_djstripe_created ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_created > , is_next = False , ** kwargs ) Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . billing . SubscriptionItem . get_previous_by_djstripe_updated ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_updated > , is_next = False , ** kwargs ) Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe.models.billing.SubscriptionSchedule Subscription schedules allow you to create and manage the lifecycle of a subscription by predefining expected changes. Stripe documentation: https://stripe.com/docs/api/subscription_schedules djstripe . models . billing . SubscriptionSchedule . billing_thresholds djstripe . models . billing . SubscriptionSchedule . canceled_at djstripe . models . billing . SubscriptionSchedule . completed_at djstripe . models . billing . SubscriptionSchedule . current_phase djstripe . models . billing . SubscriptionSchedule . customer djstripe . models . billing . SubscriptionSchedule . default_settings djstripe . models . billing . SubscriptionSchedule . djstripe_owner_account : Optional [ djstripe . fields . StripeForeignKey ] djstripe . models . billing . SubscriptionSchedule . end_behavior djstripe . models . billing . SubscriptionSchedule . phases djstripe . models . billing . SubscriptionSchedule . released_at djstripe . models . billing . SubscriptionSchedule . released_subscription djstripe . models . billing . SubscriptionSchedule . status djstripe.models.billing.SubscriptionSchedule.DoesNotExist djstripe.models.billing.SubscriptionSchedule.MultipleObjectsReturned djstripe.models.billing.SubscriptionSchedule.stripe_class djstripe . models . billing . SubscriptionSchedule . stripe_class . OBJECT_NAME djstripe . models . billing . SubscriptionSchedule . stripe_class . _cls_cancel ( sid , ** params ) classmethod private Source code in djstripe/models/billing.py def custom_method_request ( cls , sid , ** params ): url = \" %s / %s / %s \" % ( cls . class_url (), quote_plus ( util . utf8 ( sid )), http_path , ) obj = cls . _static_request ( http_verb , url , ** params ) # For list objects, we have to attach the parameters so that they # can be referenced in auto-pagination and ensure consistency. if \"object\" in obj and obj . object == \"list\" : obj . _retrieve_params = params return obj djstripe . models . billing . SubscriptionSchedule . stripe_class . _cls_release ( sid , ** params ) classmethod private Source code in djstripe/models/billing.py def custom_method_request ( cls , sid , ** params ): url = \" %s / %s / %s \" % ( cls . class_url (), quote_plus ( util . utf8 ( sid )), http_path , ) obj = cls . _static_request ( http_verb , url , ** params ) # For list objects, we have to attach the parameters so that they # can be referenced in auto-pagination and ensure consistency. if \"object\" in obj and obj . object == \"list\" : obj . _retrieve_params = params return obj djstripe . models . billing . SubscriptionSchedule . stripe_class . cancel ( self , idempotency_key = None , ** params ) Source code in djstripe/models/billing.py def cancel ( self , idempotency_key = None , ** params ): url = self . instance_url () + \"/cancel\" headers = util . populate_headers ( idempotency_key ) self . refresh_from ( self . request ( \"post\" , url , params , headers )) return self djstripe . models . billing . SubscriptionSchedule . stripe_class . release ( self , idempotency_key = None , ** params ) Source code in djstripe/models/billing.py def release ( self , idempotency_key = None , ** params ): url = self . instance_url () + \"/release\" headers = util . populate_headers ( idempotency_key ) self . refresh_from ( self . request ( \"post\" , url , params , headers )) return self djstripe . models . billing . SubscriptionSchedule . get_end_behavior_display ( self , * , field =< djstripe . fields . StripeEnumField : end_behavior > ) Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . billing . SubscriptionSchedule . get_next_by_djstripe_created ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_created > , is_next = True , ** kwargs ) Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . billing . SubscriptionSchedule . get_next_by_djstripe_updated ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_updated > , is_next = True , ** kwargs ) Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . billing . SubscriptionSchedule . get_previous_by_djstripe_created ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_created > , is_next = False , ** kwargs ) Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . billing . SubscriptionSchedule . get_previous_by_djstripe_updated ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_updated > , is_next = False , ** kwargs ) Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . billing . SubscriptionSchedule . get_status_display ( self , * , field =< djstripe . fields . StripeEnumField : status > ) Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe.models.billing.TaxId Add one or multiple tax IDs to a customer. A customer's tax IDs are displayed on invoices and credit notes issued for the customer. Stripe documentation: https://stripe.com/docs/api/customer_tax_ids djstripe . models . billing . TaxId . country djstripe . models . billing . TaxId . customer djstripe . models . billing . TaxId . description djstripe . models . billing . TaxId . djstripe_owner_account : Optional [ djstripe . fields . StripeForeignKey ] djstripe . models . billing . TaxId . metadata djstripe . models . billing . TaxId . type djstripe . models . billing . TaxId . value djstripe . models . billing . TaxId . verification djstripe.models.billing.TaxId.DoesNotExist djstripe.models.billing.TaxId.MultipleObjectsReturned djstripe.models.billing.TaxId.stripe_class djstripe . models . billing . TaxId . stripe_class . OBJECT_NAME djstripe . models . billing . TaxId . stripe_class . instance_url ( self ) Source code in djstripe/models/billing.py def instance_url ( self ): token = util . utf8 ( self . id ) customer = util . utf8 ( self . customer ) base = Customer . class_url () cust_extn = quote_plus ( customer ) extn = quote_plus ( token ) return \" %s / %s /tax_ids/ %s \" % ( base , cust_extn , extn ) djstripe . models . billing . TaxId . stripe_class . retrieve ( id , api_key = None , ** params ) classmethod Source code in djstripe/models/billing.py @classmethod def retrieve ( cls , id , api_key = None , ** params ): raise NotImplementedError ( \"Can't retrieve a tax id without a customer ID. Use customer.retrieve_tax_id('tax_id')\" ) Methods djstripe . models . billing . TaxId . __str__ ( self ) special Source code in djstripe/models/billing.py def __str__ ( self ): return f \" { enums . TaxIdType . humanize ( self . type ) } { self . value } ( { self . verification . get ( 'status' ) } )\" djstripe . models . billing . TaxId . _api_create ( api_key = 'sk_test_XXXXXXXXXXXXXXXXXXXXXXXXX' , ** kwargs ) classmethod private Call the stripe API's create operation for this model. :param api_key: The api key to use for this request. Defaults to djstripe_settings.STRIPE_SECRET_KEY. :type api_key: string Source code in djstripe/models/billing.py @classmethod def _api_create ( cls , api_key = djstripe_settings . STRIPE_SECRET_KEY , ** kwargs ): \"\"\" Call the stripe API's create operation for this model. :param api_key: The api key to use for this request. \\ Defaults to djstripe_settings.STRIPE_SECRET_KEY. :type api_key: string \"\"\" if not kwargs . get ( \"id\" ): raise KeyError ( \"Customer Object ID is missing\" ) try : Customer . objects . get ( id = kwargs [ \"id\" ]) except Customer . DoesNotExist : raise return stripe . Customer . create_tax_id ( api_key = api_key , ** kwargs ) djstripe . models . billing . TaxId . api_list ( api_key = 'sk_test_XXXXXXXXXXXXXXXXXXXXXXXXX' , ** kwargs ) classmethod Call the stripe API's list operation for this model. :param api_key: The api key to use for this request. Defaults to djstripe_settings.STRIPE_SECRET_KEY. :type api_key: string See Stripe documentation for accepted kwargs for each object. :returns: an iterator over all items in the query Source code in djstripe/models/billing.py @classmethod def api_list ( cls , api_key = djstripe_settings . STRIPE_SECRET_KEY , ** kwargs ): \"\"\" Call the stripe API's list operation for this model. :param api_key: The api key to use for this request. \\ Defaults to djstripe_settings.STRIPE_SECRET_KEY. :type api_key: string See Stripe documentation for accepted kwargs for each object. :returns: an iterator over all items in the query \"\"\" return stripe . Customer . list_tax_ids ( api_key = api_key , ** kwargs ) . auto_paging_iter () djstripe . models . billing . TaxId . api_retrieve ( self , api_key = None , stripe_account = None ) Call the stripe API's retrieve operation for this model. :param api_key: The api key to use for this request. Defaults to djstripe_settings.STRIPE_SECRET_KEY. :type api_key: string :param stripe_account: The optional connected account for which this request is being made. :type stripe_account: string Source code in djstripe/models/billing.py def api_retrieve ( self , api_key = None , stripe_account = None ): \"\"\" Call the stripe API's retrieve operation for this model. :param api_key: The api key to use for this request. \\ Defaults to djstripe_settings.STRIPE_SECRET_KEY. :type api_key: string :param stripe_account: The optional connected account \\ for which this request is being made. :type stripe_account: string \"\"\" nested_id = self . id id = self . customer . id # Prefer passed in stripe_account if set. if not stripe_account : stripe_account = self . _get_stripe_account_id ( api_key ) return stripe . Customer . retrieve_tax_id ( id = id , nested_id = nested_id , api_key = api_key or self . default_api_key , expand = self . expand_fields , stripe_account = stripe_account , ) djstripe . models . billing . TaxId . get_next_by_djstripe_created ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_created > , is_next = True , ** kwargs ) Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . billing . TaxId . get_next_by_djstripe_updated ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_updated > , is_next = True , ** kwargs ) Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . billing . TaxId . get_previous_by_djstripe_created ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_created > , is_next = False , ** kwargs ) Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . billing . TaxId . get_previous_by_djstripe_updated ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_updated > , is_next = False , ** kwargs ) Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . billing . TaxId . get_type_display ( self , * , field =< djstripe . fields . StripeEnumField : type > ) Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe.models.billing.TaxRate Tax rates can be applied to invoices and subscriptions to collect tax. Stripe documentation: https://stripe.com/docs/api/tax_rates djstripe . models . billing . TaxRate . active djstripe . models . billing . TaxRate . display_name djstripe . models . billing . TaxRate . djstripe_owner_account : Optional [ djstripe . fields . StripeForeignKey ] djstripe . models . billing . TaxRate . inclusive djstripe . models . billing . TaxRate . jurisdiction djstripe . models . billing . TaxRate . percentage djstripe.models.billing.TaxRate.DoesNotExist djstripe.models.billing.TaxRate.MultipleObjectsReturned djstripe.models.billing.TaxRate.stripe_class djstripe . models . billing . TaxRate . __str__ ( self ) special Source code in djstripe/models/billing.py def __str__ ( self ): return f \" { self . display_name } \u2013 { self . jurisdiction } at { self . percentage } %\" djstripe . models . billing . TaxRate . get_next_by_djstripe_created ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_created > , is_next = True , ** kwargs ) Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . billing . TaxRate . get_next_by_djstripe_updated ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_updated > , is_next = True , ** kwargs ) Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . billing . TaxRate . get_previous_by_djstripe_created ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_created > , is_next = False , ** kwargs ) Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . billing . TaxRate . get_previous_by_djstripe_updated ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_updated > , is_next = False , ** kwargs ) Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe.models.billing.UpcomingInvoice The preview of an upcoming invoice - does not exist in the Django database. See BaseInvoice.upcoming() Logically it should be set abstract, but that doesn't quite work since we do actually want to instantiate the model and use relations. Attributes djstripe . models . billing . UpcomingInvoice . charge djstripe . models . billing . UpcomingInvoice . customer djstripe . models . billing . UpcomingInvoice . default_payment_method djstripe . models . billing . UpcomingInvoice . default_source djstripe . models . billing . UpcomingInvoice . default_tax_rates property readonly Gets the default tax rates associated with this upcoming invoice. :return: djstripe . models . billing . UpcomingInvoice . djstripe_owner_account : Optional [ djstripe . fields . StripeForeignKey ] djstripe . models . billing . UpcomingInvoice . id property writable djstripe . models . billing . UpcomingInvoice . invoiceitems property readonly Gets the invoice items associated with this upcoming invoice. This differs from normal (non-upcoming) invoices, in that upcoming invoices are in-memory and do not persist to the database. Therefore, all of the data comes from the Stripe API itself. Instead of returning a normal queryset for the invoiceitems, this will return a mock of a queryset, but with the data fetched from Stripe - It will act like a normal queryset, but mutation will silently fail. djstripe . models . billing . UpcomingInvoice . payment_intent djstripe . models . billing . UpcomingInvoice . subscription djstripe . models . billing . UpcomingInvoice . total_tax_amounts property readonly Gets the total tax amounts associated with this upcoming invoice. :return: djstripe.models.billing.UpcomingInvoice.DoesNotExist djstripe.models.billing.UpcomingInvoice.MultipleObjectsReturned Methods djstripe . models . billing . UpcomingInvoice . __init__ ( self , * args , ** kwargs ) special Source code in djstripe/models/billing.py def __init__ ( self , * args , ** kwargs ): super () . __init__ ( * args , ** kwargs ) self . _invoiceitems = [] self . _default_tax_rates = [] self . _total_tax_amounts = [] djstripe . models . billing . UpcomingInvoice . _attach_objects_hook ( self , cls , data , current_ids = None ) private Gets called by this object's create and sync methods just before save. Use this to populate fields before the model is saved. :param cls: The target class for the instantiated object. :param data: The data dictionary received from the Stripe API. :type data: dict :param current_ids: stripe ids of objects that are currently being processed :type current_ids: set Source code in djstripe/models/billing.py def _attach_objects_hook ( self , cls , data , current_ids = None ): super () . _attach_objects_hook ( cls , data , current_ids = current_ids ) self . _invoiceitems = cls . _stripe_object_to_invoice_items ( target_cls = InvoiceItem , data = data , invoice = self ) djstripe . models . billing . UpcomingInvoice . _attach_objects_post_save_hook ( self , cls , data , pending_relations = None ) private Gets called by this object's create and sync methods just after save. Use this to populate fields after the model is saved. :param cls: The target class for the instantiated object. :param data: The data dictionary received from the Stripe API. :type data: dict Source code in djstripe/models/billing.py def _attach_objects_post_save_hook ( self , cls , data , pending_relations = None ): super () . _attach_objects_post_save_hook ( cls , data , pending_relations = pending_relations ) self . _default_tax_rates = cls . _stripe_object_to_default_tax_rates ( target_cls = TaxRate , data = data ) total_tax_amounts = [] for tax_amount_data in data . get ( \"total_tax_amounts\" , []): tax_rate_id = tax_amount_data [ \"tax_rate\" ] if not isinstance ( tax_rate_id , str ): tax_rate_id = tax_rate_id [ \"tax_rate\" ] tax_rate = TaxRate . _get_or_retrieve ( id = tax_rate_id ) tax_amount = DjstripeUpcomingInvoiceTotalTaxAmount ( invoice = self , amount = tax_amount_data [ \"amount\" ], inclusive = tax_amount_data [ \"inclusive\" ], tax_rate = tax_rate , ) total_tax_amounts . append ( tax_amount ) self . _total_tax_amounts = total_tax_amounts djstripe . models . billing . UpcomingInvoice . get_billing_reason_display ( self , * , field =< djstripe . fields . StripeEnumField : billing_reason > ) Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . billing . UpcomingInvoice . get_collection_method_display ( self , * , field =< djstripe . fields . StripeEnumField : collection_method > ) Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . billing . UpcomingInvoice . get_customer_tax_exempt_display ( self , * , field =< djstripe . fields . StripeEnumField : customer_tax_exempt > ) Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . billing . UpcomingInvoice . get_next_by_djstripe_created ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_created > , is_next = True , ** kwargs ) Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . billing . UpcomingInvoice . get_next_by_djstripe_updated ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_updated > , is_next = True , ** kwargs ) Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . billing . UpcomingInvoice . get_next_by_period_end ( self , * , field =< djstripe . fields . StripeDateTimeField : period_end > , is_next = True , ** kwargs ) Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . billing . UpcomingInvoice . get_next_by_period_start ( self , * , field =< djstripe . fields . StripeDateTimeField : period_start > , is_next = True , ** kwargs ) Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . billing . UpcomingInvoice . get_previous_by_djstripe_created ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_created > , is_next = False , ** kwargs ) Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . billing . UpcomingInvoice . get_previous_by_djstripe_updated ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_updated > , is_next = False , ** kwargs ) Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . billing . UpcomingInvoice . get_previous_by_period_end ( self , * , field =< djstripe . fields . StripeDateTimeField : period_end > , is_next = False , ** kwargs ) Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . billing . UpcomingInvoice . get_previous_by_period_start ( self , * , field =< djstripe . fields . StripeDateTimeField : period_start > , is_next = False , ** kwargs ) Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . billing . UpcomingInvoice . get_status_display ( self , * , field =< djstripe . fields . StripeEnumField : status > ) Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . billing . UpcomingInvoice . get_stripe_dashboard_url ( self ) Get the stripe dashboard url for this object. Source code in djstripe/models/billing.py def get_stripe_dashboard_url ( self ): return \"\" djstripe . models . billing . UpcomingInvoice . save ( self , * args , ** kwargs ) Save the current instance. Override this in a subclass if you want to control the saving process. The 'force_insert' and 'force_update' parameters can be used to insist that the \"save\" must be an SQL insert or update (or equivalent for non-SQL backends), respectively. Normally, they should not be set. Source code in djstripe/models/billing.py def save ( self , * args , ** kwargs ): return # noop djstripe.models.billing.UsageRecord Usage records allow you to continually report usage and metrics to Stripe for metered billing of plans. Stripe documentation: https://stripe.com/docs/api#usage_records djstripe . models . billing . UsageRecord . action djstripe . models . billing . UsageRecord . description djstripe . models . billing . UsageRecord . djstripe_owner_account : Optional [ djstripe . fields . StripeForeignKey ] djstripe . models . billing . UsageRecord . metadata djstripe . models . billing . UsageRecord . quantity djstripe . models . billing . UsageRecord . subscription_item djstripe . models . billing . UsageRecord . timestamp djstripe.models.billing.UsageRecord.DoesNotExist djstripe.models.billing.UsageRecord.MultipleObjectsReturned djstripe.models.billing.UsageRecord.stripe_class djstripe . models . billing . UsageRecord . stripe_class . OBJECT_NAME djstripe . models . billing . UsageRecord . stripe_class . create ( api_key = None , idempotency_key = None , stripe_version = None , stripe_account = None , ** params ) classmethod Source code in djstripe/models/billing.py @classmethod def create ( cls , api_key = None , idempotency_key = None , stripe_version = None , stripe_account = None , ** params ): if \"subscription_item\" not in params : raise ValueError ( \"Params must have a subscription_item key\" ) subscription_item = params . pop ( \"subscription_item\" ) requestor = api_requestor . APIRequestor ( api_key , api_version = stripe_version , account = stripe_account ) url = \"/v1/subscription_items/ %s /usage_records\" % subscription_item headers = util . populate_headers ( idempotency_key ) response , api_key = requestor . request ( \"post\" , url , params , headers ) return util . convert_to_stripe_object ( response , api_key , stripe_version , stripe_account ) Methods djstripe . models . billing . UsageRecord . __str__ ( self ) special Source code in djstripe/models/billing.py def __str__ ( self ): return f \"Usage for { self . subscription_item } ( { self . action } ) is { self . quantity } \" djstripe . models . billing . UsageRecord . _api_create ( api_key = 'sk_test_XXXXXXXXXXXXXXXXXXXXXXXXX' , ** kwargs ) classmethod private Call the stripe API's create operation for this model. :param api_key: The api key to use for this request. Defaults to djstripe_settings.STRIPE_SECRET_KEY. :type api_key: string Source code in djstripe/models/billing.py @classmethod def _api_create ( cls , api_key = djstripe_settings . STRIPE_SECRET_KEY , ** kwargs ): \"\"\" Call the stripe API's create operation for this model. :param api_key: The api key to use for this request. \\ Defaults to djstripe_settings.STRIPE_SECRET_KEY. :type api_key: string \"\"\" if not kwargs . get ( \"id\" ): raise KeyError ( \"SubscriptionItem Object ID is missing\" ) try : SubscriptionItem . objects . get ( id = kwargs [ \"id\" ]) except SubscriptionItem . DoesNotExist : raise usage_stripe_data = stripe . SubscriptionItem . create_usage_record ( api_key = api_key , ** kwargs ) # ! Hack: there is no way to retrieve a UsageRecord object from Stripe, # ! which is why we create and sync it right here cls . sync_from_stripe_data ( usage_stripe_data ) return usage_stripe_data djstripe . models . billing . UsageRecord . create ( ** kwargs ) classmethod A wrapper around _api_create() to allow one to create and sync UsageRecord Objects Source code in djstripe/models/billing.py @classmethod def create ( cls , ** kwargs ): \"\"\" A wrapper around _api_create() to allow one to create and sync UsageRecord Objects \"\"\" return cls . _api_create ( ** kwargs ) djstripe . models . billing . UsageRecord . get_action_display ( self , * , field =< djstripe . fields . StripeEnumField : action > ) Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . billing . UsageRecord . get_next_by_djstripe_created ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_created > , is_next = True , ** kwargs ) Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . billing . UsageRecord . get_next_by_djstripe_updated ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_updated > , is_next = True , ** kwargs ) Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . billing . UsageRecord . get_previous_by_djstripe_created ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_created > , is_next = False , ** kwargs ) Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . billing . UsageRecord . get_previous_by_djstripe_updated ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_updated > , is_next = False , ** kwargs ) Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe.models.billing.UsageRecordSummary Usage record summaries provides usage information that's been summarized from multiple usage records and over a subscription billing period (e.g., 15 usage records in the month of September). Since new usage records can still be added, the returned summary information for the subscription item's ID should be seen as unstable until the subscription billing period ends. Stripe documentation: https://stripe.com/docs/api/usage_records/subscription_item_summary_list djstripe . models . billing . UsageRecordSummary . description djstripe . models . billing . UsageRecordSummary . djstripe_owner_account : Optional [ djstripe . fields . StripeForeignKey ] djstripe . models . billing . UsageRecordSummary . invoice djstripe . models . billing . UsageRecordSummary . metadata djstripe . models . billing . UsageRecordSummary . period djstripe . models . billing . UsageRecordSummary . period_end djstripe . models . billing . UsageRecordSummary . period_start djstripe . models . billing . UsageRecordSummary . subscription_item djstripe . models . billing . UsageRecordSummary . total_usage djstripe.models.billing.UsageRecordSummary.DoesNotExist djstripe.models.billing.UsageRecordSummary.MultipleObjectsReturned djstripe.models.billing.UsageRecordSummary.stripe_class Methods djstripe . models . billing . UsageRecordSummary . __str__ ( self ) special Source code in djstripe/models/billing.py def __str__ ( self ): return f \"Usage Summary for { self . subscription_item } ( { self . invoice } ) is { self . total_usage } \" djstripe . models . billing . UsageRecordSummary . _manipulate_stripe_object_hook ( data ) classmethod private Gets called by this object's stripe object conversion method just before conversion. Use this to populate custom fields in a StripeModel from stripe data. Source code in djstripe/models/billing.py @classmethod def _manipulate_stripe_object_hook ( cls , data ): data [ \"period_start\" ] = data [ \"period\" ][ \"start\" ] data [ \"period_end\" ] = data [ \"period\" ][ \"end\" ] return data djstripe . models . billing . UsageRecordSummary . api_list ( api_key = 'sk_test_XXXXXXXXXXXXXXXXXXXXXXXXX' , ** kwargs ) classmethod Call the stripe API's list operation for this model. :param api_key: The api key to use for this request. Defaults to djstripe_settings.STRIPE_SECRET_KEY. :type api_key: string See Stripe documentation for accepted kwargs for each object. :returns: an iterator over all items in the query Source code in djstripe/models/billing.py @classmethod def api_list ( cls , api_key = djstripe_settings . STRIPE_SECRET_KEY , ** kwargs ): \"\"\" Call the stripe API's list operation for this model. :param api_key: The api key to use for this request. \\ Defaults to djstripe_settings.STRIPE_SECRET_KEY. :type api_key: string See Stripe documentation for accepted kwargs for each object. :returns: an iterator over all items in the query \"\"\" if not kwargs . get ( \"id\" ): raise KeyError ( \"SubscriptionItem Object ID is missing\" ) try : SubscriptionItem . objects . get ( id = kwargs [ \"id\" ]) except SubscriptionItem . DoesNotExist : raise return stripe . SubscriptionItem . list_usage_record_summaries ( api_key = api_key , ** kwargs ) . auto_paging_iter () djstripe . models . billing . UsageRecordSummary . get_next_by_djstripe_created ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_created > , is_next = True , ** kwargs ) Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . billing . UsageRecordSummary . get_next_by_djstripe_updated ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_updated > , is_next = True , ** kwargs ) Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . billing . UsageRecordSummary . get_previous_by_djstripe_created ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_created > , is_next = False , ** kwargs ) Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . billing . UsageRecordSummary . get_previous_by_djstripe_updated ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_updated > , is_next = False , ** kwargs ) Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) Connect Classes djstripe.models.account.Account Stripe documentation: https://stripe.com/docs/api/accounts Attributes djstripe . models . account . Account . branding_icon property readonly djstripe . models . account . Account . branding_logo property readonly djstripe . models . account . Account . business_profile djstripe . models . account . Account . business_type djstripe . models . account . Account . business_url : str property readonly The business's publicly available website. djstripe . models . account . Account . charges_enabled djstripe . models . account . Account . company djstripe . models . account . Account . country djstripe . models . account . Account . default_api_key : str property readonly djstripe . models . account . Account . default_currency djstripe . models . account . Account . details_submitted djstripe . models . account . Account . djstripe_owner_account : Optional [ djstripe . fields . StripeForeignKey ] djstripe . models . account . Account . email djstripe . models . account . Account . individual djstripe . models . account . Account . payouts_enabled djstripe . models . account . Account . product_description djstripe . models . account . Account . requirements djstripe . models . account . Account . settings djstripe . models . account . Account . tos_acceptance djstripe . models . account . Account . type djstripe.models.account.Account.DoesNotExist djstripe.models.account.Account.MultipleObjectsReturned djstripe.models.account.Account.stripe_class djstripe . models . account . Account . stripe_class . OBJECT_NAME djstripe . models . account . Account . stripe_class . capabilitys_request ( method , url , api_key = None , idempotency_key = None , stripe_version = None , stripe_account = None , ** params ) classmethod Source code in djstripe/models/account.py def nested_resource_request ( cls , method , url , api_key = None , idempotency_key = None , stripe_version = None , stripe_account = None , ** params ): requestor = api_requestor . APIRequestor ( api_key , api_version = stripe_version , account = stripe_account ) headers = util . populate_headers ( idempotency_key ) response , api_key = requestor . request ( method , url , params , headers ) return util . convert_to_stripe_object ( response , api_key , stripe_version , stripe_account ) djstripe . models . account . Account . stripe_class . capabilitys_url ( id , nested_id = None ) classmethod Source code in djstripe/models/account.py def nested_resource_url ( cls , id , nested_id = None ): url = \" %s / %s / %s \" % ( cls . class_url (), quote_plus ( id ), quote_plus ( path ), ) if nested_id is not None : url += \"/ %s \" % quote_plus ( nested_id ) return url djstripe . models . account . Account . stripe_class . create_external_account ( id , ** params ) classmethod Source code in djstripe/models/account.py def create_nested_resource ( cls , id , ** params ): url = getattr ( cls , resource_url_method )( id ) return getattr ( cls , resource_request_method )( \"post\" , url , ** params ) djstripe . models . account . Account . stripe_class . create_login_link ( id , ** params ) classmethod Source code in djstripe/models/account.py def create_nested_resource ( cls , id , ** params ): url = getattr ( cls , resource_url_method )( id ) return getattr ( cls , resource_request_method )( \"post\" , url , ** params ) djstripe . models . account . Account . stripe_class . create_person ( id , ** params ) classmethod Source code in djstripe/models/account.py def create_nested_resource ( cls , id , ** params ): url = getattr ( cls , resource_url_method )( id ) return getattr ( cls , resource_request_method )( \"post\" , url , ** params ) djstripe . models . account . Account . stripe_class . deauthorize ( self , ** params ) Source code in djstripe/models/account.py def deauthorize ( self , ** params ): params [ \"stripe_user_id\" ] = self . id return oauth . OAuth . deauthorize ( ** params ) djstripe . models . account . Account . stripe_class . delete_external_account ( id , nested_id , ** params ) classmethod Source code in djstripe/models/account.py def delete_nested_resource ( cls , id , nested_id , ** params ): url = getattr ( cls , resource_url_method )( id , nested_id ) return getattr ( cls , resource_request_method )( \"delete\" , url , ** params ) djstripe . models . account . Account . stripe_class . delete_person ( id , nested_id , ** params ) classmethod Source code in djstripe/models/account.py def delete_nested_resource ( cls , id , nested_id , ** params ): url = getattr ( cls , resource_url_method )( id , nested_id ) return getattr ( cls , resource_request_method )( \"delete\" , url , ** params ) djstripe . models . account . Account . stripe_class . external_accounts_request ( method , url , api_key = None , idempotency_key = None , stripe_version = None , stripe_account = None , ** params ) classmethod Source code in djstripe/models/account.py def nested_resource_request ( cls , method , url , api_key = None , idempotency_key = None , stripe_version = None , stripe_account = None , ** params ): requestor = api_requestor . APIRequestor ( api_key , api_version = stripe_version , account = stripe_account ) headers = util . populate_headers ( idempotency_key ) response , api_key = requestor . request ( method , url , params , headers ) return util . convert_to_stripe_object ( response , api_key , stripe_version , stripe_account ) djstripe . models . account . Account . stripe_class . external_accounts_url ( id , nested_id = None ) classmethod Source code in djstripe/models/account.py def nested_resource_url ( cls , id , nested_id = None ): url = \" %s / %s / %s \" % ( cls . class_url (), quote_plus ( id ), quote_plus ( path ), ) if nested_id is not None : url += \"/ %s \" % quote_plus ( nested_id ) return url djstripe . models . account . Account . stripe_class . instance_url ( self ) Source code in djstripe/models/account.py def instance_url ( self ): return self . _build_instance_url ( self . get ( \"id\" )) djstripe . models . account . Account . stripe_class . list_capabilities ( id , ** params ) classmethod Source code in djstripe/models/account.py def list_nested_resources ( cls , id , ** params ): url = getattr ( cls , resource_url_method )( id ) return getattr ( cls , resource_request_method )( \"get\" , url , ** params ) djstripe . models . account . Account . stripe_class . list_external_accounts ( id , ** params ) classmethod Source code in djstripe/models/account.py def list_nested_resources ( cls , id , ** params ): url = getattr ( cls , resource_url_method )( id ) return getattr ( cls , resource_request_method )( \"get\" , url , ** params ) djstripe . models . account . Account . stripe_class . list_persons ( id , ** params ) classmethod Source code in djstripe/models/account.py def list_nested_resources ( cls , id , ** params ): url = getattr ( cls , resource_url_method )( id ) return getattr ( cls , resource_request_method )( \"get\" , url , ** params ) djstripe . models . account . Account . stripe_class . login_links_request ( method , url , api_key = None , idempotency_key = None , stripe_version = None , stripe_account = None , ** params ) classmethod Source code in djstripe/models/account.py def nested_resource_request ( cls , method , url , api_key = None , idempotency_key = None , stripe_version = None , stripe_account = None , ** params ): requestor = api_requestor . APIRequestor ( api_key , api_version = stripe_version , account = stripe_account ) headers = util . populate_headers ( idempotency_key ) response , api_key = requestor . request ( method , url , params , headers ) return util . convert_to_stripe_object ( response , api_key , stripe_version , stripe_account ) djstripe . models . account . Account . stripe_class . login_links_url ( id , nested_id = None ) classmethod Source code in djstripe/models/account.py def nested_resource_url ( cls , id , nested_id = None ): url = \" %s / %s / %s \" % ( cls . class_url (), quote_plus ( id ), quote_plus ( path ), ) if nested_id is not None : url += \"/ %s \" % quote_plus ( nested_id ) return url djstripe . models . account . Account . stripe_class . modify ( id = None , ** params ) classmethod Source code in djstripe/models/account.py @classmethod def modify ( cls , id = None , ** params ): url = cls . _build_instance_url ( id ) return cls . _static_request ( \"post\" , url , ** params ) djstripe . models . account . Account . stripe_class . modify_capability ( id , nested_id , ** params ) classmethod Source code in djstripe/models/account.py def modify_nested_resource ( cls , id , nested_id , ** params ): url = getattr ( cls , resource_url_method )( id , nested_id ) return getattr ( cls , resource_request_method )( \"post\" , url , ** params ) djstripe . models . account . Account . stripe_class . modify_external_account ( id , nested_id , ** params ) classmethod Source code in djstripe/models/account.py def modify_nested_resource ( cls , id , nested_id , ** params ): url = getattr ( cls , resource_url_method )( id , nested_id ) return getattr ( cls , resource_request_method )( \"post\" , url , ** params ) djstripe . models . account . Account . stripe_class . modify_person ( id , nested_id , ** params ) classmethod Source code in djstripe/models/account.py def modify_nested_resource ( cls , id , nested_id , ** params ): url = getattr ( cls , resource_url_method )( id , nested_id ) return getattr ( cls , resource_request_method )( \"post\" , url , ** params ) djstripe . models . account . Account . stripe_class . persons ( self , ** params ) Source code in djstripe/models/account.py def persons ( self , ** params ): return self . request ( \"get\" , self . instance_url () + \"/persons\" , params ) djstripe . models . account . Account . stripe_class . persons_request ( method , url , api_key = None , idempotency_key = None , stripe_version = None , stripe_account = None , ** params ) classmethod Source code in djstripe/models/account.py def nested_resource_request ( cls , method , url , api_key = None , idempotency_key = None , stripe_version = None , stripe_account = None , ** params ): requestor = api_requestor . APIRequestor ( api_key , api_version = stripe_version , account = stripe_account ) headers = util . populate_headers ( idempotency_key ) response , api_key = requestor . request ( method , url , params , headers ) return util . convert_to_stripe_object ( response , api_key , stripe_version , stripe_account ) djstripe . models . account . Account . stripe_class . persons_url ( id , nested_id = None ) classmethod Source code in djstripe/models/account.py def nested_resource_url ( cls , id , nested_id = None ): url = \" %s / %s / %s \" % ( cls . class_url (), quote_plus ( id ), quote_plus ( path ), ) if nested_id is not None : url += \"/ %s \" % quote_plus ( nested_id ) return url djstripe . models . account . Account . stripe_class . reject ( self , idempotency_key = None , ** params ) Source code in djstripe/models/account.py def reject ( self , idempotency_key = None , ** params ): url = self . instance_url () + \"/reject\" headers = util . populate_headers ( idempotency_key ) self . refresh_from ( self . request ( \"post\" , url , params , headers )) return self djstripe . models . account . Account . stripe_class . retrieve ( id = None , api_key = None , ** params ) classmethod Source code in djstripe/models/account.py @classmethod def retrieve ( cls , id = None , api_key = None , ** params ): instance = cls ( id , api_key , ** params ) instance . refresh () return instance djstripe . models . account . Account . stripe_class . retrieve_capability ( id , nested_id , ** params ) classmethod Source code in djstripe/models/account.py def retrieve_nested_resource ( cls , id , nested_id , ** params ): url = getattr ( cls , resource_url_method )( id , nested_id ) return getattr ( cls , resource_request_method )( \"get\" , url , ** params ) djstripe . models . account . Account . stripe_class . retrieve_external_account ( id , nested_id , ** params ) classmethod Source code in djstripe/models/account.py def retrieve_nested_resource ( cls , id , nested_id , ** params ): url = getattr ( cls , resource_url_method )( id , nested_id ) return getattr ( cls , resource_request_method )( \"get\" , url , ** params ) djstripe . models . account . Account . stripe_class . retrieve_person ( id , nested_id , ** params ) classmethod Source code in djstripe/models/account.py def retrieve_nested_resource ( cls , id , nested_id , ** params ): url = getattr ( cls , resource_url_method )( id , nested_id ) return getattr ( cls , resource_request_method )( \"get\" , url , ** params ) djstripe . models . account . Account . stripe_class . serialize ( self , previous ) Source code in djstripe/models/account.py def serialize ( self , previous ): params = super ( Account , self ) . serialize ( previous ) previous = previous or self . _previous or {} for k , v in six . iteritems ( self ): if ( k == \"individual\" and isinstance ( v , stripe . api_resources . Person ) and k not in params ): params [ k ] = v . serialize ( previous . get ( k , None )) return params djstripe . models . account . Account . __str__ ( self ) special Source code in djstripe/models/account.py def __str__ ( self ): settings = self . settings or {} business_profile = self . business_profile or {} return ( settings . get ( \"dashboard\" , {}) . get ( \"display_name\" ) or business_profile . get ( \"name\" ) or super () . __str__ () ) djstripe . models . account . Account . get_business_type_display ( self , * , field =< djstripe . fields . StripeEnumField : business_type > ) Source code in djstripe/models/account.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . account . Account . get_default_account () classmethod Source code in djstripe/models/account.py @classmethod def get_default_account ( cls ): # As of API version 2020-03-02, there is no permission that can allow # restricted keys to call GET /v1/account if djstripe_settings . STRIPE_SECRET_KEY . startswith ( \"rk_\" ): return None account_data = cls . stripe_class . retrieve ( api_key = djstripe_settings . STRIPE_SECRET_KEY ) return cls . _get_or_create_from_stripe_object ( account_data )[ 0 ] djstripe . models . account . Account . get_default_api_key ( self ) Source code in djstripe/models/account.py def get_default_api_key ( self ) -> str : api_key = APIKey . objects . filter ( djstripe_owner_account = self , type = APIKeyType . secret ) . first () if api_key : return api_key . secret return djstripe_settings . get_default_api_key ( self . livemode ) djstripe . models . account . Account . get_next_by_djstripe_created ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_created > , is_next = True , ** kwargs ) Source code in djstripe/models/account.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . account . Account . get_next_by_djstripe_updated ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_updated > , is_next = True , ** kwargs ) Source code in djstripe/models/account.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . account . Account . get_or_retrieve_for_api_key ( api_key ) classmethod Source code in djstripe/models/account.py @classmethod def get_or_retrieve_for_api_key ( cls , api_key : str ): with transaction . atomic (): apikey_instance , _ = APIKey . objects . get_or_create_by_api_key ( api_key ) if not apikey_instance . djstripe_owner_account : apikey_instance . refresh_account () return apikey_instance . djstripe_owner_account djstripe . models . account . Account . get_previous_by_djstripe_created ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_created > , is_next = False , ** kwargs ) Source code in djstripe/models/account.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . account . Account . get_previous_by_djstripe_updated ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_updated > , is_next = False , ** kwargs ) Source code in djstripe/models/account.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . account . Account . get_type_display ( self , * , field =< djstripe . fields . StripeEnumField : type > ) Source code in djstripe/models/account.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) Classes djstripe.models.connect.ApplicationFee When you collect a transaction fee on top of a charge made for your user (using Connect), an ApplicationFee is created in your account. Please note the model field charge exists on the Stripe Connected Account while the application_fee modelfield on Charge model exists on the Platform Account! Stripe documentation: https://stripe.com/docs/api#application_fees djstripe . models . connect . ApplicationFee . account djstripe . models . connect . ApplicationFee . amount djstripe . models . connect . ApplicationFee . amount_refunded djstripe . models . connect . ApplicationFee . balance_transaction djstripe . models . connect . ApplicationFee . charge djstripe . models . connect . ApplicationFee . currency djstripe . models . connect . ApplicationFee . djstripe_owner_account : Optional [ djstripe . fields . StripeForeignKey ] djstripe . models . connect . ApplicationFee . refunded djstripe.models.connect.ApplicationFee.DoesNotExist djstripe.models.connect.ApplicationFee.MultipleObjectsReturned djstripe.models.connect.ApplicationFee.stripe_class djstripe . models . connect . ApplicationFee . stripe_class . OBJECT_NAME djstripe . models . connect . ApplicationFee . stripe_class . create_refund ( id , ** params ) classmethod Source code in djstripe/models/connect.py def create_nested_resource ( cls , id , ** params ): url = getattr ( cls , resource_url_method )( id ) return getattr ( cls , resource_request_method )( \"post\" , url , ** params ) djstripe . models . connect . ApplicationFee . stripe_class . list_refunds ( id , ** params ) classmethod Source code in djstripe/models/connect.py def list_nested_resources ( cls , id , ** params ): url = getattr ( cls , resource_url_method )( id ) return getattr ( cls , resource_request_method )( \"get\" , url , ** params ) djstripe . models . connect . ApplicationFee . stripe_class . modify_refund ( id , nested_id , ** params ) classmethod Source code in djstripe/models/connect.py def modify_nested_resource ( cls , id , nested_id , ** params ): url = getattr ( cls , resource_url_method )( id , nested_id ) return getattr ( cls , resource_request_method )( \"post\" , url , ** params ) djstripe . models . connect . ApplicationFee . stripe_class . refund ( self , idempotency_key = None , ** params ) Source code in djstripe/models/connect.py def refund ( self , idempotency_key = None , ** params ): headers = util . populate_headers ( idempotency_key ) url = self . instance_url () + \"/refund\" self . refresh_from ( self . request ( \"post\" , url , params , headers )) return self djstripe . models . connect . ApplicationFee . stripe_class . refunds_request ( method , url , api_key = None , idempotency_key = None , stripe_version = None , stripe_account = None , ** params ) classmethod Source code in djstripe/models/connect.py def nested_resource_request ( cls , method , url , api_key = None , idempotency_key = None , stripe_version = None , stripe_account = None , ** params ): requestor = api_requestor . APIRequestor ( api_key , api_version = stripe_version , account = stripe_account ) headers = util . populate_headers ( idempotency_key ) response , api_key = requestor . request ( method , url , params , headers ) return util . convert_to_stripe_object ( response , api_key , stripe_version , stripe_account ) djstripe . models . connect . ApplicationFee . stripe_class . refunds_url ( id , nested_id = None ) classmethod Source code in djstripe/models/connect.py def nested_resource_url ( cls , id , nested_id = None ): url = \" %s / %s / %s \" % ( cls . class_url (), quote_plus ( id ), quote_plus ( path ), ) if nested_id is not None : url += \"/ %s \" % quote_plus ( nested_id ) return url djstripe . models . connect . ApplicationFee . stripe_class . retrieve_refund ( id , nested_id , ** params ) classmethod Source code in djstripe/models/connect.py def retrieve_nested_resource ( cls , id , nested_id , ** params ): url = getattr ( cls , resource_url_method )( id , nested_id ) return getattr ( cls , resource_request_method )( \"get\" , url , ** params ) djstripe . models . connect . ApplicationFee . get_next_by_djstripe_created ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_created > , is_next = True , ** kwargs ) Source code in djstripe/models/connect.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . connect . ApplicationFee . get_next_by_djstripe_updated ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_updated > , is_next = True , ** kwargs ) Source code in djstripe/models/connect.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . connect . ApplicationFee . get_previous_by_djstripe_created ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_created > , is_next = False , ** kwargs ) Source code in djstripe/models/connect.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . connect . ApplicationFee . get_previous_by_djstripe_updated ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_updated > , is_next = False , ** kwargs ) Source code in djstripe/models/connect.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe.models.connect.ApplicationFeeRefund ApplicationFeeRefund objects allow you to refund an ApplicationFee that has previously been created but not yet refunded. Funds will be refunded to the Stripe account from which the fee was originally collected. Stripe documentation: https://stripe.com/docs/api#fee_refunds djstripe . models . connect . ApplicationFeeRefund . amount djstripe . models . connect . ApplicationFeeRefund . balance_transaction djstripe . models . connect . ApplicationFeeRefund . currency djstripe . models . connect . ApplicationFeeRefund . description djstripe . models . connect . ApplicationFeeRefund . djstripe_owner_account : Optional [ djstripe . fields . StripeForeignKey ] djstripe . models . connect . ApplicationFeeRefund . fee djstripe.models.connect.ApplicationFeeRefund.DoesNotExist djstripe.models.connect.ApplicationFeeRefund.MultipleObjectsReturned djstripe . models . connect . ApplicationFeeRefund . get_next_by_djstripe_created ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_created > , is_next = True , ** kwargs ) Source code in djstripe/models/connect.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . connect . ApplicationFeeRefund . get_next_by_djstripe_updated ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_updated > , is_next = True , ** kwargs ) Source code in djstripe/models/connect.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . connect . ApplicationFeeRefund . get_previous_by_djstripe_created ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_created > , is_next = False , ** kwargs ) Source code in djstripe/models/connect.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . connect . ApplicationFeeRefund . get_previous_by_djstripe_updated ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_updated > , is_next = False , ** kwargs ) Source code in djstripe/models/connect.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe.models.connect.CountrySpec Stripe documentation: https://stripe.com/docs/api#country_specs djstripe . models . connect . CountrySpec . default_currency djstripe . models . connect . CountrySpec . id djstripe . models . connect . CountrySpec . supported_bank_account_currencies djstripe . models . connect . CountrySpec . supported_payment_currencies djstripe . models . connect . CountrySpec . supported_payment_methods djstripe . models . connect . CountrySpec . supported_transfer_countries djstripe . models . connect . CountrySpec . verification_fields djstripe.models.connect.CountrySpec.DoesNotExist djstripe.models.connect.CountrySpec.MultipleObjectsReturned djstripe.models.connect.CountrySpec.stripe_class Methods djstripe . models . connect . CountrySpec . api_retrieve ( self , api_key = None , stripe_account = None ) Source code in djstripe/models/connect.py def api_retrieve ( self , api_key : str = None , stripe_account = None ): if api_key is None : api_key = djstripe_settings . get_default_api_key ( livemode = None ) return self . stripe_class . retrieve ( id = self . id , api_key = api_key , stripe_account = stripe_account , ) djstripe . models . connect . CountrySpec . get_next_by_djstripe_created ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_created > , is_next = True , ** kwargs ) Source code in djstripe/models/connect.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . connect . CountrySpec . get_next_by_djstripe_updated ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_updated > , is_next = True , ** kwargs ) Source code in djstripe/models/connect.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . connect . CountrySpec . get_previous_by_djstripe_created ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_created > , is_next = False , ** kwargs ) Source code in djstripe/models/connect.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . connect . CountrySpec . get_previous_by_djstripe_updated ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_updated > , is_next = False , ** kwargs ) Source code in djstripe/models/connect.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . connect . CountrySpec . sync_from_stripe_data ( data ) classmethod Syncs this object from the stripe data provided. Foreign keys will also be retrieved and synced recursively. :param data: stripe object :type data: dict :rtype: cls Source code in djstripe/models/connect.py @classmethod def sync_from_stripe_data ( cls , data ) -> \"CountrySpec\" : \"\"\" Syncs this object from the stripe data provided. Foreign keys will also be retrieved and synced recursively. :param data: stripe object :type data: dict :rtype: cls \"\"\" data_id = data [ \"id\" ] supported_fields = ( \"default_currency\" , \"supported_bank_account_currencies\" , \"supported_payment_currencies\" , \"supported_payment_methods\" , \"supported_transfer_countries\" , \"verification_fields\" , ) instance , created = cls . objects . get_or_create ( id = data_id , defaults = { k : data [ k ] for k in supported_fields }, ) return instance djstripe.models.connect.Transfer When Stripe sends you money or you initiate a transfer to a bank account, debit card, or connected Stripe account, a transfer object will be created. Stripe documentation: https://stripe.com/docs/api?lang=python#transfers djstripe . models . connect . Transfer . amount djstripe . models . connect . Transfer . amount_reversed djstripe . models . connect . Transfer . balance_transaction djstripe . models . connect . Transfer . currency djstripe . models . connect . Transfer . destination djstripe . models . connect . Transfer . destination_payment djstripe . models . connect . Transfer . djstripe_owner_account : Optional [ djstripe . fields . StripeForeignKey ] djstripe . models . connect . Transfer . expand_fields : List [ str ] djstripe . models . connect . Transfer . fee property readonly djstripe . models . connect . Transfer . objects djstripe . models . connect . Transfer . reversed djstripe . models . connect . Transfer . source_transaction djstripe . models . connect . Transfer . source_type djstripe . models . connect . Transfer . stripe_dashboard_item_name djstripe . models . connect . Transfer . transfer_group djstripe.models.connect.Transfer.DoesNotExist djstripe.models.connect.Transfer.MultipleObjectsReturned djstripe.models.connect.Transfer.stripe_class djstripe . models . connect . Transfer . stripe_class . OBJECT_NAME djstripe . models . connect . Transfer . stripe_class . cancel ( self , idempotency_key = None , ** params ) Source code in djstripe/models/connect.py def cancel ( self , idempotency_key = None , ** params ): url = self . instance_url () + \"/cancel\" headers = util . populate_headers ( idempotency_key ) self . refresh_from ( self . request ( \"post\" , url , params , headers )) return self djstripe . models . connect . Transfer . stripe_class . create_reversal ( id , ** params ) classmethod Source code in djstripe/models/connect.py def create_nested_resource ( cls , id , ** params ): url = getattr ( cls , resource_url_method )( id ) return getattr ( cls , resource_request_method )( \"post\" , url , ** params ) djstripe . models . connect . Transfer . stripe_class . list_reversals ( id , ** params ) classmethod Source code in djstripe/models/connect.py def list_nested_resources ( cls , id , ** params ): url = getattr ( cls , resource_url_method )( id ) return getattr ( cls , resource_request_method )( \"get\" , url , ** params ) djstripe . models . connect . Transfer . stripe_class . modify_reversal ( id , nested_id , ** params ) classmethod Source code in djstripe/models/connect.py def modify_nested_resource ( cls , id , nested_id , ** params ): url = getattr ( cls , resource_url_method )( id , nested_id ) return getattr ( cls , resource_request_method )( \"post\" , url , ** params ) djstripe . models . connect . Transfer . stripe_class . retrieve_reversal ( id , nested_id , ** params ) classmethod Source code in djstripe/models/connect.py def retrieve_nested_resource ( cls , id , nested_id , ** params ): url = getattr ( cls , resource_url_method )( id , nested_id ) return getattr ( cls , resource_request_method )( \"get\" , url , ** params ) djstripe . models . connect . Transfer . stripe_class . reversals_request ( method , url , api_key = None , idempotency_key = None , stripe_version = None , stripe_account = None , ** params ) classmethod Source code in djstripe/models/connect.py def nested_resource_request ( cls , method , url , api_key = None , idempotency_key = None , stripe_version = None , stripe_account = None , ** params ): requestor = api_requestor . APIRequestor ( api_key , api_version = stripe_version , account = stripe_account ) headers = util . populate_headers ( idempotency_key ) response , api_key = requestor . request ( method , url , params , headers ) return util . convert_to_stripe_object ( response , api_key , stripe_version , stripe_account ) djstripe . models . connect . Transfer . stripe_class . reversals_url ( id , nested_id = None ) classmethod Source code in djstripe/models/connect.py def nested_resource_url ( cls , id , nested_id = None ): url = \" %s / %s / %s \" % ( cls . class_url (), quote_plus ( id ), quote_plus ( path ), ) if nested_id is not None : url += \"/ %s \" % quote_plus ( nested_id ) return url djstripe . models . connect . Transfer . __str__ ( self ) special Source code in djstripe/models/connect.py def __str__ ( self ): if self . reversed : # Complete Reversal return f \" { self . human_readable_amount } Reversed\" elif self . amount_reversed : # Partial Reversal return f \" { self . human_readable_amount } Partially Reversed\" # No Reversal return f \" { self . human_readable_amount } \" djstripe . models . connect . Transfer . get_next_by_djstripe_created ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_created > , is_next = True , ** kwargs ) Source code in djstripe/models/connect.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . connect . Transfer . get_next_by_djstripe_updated ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_updated > , is_next = True , ** kwargs ) Source code in djstripe/models/connect.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . connect . Transfer . get_previous_by_djstripe_created ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_created > , is_next = False , ** kwargs ) Source code in djstripe/models/connect.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . connect . Transfer . get_previous_by_djstripe_updated ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_updated > , is_next = False , ** kwargs ) Source code in djstripe/models/connect.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . connect . Transfer . get_source_type_display ( self , * , field =< djstripe . fields . StripeEnumField : source_type > ) Source code in djstripe/models/connect.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe.models.connect.TransferReversal Stripe documentation: https://stripe.com/docs/api#transfer_reversals djstripe . models . connect . TransferReversal . amount djstripe . models . connect . TransferReversal . balance_transaction djstripe . models . connect . TransferReversal . currency djstripe . models . connect . TransferReversal . djstripe_owner_account : Optional [ djstripe . fields . StripeForeignKey ] djstripe . models . connect . TransferReversal . expand_fields : List [ str ] djstripe . models . connect . TransferReversal . transfer djstripe.models.connect.TransferReversal.DoesNotExist djstripe.models.connect.TransferReversal.MultipleObjectsReturned djstripe.models.connect.TransferReversal.stripe_class djstripe . models . connect . TransferReversal . stripe_class . OBJECT_NAME djstripe . models . connect . TransferReversal . stripe_class . cancel ( self , idempotency_key = None , ** params ) Source code in djstripe/models/connect.py def cancel ( self , idempotency_key = None , ** params ): url = self . instance_url () + \"/cancel\" headers = util . populate_headers ( idempotency_key ) self . refresh_from ( self . request ( \"post\" , url , params , headers )) return self djstripe . models . connect . TransferReversal . stripe_class . create_reversal ( id , ** params ) classmethod Source code in djstripe/models/connect.py def create_nested_resource ( cls , id , ** params ): url = getattr ( cls , resource_url_method )( id ) return getattr ( cls , resource_request_method )( \"post\" , url , ** params ) djstripe . models . connect . TransferReversal . stripe_class . list_reversals ( id , ** params ) classmethod Source code in djstripe/models/connect.py def list_nested_resources ( cls , id , ** params ): url = getattr ( cls , resource_url_method )( id ) return getattr ( cls , resource_request_method )( \"get\" , url , ** params ) djstripe . models . connect . TransferReversal . stripe_class . modify_reversal ( id , nested_id , ** params ) classmethod Source code in djstripe/models/connect.py def modify_nested_resource ( cls , id , nested_id , ** params ): url = getattr ( cls , resource_url_method )( id , nested_id ) return getattr ( cls , resource_request_method )( \"post\" , url , ** params ) djstripe . models . connect . TransferReversal . stripe_class . retrieve_reversal ( id , nested_id , ** params ) classmethod Source code in djstripe/models/connect.py def retrieve_nested_resource ( cls , id , nested_id , ** params ): url = getattr ( cls , resource_url_method )( id , nested_id ) return getattr ( cls , resource_request_method )( \"get\" , url , ** params ) djstripe . models . connect . TransferReversal . stripe_class . reversals_request ( method , url , api_key = None , idempotency_key = None , stripe_version = None , stripe_account = None , ** params ) classmethod Source code in djstripe/models/connect.py def nested_resource_request ( cls , method , url , api_key = None , idempotency_key = None , stripe_version = None , stripe_account = None , ** params ): requestor = api_requestor . APIRequestor ( api_key , api_version = stripe_version , account = stripe_account ) headers = util . populate_headers ( idempotency_key ) response , api_key = requestor . request ( method , url , params , headers ) return util . convert_to_stripe_object ( response , api_key , stripe_version , stripe_account ) djstripe . models . connect . TransferReversal . stripe_class . reversals_url ( id , nested_id = None ) classmethod Source code in djstripe/models/connect.py def nested_resource_url ( cls , id , nested_id = None ): url = \" %s / %s / %s \" % ( cls . class_url (), quote_plus ( id ), quote_plus ( path ), ) if nested_id is not None : url += \"/ %s \" % quote_plus ( nested_id ) return url Methods djstripe . models . connect . TransferReversal . __str__ ( self ) special Source code in djstripe/models/connect.py def __str__ ( self ): return str ( self . transfer ) djstripe . models . connect . TransferReversal . api_list ( api_key = 'sk_test_XXXXXXXXXXXXXXXXXXXXXXXXX' , ** kwargs ) classmethod Call the stripe API's list operation for this model. :param api_key: The api key to use for this request. Defaults to djstripe_settings.STRIPE_SECRET_KEY. :type api_key: string See Stripe documentation for accepted kwargs for each object. :returns: an iterator over all items in the query Source code in djstripe/models/connect.py @classmethod def api_list ( cls , api_key = djstripe_settings . STRIPE_SECRET_KEY , ** kwargs ): \"\"\" Call the stripe API's list operation for this model. :param api_key: The api key to use for this request. \\ Defaults to djstripe_settings.STRIPE_SECRET_KEY. :type api_key: string See Stripe documentation for accepted kwargs for each object. :returns: an iterator over all items in the query \"\"\" return stripe . Transfer . list_reversals ( api_key = api_key , ** kwargs ) . auto_paging_iter () djstripe . models . connect . TransferReversal . api_retrieve ( self , api_key = None , stripe_account = None ) Call the stripe API's retrieve operation for this model. :param api_key: The api key to use for this request. Defaults to djstripe_settings.STRIPE_SECRET_KEY. :type api_key: string :param stripe_account: The optional connected account for which this request is being made. :type stripe_account: string Source code in djstripe/models/connect.py def api_retrieve ( self , api_key = None , stripe_account = None ): \"\"\" Call the stripe API's retrieve operation for this model. :param api_key: The api key to use for this request. \\ Defaults to djstripe_settings.STRIPE_SECRET_KEY. :type api_key: string :param stripe_account: The optional connected account \\ for which this request is being made. :type stripe_account: string \"\"\" nested_id = self . id id = self . transfer . id # Prefer passed in stripe_account if set. if not stripe_account : stripe_account = self . _get_stripe_account_id ( api_key ) return stripe . Transfer . retrieve_reversal ( id = id , nested_id = nested_id , api_key = api_key or self . default_api_key , expand = self . expand_fields , stripe_account = stripe_account , ) djstripe . models . connect . TransferReversal . get_next_by_djstripe_created ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_created > , is_next = True , ** kwargs ) Source code in djstripe/models/connect.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . connect . TransferReversal . get_next_by_djstripe_updated ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_updated > , is_next = True , ** kwargs ) Source code in djstripe/models/connect.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . connect . TransferReversal . get_previous_by_djstripe_created ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_created > , is_next = False , ** kwargs ) Source code in djstripe/models/connect.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . connect . TransferReversal . get_previous_by_djstripe_updated ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_updated > , is_next = False , ** kwargs ) Source code in djstripe/models/connect.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . connect . TransferReversal . is_valid_object ( data ) classmethod Returns whether the data is a valid object for the class Source code in djstripe/models/connect.py @classmethod def is_valid_object ( cls , data ): \"\"\" Returns whether the data is a valid object for the class \"\"\" return \"object\" in data and data [ \"object\" ] == \"transfer_reversal\" Fraud Orders Sigma Classes djstripe.models.sigma.ScheduledQueryRun Stripe documentation: https://stripe.com/docs/api#scheduled_queries djstripe . models . sigma . ScheduledQueryRun . data_load_time djstripe . models . sigma . ScheduledQueryRun . djstripe_owner_account : Optional [ djstripe . fields . StripeForeignKey ] djstripe . models . sigma . ScheduledQueryRun . error djstripe . models . sigma . ScheduledQueryRun . file djstripe . models . sigma . ScheduledQueryRun . result_available_until djstripe . models . sigma . ScheduledQueryRun . sql djstripe . models . sigma . ScheduledQueryRun . status djstripe . models . sigma . ScheduledQueryRun . title djstripe.models.sigma.ScheduledQueryRun.DoesNotExist djstripe.models.sigma.ScheduledQueryRun.MultipleObjectsReturned djstripe.models.sigma.ScheduledQueryRun.stripe_class djstripe . models . sigma . ScheduledQueryRun . stripe_class . OBJECT_NAME djstripe . models . sigma . ScheduledQueryRun . stripe_class . class_url () classmethod Source code in djstripe/models/sigma.py @classmethod def class_url ( cls ): return \"/v1/sigma/scheduled_query_runs\" djstripe . models . sigma . ScheduledQueryRun . __str__ ( self ) special Source code in djstripe/models/sigma.py def __str__ ( self ): return f \" { self . title or self . id } ( { self . status } )\" djstripe . models . sigma . ScheduledQueryRun . get_next_by_data_load_time ( self , * , field =< djstripe . fields . StripeDateTimeField : data_load_time > , is_next = True , ** kwargs ) Source code in djstripe/models/sigma.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . sigma . ScheduledQueryRun . get_next_by_djstripe_created ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_created > , is_next = True , ** kwargs ) Source code in djstripe/models/sigma.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . sigma . ScheduledQueryRun . get_next_by_djstripe_updated ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_updated > , is_next = True , ** kwargs ) Source code in djstripe/models/sigma.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . sigma . ScheduledQueryRun . get_next_by_result_available_until ( self , * , field =< djstripe . fields . StripeDateTimeField : result_available_until > , is_next = True , ** kwargs ) Source code in djstripe/models/sigma.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . sigma . ScheduledQueryRun . get_previous_by_data_load_time ( self , * , field =< djstripe . fields . StripeDateTimeField : data_load_time > , is_next = False , ** kwargs ) Source code in djstripe/models/sigma.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . sigma . ScheduledQueryRun . get_previous_by_djstripe_created ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_created > , is_next = False , ** kwargs ) Source code in djstripe/models/sigma.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . sigma . ScheduledQueryRun . get_previous_by_djstripe_updated ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_updated > , is_next = False , ** kwargs ) Source code in djstripe/models/sigma.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . sigma . ScheduledQueryRun . get_previous_by_result_available_until ( self , * , field =< djstripe . fields . StripeDateTimeField : result_available_until > , is_next = False , ** kwargs ) Source code in djstripe/models/sigma.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . sigma . ScheduledQueryRun . get_status_display ( self , * , field =< djstripe . fields . StripeEnumField : status > ) Source code in djstripe/models/sigma.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) Webhooks Module for dj-stripe Webhook models Classes djstripe.models.webhooks.WebhookEndpoint WebhookEndpoint(djstripe_created, djstripe_updated, djstripe_id, id, djstripe_owner_account, livemode, created, metadata, description, api_version, enabled_events, secret, status, url, application, djstripe_uuid) djstripe . models . webhooks . WebhookEndpoint . api_version djstripe . models . webhooks . WebhookEndpoint . application djstripe . models . webhooks . WebhookEndpoint . djstripe_owner_account : Optional [ djstripe . fields . StripeForeignKey ] djstripe . models . webhooks . WebhookEndpoint . djstripe_uuid djstripe . models . webhooks . WebhookEndpoint . enabled_events djstripe . models . webhooks . WebhookEndpoint . secret djstripe . models . webhooks . WebhookEndpoint . status djstripe . models . webhooks . WebhookEndpoint . url djstripe.models.webhooks.WebhookEndpoint.DoesNotExist djstripe.models.webhooks.WebhookEndpoint.MultipleObjectsReturned djstripe.models.webhooks.WebhookEndpoint.stripe_class djstripe . models . webhooks . WebhookEndpoint . __str__ ( self ) special Source code in djstripe/models/webhooks.py def __str__ ( self ): return self . url or str ( self . djstripe_uuid ) djstripe . models . webhooks . WebhookEndpoint . get_next_by_djstripe_created ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_created > , is_next = True , ** kwargs ) Source code in djstripe/models/webhooks.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . webhooks . WebhookEndpoint . get_next_by_djstripe_updated ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_updated > , is_next = True , ** kwargs ) Source code in djstripe/models/webhooks.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . webhooks . WebhookEndpoint . get_previous_by_djstripe_created ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_created > , is_next = False , ** kwargs ) Source code in djstripe/models/webhooks.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . webhooks . WebhookEndpoint . get_previous_by_djstripe_updated ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_updated > , is_next = False , ** kwargs ) Source code in djstripe/models/webhooks.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . webhooks . WebhookEndpoint . get_status_display ( self , * , field =< djstripe . fields . StripeEnumField : status > ) Source code in djstripe/models/webhooks.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe.models.webhooks.WebhookEventTrigger An instance of a request that reached the server endpoint for Stripe webhooks. Webhook Events are initially UNTRUSTED , as it is possible for any web entity to post any data to our webhook url. Data posted may be valid Stripe information, garbage, or even malicious. The 'valid' flag in this model monitors this. djstripe . models . webhooks . WebhookEventTrigger . body djstripe . models . webhooks . WebhookEventTrigger . created djstripe . models . webhooks . WebhookEventTrigger . djstripe_version djstripe . models . webhooks . WebhookEventTrigger . event djstripe . models . webhooks . WebhookEventTrigger . exception djstripe . models . webhooks . WebhookEventTrigger . headers djstripe . models . webhooks . WebhookEventTrigger . id djstripe . models . webhooks . WebhookEventTrigger . is_test_event property readonly djstripe . models . webhooks . WebhookEventTrigger . processed djstripe . models . webhooks . WebhookEventTrigger . remote_ip djstripe . models . webhooks . WebhookEventTrigger . stripe_trigger_account djstripe . models . webhooks . WebhookEventTrigger . traceback djstripe . models . webhooks . WebhookEventTrigger . updated djstripe . models . webhooks . WebhookEventTrigger . valid djstripe.models.webhooks.WebhookEventTrigger.DoesNotExist djstripe.models.webhooks.WebhookEventTrigger.MultipleObjectsReturned Methods djstripe . models . webhooks . WebhookEventTrigger . __str__ ( self ) special Source code in djstripe/models/webhooks.py def __str__ ( self ): return f \"id= { self . id } , valid= { self . valid } , processed= { self . processed } \" djstripe . models . webhooks . WebhookEventTrigger . from_request ( request , stripe_account = None ) classmethod Create, validate and process a WebhookEventTrigger given a Django request object. The process is three-fold: 1. Create a WebhookEventTrigger object from a Django request. 2. Validate the WebhookEventTrigger as a Stripe event using the API. 3. If valid, process it into an Event object (and child resource). Source code in djstripe/models/webhooks.py @classmethod def from_request ( cls , request , stripe_account = None ): \"\"\" Create, validate and process a WebhookEventTrigger given a Django request object. The process is three-fold: 1. Create a WebhookEventTrigger object from a Django request. 2. Validate the WebhookEventTrigger as a Stripe event using the API. 3. If valid, process it into an Event object (and child resource). \"\"\" try : body = request . body . decode ( request . encoding or \"utf-8\" ) except Exception : body = \"(error decoding body)\" ip = get_remote_ip ( request ) try : data = json . loads ( body ) except ValueError : data = {} if stripe_account is None : stripe_account = StripeModel . _find_owner_account ( data = data ) obj = cls . objects . create ( headers = dict ( request . headers ), body = body , remote_ip = ip , stripe_trigger_account = stripe_account , ) try : obj . valid = obj . validate () if obj . valid : if djstripe_settings . WEBHOOK_EVENT_CALLBACK : # If WEBHOOK_EVENT_CALLBACK, pass it for processing djstripe_settings . WEBHOOK_EVENT_CALLBACK ( obj ) else : # Process the item (do not save it, it'll get saved below) obj . process ( save = False ) except Exception as e : max_length = WebhookEventTrigger . _meta . get_field ( \"exception\" ) . max_length obj . exception = str ( e )[: max_length ] obj . traceback = format_exc () # Send the exception as the webhook_processing_error signal webhook_processing_error . send ( sender = WebhookEventTrigger , exception = e , data = getattr ( e , \"http_body\" , \"\" ), ) # re-raise the exception so Django sees it raise e finally : obj . save () return obj djstripe . models . webhooks . WebhookEventTrigger . get_next_by_created ( self , * , field =< django . db . models . fields . DateTimeField : created > , is_next = True , ** kwargs ) Source code in djstripe/models/webhooks.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . webhooks . WebhookEventTrigger . get_next_by_updated ( self , * , field =< django . db . models . fields . DateTimeField : updated > , is_next = True , ** kwargs ) Source code in djstripe/models/webhooks.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . webhooks . WebhookEventTrigger . get_previous_by_created ( self , * , field =< django . db . models . fields . DateTimeField : created > , is_next = False , ** kwargs ) Source code in djstripe/models/webhooks.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . webhooks . WebhookEventTrigger . get_previous_by_updated ( self , * , field =< django . db . models . fields . DateTimeField : updated > , is_next = False , ** kwargs ) Source code in djstripe/models/webhooks.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . webhooks . WebhookEventTrigger . process ( self , save = True ) Source code in djstripe/models/webhooks.py def process ( self , save = True ): # Reset traceback and exception in case of reprocessing self . exception = \"\" self . traceback = \"\" self . event = Event . process ( self . json_body ) self . processed = True if save : self . save () return self . event djstripe . models . webhooks . WebhookEventTrigger . validate ( self , api_key = None ) The original contents of the Event message must be confirmed by refetching it and comparing the fetched data with the original data. This function makes an API call to Stripe to redownload the Event data and returns whether or not it matches the WebhookEventTrigger data. Source code in djstripe/models/webhooks.py def validate ( self , api_key = None ): \"\"\" The original contents of the Event message must be confirmed by refetching it and comparing the fetched data with the original data. This function makes an API call to Stripe to redownload the Event data and returns whether or not it matches the WebhookEventTrigger data. \"\"\" local_data = self . json_body if \"id\" not in local_data or \"livemode\" not in local_data : logger . error ( '\"id\" not in json body or \"livemode\" not in json body( %s )' , local_data ) return False if self . is_test_event : logger . info ( \"Test webhook received and discarded: {} \" . format ( local_data )) return False if djstripe_settings . WEBHOOK_VALIDATION is None : # validation disabled warnings . warn ( \"WEBHOOK VALIDATION is disabled.\" ) return True elif ( djstripe_settings . WEBHOOK_VALIDATION == \"verify_signature\" and djstripe_settings . WEBHOOK_SECRET ): # HTTP headers are case-insensitive, but we store them as a dict. headers = CaseInsensitiveMapping ( self . headers ) try : stripe . WebhookSignature . verify_header ( self . body , headers . get ( \"stripe-signature\" ), djstripe_settings . WEBHOOK_SECRET , djstripe_settings . WEBHOOK_TOLERANCE , ) except stripe . error . SignatureVerificationError : logger . exception ( \"Failed to verify header\" ) return False else : return True livemode = local_data [ \"livemode\" ] api_key = api_key or djstripe_settings . get_default_api_key ( livemode ) # Retrieve the event using the api_version specified in itself with stripe_temporary_api_version ( local_data [ \"api_version\" ], validate = False ): remote_data = Event . stripe_class . retrieve ( id = local_data [ \"id\" ], api_key = api_key ) return local_data [ \"data\" ] == remote_data [ \"data\" ] Functions djstripe . models . webhooks . get_remote_ip ( request ) Given the HTTPRequest object return the IP Address of the client :param request: client request :type request: HTTPRequest :Returns: the client ip address Source code in djstripe/models/webhooks.py def get_remote_ip ( request ): \"\"\"Given the HTTPRequest object return the IP Address of the client :param request: client request :type request: HTTPRequest :Returns: the client ip address \"\"\" # HTTP_X_FORWARDED_FOR is relevant for django running behind a proxy x_forwarded_for = request . META . get ( \"HTTP_X_FORWARDED_FOR\" ) if x_forwarded_for : ip = x_forwarded_for . split ( \",\" )[ 0 ] else : ip = request . META . get ( \"REMOTE_ADDR\" ) if not ip : warnings . warn ( \"Could not determine remote IP (missing REMOTE_ADDR). \" \"This is likely an issue with your wsgi/server setup.\" ) ip = \"0.0.0.0\" return ip","title":"Models"},{"location":"reference/models/#models","text":"Models hold the bulk of the functionality included in the dj-stripe package. Each model is tied closely to its corresponding object in the stripe dashboard. Fields that are not implemented for each model have a short reason behind the decision in the docstring for each model.","title":"Models"},{"location":"reference/models/#core-resources","text":"","title":"Core Resources"},{"location":"reference/models/#djstripe.models.core-classes","text":"","title":"Classes"},{"location":"reference/models/#djstripe.models.core.BalanceTransaction","text":"A single transaction that updates the Stripe balance. Stripe documentation: https://stripe.com/docs/api#balance_transaction_object","title":"BalanceTransaction"},{"location":"reference/models/#djstripe.models.core.BalanceTransaction.amount","text":"","title":"amount"},{"location":"reference/models/#djstripe.models.core.BalanceTransaction.available_on","text":"","title":"available_on"},{"location":"reference/models/#djstripe.models.core.BalanceTransaction.currency","text":"","title":"currency"},{"location":"reference/models/#djstripe.models.core.BalanceTransaction.djstripe_owner_account","text":"","title":"djstripe_owner_account"},{"location":"reference/models/#djstripe.models.core.BalanceTransaction.exchange_rate","text":"","title":"exchange_rate"},{"location":"reference/models/#djstripe.models.core.BalanceTransaction.fee","text":"","title":"fee"},{"location":"reference/models/#djstripe.models.core.BalanceTransaction.fee_details","text":"","title":"fee_details"},{"location":"reference/models/#djstripe.models.core.BalanceTransaction.net","text":"","title":"net"},{"location":"reference/models/#djstripe.models.core.BalanceTransaction.reporting_category","text":"","title":"reporting_category"},{"location":"reference/models/#djstripe.models.core.BalanceTransaction.source","text":"","title":"source"},{"location":"reference/models/#djstripe.models.core.BalanceTransaction.status","text":"","title":"status"},{"location":"reference/models/#djstripe.models.core.BalanceTransaction.type","text":"","title":"type"},{"location":"reference/models/#djstripe.models.core.BalanceTransaction.DoesNotExist","text":"","title":"DoesNotExist"},{"location":"reference/models/#djstripe.models.core.BalanceTransaction.MultipleObjectsReturned","text":"","title":"MultipleObjectsReturned"},{"location":"reference/models/#djstripe.models.core.BalanceTransaction.stripe_class","text":"","title":"stripe_class"},{"location":"reference/models/#djstripe.models.core.BalanceTransaction-methods","text":"","title":"Methods"},{"location":"reference/models/#djstripe.models.core.BalanceTransaction.__str__","text":"Source code in djstripe/models/core.py def __str__ ( self ): return f \" { self . human_readable_amount } ( { enums . BalanceTransactionStatus . humanize ( self . status ) } )\"","title":"__str__()"},{"location":"reference/models/#djstripe.models.core.BalanceTransaction.get_next_by_available_on","text":"Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_next_by_available_on()"},{"location":"reference/models/#djstripe.models.core.BalanceTransaction.get_next_by_djstripe_created","text":"Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_next_by_djstripe_created()"},{"location":"reference/models/#djstripe.models.core.BalanceTransaction.get_next_by_djstripe_updated","text":"Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_next_by_djstripe_updated()"},{"location":"reference/models/#djstripe.models.core.BalanceTransaction.get_previous_by_available_on","text":"Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_previous_by_available_on()"},{"location":"reference/models/#djstripe.models.core.BalanceTransaction.get_previous_by_djstripe_created","text":"Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_previous_by_djstripe_created()"},{"location":"reference/models/#djstripe.models.core.BalanceTransaction.get_previous_by_djstripe_updated","text":"Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_previous_by_djstripe_updated()"},{"location":"reference/models/#djstripe.models.core.BalanceTransaction.get_reporting_category_display","text":"Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_reporting_category_display()"},{"location":"reference/models/#djstripe.models.core.BalanceTransaction.get_source_class","text":"Source code in djstripe/models/core.py def get_source_class ( self ): try : return apps . get_model ( \"djstripe\" , self . type ) except LookupError : raise","title":"get_source_class()"},{"location":"reference/models/#djstripe.models.core.BalanceTransaction.get_source_instance","text":"Source code in djstripe/models/core.py def get_source_instance ( self ): return self . get_source_class () . objects . get ( id = self . source )","title":"get_source_instance()"},{"location":"reference/models/#djstripe.models.core.BalanceTransaction.get_status_display","text":"Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_status_display()"},{"location":"reference/models/#djstripe.models.core.BalanceTransaction.get_stripe_dashboard_url","text":"Get the stripe dashboard url for this object. Source code in djstripe/models/core.py def get_stripe_dashboard_url ( self ): return self . get_source_instance () . get_stripe_dashboard_url ()","title":"get_stripe_dashboard_url()"},{"location":"reference/models/#djstripe.models.core.BalanceTransaction.get_type_display","text":"Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_type_display()"},{"location":"reference/models/#djstripe.models.core.Charge","text":"To charge a credit or a debit card, you create a charge object. You can retrieve and refund individual charges as well as list all charges. Charges are identified by a unique random ID. Stripe documentation: https://stripe.com/docs/api?lang=python#charges","title":"Charge"},{"location":"reference/models/#djstripe.models.core.Charge.amount","text":"","title":"amount"},{"location":"reference/models/#djstripe.models.core.Charge.amount_captured","text":"","title":"amount_captured"},{"location":"reference/models/#djstripe.models.core.Charge.amount_refunded","text":"","title":"amount_refunded"},{"location":"reference/models/#djstripe.models.core.Charge.application","text":"","title":"application"},{"location":"reference/models/#djstripe.models.core.Charge.application_fee","text":"","title":"application_fee"},{"location":"reference/models/#djstripe.models.core.Charge.application_fee_amount","text":"","title":"application_fee_amount"},{"location":"reference/models/#djstripe.models.core.Charge.balance_transaction","text":"","title":"balance_transaction"},{"location":"reference/models/#djstripe.models.core.Charge.billing_details","text":"","title":"billing_details"},{"location":"reference/models/#djstripe.models.core.Charge.calculated_statement_descriptor","text":"","title":"calculated_statement_descriptor"},{"location":"reference/models/#djstripe.models.core.Charge.captured","text":"","title":"captured"},{"location":"reference/models/#djstripe.models.core.Charge.currency","text":"","title":"currency"},{"location":"reference/models/#djstripe.models.core.Charge.customer","text":"","title":"customer"},{"location":"reference/models/#djstripe.models.core.Charge.dispute","text":"","title":"dispute"},{"location":"reference/models/#djstripe.models.core.Charge.disputed","text":"","title":"disputed"},{"location":"reference/models/#djstripe.models.core.Charge.djstripe_owner_account","text":"","title":"djstripe_owner_account"},{"location":"reference/models/#djstripe.models.core.Charge.expand_fields","text":"","title":"expand_fields"},{"location":"reference/models/#djstripe.models.core.Charge.failure_code","text":"","title":"failure_code"},{"location":"reference/models/#djstripe.models.core.Charge.failure_message","text":"","title":"failure_message"},{"location":"reference/models/#djstripe.models.core.Charge.fee","text":"","title":"fee"},{"location":"reference/models/#djstripe.models.core.Charge.fraud_details","text":"","title":"fraud_details"},{"location":"reference/models/#djstripe.models.core.Charge.fraudulent","text":"","title":"fraudulent"},{"location":"reference/models/#djstripe.models.core.Charge.human_readable_status","text":"","title":"human_readable_status"},{"location":"reference/models/#djstripe.models.core.Charge.invoice","text":"","title":"invoice"},{"location":"reference/models/#djstripe.models.core.Charge.objects","text":"","title":"objects"},{"location":"reference/models/#djstripe.models.core.Charge.on_behalf_of","text":"","title":"on_behalf_of"},{"location":"reference/models/#djstripe.models.core.Charge.outcome","text":"","title":"outcome"},{"location":"reference/models/#djstripe.models.core.Charge.paid","text":"","title":"paid"},{"location":"reference/models/#djstripe.models.core.Charge.payment_intent","text":"","title":"payment_intent"},{"location":"reference/models/#djstripe.models.core.Charge.payment_method","text":"","title":"payment_method"},{"location":"reference/models/#djstripe.models.core.Charge.payment_method_details","text":"","title":"payment_method_details"},{"location":"reference/models/#djstripe.models.core.Charge.receipt_email","text":"","title":"receipt_email"},{"location":"reference/models/#djstripe.models.core.Charge.receipt_number","text":"","title":"receipt_number"},{"location":"reference/models/#djstripe.models.core.Charge.receipt_url","text":"","title":"receipt_url"},{"location":"reference/models/#djstripe.models.core.Charge.refunded","text":"","title":"refunded"},{"location":"reference/models/#djstripe.models.core.Charge.shipping","text":"","title":"shipping"},{"location":"reference/models/#djstripe.models.core.Charge.source","text":"","title":"source"},{"location":"reference/models/#djstripe.models.core.Charge.source_transfer","text":"","title":"source_transfer"},{"location":"reference/models/#djstripe.models.core.Charge.statement_descriptor","text":"","title":"statement_descriptor"},{"location":"reference/models/#djstripe.models.core.Charge.statement_descriptor_suffix","text":"","title":"statement_descriptor_suffix"},{"location":"reference/models/#djstripe.models.core.Charge.status","text":"","title":"status"},{"location":"reference/models/#djstripe.models.core.Charge.stripe_dashboard_item_name","text":"","title":"stripe_dashboard_item_name"},{"location":"reference/models/#djstripe.models.core.Charge.transfer","text":"","title":"transfer"},{"location":"reference/models/#djstripe.models.core.Charge.transfer_data","text":"","title":"transfer_data"},{"location":"reference/models/#djstripe.models.core.Charge.transfer_group","text":"","title":"transfer_group"},{"location":"reference/models/#djstripe.models.core.Charge.DoesNotExist","text":"","title":"DoesNotExist"},{"location":"reference/models/#djstripe.models.core.Charge.MultipleObjectsReturned","text":"","title":"MultipleObjectsReturned"},{"location":"reference/models/#djstripe.models.core.Charge.stripe_class","text":"djstripe . models . core . Charge . stripe_class . OBJECT_NAME djstripe . models . core . Charge . stripe_class . capture ( self , idempotency_key = None , ** params ) Source code in djstripe/models/core.py def capture ( self , idempotency_key = None , ** params ): url = self . instance_url () + \"/capture\" headers = util . populate_headers ( idempotency_key ) self . refresh_from ( self . request ( \"post\" , url , params , headers )) return self djstripe . models . core . Charge . stripe_class . close_dispute ( self , idempotency_key = None , ** params ) Source code in djstripe/models/core.py def close_dispute ( self , idempotency_key = None , ** params ): requestor = api_requestor . APIRequestor ( self . api_key , api_version = self . stripe_version , account = self . stripe_account , ) url = self . instance_url () + \"/dispute/close\" headers = util . populate_headers ( idempotency_key ) response , api_key = requestor . request ( \"post\" , url , params , headers ) self . refresh_from ({ \"dispute\" : response }, api_key , True ) return self . dispute djstripe . models . core . Charge . stripe_class . mark_as_fraudulent ( self , idempotency_key = None ) Source code in djstripe/models/core.py def mark_as_fraudulent ( self , idempotency_key = None ): params = { \"fraud_details\" : { \"user_report\" : \"fraudulent\" }} url = self . instance_url () headers = util . populate_headers ( idempotency_key ) self . refresh_from ( self . request ( \"post\" , url , params , headers )) return self djstripe . models . core . Charge . stripe_class . mark_as_safe ( self , idempotency_key = None ) Source code in djstripe/models/core.py def mark_as_safe ( self , idempotency_key = None ): params = { \"fraud_details\" : { \"user_report\" : \"safe\" }} url = self . instance_url () headers = util . populate_headers ( idempotency_key ) self . refresh_from ( self . request ( \"post\" , url , params , headers )) return self djstripe . models . core . Charge . stripe_class . refund ( self , idempotency_key = None , ** params ) Source code in djstripe/models/core.py def refund ( self , idempotency_key = None , ** params ): url = self . instance_url () + \"/refund\" headers = util . populate_headers ( idempotency_key ) self . refresh_from ( self . request ( \"post\" , url , params , headers )) return self djstripe . models . core . Charge . stripe_class . update_dispute ( self , idempotency_key = None , ** params ) Source code in djstripe/models/core.py def update_dispute ( self , idempotency_key = None , ** params ): requestor = api_requestor . APIRequestor ( self . api_key , api_version = self . stripe_version , account = self . stripe_account , ) url = self . instance_url () + \"/dispute\" headers = util . populate_headers ( idempotency_key ) response , api_key = requestor . request ( \"post\" , url , params , headers ) self . refresh_from ({ \"dispute\" : response }, api_key , True ) return self . dispute","title":"stripe_class"},{"location":"reference/models/#djstripe.models.core.Charge-methods","text":"","title":"Methods"},{"location":"reference/models/#djstripe.models.core.Charge.__str__","text":"Source code in djstripe/models/core.py def __str__ ( self ): amount = self . human_readable_amount status = self . human_readable_status return \" {amount} ( {status} )\" . format ( amount = amount , status = status )","title":"__str__()"},{"location":"reference/models/#djstripe.models.core.Charge.capture","text":"Capture the payment of an existing, uncaptured, charge. This is the second half of the two-step payment flow, where first you created a charge with the capture option set to False. See https://stripe.com/docs/api#capture_charge Source code in djstripe/models/core.py def capture ( self , ** kwargs ) -> \"Charge\" : \"\"\" Capture the payment of an existing, uncaptured, charge. This is the second half of the two-step payment flow, where first you created a charge with the capture option set to False. See https://stripe.com/docs/api#capture_charge \"\"\" captured_charge = self . api_retrieve () . capture ( ** kwargs ) return self . __class__ . sync_from_stripe_data ( captured_charge )","title":"capture()"},{"location":"reference/models/#djstripe.models.core.Charge.get_failure_code_display","text":"Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_failure_code_display()"},{"location":"reference/models/#djstripe.models.core.Charge.get_next_by_djstripe_created","text":"Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_next_by_djstripe_created()"},{"location":"reference/models/#djstripe.models.core.Charge.get_next_by_djstripe_updated","text":"Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_next_by_djstripe_updated()"},{"location":"reference/models/#djstripe.models.core.Charge.get_previous_by_djstripe_created","text":"Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_previous_by_djstripe_created()"},{"location":"reference/models/#djstripe.models.core.Charge.get_previous_by_djstripe_updated","text":"Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_previous_by_djstripe_updated()"},{"location":"reference/models/#djstripe.models.core.Charge.get_status_display","text":"Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_status_display()"},{"location":"reference/models/#djstripe.models.core.Charge.refund","text":"Initiate a refund. Returns the charge object. :param amount: A positive decimal amount representing how much of this charge to refund. If amount is not provided, then this will be a full refund. Can only refund up to the unrefunded amount remaining of the charge. :param reason: String indicating the reason for the refund. If set, possible values are duplicate , fraudulent , and requested_by_customer . Specifying fraudulent as the reason when you believe the charge to be fraudulent will help Stripe improve their fraud detection algorithms. Source code in djstripe/models/core.py def refund ( self , amount : Decimal = None , reason : str = None ) -> \"Charge\" : \"\"\" Initiate a refund. Returns the charge object. :param amount: A positive decimal amount representing how much of this charge to refund. If amount is not provided, then this will be a full refund. Can only refund up to the unrefunded amount remaining of the charge. :param reason: String indicating the reason for the refund. If set, possible values are ``duplicate``, ``fraudulent``, and ``requested_by_customer``. Specifying ``fraudulent`` as the reason when you believe the charge to be fraudulent will help Stripe improve their fraud detection algorithms. \"\"\" charge_obj = self . api_retrieve () . refund ( amount = self . _calculate_refund_amount ( amount = amount ), reason = reason ) return self . __class__ . sync_from_stripe_data ( charge_obj )","title":"refund()"},{"location":"reference/models/#djstripe.models.core.Customer","text":"Customer objects allow you to perform recurring charges and track multiple charges that are associated with the same customer. Stripe documentation: https://stripe.com/docs/api?lang=python#customers","title":"Customer"},{"location":"reference/models/#djstripe.models.core.Customer-attributes","text":"","title":"Attributes"},{"location":"reference/models/#djstripe.models.core.Customer.active_subscriptions","text":"Returns active subscriptions (subscriptions with an active status that end in the future).","title":"active_subscriptions"},{"location":"reference/models/#djstripe.models.core.Customer.address","text":"","title":"address"},{"location":"reference/models/#djstripe.models.core.Customer.balance","text":"","title":"balance"},{"location":"reference/models/#djstripe.models.core.Customer.coupon","text":"","title":"coupon"},{"location":"reference/models/#djstripe.models.core.Customer.coupon_end","text":"","title":"coupon_end"},{"location":"reference/models/#djstripe.models.core.Customer.coupon_start","text":"","title":"coupon_start"},{"location":"reference/models/#djstripe.models.core.Customer.credits","text":"The customer is considered to have credits if their balance is below 0.","title":"credits"},{"location":"reference/models/#djstripe.models.core.Customer.currency","text":"","title":"currency"},{"location":"reference/models/#djstripe.models.core.Customer.customer_payment_methods","text":"An iterable of all of the customer's payment methods (sources, then legacy cards)","title":"customer_payment_methods"},{"location":"reference/models/#djstripe.models.core.Customer.date_purged","text":"","title":"date_purged"},{"location":"reference/models/#djstripe.models.core.Customer.default_payment_method","text":"","title":"default_payment_method"},{"location":"reference/models/#djstripe.models.core.Customer.default_source","text":"","title":"default_source"},{"location":"reference/models/#djstripe.models.core.Customer.deleted","text":"","title":"deleted"},{"location":"reference/models/#djstripe.models.core.Customer.delinquent","text":"","title":"delinquent"},{"location":"reference/models/#djstripe.models.core.Customer.djstripe_owner_account","text":"","title":"djstripe_owner_account"},{"location":"reference/models/#djstripe.models.core.Customer.email","text":"","title":"email"},{"location":"reference/models/#djstripe.models.core.Customer.expand_fields","text":"","title":"expand_fields"},{"location":"reference/models/#djstripe.models.core.Customer.invoice_prefix","text":"","title":"invoice_prefix"},{"location":"reference/models/#djstripe.models.core.Customer.invoice_settings","text":"","title":"invoice_settings"},{"location":"reference/models/#djstripe.models.core.Customer.name","text":"","title":"name"},{"location":"reference/models/#djstripe.models.core.Customer.pending_charges","text":"The customer is considered to have pending charges if their balance is above 0.","title":"pending_charges"},{"location":"reference/models/#djstripe.models.core.Customer.phone","text":"","title":"phone"},{"location":"reference/models/#djstripe.models.core.Customer.preferred_locales","text":"","title":"preferred_locales"},{"location":"reference/models/#djstripe.models.core.Customer.shipping","text":"","title":"shipping"},{"location":"reference/models/#djstripe.models.core.Customer.stripe_dashboard_item_name","text":"","title":"stripe_dashboard_item_name"},{"location":"reference/models/#djstripe.models.core.Customer.subscriber","text":"","title":"subscriber"},{"location":"reference/models/#djstripe.models.core.Customer.subscription","text":"Shortcut to get this customer's subscription. :returns: None if the customer has no subscriptions, the subscription if the customer has a subscription. :raises MultipleSubscriptionException: Raised if the customer has multiple subscriptions. In this case, use Customer.subscriptions instead.","title":"subscription"},{"location":"reference/models/#djstripe.models.core.Customer.tax_exempt","text":"","title":"tax_exempt"},{"location":"reference/models/#djstripe.models.core.Customer.valid_subscriptions","text":"Returns this customer's valid subscriptions (subscriptions that aren't canceled or incomplete_expired).","title":"valid_subscriptions"},{"location":"reference/models/#djstripe.models.core.Customer.DoesNotExist","text":"","title":"DoesNotExist"},{"location":"reference/models/#djstripe.models.core.Customer.MultipleObjectsReturned","text":"","title":"MultipleObjectsReturned"},{"location":"reference/models/#djstripe.models.core.Customer.stripe_class","text":"djstripe . models . core . Customer . stripe_class . OBJECT_NAME djstripe . models . core . Customer . stripe_class . balance_transactions_request ( method , url , api_key = None , idempotency_key = None , stripe_version = None , stripe_account = None , ** params ) classmethod Source code in djstripe/models/core.py def nested_resource_request ( cls , method , url , api_key = None , idempotency_key = None , stripe_version = None , stripe_account = None , ** params ): requestor = api_requestor . APIRequestor ( api_key , api_version = stripe_version , account = stripe_account ) headers = util . populate_headers ( idempotency_key ) response , api_key = requestor . request ( method , url , params , headers ) return util . convert_to_stripe_object ( response , api_key , stripe_version , stripe_account ) djstripe . models . core . Customer . stripe_class . balance_transactions_url ( id , nested_id = None ) classmethod Source code in djstripe/models/core.py def nested_resource_url ( cls , id , nested_id = None ): url = \" %s / %s / %s \" % ( cls . class_url (), quote_plus ( id ), quote_plus ( path ), ) if nested_id is not None : url += \"/ %s \" % quote_plus ( nested_id ) return url djstripe . models . core . Customer . stripe_class . create_balance_transaction ( id , ** params ) classmethod Source code in djstripe/models/core.py def create_nested_resource ( cls , id , ** params ): url = getattr ( cls , resource_url_method )( id ) return getattr ( cls , resource_request_method )( \"post\" , url , ** params ) djstripe . models . core . Customer . stripe_class . create_source ( id , ** params ) classmethod Source code in djstripe/models/core.py def create_nested_resource ( cls , id , ** params ): url = getattr ( cls , resource_url_method )( id ) return getattr ( cls , resource_request_method )( \"post\" , url , ** params ) djstripe . models . core . Customer . stripe_class . create_tax_id ( id , ** params ) classmethod Source code in djstripe/models/core.py def create_nested_resource ( cls , id , ** params ): url = getattr ( cls , resource_url_method )( id ) return getattr ( cls , resource_request_method )( \"post\" , url , ** params ) djstripe . models . core . Customer . stripe_class . delete_discount ( self , ** params ) Source code in djstripe/models/core.py def delete_discount ( self , ** params ): requestor = api_requestor . APIRequestor ( self . api_key , api_version = self . stripe_version , account = self . stripe_account , ) url = self . instance_url () + \"/discount\" _ , api_key = requestor . request ( \"delete\" , url , params ) self . refresh_from ({ \"discount\" : None }, api_key , True ) djstripe . models . core . Customer . stripe_class . delete_source ( id , nested_id , ** params ) classmethod Source code in djstripe/models/core.py def delete_nested_resource ( cls , id , nested_id , ** params ): url = getattr ( cls , resource_url_method )( id , nested_id ) return getattr ( cls , resource_request_method )( \"delete\" , url , ** params ) djstripe . models . core . Customer . stripe_class . delete_tax_id ( id , nested_id , ** params ) classmethod Source code in djstripe/models/core.py def delete_nested_resource ( cls , id , nested_id , ** params ): url = getattr ( cls , resource_url_method )( id , nested_id ) return getattr ( cls , resource_request_method )( \"delete\" , url , ** params ) djstripe . models . core . Customer . stripe_class . list_balance_transactions ( id , ** params ) classmethod Source code in djstripe/models/core.py def list_nested_resources ( cls , id , ** params ): url = getattr ( cls , resource_url_method )( id ) return getattr ( cls , resource_request_method )( \"get\" , url , ** params ) djstripe . models . core . Customer . stripe_class . list_payment_methods ( self , idempotency_key = None , ** params ) Source code in djstripe/models/core.py def list_payment_methods ( self , idempotency_key = None , ** params ): url = self . instance_url () + \"/payment_methods\" headers = util . populate_headers ( idempotency_key ) resp = self . request ( \"get\" , url , params , headers ) stripe_object = util . convert_to_stripe_object ( resp ) stripe_object . _retrieve_params = params return stripe_object djstripe . models . core . Customer . stripe_class . list_sources ( id , ** params ) classmethod Source code in djstripe/models/core.py def list_nested_resources ( cls , id , ** params ): url = getattr ( cls , resource_url_method )( id ) return getattr ( cls , resource_request_method )( \"get\" , url , ** params ) djstripe . models . core . Customer . stripe_class . list_tax_ids ( id , ** params ) classmethod Source code in djstripe/models/core.py def list_nested_resources ( cls , id , ** params ): url = getattr ( cls , resource_url_method )( id ) return getattr ( cls , resource_request_method )( \"get\" , url , ** params ) djstripe . models . core . Customer . stripe_class . modify_balance_transaction ( id , nested_id , ** params ) classmethod Source code in djstripe/models/core.py def modify_nested_resource ( cls , id , nested_id , ** params ): url = getattr ( cls , resource_url_method )( id , nested_id ) return getattr ( cls , resource_request_method )( \"post\" , url , ** params ) djstripe . models . core . Customer . stripe_class . modify_source ( id , nested_id , ** params ) classmethod Source code in djstripe/models/core.py def modify_nested_resource ( cls , id , nested_id , ** params ): url = getattr ( cls , resource_url_method )( id , nested_id ) return getattr ( cls , resource_request_method )( \"post\" , url , ** params ) djstripe . models . core . Customer . stripe_class . retrieve_balance_transaction ( id , nested_id , ** params ) classmethod Source code in djstripe/models/core.py def retrieve_nested_resource ( cls , id , nested_id , ** params ): url = getattr ( cls , resource_url_method )( id , nested_id ) return getattr ( cls , resource_request_method )( \"get\" , url , ** params ) djstripe . models . core . Customer . stripe_class . retrieve_source ( id , nested_id , ** params ) classmethod Source code in djstripe/models/core.py def retrieve_nested_resource ( cls , id , nested_id , ** params ): url = getattr ( cls , resource_url_method )( id , nested_id ) return getattr ( cls , resource_request_method )( \"get\" , url , ** params ) djstripe . models . core . Customer . stripe_class . retrieve_tax_id ( id , nested_id , ** params ) classmethod Source code in djstripe/models/core.py def retrieve_nested_resource ( cls , id , nested_id , ** params ): url = getattr ( cls , resource_url_method )( id , nested_id ) return getattr ( cls , resource_request_method )( \"get\" , url , ** params ) djstripe . models . core . Customer . stripe_class . sources_request ( method , url , api_key = None , idempotency_key = None , stripe_version = None , stripe_account = None , ** params ) classmethod Source code in djstripe/models/core.py def nested_resource_request ( cls , method , url , api_key = None , idempotency_key = None , stripe_version = None , stripe_account = None , ** params ): requestor = api_requestor . APIRequestor ( api_key , api_version = stripe_version , account = stripe_account ) headers = util . populate_headers ( idempotency_key ) response , api_key = requestor . request ( method , url , params , headers ) return util . convert_to_stripe_object ( response , api_key , stripe_version , stripe_account ) djstripe . models . core . Customer . stripe_class . sources_url ( id , nested_id = None ) classmethod Source code in djstripe/models/core.py def nested_resource_url ( cls , id , nested_id = None ): url = \" %s / %s / %s \" % ( cls . class_url (), quote_plus ( id ), quote_plus ( path ), ) if nested_id is not None : url += \"/ %s \" % quote_plus ( nested_id ) return url djstripe . models . core . Customer . stripe_class . tax_ids_request ( method , url , api_key = None , idempotency_key = None , stripe_version = None , stripe_account = None , ** params ) classmethod Source code in djstripe/models/core.py def nested_resource_request ( cls , method , url , api_key = None , idempotency_key = None , stripe_version = None , stripe_account = None , ** params ): requestor = api_requestor . APIRequestor ( api_key , api_version = stripe_version , account = stripe_account ) headers = util . populate_headers ( idempotency_key ) response , api_key = requestor . request ( method , url , params , headers ) return util . convert_to_stripe_object ( response , api_key , stripe_version , stripe_account ) djstripe . models . core . Customer . stripe_class . tax_ids_url ( id , nested_id = None ) classmethod Source code in djstripe/models/core.py def nested_resource_url ( cls , id , nested_id = None ): url = \" %s / %s / %s \" % ( cls . class_url (), quote_plus ( id ), quote_plus ( path ), ) if nested_id is not None : url += \"/ %s \" % quote_plus ( nested_id ) return url","title":"stripe_class"},{"location":"reference/models/#djstripe.models.core.Customer-methods","text":"","title":"Methods"},{"location":"reference/models/#djstripe.models.core.Customer.__str__","text":"Source code in djstripe/models/core.py def __str__ ( self ): if self . subscriber : return str ( self . subscriber ) return self . name or self . description or self . id","title":"__str__()"},{"location":"reference/models/#djstripe.models.core.Customer.add_card","text":"Adds a card to this customer's account. :param source: Either a token, like the ones returned by our Stripe.js, or a dictionary containing a user's credit card details. Stripe will automatically validate the card. :type source: string, dict :param set_default: Whether or not to set the source as the customer's default source :type set_default: boolean Source code in djstripe/models/core.py def add_card ( self , source , set_default = True ): \"\"\" Adds a card to this customer's account. :param source: Either a token, like the ones returned by our Stripe.js, or a dictionary containing a user's credit card details. Stripe will automatically validate the card. :type source: string, dict :param set_default: Whether or not to set the source as the customer's default source :type set_default: boolean \"\"\" from .payment_methods import DjstripePaymentMethod stripe_customer = self . api_retrieve () new_stripe_payment_method = stripe_customer . sources . create ( source = source ) if set_default : stripe_customer . default_source = new_stripe_payment_method [ \"id\" ] stripe_customer . save () new_payment_method = DjstripePaymentMethod . from_stripe_object ( new_stripe_payment_method ) # Change the default source if set_default : self . default_source = new_payment_method self . save () return new_payment_method . resolve ()","title":"add_card()"},{"location":"reference/models/#djstripe.models.core.Customer.add_coupon","text":"Add a coupon to a Customer. The coupon can be a Coupon object, or a valid Stripe Coupon ID. Source code in djstripe/models/core.py def add_coupon ( self , coupon , idempotency_key = None ): \"\"\" Add a coupon to a Customer. The coupon can be a Coupon object, or a valid Stripe Coupon ID. \"\"\" if isinstance ( coupon , StripeModel ): coupon = coupon . id stripe_customer = self . api_retrieve () stripe_customer [ \"coupon\" ] = coupon stripe_customer . save ( idempotency_key = idempotency_key ) return self . __class__ . sync_from_stripe_data ( stripe_customer )","title":"add_coupon()"},{"location":"reference/models/#djstripe.models.core.Customer.add_invoice_item","text":"Adds an arbitrary charge or credit to the customer's upcoming invoice. Different than creating a charge. Charges are separate bills that get processed immediately. Invoice items are appended to the customer's next invoice. This is extremely useful when adding surcharges to subscriptions. :param amount: The amount to charge. :type amount: Decimal. Precision is 2; anything more will be ignored. :param currency: 3-letter ISO code for currency :type currency: string :param description: An arbitrary string. :type description: string :param discountable: Controls whether discounts apply to this invoice item. Defaults to False for prorations or negative invoice items, and True for all other invoice items. :type discountable: boolean :param invoice: An existing invoice to add this invoice item to. When left blank, the invoice item will be added to the next upcoming scheduled invoice. Use this when adding invoice items in response to an invoice.created webhook. You cannot add an invoice item to an invoice that has already been paid, attempted or closed. :type invoice: Invoice or string (invoice ID) :param metadata: A set of key/value pairs useful for storing additional information. :type metadata: dict :param subscription: A subscription to add this invoice item to. When left blank, the invoice item will be be added to the next upcoming scheduled invoice. When set, scheduled invoices for subscriptions other than the specified subscription will ignore the invoice item. Use this when you want to express that an invoice item has been accrued within the context of a particular subscription. :type subscription: Subscription or string (subscription ID) .. Notes: .. if you're using Customer.add_invoice_item() instead of .. Customer.add_invoice_item() , invoice and subscriptions .. can only be strings Source code in djstripe/models/core.py def add_invoice_item ( self , amount , currency , description = None , discountable = None , invoice = None , metadata = None , subscription = None , ): \"\"\" Adds an arbitrary charge or credit to the customer's upcoming invoice. Different than creating a charge. Charges are separate bills that get processed immediately. Invoice items are appended to the customer's next invoice. This is extremely useful when adding surcharges to subscriptions. :param amount: The amount to charge. :type amount: Decimal. Precision is 2; anything more will be ignored. :param currency: 3-letter ISO code for currency :type currency: string :param description: An arbitrary string. :type description: string :param discountable: Controls whether discounts apply to this invoice item. Defaults to False for prorations or negative invoice items, and True for all other invoice items. :type discountable: boolean :param invoice: An existing invoice to add this invoice item to. When left blank, the invoice item will be added to the next upcoming \\ scheduled invoice. \\ Use this when adding invoice items in response to an \\ ``invoice.created`` webhook. You cannot add an invoice \\ item to an invoice that has already been paid, attempted or closed. :type invoice: Invoice or string (invoice ID) :param metadata: A set of key/value pairs useful for storing additional information. :type metadata: dict :param subscription: A subscription to add this invoice item to. When left blank, the invoice item will be be added to the next upcoming \\ scheduled invoice. When set, scheduled invoices for subscriptions other \\ than the specified subscription will ignore the invoice item. \\ Use this when you want to express that an invoice item has been accrued \\ within the context of a particular subscription. :type subscription: Subscription or string (subscription ID) .. Notes: .. if you're using ``Customer.add_invoice_item()`` instead of .. ``Customer.add_invoice_item()``, ``invoice`` and ``subscriptions`` .. can only be strings \"\"\" from .billing import InvoiceItem if not isinstance ( amount , Decimal ): raise ValueError ( \"You must supply a decimal value representing dollars.\" ) # Convert Invoice to id if invoice is not None and isinstance ( invoice , StripeModel ): invoice = invoice . id # Convert Subscription to id if subscription is not None and isinstance ( subscription , StripeModel ): subscription = subscription . id stripe_invoiceitem = InvoiceItem . _api_create ( amount = int ( amount * 100 ), # Convert dollars into cents currency = currency , customer = self . id , description = description , discountable = discountable , invoice = invoice , metadata = metadata , subscription = subscription , ) return InvoiceItem . sync_from_stripe_data ( stripe_invoiceitem )","title":"add_invoice_item()"},{"location":"reference/models/#djstripe.models.core.Customer.add_payment_method","text":"Adds an already existing payment method to this customer's account :param payment_method: PaymentMethod to be attached to the customer :type payment_method: str, PaymentMethod :param set_default: If true, this will be set as the default_payment_method :type set_default: bool :rtype: PaymentMethod Source code in djstripe/models/core.py def add_payment_method ( self , payment_method , set_default = True ): \"\"\" Adds an already existing payment method to this customer's account :param payment_method: PaymentMethod to be attached to the customer :type payment_method: str, PaymentMethod :param set_default: If true, this will be set as the default_payment_method :type set_default: bool :rtype: PaymentMethod \"\"\" from .payment_methods import PaymentMethod stripe_customer = self . api_retrieve () payment_method = PaymentMethod . attach ( payment_method , stripe_customer ) if set_default : stripe_customer [ \"invoice_settings\" ][ \"default_payment_method\" ] = payment_method . id stripe_customer . save () # Refresh self from the stripe customer, this should have two effects: # 1) sets self.default_payment_method (we rely on logic in # Customer._manipulate_stripe_object_hook to do this) # 2) updates self.invoice_settings.default_payment_methods self . sync_from_stripe_data ( stripe_customer ) self . refresh_from_db () return payment_method","title":"add_payment_method()"},{"location":"reference/models/#djstripe.models.core.Customer.can_charge","text":"Determines if this customer is able to be charged. Source code in djstripe/models/core.py def can_charge ( self ): \"\"\"Determines if this customer is able to be charged.\"\"\" warnings . warn ( \"Customer.can_charge() is misleading and deprecated, will be removed in dj-stripe 2.8. \" \"Look at Customer.payment_methods.all() instead.\" , DeprecationWarning , ) return ( self . has_valid_source () or self . default_payment_method is not None ) and self . date_purged is None","title":"can_charge()"},{"location":"reference/models/#djstripe.models.core.Customer.charge","text":"Creates a charge for this customer. :param amount: The amount to charge. :type amount: Decimal. Precision is 2; anything more will be ignored. :param source: The source to use for this charge. Must be a source attributed to this customer. If None, the customer's default source is used. Can be either the id of the source or the source object itself. :type source: string, Source Source code in djstripe/models/core.py def charge ( self , amount : Decimal , * , application_fee : Decimal = None , source : Union [ str , StripeModel ] = None , ** kwargs , ) -> Charge : \"\"\" Creates a charge for this customer. :param amount: The amount to charge. :type amount: Decimal. Precision is 2; anything more will be ignored. :param source: The source to use for this charge. Must be a source attributed to this customer. If None, the customer's default source is used. Can be either the id of the source or the source object itself. :type source: string, Source \"\"\" if not isinstance ( amount , Decimal ): raise ValueError ( \"You must supply a decimal value representing dollars.\" ) # Convert Source to id if source and isinstance ( source , StripeModel ): source = source . id stripe_charge = Charge . _api_create ( customer = self . id , amount = int ( amount * 100 ), # Convert dollars into cents application_fee = int ( application_fee * 100 ) if application_fee else None , # Convert dollars into cents source = source , ** kwargs , ) return Charge . sync_from_stripe_data ( stripe_charge )","title":"charge()"},{"location":"reference/models/#djstripe.models.core.Customer.create","text":"Source code in djstripe/models/core.py @classmethod def create ( cls , subscriber , idempotency_key = None , stripe_account = None ): metadata = {} subscriber_key = djstripe_settings . SUBSCRIBER_CUSTOMER_KEY if subscriber_key not in ( \"\" , None ): metadata [ subscriber_key ] = subscriber . pk stripe_customer = cls . _api_create ( email = subscriber . email , idempotency_key = idempotency_key , metadata = metadata , stripe_account = stripe_account , ) customer , created = Customer . objects . get_or_create ( id = stripe_customer [ \"id\" ], defaults = { \"subscriber\" : subscriber , \"livemode\" : stripe_customer [ \"livemode\" ], \"balance\" : stripe_customer . get ( \"balance\" , 0 ), \"delinquent\" : stripe_customer . get ( \"delinquent\" , False ), }, ) return customer","title":"create()"},{"location":"reference/models/#djstripe.models.core.Customer.get_next_by_djstripe_created","text":"Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_next_by_djstripe_created()"},{"location":"reference/models/#djstripe.models.core.Customer.get_next_by_djstripe_updated","text":"Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_next_by_djstripe_updated()"},{"location":"reference/models/#djstripe.models.core.Customer.get_or_create","text":"Get or create a dj-stripe customer. :param subscriber: The subscriber model instance for which to get or create a customer. :type subscriber: User :param livemode: Whether to get the subscriber in live or test mode. :type livemode: bool Source code in djstripe/models/core.py @classmethod def get_or_create ( cls , subscriber , livemode = djstripe_settings . STRIPE_LIVE_MODE , stripe_account = None , ): \"\"\" Get or create a dj-stripe customer. :param subscriber: The subscriber model instance for which to get or create a customer. :type subscriber: User :param livemode: Whether to get the subscriber in live or test mode. :type livemode: bool \"\"\" try : return Customer . objects . get ( subscriber = subscriber , livemode = livemode ), False except Customer . DoesNotExist : action = \"create: {} \" . format ( subscriber . pk ) idempotency_key = djstripe_settings . get_idempotency_key ( \"customer\" , action , livemode ) return ( cls . create ( subscriber , idempotency_key = idempotency_key , stripe_account = stripe_account , ), True , )","title":"get_or_create()"},{"location":"reference/models/#djstripe.models.core.Customer.get_previous_by_djstripe_created","text":"Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_previous_by_djstripe_created()"},{"location":"reference/models/#djstripe.models.core.Customer.get_previous_by_djstripe_updated","text":"Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_previous_by_djstripe_updated()"},{"location":"reference/models/#djstripe.models.core.Customer.get_tax_exempt_display","text":"Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_tax_exempt_display()"},{"location":"reference/models/#djstripe.models.core.Customer.has_any_active_subscription","text":"Checks to see if this customer has an active subscription to any plan. :returns: True if there exists an active subscription, False otherwise. Source code in djstripe/models/core.py def has_any_active_subscription ( self ): \"\"\" Checks to see if this customer has an active subscription to any plan. :returns: True if there exists an active subscription, False otherwise. \"\"\" return len ( self . _get_valid_subscriptions ()) != 0","title":"has_any_active_subscription()"},{"location":"reference/models/#djstripe.models.core.Customer.has_valid_source","text":"Check whether the customer has a valid payment source. Source code in djstripe/models/core.py def has_valid_source ( self ): \"\"\"Check whether the customer has a valid payment source.\"\"\" warnings . warn ( \"Customer.has_valid_source() is deprecated and will be removed in dj-stripe 2.8. \" \"Use `Customer.default_source is not None` instead.\" , DeprecationWarning , ) return self . default_source is not None","title":"has_valid_source()"},{"location":"reference/models/#djstripe.models.core.Customer.is_subscribed_to","text":"Checks to see if this customer has an active subscription to the given product. :param product: The product for which to check for an active subscription. :type product: Product or string (product ID) :returns: True if there exists an active subscription, False otherwise. Source code in djstripe/models/core.py def is_subscribed_to ( self , product : Union [ Product , str ]) -> bool : \"\"\" Checks to see if this customer has an active subscription to the given product. :param product: The product for which to check for an active subscription. :type product: Product or string (product ID) :returns: True if there exists an active subscription, False otherwise. \"\"\" if isinstance ( product , StripeModel ): product = product . id for subscription in self . _get_valid_subscriptions (): for item in subscription . items . all (): if item . price and item . price . product . id == product : return True return False","title":"is_subscribed_to()"},{"location":"reference/models/#djstripe.models.core.Customer.purge","text":"Customers are soft deleted as deleted customers are still accessible by the Stripe API and sync for all RelatedModels would fail Source code in djstripe/models/core.py def purge ( self ): \"\"\"Customers are soft deleted as deleted customers are still accessible by the Stripe API and sync for all RelatedModels would fail\"\"\" try : self . _api_delete () except InvalidRequestError as exc : if \"No such customer:\" in str ( exc ): # The exception was thrown because the stripe customer was already # deleted on the stripe side, ignore the exception pass else : # The exception was raised for another reason, re-raise it raise # toggle the deleted flag on Customer to indicate it has been # deleted upstream in Stripe self . deleted = True if self . subscriber : # Delete the idempotency key used by Customer.create() # So re-creating a customer for this subscriber before the key expires # doesn't return the older Customer data idempotency_key_action = \"customer:create: {} \" . format ( self . subscriber . pk ) IdempotencyKey . objects . filter ( action = idempotency_key_action ) . delete () self . subscriber = None # Remove sources self . default_source = None for source in self . legacy_cards . all (): source . remove () for source in self . sources . all (): source . detach () self . date_purged = timezone . now () self . save ()","title":"purge()"},{"location":"reference/models/#djstripe.models.core.Customer.retry_unpaid_invoices","text":"Attempt to retry collecting payment on the customer's unpaid invoices. Source code in djstripe/models/core.py def retry_unpaid_invoices ( self ): \"\"\"Attempt to retry collecting payment on the customer's unpaid invoices.\"\"\" self . _sync_invoices () for invoice in self . invoices . filter ( auto_advance = True ) . exclude ( status = \"paid\" ): try : invoice . retry () # Always retry unpaid invoices except InvalidRequestError as exc : if str ( exc ) != \"Invoice is already paid\" : raise","title":"retry_unpaid_invoices()"},{"location":"reference/models/#djstripe.models.core.Customer.send_invoice","text":"Pay and send the customer's latest invoice. :returns: True if an invoice was able to be created and paid, False otherwise (typically if there was nothing to invoice). Source code in djstripe/models/core.py def send_invoice ( self ): \"\"\" Pay and send the customer's latest invoice. :returns: True if an invoice was able to be created and paid, False otherwise (typically if there was nothing to invoice). \"\"\" from .billing import Invoice try : invoice = Invoice . _api_create ( customer = self . id ) invoice . pay () return True except InvalidRequestError : # TODO: Check this for a more # specific error message. return False # There was nothing to invoice","title":"send_invoice()"},{"location":"reference/models/#djstripe.models.core.Customer.subscribe","text":"Subscribes this customer to all the prices or plans in the items dict (Recommended). :param items: A list of up to 20 subscription items, each with an attached price :type list: :param items: A dictionary of Plan (or Plan ID) or Price (or Price ID) :type dict: The price or plan to which to subscribe the customer. :param price: The price to which to subscribe the customer. :type price: Price or string (price ID) :param plan: The plan to which to subscribe the customer. :type plan: Plan or string (plan ID) Source code in djstripe/models/core.py def subscribe ( self , * , items = None , price = None , plan = None , ** kwargs ): \"\"\" Subscribes this customer to all the prices or plans in the items dict (Recommended). :param items: A list of up to 20 subscription items, each with an attached price :type list: :param items: A dictionary of Plan (or Plan ID) or Price (or Price ID) :type dict: The price or plan to which to subscribe the customer. :param price: The price to which to subscribe the customer. :type price: Price or string (price ID) :param plan: The plan to which to subscribe the customer. :type plan: Plan or string (plan ID) \"\"\" from .billing import Subscription if ( items and price ) or ( items and plan ) or ( price and plan ): raise TypeError ( \"Please define only one of items, price or plan arguments.\" ) if items is None : _items = [{ \"price\" : price }] else : _items = [] for item in items : price = item . get ( \"price\" , \"\" ) plan = item . get ( \"plan\" , \"\" ) price , kwargs = _sanitise_price ( price , plan , ** kwargs ) if \"price\" in item : _items . append ({ \"price\" : price }) if \"plan\" in item : _items . append ({ \"plan\" : price }) stripe_subscription = Subscription . _api_create ( items = _items , customer = self . id , ** kwargs ) Subscription . sync_from_stripe_data ( stripe_subscription )","title":"subscribe()"},{"location":"reference/models/#djstripe.models.core.Customer.upcoming_invoice","text":"Gets the upcoming preview invoice (singular) for this customer. See Invoice.upcoming() <#djstripe.Invoice.upcoming> __. The customer argument to the upcoming() call is automatically set by this method. Source code in djstripe/models/core.py def upcoming_invoice ( self , ** kwargs ): \"\"\"Gets the upcoming preview invoice (singular) for this customer. See `Invoice.upcoming() <#djstripe.Invoice.upcoming>`__. The ``customer`` argument to the ``upcoming()`` call is automatically set by this method. \"\"\" from .billing import Invoice kwargs [ \"customer\" ] = self return Invoice . upcoming ( ** kwargs )","title":"upcoming_invoice()"},{"location":"reference/models/#djstripe.models.core.Dispute","text":"A dispute occurs when a customer questions your charge with their card issuer. When this happens, you're given the opportunity to respond to the dispute with evidence that shows that the charge is legitimate Stripe documentation: https://stripe.com/docs/api#disputes","title":"Dispute"},{"location":"reference/models/#djstripe.models.core.Dispute.amount","text":"","title":"amount"},{"location":"reference/models/#djstripe.models.core.Dispute.balance_transaction","text":"","title":"balance_transaction"},{"location":"reference/models/#djstripe.models.core.Dispute.balance_transactions","text":"","title":"balance_transactions"},{"location":"reference/models/#djstripe.models.core.Dispute.charge","text":"","title":"charge"},{"location":"reference/models/#djstripe.models.core.Dispute.currency","text":"","title":"currency"},{"location":"reference/models/#djstripe.models.core.Dispute.djstripe_owner_account","text":"","title":"djstripe_owner_account"},{"location":"reference/models/#djstripe.models.core.Dispute.evidence","text":"","title":"evidence"},{"location":"reference/models/#djstripe.models.core.Dispute.evidence_details","text":"","title":"evidence_details"},{"location":"reference/models/#djstripe.models.core.Dispute.is_charge_refundable","text":"","title":"is_charge_refundable"},{"location":"reference/models/#djstripe.models.core.Dispute.payment_intent","text":"","title":"payment_intent"},{"location":"reference/models/#djstripe.models.core.Dispute.reason","text":"","title":"reason"},{"location":"reference/models/#djstripe.models.core.Dispute.status","text":"","title":"status"},{"location":"reference/models/#djstripe.models.core.Dispute.stripe_dashboard_item_name","text":"","title":"stripe_dashboard_item_name"},{"location":"reference/models/#djstripe.models.core.Dispute.DoesNotExist","text":"","title":"DoesNotExist"},{"location":"reference/models/#djstripe.models.core.Dispute.MultipleObjectsReturned","text":"","title":"MultipleObjectsReturned"},{"location":"reference/models/#djstripe.models.core.Dispute.stripe_class","text":"djstripe . models . core . Dispute . stripe_class . OBJECT_NAME djstripe . models . core . Dispute . stripe_class . close ( self , idempotency_key = None , ** params ) Source code in djstripe/models/core.py def close ( self , idempotency_key = None , ** params ): url = self . instance_url () + \"/close\" headers = util . populate_headers ( idempotency_key ) self . refresh_from ( self . request ( \"post\" , url , params , headers )) return self","title":"stripe_class"},{"location":"reference/models/#djstripe.models.core.Dispute.__str__","text":"Source code in djstripe/models/core.py def __str__ ( self ): return f \" { self . human_readable_amount } ( { enums . DisputeStatus . humanize ( self . status ) } ) \"","title":"__str__()"},{"location":"reference/models/#djstripe.models.core.Dispute.get_next_by_djstripe_created","text":"Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_next_by_djstripe_created()"},{"location":"reference/models/#djstripe.models.core.Dispute.get_next_by_djstripe_updated","text":"Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_next_by_djstripe_updated()"},{"location":"reference/models/#djstripe.models.core.Dispute.get_previous_by_djstripe_created","text":"Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_previous_by_djstripe_created()"},{"location":"reference/models/#djstripe.models.core.Dispute.get_previous_by_djstripe_updated","text":"Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_previous_by_djstripe_updated()"},{"location":"reference/models/#djstripe.models.core.Dispute.get_reason_display","text":"Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_reason_display()"},{"location":"reference/models/#djstripe.models.core.Dispute.get_status_display","text":"Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_status_display()"},{"location":"reference/models/#djstripe.models.core.Event","text":"Events are Stripe's way of letting you know when something interesting happens in your account. When an interesting event occurs, a new Event object is created and POSTed to the configured webhook URL if the Event type matches. Stripe documentation: https://stripe.com/docs/api/events","title":"Event"},{"location":"reference/models/#djstripe.models.core.Event.api_version","text":"","title":"api_version"},{"location":"reference/models/#djstripe.models.core.Event.customer","text":"","title":"customer"},{"location":"reference/models/#djstripe.models.core.Event.data","text":"","title":"data"},{"location":"reference/models/#djstripe.models.core.Event.djstripe_owner_account","text":"","title":"djstripe_owner_account"},{"location":"reference/models/#djstripe.models.core.Event.idempotency_key","text":"","title":"idempotency_key"},{"location":"reference/models/#djstripe.models.core.Event.request_id","text":"","title":"request_id"},{"location":"reference/models/#djstripe.models.core.Event.stripe_dashboard_item_name","text":"","title":"stripe_dashboard_item_name"},{"location":"reference/models/#djstripe.models.core.Event.type","text":"","title":"type"},{"location":"reference/models/#djstripe.models.core.Event.DoesNotExist","text":"","title":"DoesNotExist"},{"location":"reference/models/#djstripe.models.core.Event.MultipleObjectsReturned","text":"","title":"MultipleObjectsReturned"},{"location":"reference/models/#djstripe.models.core.Event.stripe_class","text":"","title":"stripe_class"},{"location":"reference/models/#djstripe.models.core.Event-methods","text":"","title":"Methods"},{"location":"reference/models/#djstripe.models.core.Event.__str__","text":"Source code in djstripe/models/core.py def __str__ ( self ): return f \"type= { self . type } , id= { self . id } \"","title":"__str__()"},{"location":"reference/models/#djstripe.models.core.Event.get_next_by_djstripe_created","text":"Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_next_by_djstripe_created()"},{"location":"reference/models/#djstripe.models.core.Event.get_next_by_djstripe_updated","text":"Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_next_by_djstripe_updated()"},{"location":"reference/models/#djstripe.models.core.Event.get_previous_by_djstripe_created","text":"Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_previous_by_djstripe_created()"},{"location":"reference/models/#djstripe.models.core.Event.get_previous_by_djstripe_updated","text":"Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_previous_by_djstripe_updated()"},{"location":"reference/models/#djstripe.models.core.Event.invoke_webhook_handlers","text":"Invokes any webhook handlers that have been registered for this event based on event type or event sub-type. See event handlers registered in the djstripe.event_handlers module (or handlers registered in djstripe plugins or contrib packages). Source code in djstripe/models/core.py def invoke_webhook_handlers ( self ): \"\"\" Invokes any webhook handlers that have been registered for this event based on event type or event sub-type. See event handlers registered in the ``djstripe.event_handlers`` module (or handlers registered in djstripe plugins or contrib packages). \"\"\" webhooks . call_handlers ( event = self ) signal = WEBHOOK_SIGNALS . get ( self . type ) if signal : return signal . send ( sender = Event , event = self )","title":"invoke_webhook_handlers()"},{"location":"reference/models/#djstripe.models.core.Event.process","text":"Source code in djstripe/models/core.py @classmethod def process ( cls , data ): qs = cls . objects . filter ( id = data [ \"id\" ]) if qs . exists (): return qs . first () # Rollback any DB operations in the case of failure so # we will retry creating and processing the event the # next time the webhook fires. with transaction . atomic (): # process the event and create an Event Object ret = cls . _create_from_stripe_object ( data ) ret . invoke_webhook_handlers () return ret","title":"process()"},{"location":"reference/models/#djstripe.models.core.File","text":"Stripe documentation: https://stripe.com/docs/api/files","title":"File"},{"location":"reference/models/#djstripe.models.core.File.djstripe_owner_account","text":"","title":"djstripe_owner_account"},{"location":"reference/models/#djstripe.models.core.File.filename","text":"","title":"filename"},{"location":"reference/models/#djstripe.models.core.File.purpose","text":"","title":"purpose"},{"location":"reference/models/#djstripe.models.core.File.size","text":"","title":"size"},{"location":"reference/models/#djstripe.models.core.File.type","text":"","title":"type"},{"location":"reference/models/#djstripe.models.core.File.url","text":"","title":"url"},{"location":"reference/models/#djstripe.models.core.File.DoesNotExist","text":"","title":"DoesNotExist"},{"location":"reference/models/#djstripe.models.core.File.MultipleObjectsReturned","text":"","title":"MultipleObjectsReturned"},{"location":"reference/models/#djstripe.models.core.File.stripe_class","text":"djstripe . models . core . File . stripe_class . OBJECT_NAME djstripe . models . core . File . stripe_class . OBJECT_NAME_ALT djstripe . models . core . File . stripe_class . class_url () classmethod Source code in djstripe/models/core.py @classmethod def class_url ( cls ): return \"/v1/files\" djstripe . models . core . File . stripe_class . create ( api_key = None , api_version = None , stripe_version = None , stripe_account = None , ** params ) classmethod Source code in djstripe/models/core.py @classmethod def create ( # 'api_version' is deprecated, please use 'stripe_version' cls , api_key = None , api_version = None , stripe_version = None , stripe_account = None , ** params ): version = api_version or stripe_version requestor = api_requestor . APIRequestor ( api_key , api_base = stripe . upload_api_base , api_version = version , account = stripe_account , ) url = cls . class_url () supplied_headers = { \"Content-Type\" : \"multipart/form-data\" } response , api_key = requestor . request ( \"post\" , url , params = params , headers = supplied_headers ) return util . convert_to_stripe_object ( response , api_key , version , stripe_account )","title":"stripe_class"},{"location":"reference/models/#djstripe.models.core.File-methods","text":"","title":"Methods"},{"location":"reference/models/#djstripe.models.core.File.__str__","text":"Source code in djstripe/models/core.py def __str__ ( self ): return f \" { self . filename } , { enums . FilePurpose . humanize ( self . purpose ) } \"","title":"__str__()"},{"location":"reference/models/#djstripe.models.core.File.get_next_by_djstripe_created","text":"Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_next_by_djstripe_created()"},{"location":"reference/models/#djstripe.models.core.File.get_next_by_djstripe_updated","text":"Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_next_by_djstripe_updated()"},{"location":"reference/models/#djstripe.models.core.File.get_previous_by_djstripe_created","text":"Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_previous_by_djstripe_created()"},{"location":"reference/models/#djstripe.models.core.File.get_previous_by_djstripe_updated","text":"Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_previous_by_djstripe_updated()"},{"location":"reference/models/#djstripe.models.core.File.get_purpose_display","text":"Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_purpose_display()"},{"location":"reference/models/#djstripe.models.core.File.get_type_display","text":"Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_type_display()"},{"location":"reference/models/#djstripe.models.core.File.is_valid_object","text":"Returns whether the data is a valid object for the class Source code in djstripe/models/core.py @classmethod def is_valid_object ( cls , data ): return \"object\" in data and data [ \"object\" ] in ( \"file\" , \"file_upload\" )","title":"is_valid_object()"},{"location":"reference/models/#djstripe.models.core.FileLink","text":"Stripe documentation: https://stripe.com/docs/api/file_links","title":"FileLink"},{"location":"reference/models/#djstripe.models.core.FileLink.djstripe_owner_account","text":"","title":"djstripe_owner_account"},{"location":"reference/models/#djstripe.models.core.FileLink.expires_at","text":"","title":"expires_at"},{"location":"reference/models/#djstripe.models.core.FileLink.file","text":"","title":"file"},{"location":"reference/models/#djstripe.models.core.FileLink.url","text":"","title":"url"},{"location":"reference/models/#djstripe.models.core.FileLink.DoesNotExist","text":"","title":"DoesNotExist"},{"location":"reference/models/#djstripe.models.core.FileLink.MultipleObjectsReturned","text":"","title":"MultipleObjectsReturned"},{"location":"reference/models/#djstripe.models.core.FileLink.stripe_class","text":"","title":"stripe_class"},{"location":"reference/models/#djstripe.models.core.FileLink.__str__","text":"Source code in djstripe/models/core.py def __str__ ( self ): return f \" { self . file . filename } , { self . url } \"","title":"__str__()"},{"location":"reference/models/#djstripe.models.core.FileLink.get_next_by_djstripe_created","text":"Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_next_by_djstripe_created()"},{"location":"reference/models/#djstripe.models.core.FileLink.get_next_by_djstripe_updated","text":"Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_next_by_djstripe_updated()"},{"location":"reference/models/#djstripe.models.core.FileLink.get_previous_by_djstripe_created","text":"Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_previous_by_djstripe_created()"},{"location":"reference/models/#djstripe.models.core.FileLink.get_previous_by_djstripe_updated","text":"Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_previous_by_djstripe_updated()"},{"location":"reference/models/#djstripe.models.core.FileUpload","text":"Stripe documentation: https://stripe.com/docs/api/files","title":"FileUpload"},{"location":"reference/models/#djstripe.models.core.FileUpload.djstripe_owner_account","text":"","title":"djstripe_owner_account"},{"location":"reference/models/#djstripe.models.core.FileUpload.filename","text":"","title":"filename"},{"location":"reference/models/#djstripe.models.core.FileUpload.purpose","text":"","title":"purpose"},{"location":"reference/models/#djstripe.models.core.FileUpload.size","text":"","title":"size"},{"location":"reference/models/#djstripe.models.core.FileUpload.type","text":"","title":"type"},{"location":"reference/models/#djstripe.models.core.FileUpload.url","text":"","title":"url"},{"location":"reference/models/#djstripe.models.core.FileUpload.DoesNotExist","text":"","title":"DoesNotExist"},{"location":"reference/models/#djstripe.models.core.FileUpload.MultipleObjectsReturned","text":"","title":"MultipleObjectsReturned"},{"location":"reference/models/#djstripe.models.core.FileUpload.stripe_class","text":"djstripe . models . core . FileUpload . stripe_class . OBJECT_NAME djstripe . models . core . FileUpload . stripe_class . OBJECT_NAME_ALT djstripe . models . core . FileUpload . stripe_class . class_url () classmethod Source code in djstripe/models/core.py @classmethod def class_url ( cls ): return \"/v1/files\" djstripe . models . core . FileUpload . stripe_class . create ( api_key = None , api_version = None , stripe_version = None , stripe_account = None , ** params ) classmethod Source code in djstripe/models/core.py @classmethod def create ( # 'api_version' is deprecated, please use 'stripe_version' cls , api_key = None , api_version = None , stripe_version = None , stripe_account = None , ** params ): version = api_version or stripe_version requestor = api_requestor . APIRequestor ( api_key , api_base = stripe . upload_api_base , api_version = version , account = stripe_account , ) url = cls . class_url () supplied_headers = { \"Content-Type\" : \"multipart/form-data\" } response , api_key = requestor . request ( \"post\" , url , params = params , headers = supplied_headers ) return util . convert_to_stripe_object ( response , api_key , version , stripe_account )","title":"stripe_class"},{"location":"reference/models/#djstripe.models.core.FileUpload-methods","text":"","title":"Methods"},{"location":"reference/models/#djstripe.models.core.FileUpload.__str__","text":"Source code in djstripe/models/core.py def __str__ ( self ): return f \" { self . filename } , { enums . FilePurpose . humanize ( self . purpose ) } \"","title":"__str__()"},{"location":"reference/models/#djstripe.models.core.FileUpload.get_next_by_djstripe_created","text":"Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_next_by_djstripe_created()"},{"location":"reference/models/#djstripe.models.core.FileUpload.get_next_by_djstripe_updated","text":"Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_next_by_djstripe_updated()"},{"location":"reference/models/#djstripe.models.core.FileUpload.get_previous_by_djstripe_created","text":"Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_previous_by_djstripe_created()"},{"location":"reference/models/#djstripe.models.core.FileUpload.get_previous_by_djstripe_updated","text":"Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_previous_by_djstripe_updated()"},{"location":"reference/models/#djstripe.models.core.FileUpload.get_purpose_display","text":"Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_purpose_display()"},{"location":"reference/models/#djstripe.models.core.FileUpload.get_type_display","text":"Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_type_display()"},{"location":"reference/models/#djstripe.models.core.FileUpload.is_valid_object","text":"Returns whether the data is a valid object for the class Source code in djstripe/models/core.py @classmethod def is_valid_object ( cls , data ): return \"object\" in data and data [ \"object\" ] in ( \"file\" , \"file_upload\" )","title":"is_valid_object()"},{"location":"reference/models/#djstripe.models.core.Mandate","text":"https://stripe.com/docs/api/mandates","title":"Mandate"},{"location":"reference/models/#djstripe.models.core.Mandate.customer_acceptance","text":"","title":"customer_acceptance"},{"location":"reference/models/#djstripe.models.core.Mandate.djstripe_owner_account","text":"","title":"djstripe_owner_account"},{"location":"reference/models/#djstripe.models.core.Mandate.multi_use","text":"","title":"multi_use"},{"location":"reference/models/#djstripe.models.core.Mandate.payment_method","text":"","title":"payment_method"},{"location":"reference/models/#djstripe.models.core.Mandate.payment_method_details","text":"","title":"payment_method_details"},{"location":"reference/models/#djstripe.models.core.Mandate.single_use","text":"","title":"single_use"},{"location":"reference/models/#djstripe.models.core.Mandate.status","text":"","title":"status"},{"location":"reference/models/#djstripe.models.core.Mandate.type","text":"","title":"type"},{"location":"reference/models/#djstripe.models.core.Mandate.DoesNotExist","text":"","title":"DoesNotExist"},{"location":"reference/models/#djstripe.models.core.Mandate.MultipleObjectsReturned","text":"","title":"MultipleObjectsReturned"},{"location":"reference/models/#djstripe.models.core.Mandate.stripe_class","text":"","title":"stripe_class"},{"location":"reference/models/#djstripe.models.core.Mandate.get_next_by_djstripe_created","text":"Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_next_by_djstripe_created()"},{"location":"reference/models/#djstripe.models.core.Mandate.get_next_by_djstripe_updated","text":"Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_next_by_djstripe_updated()"},{"location":"reference/models/#djstripe.models.core.Mandate.get_previous_by_djstripe_created","text":"Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_previous_by_djstripe_created()"},{"location":"reference/models/#djstripe.models.core.Mandate.get_previous_by_djstripe_updated","text":"Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_previous_by_djstripe_updated()"},{"location":"reference/models/#djstripe.models.core.Mandate.get_status_display","text":"Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_status_display()"},{"location":"reference/models/#djstripe.models.core.Mandate.get_type_display","text":"Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_type_display()"},{"location":"reference/models/#djstripe.models.core.PaymentIntent","text":"Stripe documentation: https://stripe.com/docs/api#payment_intents","title":"PaymentIntent"},{"location":"reference/models/#djstripe.models.core.PaymentIntent.amount","text":"","title":"amount"},{"location":"reference/models/#djstripe.models.core.PaymentIntent.amount_capturable","text":"","title":"amount_capturable"},{"location":"reference/models/#djstripe.models.core.PaymentIntent.amount_received","text":"","title":"amount_received"},{"location":"reference/models/#djstripe.models.core.PaymentIntent.canceled_at","text":"","title":"canceled_at"},{"location":"reference/models/#djstripe.models.core.PaymentIntent.cancellation_reason","text":"","title":"cancellation_reason"},{"location":"reference/models/#djstripe.models.core.PaymentIntent.capture_method","text":"","title":"capture_method"},{"location":"reference/models/#djstripe.models.core.PaymentIntent.client_secret","text":"","title":"client_secret"},{"location":"reference/models/#djstripe.models.core.PaymentIntent.confirmation_method","text":"","title":"confirmation_method"},{"location":"reference/models/#djstripe.models.core.PaymentIntent.currency","text":"","title":"currency"},{"location":"reference/models/#djstripe.models.core.PaymentIntent.customer","text":"","title":"customer"},{"location":"reference/models/#djstripe.models.core.PaymentIntent.djstripe_owner_account","text":"","title":"djstripe_owner_account"},{"location":"reference/models/#djstripe.models.core.PaymentIntent.last_payment_error","text":"","title":"last_payment_error"},{"location":"reference/models/#djstripe.models.core.PaymentIntent.next_action","text":"","title":"next_action"},{"location":"reference/models/#djstripe.models.core.PaymentIntent.on_behalf_of","text":"","title":"on_behalf_of"},{"location":"reference/models/#djstripe.models.core.PaymentIntent.payment_method","text":"","title":"payment_method"},{"location":"reference/models/#djstripe.models.core.PaymentIntent.payment_method_types","text":"","title":"payment_method_types"},{"location":"reference/models/#djstripe.models.core.PaymentIntent.receipt_email","text":"","title":"receipt_email"},{"location":"reference/models/#djstripe.models.core.PaymentIntent.setup_future_usage","text":"","title":"setup_future_usage"},{"location":"reference/models/#djstripe.models.core.PaymentIntent.shipping","text":"","title":"shipping"},{"location":"reference/models/#djstripe.models.core.PaymentIntent.statement_descriptor","text":"","title":"statement_descriptor"},{"location":"reference/models/#djstripe.models.core.PaymentIntent.status","text":"","title":"status"},{"location":"reference/models/#djstripe.models.core.PaymentIntent.stripe_dashboard_item_name","text":"","title":"stripe_dashboard_item_name"},{"location":"reference/models/#djstripe.models.core.PaymentIntent.transfer_data","text":"","title":"transfer_data"},{"location":"reference/models/#djstripe.models.core.PaymentIntent.transfer_group","text":"","title":"transfer_group"},{"location":"reference/models/#djstripe.models.core.PaymentIntent.DoesNotExist","text":"","title":"DoesNotExist"},{"location":"reference/models/#djstripe.models.core.PaymentIntent.MultipleObjectsReturned","text":"","title":"MultipleObjectsReturned"},{"location":"reference/models/#djstripe.models.core.PaymentIntent.stripe_class","text":"djstripe . models . core . PaymentIntent . stripe_class . OBJECT_NAME djstripe . models . core . PaymentIntent . stripe_class . cancel ( self , idempotency_key = None , ** params ) Source code in djstripe/models/core.py def cancel ( self , idempotency_key = None , ** params ): url = self . instance_url () + \"/cancel\" headers = util . populate_headers ( idempotency_key ) self . refresh_from ( self . request ( \"post\" , url , params , headers )) return self djstripe . models . core . PaymentIntent . stripe_class . capture ( self , idempotency_key = None , ** params ) Source code in djstripe/models/core.py def capture ( self , idempotency_key = None , ** params ): url = self . instance_url () + \"/capture\" headers = util . populate_headers ( idempotency_key ) self . refresh_from ( self . request ( \"post\" , url , params , headers )) return self djstripe . models . core . PaymentIntent . stripe_class . confirm ( self , idempotency_key = None , ** params ) Source code in djstripe/models/core.py def confirm ( self , idempotency_key = None , ** params ): url = self . instance_url () + \"/confirm\" headers = util . populate_headers ( idempotency_key ) self . refresh_from ( self . request ( \"post\" , url , params , headers )) return self","title":"stripe_class"},{"location":"reference/models/#djstripe.models.core.PaymentIntent-methods","text":"","title":"Methods"},{"location":"reference/models/#djstripe.models.core.PaymentIntent.__str__","text":"Source code in djstripe/models/core.py def __str__ ( self ): account = self . on_behalf_of customer = self . customer if account and customer : return ( f \" { self . human_readable_amount } ( { enums . PaymentIntentStatus . humanize ( self . status ) } ) \" f \"for { account } \" f \"by { customer } \" ) if account : return f \" { self . human_readable_amount } for { account } . { enums . PaymentIntentStatus . humanize ( self . status ) } \" if customer : return f \" { self . human_readable_amount } by { customer } . { enums . PaymentIntentStatus . humanize ( self . status ) } \" return f \" { self . human_readable_amount } ( { enums . PaymentIntentStatus . humanize ( self . status ) } )\"","title":"__str__()"},{"location":"reference/models/#djstripe.models.core.PaymentIntent.get_cancellation_reason_display","text":"Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_cancellation_reason_display()"},{"location":"reference/models/#djstripe.models.core.PaymentIntent.get_capture_method_display","text":"Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_capture_method_display()"},{"location":"reference/models/#djstripe.models.core.PaymentIntent.get_confirmation_method_display","text":"Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_confirmation_method_display()"},{"location":"reference/models/#djstripe.models.core.PaymentIntent.get_next_by_djstripe_created","text":"Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_next_by_djstripe_created()"},{"location":"reference/models/#djstripe.models.core.PaymentIntent.get_next_by_djstripe_updated","text":"Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_next_by_djstripe_updated()"},{"location":"reference/models/#djstripe.models.core.PaymentIntent.get_previous_by_djstripe_created","text":"Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_previous_by_djstripe_created()"},{"location":"reference/models/#djstripe.models.core.PaymentIntent.get_previous_by_djstripe_updated","text":"Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_previous_by_djstripe_updated()"},{"location":"reference/models/#djstripe.models.core.PaymentIntent.get_setup_future_usage_display","text":"Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_setup_future_usage_display()"},{"location":"reference/models/#djstripe.models.core.PaymentIntent.get_status_display","text":"Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_status_display()"},{"location":"reference/models/#djstripe.models.core.PaymentIntent.update","text":"Call the stripe API's modify operation for this model :param api_key: The api key to use for this request. Defaults to djstripe_settings.STRIPE_SECRET_KEY. :type api_key: string Source code in djstripe/models/core.py def update ( self , api_key = None , ** kwargs ): \"\"\" Call the stripe API's modify operation for this model :param api_key: The api key to use for this request. Defaults to djstripe_settings.STRIPE_SECRET_KEY. :type api_key: string \"\"\" api_key = api_key or self . default_api_key response = self . api_retrieve ( api_key = api_key ) return response . modify ( response . stripe_id , api_key = api_key , ** kwargs )","title":"update()"},{"location":"reference/models/#djstripe.models.core.Payout","text":"A Payout object is created when you receive funds from Stripe, or when you initiate a payout to either a bank account or debit card of a connected Stripe account. Stripe documentation: https://stripe.com/docs/api#payouts","title":"Payout"},{"location":"reference/models/#djstripe.models.core.Payout.amount","text":"","title":"amount"},{"location":"reference/models/#djstripe.models.core.Payout.arrival_date","text":"","title":"arrival_date"},{"location":"reference/models/#djstripe.models.core.Payout.automatic","text":"","title":"automatic"},{"location":"reference/models/#djstripe.models.core.Payout.balance_transaction","text":"","title":"balance_transaction"},{"location":"reference/models/#djstripe.models.core.Payout.currency","text":"","title":"currency"},{"location":"reference/models/#djstripe.models.core.Payout.destination","text":"","title":"destination"},{"location":"reference/models/#djstripe.models.core.Payout.djstripe_owner_account","text":"","title":"djstripe_owner_account"},{"location":"reference/models/#djstripe.models.core.Payout.expand_fields","text":"","title":"expand_fields"},{"location":"reference/models/#djstripe.models.core.Payout.failure_balance_transaction","text":"","title":"failure_balance_transaction"},{"location":"reference/models/#djstripe.models.core.Payout.failure_code","text":"","title":"failure_code"},{"location":"reference/models/#djstripe.models.core.Payout.failure_message","text":"","title":"failure_message"},{"location":"reference/models/#djstripe.models.core.Payout.method","text":"","title":"method"},{"location":"reference/models/#djstripe.models.core.Payout.source_type","text":"","title":"source_type"},{"location":"reference/models/#djstripe.models.core.Payout.statement_descriptor","text":"","title":"statement_descriptor"},{"location":"reference/models/#djstripe.models.core.Payout.status","text":"","title":"status"},{"location":"reference/models/#djstripe.models.core.Payout.stripe_dashboard_item_name","text":"","title":"stripe_dashboard_item_name"},{"location":"reference/models/#djstripe.models.core.Payout.type","text":"","title":"type"},{"location":"reference/models/#djstripe.models.core.Payout.DoesNotExist","text":"","title":"DoesNotExist"},{"location":"reference/models/#djstripe.models.core.Payout.MultipleObjectsReturned","text":"","title":"MultipleObjectsReturned"},{"location":"reference/models/#djstripe.models.core.Payout.stripe_class","text":"djstripe . models . core . Payout . stripe_class . OBJECT_NAME djstripe . models . core . Payout . stripe_class . cancel ( self , idempotency_key = None , ** params ) Source code in djstripe/models/core.py def cancel ( self , idempotency_key = None , ** params ): url = self . instance_url () + \"/cancel\" headers = util . populate_headers ( idempotency_key ) self . refresh_from ( self . request ( \"post\" , url , params , headers )) return self djstripe . models . core . Payout . stripe_class . reverse ( self , idempotency_key = None , ** params ) Source code in djstripe/models/core.py def reverse ( self , idempotency_key = None , ** params ): url = self . instance_url () + \"/reverse\" headers = util . populate_headers ( idempotency_key ) self . refresh_from ( self . request ( \"post\" , url , params , headers )) return self","title":"stripe_class"},{"location":"reference/models/#djstripe.models.core.Payout.__str__","text":"Source code in djstripe/models/core.py def __str__ ( self ): return f \" { self . amount } ( { enums . PayoutStatus . humanize ( self . status ) } )\"","title":"__str__()"},{"location":"reference/models/#djstripe.models.core.Payout.get_failure_code_display","text":"Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_failure_code_display()"},{"location":"reference/models/#djstripe.models.core.Payout.get_method_display","text":"Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_method_display()"},{"location":"reference/models/#djstripe.models.core.Payout.get_next_by_arrival_date","text":"Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_next_by_arrival_date()"},{"location":"reference/models/#djstripe.models.core.Payout.get_next_by_djstripe_created","text":"Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_next_by_djstripe_created()"},{"location":"reference/models/#djstripe.models.core.Payout.get_next_by_djstripe_updated","text":"Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_next_by_djstripe_updated()"},{"location":"reference/models/#djstripe.models.core.Payout.get_previous_by_arrival_date","text":"Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_previous_by_arrival_date()"},{"location":"reference/models/#djstripe.models.core.Payout.get_previous_by_djstripe_created","text":"Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_previous_by_djstripe_created()"},{"location":"reference/models/#djstripe.models.core.Payout.get_previous_by_djstripe_updated","text":"Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_previous_by_djstripe_updated()"},{"location":"reference/models/#djstripe.models.core.Payout.get_source_type_display","text":"Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_source_type_display()"},{"location":"reference/models/#djstripe.models.core.Payout.get_status_display","text":"Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_status_display()"},{"location":"reference/models/#djstripe.models.core.Payout.get_type_display","text":"Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_type_display()"},{"location":"reference/models/#djstripe.models.core.Price","text":"Prices define the unit cost, currency, and (optional) billing cycle for both recurring and one-time purchases of products. Price and Plan objects are the same, but use a different representation. Creating a recurring Price in Stripe also makes a Plan available, and vice versa. This is not the case for a Price with interval=one_time. Price objects are a more recent API representation, support more features and its usage is encouraged instead of Plan objects. Stripe documentation: - https://stripe.com/docs/api/prices - https://stripe.com/docs/billing/prices-guide","title":"Price"},{"location":"reference/models/#djstripe.models.core.Price.active","text":"","title":"active"},{"location":"reference/models/#djstripe.models.core.Price.billing_scheme","text":"","title":"billing_scheme"},{"location":"reference/models/#djstripe.models.core.Price.currency","text":"","title":"currency"},{"location":"reference/models/#djstripe.models.core.Price.djstripe_owner_account","text":"","title":"djstripe_owner_account"},{"location":"reference/models/#djstripe.models.core.Price.expand_fields","text":"","title":"expand_fields"},{"location":"reference/models/#djstripe.models.core.Price.human_readable_price","text":"","title":"human_readable_price"},{"location":"reference/models/#djstripe.models.core.Price.lookup_key","text":"","title":"lookup_key"},{"location":"reference/models/#djstripe.models.core.Price.nickname","text":"","title":"nickname"},{"location":"reference/models/#djstripe.models.core.Price.product","text":"","title":"product"},{"location":"reference/models/#djstripe.models.core.Price.recurring","text":"","title":"recurring"},{"location":"reference/models/#djstripe.models.core.Price.stripe_dashboard_item_name","text":"","title":"stripe_dashboard_item_name"},{"location":"reference/models/#djstripe.models.core.Price.tiers","text":"","title":"tiers"},{"location":"reference/models/#djstripe.models.core.Price.tiers_mode","text":"","title":"tiers_mode"},{"location":"reference/models/#djstripe.models.core.Price.transform_quantity","text":"","title":"transform_quantity"},{"location":"reference/models/#djstripe.models.core.Price.type","text":"","title":"type"},{"location":"reference/models/#djstripe.models.core.Price.unit_amount","text":"","title":"unit_amount"},{"location":"reference/models/#djstripe.models.core.Price.unit_amount_decimal","text":"","title":"unit_amount_decimal"},{"location":"reference/models/#djstripe.models.core.Price.DoesNotExist","text":"","title":"DoesNotExist"},{"location":"reference/models/#djstripe.models.core.Price.MultipleObjectsReturned","text":"","title":"MultipleObjectsReturned"},{"location":"reference/models/#djstripe.models.core.Price.stripe_class","text":"","title":"stripe_class"},{"location":"reference/models/#djstripe.models.core.Price-methods","text":"","title":"Methods"},{"location":"reference/models/#djstripe.models.core.Price.__str__","text":"Source code in djstripe/models/core.py def __str__ ( self ): from .billing import Subscription subscriptions = Subscription . objects . filter ( plan__id = self . id ) . count () if self . recurring : return f \" { self . human_readable_price } for { self . product . name } ( { subscriptions } subscriptions)\" return f \" { self . human_readable_price } for { self . product . name } \"","title":"__str__()"},{"location":"reference/models/#djstripe.models.core.Price.create","text":"Source code in djstripe/models/core.py @classmethod def create ( cls , ** kwargs ): # A few minor things are changed in the api-version of the create call api_kwargs = dict ( kwargs ) api_kwargs [ \"unit_amount\" ] = int ( api_kwargs [ \"unit_amount\" ] * 100 ) if isinstance ( api_kwargs . get ( \"product\" ), StripeModel ): api_kwargs [ \"product\" ] = api_kwargs [ \"product\" ] . id stripe_price = cls . _api_create ( ** api_kwargs ) price = cls . sync_from_stripe_data ( stripe_price ) return price","title":"create()"},{"location":"reference/models/#djstripe.models.core.Price.get_billing_scheme_display","text":"Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_billing_scheme_display()"},{"location":"reference/models/#djstripe.models.core.Price.get_next_by_djstripe_created","text":"Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_next_by_djstripe_created()"},{"location":"reference/models/#djstripe.models.core.Price.get_next_by_djstripe_updated","text":"Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_next_by_djstripe_updated()"},{"location":"reference/models/#djstripe.models.core.Price.get_or_create","text":"Get or create a Price. Source code in djstripe/models/core.py @classmethod def get_or_create ( cls , ** kwargs ): \"\"\"Get or create a Price.\"\"\" try : return Price . objects . get ( id = kwargs [ \"id\" ]), False except Price . DoesNotExist : return cls . create ( ** kwargs ), True","title":"get_or_create()"},{"location":"reference/models/#djstripe.models.core.Price.get_previous_by_djstripe_created","text":"Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_previous_by_djstripe_created()"},{"location":"reference/models/#djstripe.models.core.Price.get_previous_by_djstripe_updated","text":"Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_previous_by_djstripe_updated()"},{"location":"reference/models/#djstripe.models.core.Price.get_tiers_mode_display","text":"Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_tiers_mode_display()"},{"location":"reference/models/#djstripe.models.core.Price.get_type_display","text":"Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_type_display()"},{"location":"reference/models/#djstripe.models.core.Product","text":"Stripe documentation: - https://stripe.com/docs/api#products","title":"Product"},{"location":"reference/models/#djstripe.models.core.Product.active","text":"","title":"active"},{"location":"reference/models/#djstripe.models.core.Product.attributes","text":"","title":"attributes"},{"location":"reference/models/#djstripe.models.core.Product.caption","text":"","title":"caption"},{"location":"reference/models/#djstripe.models.core.Product.deactivate_on","text":"","title":"deactivate_on"},{"location":"reference/models/#djstripe.models.core.Product.djstripe_owner_account","text":"","title":"djstripe_owner_account"},{"location":"reference/models/#djstripe.models.core.Product.images","text":"","title":"images"},{"location":"reference/models/#djstripe.models.core.Product.name","text":"","title":"name"},{"location":"reference/models/#djstripe.models.core.Product.package_dimensions","text":"","title":"package_dimensions"},{"location":"reference/models/#djstripe.models.core.Product.shippable","text":"","title":"shippable"},{"location":"reference/models/#djstripe.models.core.Product.statement_descriptor","text":"","title":"statement_descriptor"},{"location":"reference/models/#djstripe.models.core.Product.stripe_dashboard_item_name","text":"","title":"stripe_dashboard_item_name"},{"location":"reference/models/#djstripe.models.core.Product.type","text":"","title":"type"},{"location":"reference/models/#djstripe.models.core.Product.unit_label","text":"","title":"unit_label"},{"location":"reference/models/#djstripe.models.core.Product.url","text":"","title":"url"},{"location":"reference/models/#djstripe.models.core.Product.DoesNotExist","text":"","title":"DoesNotExist"},{"location":"reference/models/#djstripe.models.core.Product.MultipleObjectsReturned","text":"","title":"MultipleObjectsReturned"},{"location":"reference/models/#djstripe.models.core.Product.stripe_class","text":"","title":"stripe_class"},{"location":"reference/models/#djstripe.models.core.Product.__str__","text":"Source code in djstripe/models/core.py def __str__ ( self ): # 1 product can have 1 or more than 1 related price price_qs = Price . objects . filter ( product__id = self . id ) price_count = price_qs . count () if price_count > 1 : return f \" { self . name } ( { price_count } prices)\" elif price_count == 1 : return f \" { self . name } ( { price_qs [ 0 ] . human_readable_price } )\" else : return self . name","title":"__str__()"},{"location":"reference/models/#djstripe.models.core.Product.get_next_by_djstripe_created","text":"Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_next_by_djstripe_created()"},{"location":"reference/models/#djstripe.models.core.Product.get_next_by_djstripe_updated","text":"Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_next_by_djstripe_updated()"},{"location":"reference/models/#djstripe.models.core.Product.get_previous_by_djstripe_created","text":"Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_previous_by_djstripe_created()"},{"location":"reference/models/#djstripe.models.core.Product.get_previous_by_djstripe_updated","text":"Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_previous_by_djstripe_updated()"},{"location":"reference/models/#djstripe.models.core.Product.get_type_display","text":"Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_type_display()"},{"location":"reference/models/#djstripe.models.core.Refund","text":"Stripe documentation: https://stripe.com/docs/api#refund_object","title":"Refund"},{"location":"reference/models/#djstripe.models.core.Refund.amount","text":"","title":"amount"},{"location":"reference/models/#djstripe.models.core.Refund.balance_transaction","text":"","title":"balance_transaction"},{"location":"reference/models/#djstripe.models.core.Refund.charge","text":"","title":"charge"},{"location":"reference/models/#djstripe.models.core.Refund.currency","text":"","title":"currency"},{"location":"reference/models/#djstripe.models.core.Refund.djstripe_owner_account","text":"","title":"djstripe_owner_account"},{"location":"reference/models/#djstripe.models.core.Refund.failure_balance_transaction","text":"","title":"failure_balance_transaction"},{"location":"reference/models/#djstripe.models.core.Refund.failure_reason","text":"","title":"failure_reason"},{"location":"reference/models/#djstripe.models.core.Refund.reason","text":"","title":"reason"},{"location":"reference/models/#djstripe.models.core.Refund.receipt_number","text":"","title":"receipt_number"},{"location":"reference/models/#djstripe.models.core.Refund.status","text":"","title":"status"},{"location":"reference/models/#djstripe.models.core.Refund.DoesNotExist","text":"","title":"DoesNotExist"},{"location":"reference/models/#djstripe.models.core.Refund.MultipleObjectsReturned","text":"","title":"MultipleObjectsReturned"},{"location":"reference/models/#djstripe.models.core.Refund.stripe_class","text":"","title":"stripe_class"},{"location":"reference/models/#djstripe.models.core.Refund-methods","text":"","title":"Methods"},{"location":"reference/models/#djstripe.models.core.Refund.__str__","text":"Source code in djstripe/models/core.py def __str__ ( self ): return ( f \" { self . human_readable_amount } ( { enums . RefundStatus . humanize ( self . status ) } )\" )","title":"__str__()"},{"location":"reference/models/#djstripe.models.core.Refund.get_failure_reason_display","text":"Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_failure_reason_display()"},{"location":"reference/models/#djstripe.models.core.Refund.get_next_by_djstripe_created","text":"Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_next_by_djstripe_created()"},{"location":"reference/models/#djstripe.models.core.Refund.get_next_by_djstripe_updated","text":"Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_next_by_djstripe_updated()"},{"location":"reference/models/#djstripe.models.core.Refund.get_previous_by_djstripe_created","text":"Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_previous_by_djstripe_created()"},{"location":"reference/models/#djstripe.models.core.Refund.get_previous_by_djstripe_updated","text":"Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_previous_by_djstripe_updated()"},{"location":"reference/models/#djstripe.models.core.Refund.get_reason_display","text":"Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_reason_display()"},{"location":"reference/models/#djstripe.models.core.Refund.get_status_display","text":"Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_status_display()"},{"location":"reference/models/#djstripe.models.core.Refund.get_stripe_dashboard_url","text":"Get the stripe dashboard url for this object. Source code in djstripe/models/core.py def get_stripe_dashboard_url ( self ): return self . charge . get_stripe_dashboard_url ()","title":"get_stripe_dashboard_url()"},{"location":"reference/models/#djstripe.models.core.SetupIntent","text":"A SetupIntent guides you through the process of setting up a customer's payment credentials for future payments. For example, you could use a SetupIntent to set up your customer's card without immediately collecting a payment. Later, you can use PaymentIntents to drive the payment flow. NOTE: You should not maintain long-lived, unconfirmed SetupIntents. For security purposes, SetupIntents older than 24 hours may no longer be valid. Stripe documentation: https://stripe.com/docs/api#setup_intents","title":"SetupIntent"},{"location":"reference/models/#djstripe.models.core.SetupIntent.application","text":"","title":"application"},{"location":"reference/models/#djstripe.models.core.SetupIntent.cancellation_reason","text":"","title":"cancellation_reason"},{"location":"reference/models/#djstripe.models.core.SetupIntent.client_secret","text":"","title":"client_secret"},{"location":"reference/models/#djstripe.models.core.SetupIntent.customer","text":"","title":"customer"},{"location":"reference/models/#djstripe.models.core.SetupIntent.djstripe_owner_account","text":"","title":"djstripe_owner_account"},{"location":"reference/models/#djstripe.models.core.SetupIntent.last_setup_error","text":"","title":"last_setup_error"},{"location":"reference/models/#djstripe.models.core.SetupIntent.next_action","text":"","title":"next_action"},{"location":"reference/models/#djstripe.models.core.SetupIntent.on_behalf_of","text":"","title":"on_behalf_of"},{"location":"reference/models/#djstripe.models.core.SetupIntent.payment_method","text":"","title":"payment_method"},{"location":"reference/models/#djstripe.models.core.SetupIntent.payment_method_types","text":"","title":"payment_method_types"},{"location":"reference/models/#djstripe.models.core.SetupIntent.status","text":"","title":"status"},{"location":"reference/models/#djstripe.models.core.SetupIntent.usage","text":"","title":"usage"},{"location":"reference/models/#djstripe.models.core.SetupIntent.DoesNotExist","text":"","title":"DoesNotExist"},{"location":"reference/models/#djstripe.models.core.SetupIntent.MultipleObjectsReturned","text":"","title":"MultipleObjectsReturned"},{"location":"reference/models/#djstripe.models.core.SetupIntent.stripe_class","text":"djstripe . models . core . SetupIntent . stripe_class . OBJECT_NAME djstripe . models . core . SetupIntent . stripe_class . cancel ( self , idempotency_key = None , ** params ) Source code in djstripe/models/core.py def cancel ( self , idempotency_key = None , ** params ): url = self . instance_url () + \"/cancel\" headers = util . populate_headers ( idempotency_key ) self . refresh_from ( self . request ( \"post\" , url , params , headers )) return self djstripe . models . core . SetupIntent . stripe_class . confirm ( self , idempotency_key = None , ** params ) Source code in djstripe/models/core.py def confirm ( self , idempotency_key = None , ** params ): url = self . instance_url () + \"/confirm\" headers = util . populate_headers ( idempotency_key ) self . refresh_from ( self . request ( \"post\" , url , params , headers )) return self","title":"stripe_class"},{"location":"reference/models/#djstripe.models.core.SetupIntent.__str__","text":"Source code in djstripe/models/core.py def __str__ ( self ): account = self . on_behalf_of customer = self . customer if account and customer : return ( f \" { self . payment_method } ( { enums . SetupIntentStatus . humanize ( self . status ) } ) \" f \"for { account } \" f \"by { customer } \" ) if account : return f \" { self . payment_method } for { account } . { enums . SetupIntentStatus . humanize ( self . status ) } \" if customer : return f \" { self . payment_method } by { customer } . { enums . SetupIntentStatus . humanize ( self . status ) } \" return ( f \" { self . payment_method } ( { enums . SetupIntentStatus . humanize ( self . status ) } )\" )","title":"__str__()"},{"location":"reference/models/#djstripe.models.core.SetupIntent.get_cancellation_reason_display","text":"Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_cancellation_reason_display()"},{"location":"reference/models/#djstripe.models.core.SetupIntent.get_next_by_djstripe_created","text":"Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_next_by_djstripe_created()"},{"location":"reference/models/#djstripe.models.core.SetupIntent.get_next_by_djstripe_updated","text":"Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_next_by_djstripe_updated()"},{"location":"reference/models/#djstripe.models.core.SetupIntent.get_previous_by_djstripe_created","text":"Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_previous_by_djstripe_created()"},{"location":"reference/models/#djstripe.models.core.SetupIntent.get_previous_by_djstripe_updated","text":"Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_previous_by_djstripe_updated()"},{"location":"reference/models/#djstripe.models.core.SetupIntent.get_status_display","text":"Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_status_display()"},{"location":"reference/models/#djstripe.models.core.SetupIntent.get_usage_display","text":"Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_usage_display()"},{"location":"reference/models/#payment-methods","text":"","title":"Payment Methods"},{"location":"reference/models/#djstripe.models.payment_methods-classes","text":"","title":"Classes"},{"location":"reference/models/#djstripe.models.payment_methods.BankAccount","text":"BankAccount(djstripe_created, djstripe_updated, djstripe_id, id, djstripe_owner_account, livemode, created, metadata, description, account, account_holder_name, account_holder_type, bank_name, country, currency, customer, default_for_currency, fingerprint, last4, routing_number, status)","title":"BankAccount"},{"location":"reference/models/#djstripe.models.payment_methods.BankAccount.account","text":"","title":"account"},{"location":"reference/models/#djstripe.models.payment_methods.BankAccount.account_holder_name","text":"","title":"account_holder_name"},{"location":"reference/models/#djstripe.models.payment_methods.BankAccount.account_holder_type","text":"","title":"account_holder_type"},{"location":"reference/models/#djstripe.models.payment_methods.BankAccount.bank_name","text":"","title":"bank_name"},{"location":"reference/models/#djstripe.models.payment_methods.BankAccount.country","text":"","title":"country"},{"location":"reference/models/#djstripe.models.payment_methods.BankAccount.currency","text":"","title":"currency"},{"location":"reference/models/#djstripe.models.payment_methods.BankAccount.customer","text":"","title":"customer"},{"location":"reference/models/#djstripe.models.payment_methods.BankAccount.default_for_currency","text":"","title":"default_for_currency"},{"location":"reference/models/#djstripe.models.payment_methods.BankAccount.djstripe_owner_account","text":"","title":"djstripe_owner_account"},{"location":"reference/models/#djstripe.models.payment_methods.BankAccount.fingerprint","text":"","title":"fingerprint"},{"location":"reference/models/#djstripe.models.payment_methods.BankAccount.human_readable_status","text":"","title":"human_readable_status"},{"location":"reference/models/#djstripe.models.payment_methods.BankAccount.last4","text":"","title":"last4"},{"location":"reference/models/#djstripe.models.payment_methods.BankAccount.routing_number","text":"","title":"routing_number"},{"location":"reference/models/#djstripe.models.payment_methods.BankAccount.status","text":"","title":"status"},{"location":"reference/models/#djstripe.models.payment_methods.BankAccount.DoesNotExist","text":"","title":"DoesNotExist"},{"location":"reference/models/#djstripe.models.payment_methods.BankAccount.MultipleObjectsReturned","text":"","title":"MultipleObjectsReturned"},{"location":"reference/models/#djstripe.models.payment_methods.BankAccount.stripe_class","text":"djstripe . models . payment_methods . BankAccount . stripe_class . OBJECT_NAME djstripe . models . payment_methods . BankAccount . stripe_class . instance_url ( self ) Source code in djstripe/models/payment_methods.py def instance_url ( self ): token = util . utf8 ( self . id ) extn = quote_plus ( token ) if hasattr ( self , \"customer\" ): customer = util . utf8 ( self . customer ) base = Customer . class_url () owner_extn = quote_plus ( customer ) class_base = \"sources\" elif hasattr ( self , \"account\" ): account = util . utf8 ( self . account ) base = Account . class_url () owner_extn = quote_plus ( account ) class_base = \"external_accounts\" else : raise error . InvalidRequestError ( \"Could not determine whether bank_account_id %s is \" \"attached to a customer or an account.\" % token , \"id\" , ) return \" %s / %s / %s / %s \" % ( base , owner_extn , class_base , extn ) djstripe . models . payment_methods . BankAccount . stripe_class . modify ( sid , ** params ) classmethod Source code in djstripe/models/payment_methods.py @classmethod def modify ( cls , sid , ** params ): raise NotImplementedError ( \"Can't modify a bank account without a customer or account ID. \" \"Call save on customer.sources.retrieve('bank_account_id') or \" \"account.external_accounts.retrieve('bank_account_id') instead.\" ) djstripe . models . payment_methods . BankAccount . stripe_class . retrieve ( id , api_key = None , stripe_version = None , stripe_account = None , ** params ) classmethod Source code in djstripe/models/payment_methods.py @classmethod def retrieve ( cls , id , api_key = None , stripe_version = None , stripe_account = None , ** params ): raise NotImplementedError ( \"Can't retrieve a bank account without a customer or account ID. \" \"Use customer.sources.retrieve('bank_account_id') or \" \"account.external_accounts.retrieve('bank_account_id') instead.\" )","title":"stripe_class"},{"location":"reference/models/#djstripe.models.payment_methods.BankAccount-methods","text":"","title":"Methods"},{"location":"reference/models/#djstripe.models.payment_methods.BankAccount.__str__","text":"Source code in djstripe/models/payment_methods.py def __str__ ( self ): default = False # prefer to show it by customer format if present if self . customer : default_source = self . customer . default_source default_payment_method = self . customer . default_payment_method if ( default_payment_method and self . id == default_payment_method . id ) or ( default_source and self . id == default_source . id ): # current card is the default payment method or source default = True customer_template = f \" { self . bank_name } { self . routing_number } ( { self . human_readable_status } ) { 'Default' if default else '' } { self . currency } \" return customer_template default = getattr ( self , \"default_for_currency\" , False ) account_template = f \" { self . bank_name } { self . currency } { 'Default' if default else '' } { self . routing_number } { self . last4 } \" return account_template","title":"__str__()"},{"location":"reference/models/#djstripe.models.payment_methods.BankAccount.api_retrieve","text":"Call the stripe API's retrieve operation for this model. :param api_key: The api key to use for this request. Defaults to djstripe_settings.STRIPE_SECRET_KEY. :type api_key: string :param stripe_account: The optional connected account for which this request is being made. :type stripe_account: string Source code in djstripe/models/payment_methods.py def api_retrieve ( self , ** kwargs ): if not self . customer and not self . account : raise NotImplementedError ( \"Can't retrieve a bank account without a customer or account object.\" ) return super () . api_retrieve ( ** kwargs )","title":"api_retrieve()"},{"location":"reference/models/#djstripe.models.payment_methods.BankAccount.get_account_holder_type_display","text":"Source code in djstripe/models/payment_methods.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_account_holder_type_display()"},{"location":"reference/models/#djstripe.models.payment_methods.BankAccount.get_next_by_djstripe_created","text":"Source code in djstripe/models/payment_methods.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_next_by_djstripe_created()"},{"location":"reference/models/#djstripe.models.payment_methods.BankAccount.get_next_by_djstripe_updated","text":"Source code in djstripe/models/payment_methods.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_next_by_djstripe_updated()"},{"location":"reference/models/#djstripe.models.payment_methods.BankAccount.get_previous_by_djstripe_created","text":"Source code in djstripe/models/payment_methods.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_previous_by_djstripe_created()"},{"location":"reference/models/#djstripe.models.payment_methods.BankAccount.get_previous_by_djstripe_updated","text":"Source code in djstripe/models/payment_methods.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_previous_by_djstripe_updated()"},{"location":"reference/models/#djstripe.models.payment_methods.BankAccount.get_status_display","text":"Source code in djstripe/models/payment_methods.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_status_display()"},{"location":"reference/models/#djstripe.models.payment_methods.Card","text":"You can store multiple cards on a customer in order to charge the customer later. This is a legacy model which only applies to the \"v2\" Stripe API (eg. Checkout.js). You should strive to use the Stripe \"v3\" API (eg. Stripe Elements). Also see: https://stripe.com/docs/stripe-js/elements/migrating When using Elements, you will not be using Card objects. Instead, you will use Source objects. A Source object of type \"card\" is equivalent to a Card object. However, Card objects cannot be converted into Source objects by Stripe at this time. Stripe documentation: https://stripe.com/docs/api?lang=python#cards","title":"Card"},{"location":"reference/models/#djstripe.models.payment_methods.Card.account","text":"","title":"account"},{"location":"reference/models/#djstripe.models.payment_methods.Card.address_city","text":"","title":"address_city"},{"location":"reference/models/#djstripe.models.payment_methods.Card.address_country","text":"","title":"address_country"},{"location":"reference/models/#djstripe.models.payment_methods.Card.address_line1","text":"","title":"address_line1"},{"location":"reference/models/#djstripe.models.payment_methods.Card.address_line1_check","text":"","title":"address_line1_check"},{"location":"reference/models/#djstripe.models.payment_methods.Card.address_line2","text":"","title":"address_line2"},{"location":"reference/models/#djstripe.models.payment_methods.Card.address_state","text":"","title":"address_state"},{"location":"reference/models/#djstripe.models.payment_methods.Card.address_zip","text":"","title":"address_zip"},{"location":"reference/models/#djstripe.models.payment_methods.Card.address_zip_check","text":"","title":"address_zip_check"},{"location":"reference/models/#djstripe.models.payment_methods.Card.brand","text":"","title":"brand"},{"location":"reference/models/#djstripe.models.payment_methods.Card.country","text":"","title":"country"},{"location":"reference/models/#djstripe.models.payment_methods.Card.customer","text":"","title":"customer"},{"location":"reference/models/#djstripe.models.payment_methods.Card.cvc_check","text":"","title":"cvc_check"},{"location":"reference/models/#djstripe.models.payment_methods.Card.default_for_currency","text":"","title":"default_for_currency"},{"location":"reference/models/#djstripe.models.payment_methods.Card.djstripe_owner_account","text":"","title":"djstripe_owner_account"},{"location":"reference/models/#djstripe.models.payment_methods.Card.dynamic_last4","text":"","title":"dynamic_last4"},{"location":"reference/models/#djstripe.models.payment_methods.Card.exp_month","text":"","title":"exp_month"},{"location":"reference/models/#djstripe.models.payment_methods.Card.exp_year","text":"","title":"exp_year"},{"location":"reference/models/#djstripe.models.payment_methods.Card.fingerprint","text":"","title":"fingerprint"},{"location":"reference/models/#djstripe.models.payment_methods.Card.funding","text":"","title":"funding"},{"location":"reference/models/#djstripe.models.payment_methods.Card.last4","text":"","title":"last4"},{"location":"reference/models/#djstripe.models.payment_methods.Card.name","text":"","title":"name"},{"location":"reference/models/#djstripe.models.payment_methods.Card.tokenization_method","text":"","title":"tokenization_method"},{"location":"reference/models/#djstripe.models.payment_methods.Card.DoesNotExist","text":"","title":"DoesNotExist"},{"location":"reference/models/#djstripe.models.payment_methods.Card.MultipleObjectsReturned","text":"","title":"MultipleObjectsReturned"},{"location":"reference/models/#djstripe.models.payment_methods.Card.stripe_class","text":"djstripe . models . payment_methods . Card . stripe_class . OBJECT_NAME djstripe . models . payment_methods . Card . stripe_class . instance_url ( self ) Source code in djstripe/models/payment_methods.py def instance_url ( self ): token = util . utf8 ( self . id ) extn = quote_plus ( token ) if hasattr ( self , \"customer\" ): customer = util . utf8 ( self . customer ) base = Customer . class_url () owner_extn = quote_plus ( customer ) class_base = \"sources\" elif hasattr ( self , \"recipient\" ): recipient = util . utf8 ( self . recipient ) base = Recipient . class_url () owner_extn = quote_plus ( recipient ) class_base = \"cards\" elif hasattr ( self , \"account\" ): account = util . utf8 ( self . account ) base = Account . class_url () owner_extn = quote_plus ( account ) class_base = \"external_accounts\" else : raise error . InvalidRequestError ( \"Could not determine whether card_id %s is \" \"attached to a customer, recipient, or \" \"account.\" % token , \"id\" , ) return \" %s / %s / %s / %s \" % ( base , owner_extn , class_base , extn ) djstripe . models . payment_methods . Card . stripe_class . modify ( sid , ** params ) classmethod Source code in djstripe/models/payment_methods.py @classmethod def modify ( cls , sid , ** params ): raise NotImplementedError ( \"Can't modify a card without a customer, recipient or account \" \"ID. Call save on customer.sources.retrieve('card_id'), \" \"recipient.cards.retrieve('card_id'), or \" \"account.external_accounts.retrieve('card_id') instead.\" ) djstripe . models . payment_methods . Card . stripe_class . retrieve ( id , api_key = None , stripe_version = None , stripe_account = None , ** params ) classmethod Source code in djstripe/models/payment_methods.py @classmethod def retrieve ( cls , id , api_key = None , stripe_version = None , stripe_account = None , ** params ): raise NotImplementedError ( \"Can't retrieve a card without a customer, recipient or account \" \"ID. Use customer.sources.retrieve('card_id'), \" \"recipient.cards.retrieve('card_id'), or \" \"account.external_accounts.retrieve('card_id') instead.\" )","title":"stripe_class"},{"location":"reference/models/#djstripe.models.payment_methods.Card-methods","text":"","title":"Methods"},{"location":"reference/models/#djstripe.models.payment_methods.Card.__str__","text":"Source code in djstripe/models/payment_methods.py def __str__ ( self ): default = False # prefer to show it by customer format if present if self . customer : default_source = self . customer . default_source default_payment_method = self . customer . default_payment_method if ( default_payment_method and self . id == default_payment_method . id ) or ( default_source and self . id == default_source . id ): # current card is the default payment method or source default = True customer_template = f \" { enums . CardBrand . humanize ( self . brand ) } { self . last4 } { 'Default' if default else '' } Expires { self . exp_month } { self . exp_year } \" return customer_template elif self . account : default = getattr ( self , \"default_for_currency\" , False ) account_template = f \" { enums . CardBrand . humanize ( self . brand ) } { self . account . default_currency } { 'Default' if default else '' } { self . last4 } \" return account_template","title":"__str__()"},{"location":"reference/models/#djstripe.models.payment_methods.Card.create_token","text":"Creates a single use token that wraps the details of a credit card. This token can be used in place of a credit card dictionary with any API method. These tokens can only be used once: by creating a new charge object, or attaching them to a customer. (Source: https://stripe.com/docs/api?lang=python#create_card_token) :param number: The card number without any separators (no spaces) :param exp_month: The card's expiration month. (two digits) :param exp_year: The card's expiration year. (four digits) :param cvc: Card security code. :param api_key: The API key to use Source code in djstripe/models/payment_methods.py @classmethod def create_token ( cls , number : str , exp_month : int , exp_year : int , cvc : str , api_key : str = djstripe_settings . STRIPE_SECRET_KEY , ** kwargs , ) -> stripe . Token : \"\"\" Creates a single use token that wraps the details of a credit card. This token can be used in place of a credit card dictionary with any API method. These tokens can only be used once: by creating a new charge object, or attaching them to a customer. (Source: https://stripe.com/docs/api?lang=python#create_card_token) :param number: The card number without any separators (no spaces) :param exp_month: The card's expiration month. (two digits) :param exp_year: The card's expiration year. (four digits) :param cvc: Card security code. :param api_key: The API key to use \"\"\" card = { \"number\" : number , \"exp_month\" : exp_month , \"exp_year\" : exp_year , \"cvc\" : cvc , } card . update ( kwargs ) return stripe . Token . create ( api_key = api_key , card = card )","title":"create_token()"},{"location":"reference/models/#djstripe.models.payment_methods.Card.get_address_line1_check_display","text":"Source code in djstripe/models/payment_methods.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_address_line1_check_display()"},{"location":"reference/models/#djstripe.models.payment_methods.Card.get_address_zip_check_display","text":"Source code in djstripe/models/payment_methods.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_address_zip_check_display()"},{"location":"reference/models/#djstripe.models.payment_methods.Card.get_brand_display","text":"Source code in djstripe/models/payment_methods.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_brand_display()"},{"location":"reference/models/#djstripe.models.payment_methods.Card.get_cvc_check_display","text":"Source code in djstripe/models/payment_methods.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_cvc_check_display()"},{"location":"reference/models/#djstripe.models.payment_methods.Card.get_funding_display","text":"Source code in djstripe/models/payment_methods.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_funding_display()"},{"location":"reference/models/#djstripe.models.payment_methods.Card.get_next_by_djstripe_created","text":"Source code in djstripe/models/payment_methods.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_next_by_djstripe_created()"},{"location":"reference/models/#djstripe.models.payment_methods.Card.get_next_by_djstripe_updated","text":"Source code in djstripe/models/payment_methods.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_next_by_djstripe_updated()"},{"location":"reference/models/#djstripe.models.payment_methods.Card.get_previous_by_djstripe_created","text":"Source code in djstripe/models/payment_methods.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_previous_by_djstripe_created()"},{"location":"reference/models/#djstripe.models.payment_methods.Card.get_previous_by_djstripe_updated","text":"Source code in djstripe/models/payment_methods.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_previous_by_djstripe_updated()"},{"location":"reference/models/#djstripe.models.payment_methods.Card.get_tokenization_method_display","text":"Source code in djstripe/models/payment_methods.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_tokenization_method_display()"},{"location":"reference/models/#djstripe.models.payment_methods.PaymentMethod","text":"Stripe documentation: https://stripe.com/docs/api#payment_methods","title":"PaymentMethod"},{"location":"reference/models/#djstripe.models.payment_methods.PaymentMethod.acss_debit","text":"","title":"acss_debit"},{"location":"reference/models/#djstripe.models.payment_methods.PaymentMethod.afterpay_clearpay","text":"","title":"afterpay_clearpay"},{"location":"reference/models/#djstripe.models.payment_methods.PaymentMethod.alipay","text":"","title":"alipay"},{"location":"reference/models/#djstripe.models.payment_methods.PaymentMethod.au_becs_debit","text":"","title":"au_becs_debit"},{"location":"reference/models/#djstripe.models.payment_methods.PaymentMethod.bacs_debit","text":"","title":"bacs_debit"},{"location":"reference/models/#djstripe.models.payment_methods.PaymentMethod.bancontact","text":"","title":"bancontact"},{"location":"reference/models/#djstripe.models.payment_methods.PaymentMethod.billing_details","text":"","title":"billing_details"},{"location":"reference/models/#djstripe.models.payment_methods.PaymentMethod.boleto","text":"","title":"boleto"},{"location":"reference/models/#djstripe.models.payment_methods.PaymentMethod.card","text":"","title":"card"},{"location":"reference/models/#djstripe.models.payment_methods.PaymentMethod.card_present","text":"","title":"card_present"},{"location":"reference/models/#djstripe.models.payment_methods.PaymentMethod.customer","text":"","title":"customer"},{"location":"reference/models/#djstripe.models.payment_methods.PaymentMethod.description","text":"","title":"description"},{"location":"reference/models/#djstripe.models.payment_methods.PaymentMethod.djstripe_owner_account","text":"","title":"djstripe_owner_account"},{"location":"reference/models/#djstripe.models.payment_methods.PaymentMethod.eps","text":"","title":"eps"},{"location":"reference/models/#djstripe.models.payment_methods.PaymentMethod.fpx","text":"","title":"fpx"},{"location":"reference/models/#djstripe.models.payment_methods.PaymentMethod.giropay","text":"","title":"giropay"},{"location":"reference/models/#djstripe.models.payment_methods.PaymentMethod.grabpay","text":"","title":"grabpay"},{"location":"reference/models/#djstripe.models.payment_methods.PaymentMethod.ideal","text":"","title":"ideal"},{"location":"reference/models/#djstripe.models.payment_methods.PaymentMethod.interac_present","text":"","title":"interac_present"},{"location":"reference/models/#djstripe.models.payment_methods.PaymentMethod.oxxo","text":"","title":"oxxo"},{"location":"reference/models/#djstripe.models.payment_methods.PaymentMethod.p24","text":"","title":"p24"},{"location":"reference/models/#djstripe.models.payment_methods.PaymentMethod.sepa_debit","text":"","title":"sepa_debit"},{"location":"reference/models/#djstripe.models.payment_methods.PaymentMethod.sofort","text":"","title":"sofort"},{"location":"reference/models/#djstripe.models.payment_methods.PaymentMethod.type","text":"","title":"type"},{"location":"reference/models/#djstripe.models.payment_methods.PaymentMethod.wechat_pay","text":"","title":"wechat_pay"},{"location":"reference/models/#djstripe.models.payment_methods.PaymentMethod.DoesNotExist","text":"","title":"DoesNotExist"},{"location":"reference/models/#djstripe.models.payment_methods.PaymentMethod.MultipleObjectsReturned","text":"","title":"MultipleObjectsReturned"},{"location":"reference/models/#djstripe.models.payment_methods.PaymentMethod.stripe_class","text":"djstripe . models . payment_methods . PaymentMethod . stripe_class . OBJECT_NAME djstripe . models . payment_methods . PaymentMethod . stripe_class . _cls_attach ( sid , ** params ) classmethod private Source code in djstripe/models/payment_methods.py def custom_method_request ( cls , sid , ** params ): url = \" %s / %s / %s \" % ( cls . class_url (), quote_plus ( util . utf8 ( sid )), http_path , ) obj = cls . _static_request ( http_verb , url , ** params ) # For list objects, we have to attach the parameters so that they # can be referenced in auto-pagination and ensure consistency. if \"object\" in obj and obj . object == \"list\" : obj . _retrieve_params = params return obj djstripe . models . payment_methods . PaymentMethod . stripe_class . _cls_detach ( sid , ** params ) classmethod private Source code in djstripe/models/payment_methods.py def custom_method_request ( cls , sid , ** params ): url = \" %s / %s / %s \" % ( cls . class_url (), quote_plus ( util . utf8 ( sid )), http_path , ) obj = cls . _static_request ( http_verb , url , ** params ) # For list objects, we have to attach the parameters so that they # can be referenced in auto-pagination and ensure consistency. if \"object\" in obj and obj . object == \"list\" : obj . _retrieve_params = params return obj djstripe . models . payment_methods . PaymentMethod . stripe_class . attach ( self , idempotency_key = None , ** params ) Source code in djstripe/models/payment_methods.py def attach ( self , idempotency_key = None , ** params ): url = self . instance_url () + \"/attach\" headers = util . populate_headers ( idempotency_key ) self . refresh_from ( self . request ( \"post\" , url , params , headers )) return self djstripe . models . payment_methods . PaymentMethod . stripe_class . detach ( self , idempotency_key = None , ** params ) Source code in djstripe/models/payment_methods.py def detach ( self , idempotency_key = None , ** params ): url = self . instance_url () + \"/detach\" headers = util . populate_headers ( idempotency_key ) self . refresh_from ( self . request ( \"post\" , url , params , headers )) return self","title":"stripe_class"},{"location":"reference/models/#djstripe.models.payment_methods.PaymentMethod-methods","text":"","title":"Methods"},{"location":"reference/models/#djstripe.models.payment_methods.PaymentMethod.__str__","text":"Source code in djstripe/models/payment_methods.py def __str__ ( self ): if self . customer : return f \" { enums . PaymentMethodType . humanize ( self . type ) } for { self . customer } \" return f \" { enums . PaymentMethodType . humanize ( self . type ) } is not associated with any customer\"","title":"__str__()"},{"location":"reference/models/#djstripe.models.payment_methods.PaymentMethod._attach_objects_hook","text":"Gets called by this object's create and sync methods just before save. Use this to populate fields before the model is saved. :param cls: The target class for the instantiated object. :param data: The data dictionary received from the Stripe API. :type data: dict :param current_ids: stripe ids of objects that are currently being processed :type current_ids: set Source code in djstripe/models/payment_methods.py def _attach_objects_hook ( self , cls , data , current_ids = None ): customer = None # \"customer\" key could be like \"cus_6lsBvm5rJ0zyHc\" or {\"id\": \"cus_6lsBvm5rJ0zyHc\"} customer_id = get_id_from_stripe_data ( data . get ( \"customer\" )) if current_ids is None or customer_id not in current_ids : customer = cls . _stripe_object_to_customer ( target_cls = Customer , data = data , current_ids = current_ids ) if customer : self . customer = customer else : self . customer = None","title":"_attach_objects_hook()"},{"location":"reference/models/#djstripe.models.payment_methods.PaymentMethod.attach","text":"Attach a payment method to a customer Source code in djstripe/models/payment_methods.py @classmethod def attach ( cls , payment_method : Union [ str , \"PaymentMethod\" ], customer : Union [ str , Customer ], api_key : str = djstripe_settings . STRIPE_SECRET_KEY , ) -> \"PaymentMethod\" : \"\"\" Attach a payment method to a customer \"\"\" if isinstance ( payment_method , StripeModel ): payment_method = payment_method . id if isinstance ( customer , StripeModel ): customer = customer . id extra_kwargs = {} if not isinstance ( payment_method , stripe . PaymentMethod ): # send api_key if we're not passing in a Stripe object # avoids \"Received unknown parameter: api_key\" since api uses the # key cached in the Stripe object extra_kwargs = { \"api_key\" : api_key } stripe_payment_method = stripe . PaymentMethod . attach ( payment_method , customer = customer , ** extra_kwargs ) return cls . sync_from_stripe_data ( stripe_payment_method )","title":"attach()"},{"location":"reference/models/#djstripe.models.payment_methods.PaymentMethod.detach","text":"Detach the payment method from its customer. :return: Returns true if the payment method was newly detached, false if it was already detached :rtype: bool Source code in djstripe/models/payment_methods.py def detach ( self ): \"\"\" Detach the payment method from its customer. :return: Returns true if the payment method was newly detached, \\ false if it was already detached :rtype: bool \"\"\" # Find customers that use this customers = Customer . objects . filter ( default_payment_method = self ) . all () changed = True # special handling is needed for legacy \"card\"-type PaymentMethods, # since detaching them deletes them within Stripe. # see https://github.com/dj-stripe/dj-stripe/pull/967 is_legacy_card = self . id . startswith ( \"card_\" ) try : self . sync_from_stripe_data ( self . api_retrieve () . detach ()) # resync customer to update .default_payment_method and # .invoice_settings.default_payment_method for customer in customers : Customer . sync_from_stripe_data ( customer . api_retrieve ()) except ( InvalidRequestError ,): # The source was already detached. Resyncing. if self . pk and not is_legacy_card : self . sync_from_stripe_data ( self . api_retrieve ()) changed = False if self . pk : if is_legacy_card : self . delete () else : self . refresh_from_db () return changed","title":"detach()"},{"location":"reference/models/#djstripe.models.payment_methods.PaymentMethod.get_next_by_djstripe_created","text":"Source code in djstripe/models/payment_methods.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_next_by_djstripe_created()"},{"location":"reference/models/#djstripe.models.payment_methods.PaymentMethod.get_next_by_djstripe_updated","text":"Source code in djstripe/models/payment_methods.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_next_by_djstripe_updated()"},{"location":"reference/models/#djstripe.models.payment_methods.PaymentMethod.get_previous_by_djstripe_created","text":"Source code in djstripe/models/payment_methods.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_previous_by_djstripe_created()"},{"location":"reference/models/#djstripe.models.payment_methods.PaymentMethod.get_previous_by_djstripe_updated","text":"Source code in djstripe/models/payment_methods.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_previous_by_djstripe_updated()"},{"location":"reference/models/#djstripe.models.payment_methods.PaymentMethod.get_type_display","text":"Source code in djstripe/models/payment_methods.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_type_display()"},{"location":"reference/models/#djstripe.models.payment_methods.Source","text":"Stripe documentation: https://stripe.com/docs/api#sources","title":"Source"},{"location":"reference/models/#djstripe.models.payment_methods.Source.amount","text":"","title":"amount"},{"location":"reference/models/#djstripe.models.payment_methods.Source.client_secret","text":"","title":"client_secret"},{"location":"reference/models/#djstripe.models.payment_methods.Source.code_verification","text":"","title":"code_verification"},{"location":"reference/models/#djstripe.models.payment_methods.Source.currency","text":"","title":"currency"},{"location":"reference/models/#djstripe.models.payment_methods.Source.customer","text":"","title":"customer"},{"location":"reference/models/#djstripe.models.payment_methods.Source.djstripe_owner_account","text":"","title":"djstripe_owner_account"},{"location":"reference/models/#djstripe.models.payment_methods.Source.flow","text":"","title":"flow"},{"location":"reference/models/#djstripe.models.payment_methods.Source.owner","text":"","title":"owner"},{"location":"reference/models/#djstripe.models.payment_methods.Source.receiver","text":"","title":"receiver"},{"location":"reference/models/#djstripe.models.payment_methods.Source.redirect","text":"","title":"redirect"},{"location":"reference/models/#djstripe.models.payment_methods.Source.source_data","text":"","title":"source_data"},{"location":"reference/models/#djstripe.models.payment_methods.Source.statement_descriptor","text":"","title":"statement_descriptor"},{"location":"reference/models/#djstripe.models.payment_methods.Source.status","text":"","title":"status"},{"location":"reference/models/#djstripe.models.payment_methods.Source.stripe_dashboard_item_name","text":"","title":"stripe_dashboard_item_name"},{"location":"reference/models/#djstripe.models.payment_methods.Source.type","text":"","title":"type"},{"location":"reference/models/#djstripe.models.payment_methods.Source.usage","text":"","title":"usage"},{"location":"reference/models/#djstripe.models.payment_methods.Source-classes","text":"","title":"Classes"},{"location":"reference/models/#djstripe.models.payment_methods.Source.DoesNotExist","text":"","title":"DoesNotExist"},{"location":"reference/models/#djstripe.models.payment_methods.Source.MultipleObjectsReturned","text":"","title":"MultipleObjectsReturned"},{"location":"reference/models/#djstripe.models.payment_methods.Source.stripe_class","text":"djstripe . models . payment_methods . Source . stripe_class . OBJECT_NAME","title":"stripe_class"},{"location":"reference/models/#djstripe.models.payment_methods.Source.stripe_class-methods","text":"djstripe . models . payment_methods . Source . stripe_class . detach ( self , idempotency_key = None , ** params ) Source code in djstripe/models/payment_methods.py def detach ( self , idempotency_key = None , ** params ): token = util . utf8 ( self . id ) if hasattr ( self , \"customer\" ) and self . customer : extn = quote_plus ( token ) customer = util . utf8 ( self . customer ) base = Customer . class_url () owner_extn = quote_plus ( customer ) url = \" %s / %s /sources/ %s \" % ( base , owner_extn , extn ) headers = util . populate_headers ( idempotency_key ) self . refresh_from ( self . request ( \"delete\" , url , params , headers )) return self else : raise error . InvalidRequestError ( \"Source %s does not appear to be currently attached \" \"to a customer object.\" % token , \"id\" , ) djstripe . models . payment_methods . Source . stripe_class . list_source_transactions ( id , ** params ) classmethod Source code in djstripe/models/payment_methods.py def list_nested_resources ( cls , id , ** params ): url = getattr ( cls , resource_url_method )( id ) return getattr ( cls , resource_request_method )( \"get\" , url , ** params ) djstripe . models . payment_methods . Source . stripe_class . source_transactions ( self , ** params ) source_transactions is deprecated, use Source.list_source_transactions instead. Source code in djstripe/models/payment_methods.py def source_transactions ( self , ** params ): \"\"\"source_transactions is deprecated, use Source.list_source_transactions instead.\"\"\" return self . request ( \"get\" , self . instance_url () + \"/source_transactions\" , params ) djstripe . models . payment_methods . Source . stripe_class . source_transactions_request ( method , url , api_key = None , idempotency_key = None , stripe_version = None , stripe_account = None , ** params ) classmethod Source code in djstripe/models/payment_methods.py def nested_resource_request ( cls , method , url , api_key = None , idempotency_key = None , stripe_version = None , stripe_account = None , ** params ): requestor = api_requestor . APIRequestor ( api_key , api_version = stripe_version , account = stripe_account ) headers = util . populate_headers ( idempotency_key ) response , api_key = requestor . request ( method , url , params , headers ) return util . convert_to_stripe_object ( response , api_key , stripe_version , stripe_account ) djstripe . models . payment_methods . Source . stripe_class . source_transactions_url ( id , nested_id = None ) classmethod Source code in djstripe/models/payment_methods.py def nested_resource_url ( cls , id , nested_id = None ): url = \" %s / %s / %s \" % ( cls . class_url (), quote_plus ( id ), quote_plus ( path ), ) if nested_id is not None : url += \"/ %s \" % quote_plus ( nested_id ) return url","title":"Methods"},{"location":"reference/models/#djstripe.models.payment_methods.Source-methods","text":"","title":"Methods"},{"location":"reference/models/#djstripe.models.payment_methods.Source.__str__","text":"Source code in djstripe/models/payment_methods.py def __str__ ( self ): return f \" { self . type } { self . id } \"","title":"__str__()"},{"location":"reference/models/#djstripe.models.payment_methods.Source._attach_objects_hook","text":"Gets called by this object's create and sync methods just before save. Use this to populate fields before the model is saved. :param cls: The target class for the instantiated object. :param data: The data dictionary received from the Stripe API. :type data: dict :param current_ids: stripe ids of objects that are currently being processed :type current_ids: set Source code in djstripe/models/payment_methods.py def _attach_objects_hook ( self , cls , data , current_ids = None ): customer = None # \"customer\" key could be like \"cus_6lsBvm5rJ0zyHc\" or {\"id\": \"cus_6lsBvm5rJ0zyHc\"} customer_id = get_id_from_stripe_data ( data . get ( \"customer\" )) if current_ids is None or customer_id not in current_ids : customer = cls . _stripe_object_to_customer ( target_cls = Customer , data = data , current_ids = current_ids ) if customer : self . customer = customer else : self . customer = None","title":"_attach_objects_hook()"},{"location":"reference/models/#djstripe.models.payment_methods.Source._manipulate_stripe_object_hook","text":"Gets called by this object's stripe object conversion method just before conversion. Use this to populate custom fields in a StripeModel from stripe data. Source code in djstripe/models/payment_methods.py @classmethod def _manipulate_stripe_object_hook ( cls , data ): # The source_data dict is an alias of all the source types data [ \"source_data\" ] = data [ data [ \"type\" ]] return data","title":"_manipulate_stripe_object_hook()"},{"location":"reference/models/#djstripe.models.payment_methods.Source.detach","text":"Detach the source from its customer. Source code in djstripe/models/payment_methods.py def detach ( self ) -> bool : \"\"\" Detach the source from its customer. \"\"\" # First, wipe default source on all customers that use this. Customer . objects . filter ( default_source = self . id ) . update ( default_source = None ) try : # TODO - we could use the return value of sync_from_stripe_data # or call its internals - self._sync/_attach_objects_hook etc here # to update `self` at this point? self . sync_from_stripe_data ( self . api_retrieve () . detach ()) return True except ( InvalidRequestError , NotImplementedError ): # The source was already detached. Resyncing. # NotImplementedError is an artifact of stripe-python<2.0 # https://github.com/stripe/stripe-python/issues/376 self . sync_from_stripe_data ( self . api_retrieve ()) return False","title":"detach()"},{"location":"reference/models/#djstripe.models.payment_methods.Source.get_flow_display","text":"Source code in djstripe/models/payment_methods.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_flow_display()"},{"location":"reference/models/#djstripe.models.payment_methods.Source.get_next_by_djstripe_created","text":"Source code in djstripe/models/payment_methods.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_next_by_djstripe_created()"},{"location":"reference/models/#djstripe.models.payment_methods.Source.get_next_by_djstripe_updated","text":"Source code in djstripe/models/payment_methods.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_next_by_djstripe_updated()"},{"location":"reference/models/#djstripe.models.payment_methods.Source.get_previous_by_djstripe_created","text":"Source code in djstripe/models/payment_methods.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_previous_by_djstripe_created()"},{"location":"reference/models/#djstripe.models.payment_methods.Source.get_previous_by_djstripe_updated","text":"Source code in djstripe/models/payment_methods.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_previous_by_djstripe_updated()"},{"location":"reference/models/#djstripe.models.payment_methods.Source.get_status_display","text":"Source code in djstripe/models/payment_methods.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_status_display()"},{"location":"reference/models/#djstripe.models.payment_methods.Source.get_type_display","text":"Source code in djstripe/models/payment_methods.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_type_display()"},{"location":"reference/models/#djstripe.models.payment_methods.Source.get_usage_display","text":"Source code in djstripe/models/payment_methods.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_usage_display()"},{"location":"reference/models/#billing","text":"","title":"Billing"},{"location":"reference/models/#djstripe.models.billing-classes","text":"","title":"Classes"},{"location":"reference/models/#djstripe.models.billing.Coupon","text":"A coupon contains information about a percent-off or amount-off discount you might want to apply to a customer. Coupons may be applied to invoices or orders. Coupons do not work with conventional one-off charges. Stripe documentation: https://stripe.com/docs/api/coupons","title":"Coupon"},{"location":"reference/models/#djstripe.models.billing.Coupon.amount_off","text":"","title":"amount_off"},{"location":"reference/models/#djstripe.models.billing.Coupon.currency","text":"","title":"currency"},{"location":"reference/models/#djstripe.models.billing.Coupon.djstripe_owner_account","text":"","title":"djstripe_owner_account"},{"location":"reference/models/#djstripe.models.billing.Coupon.duration","text":"","title":"duration"},{"location":"reference/models/#djstripe.models.billing.Coupon.duration_in_months","text":"","title":"duration_in_months"},{"location":"reference/models/#djstripe.models.billing.Coupon.human_readable","text":"","title":"human_readable"},{"location":"reference/models/#djstripe.models.billing.Coupon.human_readable_amount","text":"","title":"human_readable_amount"},{"location":"reference/models/#djstripe.models.billing.Coupon.max_redemptions","text":"","title":"max_redemptions"},{"location":"reference/models/#djstripe.models.billing.Coupon.name","text":"","title":"name"},{"location":"reference/models/#djstripe.models.billing.Coupon.percent_off","text":"","title":"percent_off"},{"location":"reference/models/#djstripe.models.billing.Coupon.redeem_by","text":"","title":"redeem_by"},{"location":"reference/models/#djstripe.models.billing.Coupon.stripe_dashboard_item_name","text":"","title":"stripe_dashboard_item_name"},{"location":"reference/models/#djstripe.models.billing.Coupon.times_redeemed","text":"","title":"times_redeemed"},{"location":"reference/models/#djstripe.models.billing.Coupon.DoesNotExist","text":"","title":"DoesNotExist"},{"location":"reference/models/#djstripe.models.billing.Coupon.MultipleObjectsReturned","text":"","title":"MultipleObjectsReturned"},{"location":"reference/models/#djstripe.models.billing.Coupon.stripe_class","text":"","title":"stripe_class"},{"location":"reference/models/#djstripe.models.billing.Coupon.__str__","text":"Source code in djstripe/models/billing.py def __str__ ( self ): if self . name : return self . name return self . human_readable","title":"__str__()"},{"location":"reference/models/#djstripe.models.billing.Coupon.get_duration_display","text":"Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_duration_display()"},{"location":"reference/models/#djstripe.models.billing.Coupon.get_next_by_djstripe_created","text":"Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_next_by_djstripe_created()"},{"location":"reference/models/#djstripe.models.billing.Coupon.get_next_by_djstripe_updated","text":"Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_next_by_djstripe_updated()"},{"location":"reference/models/#djstripe.models.billing.Coupon.get_previous_by_djstripe_created","text":"Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_previous_by_djstripe_created()"},{"location":"reference/models/#djstripe.models.billing.Coupon.get_previous_by_djstripe_updated","text":"Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_previous_by_djstripe_updated()"},{"location":"reference/models/#djstripe.models.billing.Invoice","text":"Invoices are statements of what a customer owes for a particular billing period, including subscriptions, invoice items, and any automatic proration adjustments if necessary. Once an invoice is created, payment is automatically attempted. Note that the payment, while automatic, does not happen exactly at the time of invoice creation. If you have configured webhooks, the invoice will wait until one hour after the last webhook is successfully sent (or the last webhook times out after failing). Any customer credit on the account is applied before determining how much is due for that invoice (the amount that will be actually charged). If the amount due for the invoice is less than 50 cents (the minimum for a charge), we add the amount to the customer's running account balance to be added to the next invoice. If this amount is negative, it will act as a credit to offset the next invoice. Note that the customer account balance does not include unpaid invoices; it only includes balances that need to be taken into account when calculating the amount due for the next invoice. Stripe documentation: https://stripe.com/docs/api?lang=python#invoices","title":"Invoice"},{"location":"reference/models/#djstripe.models.billing.Invoice.charge","text":"","title":"charge"},{"location":"reference/models/#djstripe.models.billing.Invoice.customer","text":"","title":"customer"},{"location":"reference/models/#djstripe.models.billing.Invoice.default_payment_method","text":"","title":"default_payment_method"},{"location":"reference/models/#djstripe.models.billing.Invoice.default_source","text":"","title":"default_source"},{"location":"reference/models/#djstripe.models.billing.Invoice.default_tax_rates","text":"","title":"default_tax_rates"},{"location":"reference/models/#djstripe.models.billing.Invoice.djstripe_owner_account","text":"","title":"djstripe_owner_account"},{"location":"reference/models/#djstripe.models.billing.Invoice.payment_intent","text":"","title":"payment_intent"},{"location":"reference/models/#djstripe.models.billing.Invoice.subscription","text":"","title":"subscription"},{"location":"reference/models/#djstripe.models.billing.Invoice.DoesNotExist","text":"","title":"DoesNotExist"},{"location":"reference/models/#djstripe.models.billing.Invoice.MultipleObjectsReturned","text":"","title":"MultipleObjectsReturned"},{"location":"reference/models/#djstripe.models.billing.Invoice-methods","text":"","title":"Methods"},{"location":"reference/models/#djstripe.models.billing.Invoice._attach_objects_post_save_hook","text":"Gets called by this object's create and sync methods just after save. Use this to populate fields after the model is saved. :param cls: The target class for the instantiated object. :param data: The data dictionary received from the Stripe API. :type data: dict Source code in djstripe/models/billing.py def _attach_objects_post_save_hook ( self , cls , data , pending_relations = None ): super () . _attach_objects_post_save_hook ( cls , data , pending_relations = pending_relations ) self . default_tax_rates . set ( cls . _stripe_object_to_default_tax_rates ( target_cls = TaxRate , data = data ) ) cls . _stripe_object_set_total_tax_amounts ( target_cls = DjstripeInvoiceTotalTaxAmount , data = data , instance = self )","title":"_attach_objects_post_save_hook()"},{"location":"reference/models/#djstripe.models.billing.Invoice.get_billing_reason_display","text":"Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_billing_reason_display()"},{"location":"reference/models/#djstripe.models.billing.Invoice.get_collection_method_display","text":"Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_collection_method_display()"},{"location":"reference/models/#djstripe.models.billing.Invoice.get_customer_tax_exempt_display","text":"Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_customer_tax_exempt_display()"},{"location":"reference/models/#djstripe.models.billing.Invoice.get_next_by_djstripe_created","text":"Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_next_by_djstripe_created()"},{"location":"reference/models/#djstripe.models.billing.Invoice.get_next_by_djstripe_updated","text":"Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_next_by_djstripe_updated()"},{"location":"reference/models/#djstripe.models.billing.Invoice.get_next_by_period_end","text":"Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_next_by_period_end()"},{"location":"reference/models/#djstripe.models.billing.Invoice.get_next_by_period_start","text":"Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_next_by_period_start()"},{"location":"reference/models/#djstripe.models.billing.Invoice.get_previous_by_djstripe_created","text":"Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_previous_by_djstripe_created()"},{"location":"reference/models/#djstripe.models.billing.Invoice.get_previous_by_djstripe_updated","text":"Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_previous_by_djstripe_updated()"},{"location":"reference/models/#djstripe.models.billing.Invoice.get_previous_by_period_end","text":"Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_previous_by_period_end()"},{"location":"reference/models/#djstripe.models.billing.Invoice.get_previous_by_period_start","text":"Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_previous_by_period_start()"},{"location":"reference/models/#djstripe.models.billing.Invoice.get_status_display","text":"Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_status_display()"},{"location":"reference/models/#djstripe.models.billing.InvoiceItem","text":"Sometimes you want to add a charge or credit to a customer but only actually charge the customer's card at the end of a regular billing cycle. This is useful for combining several charges to minimize per-transaction fees or having Stripe tabulate your usage-based billing totals. Stripe documentation: https://stripe.com/docs/api?lang=python#invoiceitems","title":"InvoiceItem"},{"location":"reference/models/#djstripe.models.billing.InvoiceItem.amount","text":"","title":"amount"},{"location":"reference/models/#djstripe.models.billing.InvoiceItem.currency","text":"","title":"currency"},{"location":"reference/models/#djstripe.models.billing.InvoiceItem.customer","text":"","title":"customer"},{"location":"reference/models/#djstripe.models.billing.InvoiceItem.date","text":"","title":"date"},{"location":"reference/models/#djstripe.models.billing.InvoiceItem.discountable","text":"","title":"discountable"},{"location":"reference/models/#djstripe.models.billing.InvoiceItem.djstripe_owner_account","text":"","title":"djstripe_owner_account"},{"location":"reference/models/#djstripe.models.billing.InvoiceItem.invoice","text":"","title":"invoice"},{"location":"reference/models/#djstripe.models.billing.InvoiceItem.period","text":"","title":"period"},{"location":"reference/models/#djstripe.models.billing.InvoiceItem.period_end","text":"","title":"period_end"},{"location":"reference/models/#djstripe.models.billing.InvoiceItem.period_start","text":"","title":"period_start"},{"location":"reference/models/#djstripe.models.billing.InvoiceItem.plan","text":"","title":"plan"},{"location":"reference/models/#djstripe.models.billing.InvoiceItem.price","text":"","title":"price"},{"location":"reference/models/#djstripe.models.billing.InvoiceItem.proration","text":"","title":"proration"},{"location":"reference/models/#djstripe.models.billing.InvoiceItem.quantity","text":"","title":"quantity"},{"location":"reference/models/#djstripe.models.billing.InvoiceItem.subscription","text":"","title":"subscription"},{"location":"reference/models/#djstripe.models.billing.InvoiceItem.tax_rates","text":"","title":"tax_rates"},{"location":"reference/models/#djstripe.models.billing.InvoiceItem.unit_amount","text":"","title":"unit_amount"},{"location":"reference/models/#djstripe.models.billing.InvoiceItem.unit_amount_decimal","text":"","title":"unit_amount_decimal"},{"location":"reference/models/#djstripe.models.billing.InvoiceItem.DoesNotExist","text":"","title":"DoesNotExist"},{"location":"reference/models/#djstripe.models.billing.InvoiceItem.MultipleObjectsReturned","text":"","title":"MultipleObjectsReturned"},{"location":"reference/models/#djstripe.models.billing.InvoiceItem.stripe_class","text":"","title":"stripe_class"},{"location":"reference/models/#djstripe.models.billing.InvoiceItem-methods","text":"","title":"Methods"},{"location":"reference/models/#djstripe.models.billing.InvoiceItem.__str__","text":"Source code in djstripe/models/billing.py def __str__ ( self ): return self . description","title":"__str__()"},{"location":"reference/models/#djstripe.models.billing.InvoiceItem._attach_objects_post_save_hook","text":"Gets called by this object's create and sync methods just after save. Use this to populate fields after the model is saved. :param cls: The target class for the instantiated object. :param data: The data dictionary received from the Stripe API. :type data: dict Source code in djstripe/models/billing.py def _attach_objects_post_save_hook ( self , cls , data , pending_relations = None ): super () . _attach_objects_post_save_hook ( cls , data , pending_relations = pending_relations ) if self . pk : # only call .set() on saved instance (ie don't on items of UpcomingInvoice) self . tax_rates . set ( cls . _stripe_object_to_tax_rates ( target_cls = TaxRate , data = data ) )","title":"_attach_objects_post_save_hook()"},{"location":"reference/models/#djstripe.models.billing.InvoiceItem._manipulate_stripe_object_hook","text":"Gets called by this object's stripe object conversion method just before conversion. Use this to populate custom fields in a StripeModel from stripe data. Source code in djstripe/models/billing.py @classmethod def _manipulate_stripe_object_hook ( cls , data ): data [ \"period_start\" ] = data [ \"period\" ][ \"start\" ] data [ \"period_end\" ] = data [ \"period\" ][ \"end\" ] return data","title":"_manipulate_stripe_object_hook()"},{"location":"reference/models/#djstripe.models.billing.InvoiceItem.api_retrieve","text":"Call the stripe API's retrieve operation for this model. :param api_key: The api key to use for this request. Defaults to djstripe_settings.STRIPE_SECRET_KEY. :type api_key: string :param stripe_account: The optional connected account for which this request is being made. :type stripe_account: string Source code in djstripe/models/billing.py def api_retrieve ( self , * args , ** kwargs ): if \"-il_\" in self . id : warnings . warn ( f \"Attempting to retrieve InvoiceItem with id= { self . id !r} \" \" will most likely fail. \" \"Run manage.py djstripe_update_invoiceitem_ids if this is a problem.\" ) return super () . api_retrieve ( * args , ** kwargs )","title":"api_retrieve()"},{"location":"reference/models/#djstripe.models.billing.InvoiceItem.get_next_by_date","text":"Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_next_by_date()"},{"location":"reference/models/#djstripe.models.billing.InvoiceItem.get_next_by_djstripe_created","text":"Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_next_by_djstripe_created()"},{"location":"reference/models/#djstripe.models.billing.InvoiceItem.get_next_by_djstripe_updated","text":"Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_next_by_djstripe_updated()"},{"location":"reference/models/#djstripe.models.billing.InvoiceItem.get_next_by_period_end","text":"Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_next_by_period_end()"},{"location":"reference/models/#djstripe.models.billing.InvoiceItem.get_next_by_period_start","text":"Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_next_by_period_start()"},{"location":"reference/models/#djstripe.models.billing.InvoiceItem.get_previous_by_date","text":"Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_previous_by_date()"},{"location":"reference/models/#djstripe.models.billing.InvoiceItem.get_previous_by_djstripe_created","text":"Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_previous_by_djstripe_created()"},{"location":"reference/models/#djstripe.models.billing.InvoiceItem.get_previous_by_djstripe_updated","text":"Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_previous_by_djstripe_updated()"},{"location":"reference/models/#djstripe.models.billing.InvoiceItem.get_previous_by_period_end","text":"Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_previous_by_period_end()"},{"location":"reference/models/#djstripe.models.billing.InvoiceItem.get_previous_by_period_start","text":"Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_previous_by_period_start()"},{"location":"reference/models/#djstripe.models.billing.InvoiceItem.get_stripe_dashboard_url","text":"Get the stripe dashboard url for this object. Source code in djstripe/models/billing.py def get_stripe_dashboard_url ( self ): return self . invoice . get_stripe_dashboard_url ()","title":"get_stripe_dashboard_url()"},{"location":"reference/models/#djstripe.models.billing.InvoiceItem.is_valid_object","text":"Returns whether the data is a valid object for the class Source code in djstripe/models/billing.py @classmethod def is_valid_object ( cls , data ): return \"object\" in data and data [ \"object\" ] in ( \"invoiceitem\" , \"line_item\" )","title":"is_valid_object()"},{"location":"reference/models/#djstripe.models.billing.Plan","text":"A subscription plan contains the pricing information for different products and feature levels on your site. Stripe documentation: https://stripe.com/docs/api/plans NOTE: The Stripe Plans API has been deprecated in favor of the Prices API. You may want to upgrade to use the Price model instead of the Plan model.","title":"Plan"},{"location":"reference/models/#djstripe.models.billing.Plan.active","text":"","title":"active"},{"location":"reference/models/#djstripe.models.billing.Plan.aggregate_usage","text":"","title":"aggregate_usage"},{"location":"reference/models/#djstripe.models.billing.Plan.amount","text":"","title":"amount"},{"location":"reference/models/#djstripe.models.billing.Plan.amount_decimal","text":"","title":"amount_decimal"},{"location":"reference/models/#djstripe.models.billing.Plan.amount_in_cents","text":"","title":"amount_in_cents"},{"location":"reference/models/#djstripe.models.billing.Plan.billing_scheme","text":"","title":"billing_scheme"},{"location":"reference/models/#djstripe.models.billing.Plan.currency","text":"","title":"currency"},{"location":"reference/models/#djstripe.models.billing.Plan.djstripe_owner_account","text":"","title":"djstripe_owner_account"},{"location":"reference/models/#djstripe.models.billing.Plan.expand_fields","text":"","title":"expand_fields"},{"location":"reference/models/#djstripe.models.billing.Plan.human_readable_price","text":"","title":"human_readable_price"},{"location":"reference/models/#djstripe.models.billing.Plan.interval","text":"","title":"interval"},{"location":"reference/models/#djstripe.models.billing.Plan.interval_count","text":"","title":"interval_count"},{"location":"reference/models/#djstripe.models.billing.Plan.nickname","text":"","title":"nickname"},{"location":"reference/models/#djstripe.models.billing.Plan.product","text":"","title":"product"},{"location":"reference/models/#djstripe.models.billing.Plan.stripe_dashboard_item_name","text":"","title":"stripe_dashboard_item_name"},{"location":"reference/models/#djstripe.models.billing.Plan.tiers","text":"","title":"tiers"},{"location":"reference/models/#djstripe.models.billing.Plan.tiers_mode","text":"","title":"tiers_mode"},{"location":"reference/models/#djstripe.models.billing.Plan.transform_usage","text":"","title":"transform_usage"},{"location":"reference/models/#djstripe.models.billing.Plan.trial_period_days","text":"","title":"trial_period_days"},{"location":"reference/models/#djstripe.models.billing.Plan.usage_type","text":"","title":"usage_type"},{"location":"reference/models/#djstripe.models.billing.Plan.DoesNotExist","text":"","title":"DoesNotExist"},{"location":"reference/models/#djstripe.models.billing.Plan.MultipleObjectsReturned","text":"","title":"MultipleObjectsReturned"},{"location":"reference/models/#djstripe.models.billing.Plan.stripe_class","text":"","title":"stripe_class"},{"location":"reference/models/#djstripe.models.billing.Plan-methods","text":"","title":"Methods"},{"location":"reference/models/#djstripe.models.billing.Plan.__str__","text":"Source code in djstripe/models/billing.py def __str__ ( self ): from .billing import Subscription subscriptions = Subscription . objects . filter ( plan__id = self . id ) . count () if self . product and self . product . name : return f \" { self . human_readable_price } for { self . product . name } ( { subscriptions } subscriptions)\" return f \" { self . human_readable_price } ( { subscriptions } subscriptions)\"","title":"__str__()"},{"location":"reference/models/#djstripe.models.billing.Plan.create","text":"Source code in djstripe/models/billing.py @classmethod def create ( cls , ** kwargs ): # A few minor things are changed in the api-version of the create call api_kwargs = dict ( kwargs ) api_kwargs [ \"amount\" ] = int ( api_kwargs [ \"amount\" ] * 100 ) if isinstance ( api_kwargs . get ( \"product\" ), StripeModel ): api_kwargs [ \"product\" ] = api_kwargs [ \"product\" ] . id stripe_plan = cls . _api_create ( ** api_kwargs ) plan = cls . sync_from_stripe_data ( stripe_plan ) return plan","title":"create()"},{"location":"reference/models/#djstripe.models.billing.Plan.get_aggregate_usage_display","text":"Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_aggregate_usage_display()"},{"location":"reference/models/#djstripe.models.billing.Plan.get_billing_scheme_display","text":"Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_billing_scheme_display()"},{"location":"reference/models/#djstripe.models.billing.Plan.get_interval_display","text":"Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_interval_display()"},{"location":"reference/models/#djstripe.models.billing.Plan.get_next_by_djstripe_created","text":"Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_next_by_djstripe_created()"},{"location":"reference/models/#djstripe.models.billing.Plan.get_next_by_djstripe_updated","text":"Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_next_by_djstripe_updated()"},{"location":"reference/models/#djstripe.models.billing.Plan.get_or_create","text":"Get or create a Plan. Source code in djstripe/models/billing.py @classmethod def get_or_create ( cls , ** kwargs ): \"\"\"Get or create a Plan.\"\"\" try : return Plan . objects . get ( id = kwargs [ \"id\" ]), False except Plan . DoesNotExist : return cls . create ( ** kwargs ), True","title":"get_or_create()"},{"location":"reference/models/#djstripe.models.billing.Plan.get_previous_by_djstripe_created","text":"Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_previous_by_djstripe_created()"},{"location":"reference/models/#djstripe.models.billing.Plan.get_previous_by_djstripe_updated","text":"Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_previous_by_djstripe_updated()"},{"location":"reference/models/#djstripe.models.billing.Plan.get_tiers_mode_display","text":"Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_tiers_mode_display()"},{"location":"reference/models/#djstripe.models.billing.Plan.get_usage_type_display","text":"Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_usage_type_display()"},{"location":"reference/models/#djstripe.models.billing.Subscription","text":"Subscriptions allow you to charge a customer's card on a recurring basis. A subscription ties a customer to a particular plan you've created. A subscription still in its trial period is trialing and moves to active when the trial period is over. When payment to renew the subscription fails, the subscription becomes past_due . After Stripe has exhausted all payment retry attempts, the subscription ends up with a status of either canceled or unpaid depending on your retry settings. Note that when a subscription has a status of unpaid , no subsequent invoices will be attempted (invoices will be created, but then immediately automatically closed. Additionally, updating customer card details will not lead to Stripe retrying the latest invoice.). After receiving updated card details from a customer, you may choose to reopen and pay their closed invoices. Stripe documentation: https://stripe.com/docs/api?lang=python#subscriptions","title":"Subscription"},{"location":"reference/models/#djstripe.models.billing.Subscription.application_fee_percent","text":"","title":"application_fee_percent"},{"location":"reference/models/#djstripe.models.billing.Subscription.billing_cycle_anchor","text":"","title":"billing_cycle_anchor"},{"location":"reference/models/#djstripe.models.billing.Subscription.billing_thresholds","text":"","title":"billing_thresholds"},{"location":"reference/models/#djstripe.models.billing.Subscription.cancel_at","text":"","title":"cancel_at"},{"location":"reference/models/#djstripe.models.billing.Subscription.cancel_at_period_end","text":"","title":"cancel_at_period_end"},{"location":"reference/models/#djstripe.models.billing.Subscription.canceled_at","text":"","title":"canceled_at"},{"location":"reference/models/#djstripe.models.billing.Subscription.collection_method","text":"","title":"collection_method"},{"location":"reference/models/#djstripe.models.billing.Subscription.current_period_end","text":"","title":"current_period_end"},{"location":"reference/models/#djstripe.models.billing.Subscription.current_period_start","text":"","title":"current_period_start"},{"location":"reference/models/#djstripe.models.billing.Subscription.customer","text":"","title":"customer"},{"location":"reference/models/#djstripe.models.billing.Subscription.days_until_due","text":"","title":"days_until_due"},{"location":"reference/models/#djstripe.models.billing.Subscription.default_payment_method","text":"","title":"default_payment_method"},{"location":"reference/models/#djstripe.models.billing.Subscription.default_source","text":"","title":"default_source"},{"location":"reference/models/#djstripe.models.billing.Subscription.default_tax_rates","text":"","title":"default_tax_rates"},{"location":"reference/models/#djstripe.models.billing.Subscription.discount","text":"","title":"discount"},{"location":"reference/models/#djstripe.models.billing.Subscription.djstripe_owner_account","text":"","title":"djstripe_owner_account"},{"location":"reference/models/#djstripe.models.billing.Subscription.ended_at","text":"","title":"ended_at"},{"location":"reference/models/#djstripe.models.billing.Subscription.latest_invoice","text":"","title":"latest_invoice"},{"location":"reference/models/#djstripe.models.billing.Subscription.next_pending_invoice_item_invoice","text":"","title":"next_pending_invoice_item_invoice"},{"location":"reference/models/#djstripe.models.billing.Subscription.objects","text":"","title":"objects"},{"location":"reference/models/#djstripe.models.billing.Subscription.pending_invoice_item_interval","text":"","title":"pending_invoice_item_interval"},{"location":"reference/models/#djstripe.models.billing.Subscription.pending_setup_intent","text":"","title":"pending_setup_intent"},{"location":"reference/models/#djstripe.models.billing.Subscription.pending_update","text":"","title":"pending_update"},{"location":"reference/models/#djstripe.models.billing.Subscription.plan","text":"","title":"plan"},{"location":"reference/models/#djstripe.models.billing.Subscription.quantity","text":"","title":"quantity"},{"location":"reference/models/#djstripe.models.billing.Subscription.schedule","text":"","title":"schedule"},{"location":"reference/models/#djstripe.models.billing.Subscription.start_date","text":"","title":"start_date"},{"location":"reference/models/#djstripe.models.billing.Subscription.status","text":"","title":"status"},{"location":"reference/models/#djstripe.models.billing.Subscription.stripe_dashboard_item_name","text":"","title":"stripe_dashboard_item_name"},{"location":"reference/models/#djstripe.models.billing.Subscription.trial_end","text":"","title":"trial_end"},{"location":"reference/models/#djstripe.models.billing.Subscription.trial_start","text":"","title":"trial_start"},{"location":"reference/models/#djstripe.models.billing.Subscription.DoesNotExist","text":"","title":"DoesNotExist"},{"location":"reference/models/#djstripe.models.billing.Subscription.MultipleObjectsReturned","text":"","title":"MultipleObjectsReturned"},{"location":"reference/models/#djstripe.models.billing.Subscription.stripe_class","text":"djstripe . models . billing . Subscription . stripe_class . OBJECT_NAME djstripe . models . billing . Subscription . stripe_class . _cls_delete_discount ( sid , ** params ) classmethod private Source code in djstripe/models/billing.py def custom_method_request ( cls , sid , ** params ): url = \" %s / %s / %s \" % ( cls . class_url (), quote_plus ( util . utf8 ( sid )), http_path , ) obj = cls . _static_request ( http_verb , url , ** params ) # For list objects, we have to attach the parameters so that they # can be referenced in auto-pagination and ensure consistency. if \"object\" in obj and obj . object == \"list\" : obj . _retrieve_params = params return obj djstripe . models . billing . Subscription . stripe_class . delete_discount ( self , ** params ) Source code in djstripe/models/billing.py def delete_discount ( self , ** params ): requestor = api_requestor . APIRequestor ( self . api_key , api_version = self . stripe_version , account = self . stripe_account , ) url = self . instance_url () + \"/discount\" _ , api_key = requestor . request ( \"delete\" , url , params ) self . refresh_from ({ \"discount\" : None }, api_key , True )","title":"stripe_class"},{"location":"reference/models/#djstripe.models.billing.Subscription-methods","text":"","title":"Methods"},{"location":"reference/models/#djstripe.models.billing.Subscription.__str__","text":"Source code in djstripe/models/billing.py def __str__ ( self ): subscriptions_lst = self . customer . _get_valid_subscriptions () products_lst = [ subscription . plan . product . name for subscription in subscriptions_lst if subscription and subscription . plan ] return f \" { self . customer } on { ' and ' . join ( products_lst ) } \"","title":"__str__()"},{"location":"reference/models/#djstripe.models.billing.Subscription._attach_objects_post_save_hook","text":"Gets called by this object's create and sync methods just after save. Use this to populate fields after the model is saved. :param cls: The target class for the instantiated object. :param data: The data dictionary received from the Stripe API. :type data: dict Source code in djstripe/models/billing.py def _attach_objects_post_save_hook ( self , cls , data , pending_relations = None ): super () . _attach_objects_post_save_hook ( cls , data , pending_relations = pending_relations ) cls . _stripe_object_to_subscription_items ( target_cls = SubscriptionItem , data = data , subscription = self ) self . default_tax_rates . set ( cls . _stripe_object_to_default_tax_rates ( target_cls = TaxRate , data = data ) )","title":"_attach_objects_post_save_hook()"},{"location":"reference/models/#djstripe.models.billing.Subscription.cancel","text":"Cancels this subscription. If you set the at_period_end parameter to true, the subscription will remain active until the end of the period, at which point it will be canceled and not renewed. By default, the subscription is terminated immediately. In either case, the customer will not be charged again for the subscription. Note, however, that any pending invoice items that you've created will still be charged for at the end of the period unless manually deleted. If you've set the subscription to cancel at period end, any pending prorations will also be left in place and collected at the end of the period, but if the subscription is set to cancel immediately, pending prorations will be removed. By default, all unpaid invoices for the customer will be closed upon subscription cancellation. We do this in order to prevent unexpected payment retries once the customer has canceled a subscription. However, you can reopen the invoices manually after subscription cancellation to have us proceed with automatic retries, or you could even re-attempt payment yourself on all unpaid invoices before allowing the customer to cancel the subscription at all. :param at_period_end: A flag that if set to true will delay the cancellation of the subscription until the end of the current period. Default is False. :type at_period_end: boolean .. important:: If a subscription is canceled during a trial period, the at_period_end flag will be overridden to False so that the trial ends immediately and the customer's card isn't charged. Source code in djstripe/models/billing.py def cancel ( self , at_period_end : bool = False ): \"\"\" Cancels this subscription. If you set the at_period_end parameter to true, the subscription will remain active until the end of the period, at which point it will be canceled and not renewed. By default, the subscription is terminated immediately. In either case, the customer will not be charged again for the subscription. Note, however, that any pending invoice items that you've created will still be charged for at the end of the period unless manually deleted. If you've set the subscription to cancel at period end, any pending prorations will also be left in place and collected at the end of the period, but if the subscription is set to cancel immediately, pending prorations will be removed. By default, all unpaid invoices for the customer will be closed upon subscription cancellation. We do this in order to prevent unexpected payment retries once the customer has canceled a subscription. However, you can reopen the invoices manually after subscription cancellation to have us proceed with automatic retries, or you could even re-attempt payment yourself on all unpaid invoices before allowing the customer to cancel the subscription at all. :param at_period_end: A flag that if set to true will delay the cancellation \\ of the subscription until the end of the current period. Default is False. :type at_period_end: boolean .. important:: If a subscription is canceled during a trial period, \\ the ``at_period_end`` flag will be overridden to False so that the trial ends \\ immediately and the customer's card isn't charged. \"\"\" # If plan has trial days and customer cancels before # trial period ends, then end subscription now, # i.e. at_period_end=False if self . trial_end and self . trial_end > timezone . now (): at_period_end = False if at_period_end : stripe_subscription = self . _api_update ( cancel_at_period_end = True ) else : try : stripe_subscription = self . _api_delete () except InvalidRequestError as exc : if \"No such subscription:\" in str ( exc ): # cancel() works by deleting the subscription. The object still # exists in Stripe however, and can still be retrieved. # If the subscription was already canceled (status=canceled), # that api_retrieve() call will fail with \"No such subscription\". # However, this may also happen if the subscription legitimately # does not exist, in which case the following line will re-raise. stripe_subscription = self . api_retrieve () else : raise return Subscription . sync_from_stripe_data ( stripe_subscription )","title":"cancel()"},{"location":"reference/models/#djstripe.models.billing.Subscription.extend","text":"Extends this subscription by the provided delta. :param delta: The timedelta by which to extend this subscription. :type delta: timedelta Source code in djstripe/models/billing.py def extend ( self , delta ): \"\"\" Extends this subscription by the provided delta. :param delta: The timedelta by which to extend this subscription. :type delta: timedelta \"\"\" if delta . total_seconds () < 0 : raise ValueError ( \"delta must be a positive timedelta.\" ) if self . trial_end is not None and self . trial_end > timezone . now (): period_end = self . trial_end else : period_end = self . current_period_end period_end += delta return self . update ( proration_behavior = \"none\" , trial_end = period_end )","title":"extend()"},{"location":"reference/models/#djstripe.models.billing.Subscription.get_collection_method_display","text":"Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_collection_method_display()"},{"location":"reference/models/#djstripe.models.billing.Subscription.get_next_by_current_period_end","text":"Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_next_by_current_period_end()"},{"location":"reference/models/#djstripe.models.billing.Subscription.get_next_by_current_period_start","text":"Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_next_by_current_period_start()"},{"location":"reference/models/#djstripe.models.billing.Subscription.get_next_by_djstripe_created","text":"Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_next_by_djstripe_created()"},{"location":"reference/models/#djstripe.models.billing.Subscription.get_next_by_djstripe_updated","text":"Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_next_by_djstripe_updated()"},{"location":"reference/models/#djstripe.models.billing.Subscription.get_previous_by_current_period_end","text":"Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_previous_by_current_period_end()"},{"location":"reference/models/#djstripe.models.billing.Subscription.get_previous_by_current_period_start","text":"Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_previous_by_current_period_start()"},{"location":"reference/models/#djstripe.models.billing.Subscription.get_previous_by_djstripe_created","text":"Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_previous_by_djstripe_created()"},{"location":"reference/models/#djstripe.models.billing.Subscription.get_previous_by_djstripe_updated","text":"Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_previous_by_djstripe_updated()"},{"location":"reference/models/#djstripe.models.billing.Subscription.get_status_display","text":"Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_status_display()"},{"location":"reference/models/#djstripe.models.billing.Subscription.is_period_current","text":"Returns True if this subscription's period is current, false otherwise. Source code in djstripe/models/billing.py def is_period_current ( self ): \"\"\" Returns True if this subscription's period is current, false otherwise. \"\"\" return self . current_period_end > timezone . now () or ( self . trial_end and self . trial_end > timezone . now () )","title":"is_period_current()"},{"location":"reference/models/#djstripe.models.billing.Subscription.is_status_current","text":"Returns True if this subscription's status is current (active or trialing), false otherwise. Source code in djstripe/models/billing.py def is_status_current ( self ): \"\"\" Returns True if this subscription's status is current (active or trialing), false otherwise. \"\"\" return self . status in [ \"trialing\" , \"active\" ]","title":"is_status_current()"},{"location":"reference/models/#djstripe.models.billing.Subscription.is_status_temporarily_current","text":"A status is temporarily current when the subscription is canceled with the at_period_end flag. The subscription is still active, but is technically canceled and we're just waiting for it to run out. You could use this method to give customers limited service after they've canceled. For example, a video on demand service could only allow customers to download their libraries and do nothing else when their subscription is temporarily current. Source code in djstripe/models/billing.py def is_status_temporarily_current ( self ): \"\"\" A status is temporarily current when the subscription is canceled with the ``at_period_end`` flag. The subscription is still active, but is technically canceled and we're just waiting for it to run out. You could use this method to give customers limited service after they've canceled. For example, a video on demand service could only allow customers to download their libraries and do nothing else when their subscription is temporarily current. \"\"\" return ( self . canceled_at and self . cancel_at_period_end and timezone . now () < self . current_period_end )","title":"is_status_temporarily_current()"},{"location":"reference/models/#djstripe.models.billing.Subscription.is_valid","text":"Returns True if this subscription's status and period are current, false otherwise. Source code in djstripe/models/billing.py def is_valid ( self ): \"\"\" Returns True if this subscription's status and period are current, false otherwise. \"\"\" if not self . is_status_current (): return False if not self . is_period_current (): return False return True","title":"is_valid()"},{"location":"reference/models/#djstripe.models.billing.Subscription.reactivate","text":"Reactivates this subscription. If a customer's subscription is canceled with at_period_end set to True and it has not yet reached the end of the billing period, it can be reactivated. Subscriptions canceled immediately cannot be reactivated. (Source: https://stripe.com/docs/billing/subscriptions/cancel) .. warning:: Reactivating a fully canceled Subscription will fail silently. Be sure to check the returned Subscription's status. Source code in djstripe/models/billing.py def reactivate ( self ): \"\"\" Reactivates this subscription. If a customer's subscription is canceled with ``at_period_end`` set to True and it has not yet reached the end of the billing period, it can be reactivated. Subscriptions canceled immediately cannot be reactivated. (Source: https://stripe.com/docs/billing/subscriptions/cancel) .. warning:: Reactivating a fully canceled Subscription will fail silently. \\ Be sure to check the returned Subscription's status. \"\"\" stripe_subscription = self . api_retrieve () stripe_subscription . plan = self . plan . id stripe_subscription . cancel_at_period_end = False return Subscription . sync_from_stripe_data ( stripe_subscription . save ())","title":"reactivate()"},{"location":"reference/models/#djstripe.models.billing.Subscription.update","text":"See Customer.subscribe() <#djstripe.models.Customer.subscribe> __ :param plan: The plan to which to subscribe the customer. :type plan: Plan or string (plan ID) .. important:: Updating a subscription by changing the plan or quantity creates a new Subscription in Stripe (and dj-stripe). Source code in djstripe/models/billing.py def update ( self , plan : Union [ StripeModel , str ] = None , prorate : bool = None , ** kwargs , ): \"\"\" See `Customer.subscribe() <#djstripe.models.Customer.subscribe>`__ :param plan: The plan to which to subscribe the customer. :type plan: Plan or string (plan ID) .. important:: Updating a subscription by changing the plan or quantity \\ creates a new ``Subscription`` in \\ Stripe (and dj-stripe). \"\"\" # Convert Plan to id if plan is not None and isinstance ( plan , StripeModel ): plan = plan . id # In short: We used to have a `prorate` argument which defaulted to # a DJSTRIPE_PRORATION_POLICY setting. # This is overly complex and specific, so we are dropping support for this. # To override it, you can pass `proration_behavior`. # If instead you pass `prorate`, we will transform it until dj-stripe 2.8. # If you have DJSTRIPE_PRORATION_POLICY set, we will default to it for now. # In 2.8, we will ignore both of those and let Stripe figure it out. # Stripe's default proration policy is specified here: # https://stripe.com/docs/billing/subscriptions/prorations if \"proration_behavior\" not in kwargs : if prorate is not None : warnings . warn ( \"The `prorate` parameter to Subscription.update() is deprecated \" \"by Stripe. Use `proration_behavior` instead. \\n \" \"Read more: \" \"https://stripe.com/docs/billing/subscriptions/prorations\" ) else : prorate = djstripe_settings . PRORATION_POLICY if prorate is not None : warnings . warn ( \"The `DJSTRIPE_PRORATION_POLICY` setting is deprecated and will \" \"be ignored in dj-stripe 2.8. \" \"Specify `proration_behavior` instead.\" ) else : prorate = False if prorate : kwargs . setdefault ( \"proration_behavior\" , \"create_prorations\" ) else : kwargs . setdefault ( \"proration_behavior\" , \"none\" ) elif prorate is not None : raise TypeError ( \"`prorate` argument must not be set when `proration_behavior` is specified\" ) stripe_subscription = self . _api_update ( plan = plan , ** kwargs ) return Subscription . sync_from_stripe_data ( stripe_subscription )","title":"update()"},{"location":"reference/models/#djstripe.models.billing.SubscriptionItem","text":"Subscription items allow you to create customer subscriptions with more than one plan, making it easy to represent complex billing relationships. Stripe documentation: https://stripe.com/docs/api#subscription_items","title":"SubscriptionItem"},{"location":"reference/models/#djstripe.models.billing.SubscriptionItem.billing_thresholds","text":"","title":"billing_thresholds"},{"location":"reference/models/#djstripe.models.billing.SubscriptionItem.djstripe_owner_account","text":"","title":"djstripe_owner_account"},{"location":"reference/models/#djstripe.models.billing.SubscriptionItem.plan","text":"","title":"plan"},{"location":"reference/models/#djstripe.models.billing.SubscriptionItem.price","text":"","title":"price"},{"location":"reference/models/#djstripe.models.billing.SubscriptionItem.quantity","text":"","title":"quantity"},{"location":"reference/models/#djstripe.models.billing.SubscriptionItem.subscription","text":"","title":"subscription"},{"location":"reference/models/#djstripe.models.billing.SubscriptionItem.tax_rates","text":"","title":"tax_rates"},{"location":"reference/models/#djstripe.models.billing.SubscriptionItem-classes","text":"","title":"Classes"},{"location":"reference/models/#djstripe.models.billing.SubscriptionItem.DoesNotExist","text":"","title":"DoesNotExist"},{"location":"reference/models/#djstripe.models.billing.SubscriptionItem.MultipleObjectsReturned","text":"","title":"MultipleObjectsReturned"},{"location":"reference/models/#djstripe.models.billing.SubscriptionItem.stripe_class","text":"djstripe . models . billing . SubscriptionItem . stripe_class . OBJECT_NAME","title":"stripe_class"},{"location":"reference/models/#djstripe.models.billing.SubscriptionItem.stripe_class-methods","text":"djstripe . models . billing . SubscriptionItem . stripe_class . create_usage_record ( id , ** params ) classmethod Source code in djstripe/models/billing.py def create_nested_resource ( cls , id , ** params ): url = getattr ( cls , resource_url_method )( id ) return getattr ( cls , resource_request_method )( \"post\" , url , ** params ) djstripe . models . billing . SubscriptionItem . stripe_class . list_usage_record_summaries ( id , ** params ) classmethod Source code in djstripe/models/billing.py def list_nested_resources ( cls , id , ** params ): url = getattr ( cls , resource_url_method )( id ) return getattr ( cls , resource_request_method )( \"get\" , url , ** params ) djstripe . models . billing . SubscriptionItem . stripe_class . usage_record_summaries ( self , ** params ) usage_record_summaries is deprecated, use SubscriptionItem.list_usage_record_summaries instead. Source code in djstripe/models/billing.py def usage_record_summaries ( self , ** params ): \"\"\"usage_record_summaries is deprecated, use SubscriptionItem.list_usage_record_summaries instead.\"\"\" return self . request ( \"get\" , self . instance_url () + \"/usage_record_summaries\" , params ) djstripe . models . billing . SubscriptionItem . stripe_class . usage_record_summarys_request ( method , url , api_key = None , idempotency_key = None , stripe_version = None , stripe_account = None , ** params ) classmethod Source code in djstripe/models/billing.py def nested_resource_request ( cls , method , url , api_key = None , idempotency_key = None , stripe_version = None , stripe_account = None , ** params ): requestor = api_requestor . APIRequestor ( api_key , api_version = stripe_version , account = stripe_account ) headers = util . populate_headers ( idempotency_key ) response , api_key = requestor . request ( method , url , params , headers ) return util . convert_to_stripe_object ( response , api_key , stripe_version , stripe_account ) djstripe . models . billing . SubscriptionItem . stripe_class . usage_record_summarys_url ( id , nested_id = None ) classmethod Source code in djstripe/models/billing.py def nested_resource_url ( cls , id , nested_id = None ): url = \" %s / %s / %s \" % ( cls . class_url (), quote_plus ( id ), quote_plus ( path ), ) if nested_id is not None : url += \"/ %s \" % quote_plus ( nested_id ) return url djstripe . models . billing . SubscriptionItem . stripe_class . usage_records_request ( method , url , api_key = None , idempotency_key = None , stripe_version = None , stripe_account = None , ** params ) classmethod Source code in djstripe/models/billing.py def nested_resource_request ( cls , method , url , api_key = None , idempotency_key = None , stripe_version = None , stripe_account = None , ** params ): requestor = api_requestor . APIRequestor ( api_key , api_version = stripe_version , account = stripe_account ) headers = util . populate_headers ( idempotency_key ) response , api_key = requestor . request ( method , url , params , headers ) return util . convert_to_stripe_object ( response , api_key , stripe_version , stripe_account ) djstripe . models . billing . SubscriptionItem . stripe_class . usage_records_url ( id , nested_id = None ) classmethod Source code in djstripe/models/billing.py def nested_resource_url ( cls , id , nested_id = None ): url = \" %s / %s / %s \" % ( cls . class_url (), quote_plus ( id ), quote_plus ( path ), ) if nested_id is not None : url += \"/ %s \" % quote_plus ( nested_id ) return url","title":"Methods"},{"location":"reference/models/#djstripe.models.billing.SubscriptionItem-methods","text":"","title":"Methods"},{"location":"reference/models/#djstripe.models.billing.SubscriptionItem._attach_objects_post_save_hook","text":"Gets called by this object's create and sync methods just after save. Use this to populate fields after the model is saved. :param cls: The target class for the instantiated object. :param data: The data dictionary received from the Stripe API. :type data: dict Source code in djstripe/models/billing.py def _attach_objects_post_save_hook ( self , cls , data , pending_relations = None ): super () . _attach_objects_post_save_hook ( cls , data , pending_relations = pending_relations ) self . tax_rates . set ( cls . _stripe_object_to_tax_rates ( target_cls = TaxRate , data = data ) )","title":"_attach_objects_post_save_hook()"},{"location":"reference/models/#djstripe.models.billing.SubscriptionItem.get_next_by_djstripe_created","text":"Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_next_by_djstripe_created()"},{"location":"reference/models/#djstripe.models.billing.SubscriptionItem.get_next_by_djstripe_updated","text":"Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_next_by_djstripe_updated()"},{"location":"reference/models/#djstripe.models.billing.SubscriptionItem.get_previous_by_djstripe_created","text":"Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_previous_by_djstripe_created()"},{"location":"reference/models/#djstripe.models.billing.SubscriptionItem.get_previous_by_djstripe_updated","text":"Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_previous_by_djstripe_updated()"},{"location":"reference/models/#djstripe.models.billing.SubscriptionSchedule","text":"Subscription schedules allow you to create and manage the lifecycle of a subscription by predefining expected changes. Stripe documentation: https://stripe.com/docs/api/subscription_schedules","title":"SubscriptionSchedule"},{"location":"reference/models/#djstripe.models.billing.SubscriptionSchedule.billing_thresholds","text":"","title":"billing_thresholds"},{"location":"reference/models/#djstripe.models.billing.SubscriptionSchedule.canceled_at","text":"","title":"canceled_at"},{"location":"reference/models/#djstripe.models.billing.SubscriptionSchedule.completed_at","text":"","title":"completed_at"},{"location":"reference/models/#djstripe.models.billing.SubscriptionSchedule.current_phase","text":"","title":"current_phase"},{"location":"reference/models/#djstripe.models.billing.SubscriptionSchedule.customer","text":"","title":"customer"},{"location":"reference/models/#djstripe.models.billing.SubscriptionSchedule.default_settings","text":"","title":"default_settings"},{"location":"reference/models/#djstripe.models.billing.SubscriptionSchedule.djstripe_owner_account","text":"","title":"djstripe_owner_account"},{"location":"reference/models/#djstripe.models.billing.SubscriptionSchedule.end_behavior","text":"","title":"end_behavior"},{"location":"reference/models/#djstripe.models.billing.SubscriptionSchedule.phases","text":"","title":"phases"},{"location":"reference/models/#djstripe.models.billing.SubscriptionSchedule.released_at","text":"","title":"released_at"},{"location":"reference/models/#djstripe.models.billing.SubscriptionSchedule.released_subscription","text":"","title":"released_subscription"},{"location":"reference/models/#djstripe.models.billing.SubscriptionSchedule.status","text":"","title":"status"},{"location":"reference/models/#djstripe.models.billing.SubscriptionSchedule.DoesNotExist","text":"","title":"DoesNotExist"},{"location":"reference/models/#djstripe.models.billing.SubscriptionSchedule.MultipleObjectsReturned","text":"","title":"MultipleObjectsReturned"},{"location":"reference/models/#djstripe.models.billing.SubscriptionSchedule.stripe_class","text":"djstripe . models . billing . SubscriptionSchedule . stripe_class . OBJECT_NAME djstripe . models . billing . SubscriptionSchedule . stripe_class . _cls_cancel ( sid , ** params ) classmethod private Source code in djstripe/models/billing.py def custom_method_request ( cls , sid , ** params ): url = \" %s / %s / %s \" % ( cls . class_url (), quote_plus ( util . utf8 ( sid )), http_path , ) obj = cls . _static_request ( http_verb , url , ** params ) # For list objects, we have to attach the parameters so that they # can be referenced in auto-pagination and ensure consistency. if \"object\" in obj and obj . object == \"list\" : obj . _retrieve_params = params return obj djstripe . models . billing . SubscriptionSchedule . stripe_class . _cls_release ( sid , ** params ) classmethod private Source code in djstripe/models/billing.py def custom_method_request ( cls , sid , ** params ): url = \" %s / %s / %s \" % ( cls . class_url (), quote_plus ( util . utf8 ( sid )), http_path , ) obj = cls . _static_request ( http_verb , url , ** params ) # For list objects, we have to attach the parameters so that they # can be referenced in auto-pagination and ensure consistency. if \"object\" in obj and obj . object == \"list\" : obj . _retrieve_params = params return obj djstripe . models . billing . SubscriptionSchedule . stripe_class . cancel ( self , idempotency_key = None , ** params ) Source code in djstripe/models/billing.py def cancel ( self , idempotency_key = None , ** params ): url = self . instance_url () + \"/cancel\" headers = util . populate_headers ( idempotency_key ) self . refresh_from ( self . request ( \"post\" , url , params , headers )) return self djstripe . models . billing . SubscriptionSchedule . stripe_class . release ( self , idempotency_key = None , ** params ) Source code in djstripe/models/billing.py def release ( self , idempotency_key = None , ** params ): url = self . instance_url () + \"/release\" headers = util . populate_headers ( idempotency_key ) self . refresh_from ( self . request ( \"post\" , url , params , headers )) return self","title":"stripe_class"},{"location":"reference/models/#djstripe.models.billing.SubscriptionSchedule.get_end_behavior_display","text":"Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_end_behavior_display()"},{"location":"reference/models/#djstripe.models.billing.SubscriptionSchedule.get_next_by_djstripe_created","text":"Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_next_by_djstripe_created()"},{"location":"reference/models/#djstripe.models.billing.SubscriptionSchedule.get_next_by_djstripe_updated","text":"Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_next_by_djstripe_updated()"},{"location":"reference/models/#djstripe.models.billing.SubscriptionSchedule.get_previous_by_djstripe_created","text":"Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_previous_by_djstripe_created()"},{"location":"reference/models/#djstripe.models.billing.SubscriptionSchedule.get_previous_by_djstripe_updated","text":"Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_previous_by_djstripe_updated()"},{"location":"reference/models/#djstripe.models.billing.SubscriptionSchedule.get_status_display","text":"Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_status_display()"},{"location":"reference/models/#djstripe.models.billing.TaxId","text":"Add one or multiple tax IDs to a customer. A customer's tax IDs are displayed on invoices and credit notes issued for the customer. Stripe documentation: https://stripe.com/docs/api/customer_tax_ids","title":"TaxId"},{"location":"reference/models/#djstripe.models.billing.TaxId.country","text":"","title":"country"},{"location":"reference/models/#djstripe.models.billing.TaxId.customer","text":"","title":"customer"},{"location":"reference/models/#djstripe.models.billing.TaxId.description","text":"","title":"description"},{"location":"reference/models/#djstripe.models.billing.TaxId.djstripe_owner_account","text":"","title":"djstripe_owner_account"},{"location":"reference/models/#djstripe.models.billing.TaxId.metadata","text":"","title":"metadata"},{"location":"reference/models/#djstripe.models.billing.TaxId.type","text":"","title":"type"},{"location":"reference/models/#djstripe.models.billing.TaxId.value","text":"","title":"value"},{"location":"reference/models/#djstripe.models.billing.TaxId.verification","text":"","title":"verification"},{"location":"reference/models/#djstripe.models.billing.TaxId.DoesNotExist","text":"","title":"DoesNotExist"},{"location":"reference/models/#djstripe.models.billing.TaxId.MultipleObjectsReturned","text":"","title":"MultipleObjectsReturned"},{"location":"reference/models/#djstripe.models.billing.TaxId.stripe_class","text":"djstripe . models . billing . TaxId . stripe_class . OBJECT_NAME djstripe . models . billing . TaxId . stripe_class . instance_url ( self ) Source code in djstripe/models/billing.py def instance_url ( self ): token = util . utf8 ( self . id ) customer = util . utf8 ( self . customer ) base = Customer . class_url () cust_extn = quote_plus ( customer ) extn = quote_plus ( token ) return \" %s / %s /tax_ids/ %s \" % ( base , cust_extn , extn ) djstripe . models . billing . TaxId . stripe_class . retrieve ( id , api_key = None , ** params ) classmethod Source code in djstripe/models/billing.py @classmethod def retrieve ( cls , id , api_key = None , ** params ): raise NotImplementedError ( \"Can't retrieve a tax id without a customer ID. Use customer.retrieve_tax_id('tax_id')\" )","title":"stripe_class"},{"location":"reference/models/#djstripe.models.billing.TaxId-methods","text":"","title":"Methods"},{"location":"reference/models/#djstripe.models.billing.TaxId.__str__","text":"Source code in djstripe/models/billing.py def __str__ ( self ): return f \" { enums . TaxIdType . humanize ( self . type ) } { self . value } ( { self . verification . get ( 'status' ) } )\"","title":"__str__()"},{"location":"reference/models/#djstripe.models.billing.TaxId._api_create","text":"Call the stripe API's create operation for this model. :param api_key: The api key to use for this request. Defaults to djstripe_settings.STRIPE_SECRET_KEY. :type api_key: string Source code in djstripe/models/billing.py @classmethod def _api_create ( cls , api_key = djstripe_settings . STRIPE_SECRET_KEY , ** kwargs ): \"\"\" Call the stripe API's create operation for this model. :param api_key: The api key to use for this request. \\ Defaults to djstripe_settings.STRIPE_SECRET_KEY. :type api_key: string \"\"\" if not kwargs . get ( \"id\" ): raise KeyError ( \"Customer Object ID is missing\" ) try : Customer . objects . get ( id = kwargs [ \"id\" ]) except Customer . DoesNotExist : raise return stripe . Customer . create_tax_id ( api_key = api_key , ** kwargs )","title":"_api_create()"},{"location":"reference/models/#djstripe.models.billing.TaxId.api_list","text":"Call the stripe API's list operation for this model. :param api_key: The api key to use for this request. Defaults to djstripe_settings.STRIPE_SECRET_KEY. :type api_key: string See Stripe documentation for accepted kwargs for each object. :returns: an iterator over all items in the query Source code in djstripe/models/billing.py @classmethod def api_list ( cls , api_key = djstripe_settings . STRIPE_SECRET_KEY , ** kwargs ): \"\"\" Call the stripe API's list operation for this model. :param api_key: The api key to use for this request. \\ Defaults to djstripe_settings.STRIPE_SECRET_KEY. :type api_key: string See Stripe documentation for accepted kwargs for each object. :returns: an iterator over all items in the query \"\"\" return stripe . Customer . list_tax_ids ( api_key = api_key , ** kwargs ) . auto_paging_iter ()","title":"api_list()"},{"location":"reference/models/#djstripe.models.billing.TaxId.api_retrieve","text":"Call the stripe API's retrieve operation for this model. :param api_key: The api key to use for this request. Defaults to djstripe_settings.STRIPE_SECRET_KEY. :type api_key: string :param stripe_account: The optional connected account for which this request is being made. :type stripe_account: string Source code in djstripe/models/billing.py def api_retrieve ( self , api_key = None , stripe_account = None ): \"\"\" Call the stripe API's retrieve operation for this model. :param api_key: The api key to use for this request. \\ Defaults to djstripe_settings.STRIPE_SECRET_KEY. :type api_key: string :param stripe_account: The optional connected account \\ for which this request is being made. :type stripe_account: string \"\"\" nested_id = self . id id = self . customer . id # Prefer passed in stripe_account if set. if not stripe_account : stripe_account = self . _get_stripe_account_id ( api_key ) return stripe . Customer . retrieve_tax_id ( id = id , nested_id = nested_id , api_key = api_key or self . default_api_key , expand = self . expand_fields , stripe_account = stripe_account , )","title":"api_retrieve()"},{"location":"reference/models/#djstripe.models.billing.TaxId.get_next_by_djstripe_created","text":"Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_next_by_djstripe_created()"},{"location":"reference/models/#djstripe.models.billing.TaxId.get_next_by_djstripe_updated","text":"Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_next_by_djstripe_updated()"},{"location":"reference/models/#djstripe.models.billing.TaxId.get_previous_by_djstripe_created","text":"Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_previous_by_djstripe_created()"},{"location":"reference/models/#djstripe.models.billing.TaxId.get_previous_by_djstripe_updated","text":"Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_previous_by_djstripe_updated()"},{"location":"reference/models/#djstripe.models.billing.TaxId.get_type_display","text":"Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_type_display()"},{"location":"reference/models/#djstripe.models.billing.TaxRate","text":"Tax rates can be applied to invoices and subscriptions to collect tax. Stripe documentation: https://stripe.com/docs/api/tax_rates","title":"TaxRate"},{"location":"reference/models/#djstripe.models.billing.TaxRate.active","text":"","title":"active"},{"location":"reference/models/#djstripe.models.billing.TaxRate.display_name","text":"","title":"display_name"},{"location":"reference/models/#djstripe.models.billing.TaxRate.djstripe_owner_account","text":"","title":"djstripe_owner_account"},{"location":"reference/models/#djstripe.models.billing.TaxRate.inclusive","text":"","title":"inclusive"},{"location":"reference/models/#djstripe.models.billing.TaxRate.jurisdiction","text":"","title":"jurisdiction"},{"location":"reference/models/#djstripe.models.billing.TaxRate.percentage","text":"","title":"percentage"},{"location":"reference/models/#djstripe.models.billing.TaxRate.DoesNotExist","text":"","title":"DoesNotExist"},{"location":"reference/models/#djstripe.models.billing.TaxRate.MultipleObjectsReturned","text":"","title":"MultipleObjectsReturned"},{"location":"reference/models/#djstripe.models.billing.TaxRate.stripe_class","text":"","title":"stripe_class"},{"location":"reference/models/#djstripe.models.billing.TaxRate.__str__","text":"Source code in djstripe/models/billing.py def __str__ ( self ): return f \" { self . display_name } \u2013 { self . jurisdiction } at { self . percentage } %\"","title":"__str__()"},{"location":"reference/models/#djstripe.models.billing.TaxRate.get_next_by_djstripe_created","text":"Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_next_by_djstripe_created()"},{"location":"reference/models/#djstripe.models.billing.TaxRate.get_next_by_djstripe_updated","text":"Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_next_by_djstripe_updated()"},{"location":"reference/models/#djstripe.models.billing.TaxRate.get_previous_by_djstripe_created","text":"Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_previous_by_djstripe_created()"},{"location":"reference/models/#djstripe.models.billing.TaxRate.get_previous_by_djstripe_updated","text":"Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_previous_by_djstripe_updated()"},{"location":"reference/models/#djstripe.models.billing.UpcomingInvoice","text":"The preview of an upcoming invoice - does not exist in the Django database. See BaseInvoice.upcoming() Logically it should be set abstract, but that doesn't quite work since we do actually want to instantiate the model and use relations.","title":"UpcomingInvoice"},{"location":"reference/models/#djstripe.models.billing.UpcomingInvoice-attributes","text":"","title":"Attributes"},{"location":"reference/models/#djstripe.models.billing.UpcomingInvoice.charge","text":"","title":"charge"},{"location":"reference/models/#djstripe.models.billing.UpcomingInvoice.customer","text":"","title":"customer"},{"location":"reference/models/#djstripe.models.billing.UpcomingInvoice.default_payment_method","text":"","title":"default_payment_method"},{"location":"reference/models/#djstripe.models.billing.UpcomingInvoice.default_source","text":"","title":"default_source"},{"location":"reference/models/#djstripe.models.billing.UpcomingInvoice.default_tax_rates","text":"Gets the default tax rates associated with this upcoming invoice. :return:","title":"default_tax_rates"},{"location":"reference/models/#djstripe.models.billing.UpcomingInvoice.djstripe_owner_account","text":"","title":"djstripe_owner_account"},{"location":"reference/models/#djstripe.models.billing.UpcomingInvoice.id","text":"","title":"id"},{"location":"reference/models/#djstripe.models.billing.UpcomingInvoice.invoiceitems","text":"Gets the invoice items associated with this upcoming invoice. This differs from normal (non-upcoming) invoices, in that upcoming invoices are in-memory and do not persist to the database. Therefore, all of the data comes from the Stripe API itself. Instead of returning a normal queryset for the invoiceitems, this will return a mock of a queryset, but with the data fetched from Stripe - It will act like a normal queryset, but mutation will silently fail.","title":"invoiceitems"},{"location":"reference/models/#djstripe.models.billing.UpcomingInvoice.payment_intent","text":"","title":"payment_intent"},{"location":"reference/models/#djstripe.models.billing.UpcomingInvoice.subscription","text":"","title":"subscription"},{"location":"reference/models/#djstripe.models.billing.UpcomingInvoice.total_tax_amounts","text":"Gets the total tax amounts associated with this upcoming invoice. :return:","title":"total_tax_amounts"},{"location":"reference/models/#djstripe.models.billing.UpcomingInvoice.DoesNotExist","text":"","title":"DoesNotExist"},{"location":"reference/models/#djstripe.models.billing.UpcomingInvoice.MultipleObjectsReturned","text":"","title":"MultipleObjectsReturned"},{"location":"reference/models/#djstripe.models.billing.UpcomingInvoice-methods","text":"","title":"Methods"},{"location":"reference/models/#djstripe.models.billing.UpcomingInvoice.__init__","text":"Source code in djstripe/models/billing.py def __init__ ( self , * args , ** kwargs ): super () . __init__ ( * args , ** kwargs ) self . _invoiceitems = [] self . _default_tax_rates = [] self . _total_tax_amounts = []","title":"__init__()"},{"location":"reference/models/#djstripe.models.billing.UpcomingInvoice._attach_objects_hook","text":"Gets called by this object's create and sync methods just before save. Use this to populate fields before the model is saved. :param cls: The target class for the instantiated object. :param data: The data dictionary received from the Stripe API. :type data: dict :param current_ids: stripe ids of objects that are currently being processed :type current_ids: set Source code in djstripe/models/billing.py def _attach_objects_hook ( self , cls , data , current_ids = None ): super () . _attach_objects_hook ( cls , data , current_ids = current_ids ) self . _invoiceitems = cls . _stripe_object_to_invoice_items ( target_cls = InvoiceItem , data = data , invoice = self )","title":"_attach_objects_hook()"},{"location":"reference/models/#djstripe.models.billing.UpcomingInvoice._attach_objects_post_save_hook","text":"Gets called by this object's create and sync methods just after save. Use this to populate fields after the model is saved. :param cls: The target class for the instantiated object. :param data: The data dictionary received from the Stripe API. :type data: dict Source code in djstripe/models/billing.py def _attach_objects_post_save_hook ( self , cls , data , pending_relations = None ): super () . _attach_objects_post_save_hook ( cls , data , pending_relations = pending_relations ) self . _default_tax_rates = cls . _stripe_object_to_default_tax_rates ( target_cls = TaxRate , data = data ) total_tax_amounts = [] for tax_amount_data in data . get ( \"total_tax_amounts\" , []): tax_rate_id = tax_amount_data [ \"tax_rate\" ] if not isinstance ( tax_rate_id , str ): tax_rate_id = tax_rate_id [ \"tax_rate\" ] tax_rate = TaxRate . _get_or_retrieve ( id = tax_rate_id ) tax_amount = DjstripeUpcomingInvoiceTotalTaxAmount ( invoice = self , amount = tax_amount_data [ \"amount\" ], inclusive = tax_amount_data [ \"inclusive\" ], tax_rate = tax_rate , ) total_tax_amounts . append ( tax_amount ) self . _total_tax_amounts = total_tax_amounts","title":"_attach_objects_post_save_hook()"},{"location":"reference/models/#djstripe.models.billing.UpcomingInvoice.get_billing_reason_display","text":"Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_billing_reason_display()"},{"location":"reference/models/#djstripe.models.billing.UpcomingInvoice.get_collection_method_display","text":"Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_collection_method_display()"},{"location":"reference/models/#djstripe.models.billing.UpcomingInvoice.get_customer_tax_exempt_display","text":"Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_customer_tax_exempt_display()"},{"location":"reference/models/#djstripe.models.billing.UpcomingInvoice.get_next_by_djstripe_created","text":"Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_next_by_djstripe_created()"},{"location":"reference/models/#djstripe.models.billing.UpcomingInvoice.get_next_by_djstripe_updated","text":"Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_next_by_djstripe_updated()"},{"location":"reference/models/#djstripe.models.billing.UpcomingInvoice.get_next_by_period_end","text":"Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_next_by_period_end()"},{"location":"reference/models/#djstripe.models.billing.UpcomingInvoice.get_next_by_period_start","text":"Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_next_by_period_start()"},{"location":"reference/models/#djstripe.models.billing.UpcomingInvoice.get_previous_by_djstripe_created","text":"Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_previous_by_djstripe_created()"},{"location":"reference/models/#djstripe.models.billing.UpcomingInvoice.get_previous_by_djstripe_updated","text":"Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_previous_by_djstripe_updated()"},{"location":"reference/models/#djstripe.models.billing.UpcomingInvoice.get_previous_by_period_end","text":"Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_previous_by_period_end()"},{"location":"reference/models/#djstripe.models.billing.UpcomingInvoice.get_previous_by_period_start","text":"Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_previous_by_period_start()"},{"location":"reference/models/#djstripe.models.billing.UpcomingInvoice.get_status_display","text":"Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_status_display()"},{"location":"reference/models/#djstripe.models.billing.UpcomingInvoice.get_stripe_dashboard_url","text":"Get the stripe dashboard url for this object. Source code in djstripe/models/billing.py def get_stripe_dashboard_url ( self ): return \"\"","title":"get_stripe_dashboard_url()"},{"location":"reference/models/#djstripe.models.billing.UpcomingInvoice.save","text":"Save the current instance. Override this in a subclass if you want to control the saving process. The 'force_insert' and 'force_update' parameters can be used to insist that the \"save\" must be an SQL insert or update (or equivalent for non-SQL backends), respectively. Normally, they should not be set. Source code in djstripe/models/billing.py def save ( self , * args , ** kwargs ): return # noop","title":"save()"},{"location":"reference/models/#djstripe.models.billing.UsageRecord","text":"Usage records allow you to continually report usage and metrics to Stripe for metered billing of plans. Stripe documentation: https://stripe.com/docs/api#usage_records","title":"UsageRecord"},{"location":"reference/models/#djstripe.models.billing.UsageRecord.action","text":"","title":"action"},{"location":"reference/models/#djstripe.models.billing.UsageRecord.description","text":"","title":"description"},{"location":"reference/models/#djstripe.models.billing.UsageRecord.djstripe_owner_account","text":"","title":"djstripe_owner_account"},{"location":"reference/models/#djstripe.models.billing.UsageRecord.metadata","text":"","title":"metadata"},{"location":"reference/models/#djstripe.models.billing.UsageRecord.quantity","text":"","title":"quantity"},{"location":"reference/models/#djstripe.models.billing.UsageRecord.subscription_item","text":"","title":"subscription_item"},{"location":"reference/models/#djstripe.models.billing.UsageRecord.timestamp","text":"","title":"timestamp"},{"location":"reference/models/#djstripe.models.billing.UsageRecord.DoesNotExist","text":"","title":"DoesNotExist"},{"location":"reference/models/#djstripe.models.billing.UsageRecord.MultipleObjectsReturned","text":"","title":"MultipleObjectsReturned"},{"location":"reference/models/#djstripe.models.billing.UsageRecord.stripe_class","text":"djstripe . models . billing . UsageRecord . stripe_class . OBJECT_NAME djstripe . models . billing . UsageRecord . stripe_class . create ( api_key = None , idempotency_key = None , stripe_version = None , stripe_account = None , ** params ) classmethod Source code in djstripe/models/billing.py @classmethod def create ( cls , api_key = None , idempotency_key = None , stripe_version = None , stripe_account = None , ** params ): if \"subscription_item\" not in params : raise ValueError ( \"Params must have a subscription_item key\" ) subscription_item = params . pop ( \"subscription_item\" ) requestor = api_requestor . APIRequestor ( api_key , api_version = stripe_version , account = stripe_account ) url = \"/v1/subscription_items/ %s /usage_records\" % subscription_item headers = util . populate_headers ( idempotency_key ) response , api_key = requestor . request ( \"post\" , url , params , headers ) return util . convert_to_stripe_object ( response , api_key , stripe_version , stripe_account )","title":"stripe_class"},{"location":"reference/models/#djstripe.models.billing.UsageRecord-methods","text":"","title":"Methods"},{"location":"reference/models/#djstripe.models.billing.UsageRecord.__str__","text":"Source code in djstripe/models/billing.py def __str__ ( self ): return f \"Usage for { self . subscription_item } ( { self . action } ) is { self . quantity } \"","title":"__str__()"},{"location":"reference/models/#djstripe.models.billing.UsageRecord._api_create","text":"Call the stripe API's create operation for this model. :param api_key: The api key to use for this request. Defaults to djstripe_settings.STRIPE_SECRET_KEY. :type api_key: string Source code in djstripe/models/billing.py @classmethod def _api_create ( cls , api_key = djstripe_settings . STRIPE_SECRET_KEY , ** kwargs ): \"\"\" Call the stripe API's create operation for this model. :param api_key: The api key to use for this request. \\ Defaults to djstripe_settings.STRIPE_SECRET_KEY. :type api_key: string \"\"\" if not kwargs . get ( \"id\" ): raise KeyError ( \"SubscriptionItem Object ID is missing\" ) try : SubscriptionItem . objects . get ( id = kwargs [ \"id\" ]) except SubscriptionItem . DoesNotExist : raise usage_stripe_data = stripe . SubscriptionItem . create_usage_record ( api_key = api_key , ** kwargs ) # ! Hack: there is no way to retrieve a UsageRecord object from Stripe, # ! which is why we create and sync it right here cls . sync_from_stripe_data ( usage_stripe_data ) return usage_stripe_data","title":"_api_create()"},{"location":"reference/models/#djstripe.models.billing.UsageRecord.create","text":"A wrapper around _api_create() to allow one to create and sync UsageRecord Objects Source code in djstripe/models/billing.py @classmethod def create ( cls , ** kwargs ): \"\"\" A wrapper around _api_create() to allow one to create and sync UsageRecord Objects \"\"\" return cls . _api_create ( ** kwargs )","title":"create()"},{"location":"reference/models/#djstripe.models.billing.UsageRecord.get_action_display","text":"Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_action_display()"},{"location":"reference/models/#djstripe.models.billing.UsageRecord.get_next_by_djstripe_created","text":"Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_next_by_djstripe_created()"},{"location":"reference/models/#djstripe.models.billing.UsageRecord.get_next_by_djstripe_updated","text":"Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_next_by_djstripe_updated()"},{"location":"reference/models/#djstripe.models.billing.UsageRecord.get_previous_by_djstripe_created","text":"Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_previous_by_djstripe_created()"},{"location":"reference/models/#djstripe.models.billing.UsageRecord.get_previous_by_djstripe_updated","text":"Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_previous_by_djstripe_updated()"},{"location":"reference/models/#djstripe.models.billing.UsageRecordSummary","text":"Usage record summaries provides usage information that's been summarized from multiple usage records and over a subscription billing period (e.g., 15 usage records in the month of September). Since new usage records can still be added, the returned summary information for the subscription item's ID should be seen as unstable until the subscription billing period ends. Stripe documentation: https://stripe.com/docs/api/usage_records/subscription_item_summary_list","title":"UsageRecordSummary"},{"location":"reference/models/#djstripe.models.billing.UsageRecordSummary.description","text":"","title":"description"},{"location":"reference/models/#djstripe.models.billing.UsageRecordSummary.djstripe_owner_account","text":"","title":"djstripe_owner_account"},{"location":"reference/models/#djstripe.models.billing.UsageRecordSummary.invoice","text":"","title":"invoice"},{"location":"reference/models/#djstripe.models.billing.UsageRecordSummary.metadata","text":"","title":"metadata"},{"location":"reference/models/#djstripe.models.billing.UsageRecordSummary.period","text":"","title":"period"},{"location":"reference/models/#djstripe.models.billing.UsageRecordSummary.period_end","text":"","title":"period_end"},{"location":"reference/models/#djstripe.models.billing.UsageRecordSummary.period_start","text":"","title":"period_start"},{"location":"reference/models/#djstripe.models.billing.UsageRecordSummary.subscription_item","text":"","title":"subscription_item"},{"location":"reference/models/#djstripe.models.billing.UsageRecordSummary.total_usage","text":"","title":"total_usage"},{"location":"reference/models/#djstripe.models.billing.UsageRecordSummary.DoesNotExist","text":"","title":"DoesNotExist"},{"location":"reference/models/#djstripe.models.billing.UsageRecordSummary.MultipleObjectsReturned","text":"","title":"MultipleObjectsReturned"},{"location":"reference/models/#djstripe.models.billing.UsageRecordSummary.stripe_class","text":"","title":"stripe_class"},{"location":"reference/models/#djstripe.models.billing.UsageRecordSummary-methods","text":"","title":"Methods"},{"location":"reference/models/#djstripe.models.billing.UsageRecordSummary.__str__","text":"Source code in djstripe/models/billing.py def __str__ ( self ): return f \"Usage Summary for { self . subscription_item } ( { self . invoice } ) is { self . total_usage } \"","title":"__str__()"},{"location":"reference/models/#djstripe.models.billing.UsageRecordSummary._manipulate_stripe_object_hook","text":"Gets called by this object's stripe object conversion method just before conversion. Use this to populate custom fields in a StripeModel from stripe data. Source code in djstripe/models/billing.py @classmethod def _manipulate_stripe_object_hook ( cls , data ): data [ \"period_start\" ] = data [ \"period\" ][ \"start\" ] data [ \"period_end\" ] = data [ \"period\" ][ \"end\" ] return data","title":"_manipulate_stripe_object_hook()"},{"location":"reference/models/#djstripe.models.billing.UsageRecordSummary.api_list","text":"Call the stripe API's list operation for this model. :param api_key: The api key to use for this request. Defaults to djstripe_settings.STRIPE_SECRET_KEY. :type api_key: string See Stripe documentation for accepted kwargs for each object. :returns: an iterator over all items in the query Source code in djstripe/models/billing.py @classmethod def api_list ( cls , api_key = djstripe_settings . STRIPE_SECRET_KEY , ** kwargs ): \"\"\" Call the stripe API's list operation for this model. :param api_key: The api key to use for this request. \\ Defaults to djstripe_settings.STRIPE_SECRET_KEY. :type api_key: string See Stripe documentation for accepted kwargs for each object. :returns: an iterator over all items in the query \"\"\" if not kwargs . get ( \"id\" ): raise KeyError ( \"SubscriptionItem Object ID is missing\" ) try : SubscriptionItem . objects . get ( id = kwargs [ \"id\" ]) except SubscriptionItem . DoesNotExist : raise return stripe . SubscriptionItem . list_usage_record_summaries ( api_key = api_key , ** kwargs ) . auto_paging_iter ()","title":"api_list()"},{"location":"reference/models/#djstripe.models.billing.UsageRecordSummary.get_next_by_djstripe_created","text":"Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_next_by_djstripe_created()"},{"location":"reference/models/#djstripe.models.billing.UsageRecordSummary.get_next_by_djstripe_updated","text":"Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_next_by_djstripe_updated()"},{"location":"reference/models/#djstripe.models.billing.UsageRecordSummary.get_previous_by_djstripe_created","text":"Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_previous_by_djstripe_created()"},{"location":"reference/models/#djstripe.models.billing.UsageRecordSummary.get_previous_by_djstripe_updated","text":"Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_previous_by_djstripe_updated()"},{"location":"reference/models/#connect","text":"","title":"Connect"},{"location":"reference/models/#djstripe.models.account-classes","text":"","title":"Classes"},{"location":"reference/models/#djstripe.models.account.Account","text":"Stripe documentation: https://stripe.com/docs/api/accounts","title":"Account"},{"location":"reference/models/#djstripe.models.account.Account-attributes","text":"","title":"Attributes"},{"location":"reference/models/#djstripe.models.account.Account.branding_icon","text":"","title":"branding_icon"},{"location":"reference/models/#djstripe.models.account.Account.branding_logo","text":"","title":"branding_logo"},{"location":"reference/models/#djstripe.models.account.Account.business_profile","text":"","title":"business_profile"},{"location":"reference/models/#djstripe.models.account.Account.business_type","text":"","title":"business_type"},{"location":"reference/models/#djstripe.models.account.Account.business_url","text":"The business's publicly available website.","title":"business_url"},{"location":"reference/models/#djstripe.models.account.Account.charges_enabled","text":"","title":"charges_enabled"},{"location":"reference/models/#djstripe.models.account.Account.company","text":"","title":"company"},{"location":"reference/models/#djstripe.models.account.Account.country","text":"","title":"country"},{"location":"reference/models/#djstripe.models.account.Account.default_api_key","text":"","title":"default_api_key"},{"location":"reference/models/#djstripe.models.account.Account.default_currency","text":"","title":"default_currency"},{"location":"reference/models/#djstripe.models.account.Account.details_submitted","text":"","title":"details_submitted"},{"location":"reference/models/#djstripe.models.account.Account.djstripe_owner_account","text":"","title":"djstripe_owner_account"},{"location":"reference/models/#djstripe.models.account.Account.email","text":"","title":"email"},{"location":"reference/models/#djstripe.models.account.Account.individual","text":"","title":"individual"},{"location":"reference/models/#djstripe.models.account.Account.payouts_enabled","text":"","title":"payouts_enabled"},{"location":"reference/models/#djstripe.models.account.Account.product_description","text":"","title":"product_description"},{"location":"reference/models/#djstripe.models.account.Account.requirements","text":"","title":"requirements"},{"location":"reference/models/#djstripe.models.account.Account.settings","text":"","title":"settings"},{"location":"reference/models/#djstripe.models.account.Account.tos_acceptance","text":"","title":"tos_acceptance"},{"location":"reference/models/#djstripe.models.account.Account.type","text":"","title":"type"},{"location":"reference/models/#djstripe.models.account.Account.DoesNotExist","text":"","title":"DoesNotExist"},{"location":"reference/models/#djstripe.models.account.Account.MultipleObjectsReturned","text":"","title":"MultipleObjectsReturned"},{"location":"reference/models/#djstripe.models.account.Account.stripe_class","text":"djstripe . models . account . Account . stripe_class . OBJECT_NAME djstripe . models . account . Account . stripe_class . capabilitys_request ( method , url , api_key = None , idempotency_key = None , stripe_version = None , stripe_account = None , ** params ) classmethod Source code in djstripe/models/account.py def nested_resource_request ( cls , method , url , api_key = None , idempotency_key = None , stripe_version = None , stripe_account = None , ** params ): requestor = api_requestor . APIRequestor ( api_key , api_version = stripe_version , account = stripe_account ) headers = util . populate_headers ( idempotency_key ) response , api_key = requestor . request ( method , url , params , headers ) return util . convert_to_stripe_object ( response , api_key , stripe_version , stripe_account ) djstripe . models . account . Account . stripe_class . capabilitys_url ( id , nested_id = None ) classmethod Source code in djstripe/models/account.py def nested_resource_url ( cls , id , nested_id = None ): url = \" %s / %s / %s \" % ( cls . class_url (), quote_plus ( id ), quote_plus ( path ), ) if nested_id is not None : url += \"/ %s \" % quote_plus ( nested_id ) return url djstripe . models . account . Account . stripe_class . create_external_account ( id , ** params ) classmethod Source code in djstripe/models/account.py def create_nested_resource ( cls , id , ** params ): url = getattr ( cls , resource_url_method )( id ) return getattr ( cls , resource_request_method )( \"post\" , url , ** params ) djstripe . models . account . Account . stripe_class . create_login_link ( id , ** params ) classmethod Source code in djstripe/models/account.py def create_nested_resource ( cls , id , ** params ): url = getattr ( cls , resource_url_method )( id ) return getattr ( cls , resource_request_method )( \"post\" , url , ** params ) djstripe . models . account . Account . stripe_class . create_person ( id , ** params ) classmethod Source code in djstripe/models/account.py def create_nested_resource ( cls , id , ** params ): url = getattr ( cls , resource_url_method )( id ) return getattr ( cls , resource_request_method )( \"post\" , url , ** params ) djstripe . models . account . Account . stripe_class . deauthorize ( self , ** params ) Source code in djstripe/models/account.py def deauthorize ( self , ** params ): params [ \"stripe_user_id\" ] = self . id return oauth . OAuth . deauthorize ( ** params ) djstripe . models . account . Account . stripe_class . delete_external_account ( id , nested_id , ** params ) classmethod Source code in djstripe/models/account.py def delete_nested_resource ( cls , id , nested_id , ** params ): url = getattr ( cls , resource_url_method )( id , nested_id ) return getattr ( cls , resource_request_method )( \"delete\" , url , ** params ) djstripe . models . account . Account . stripe_class . delete_person ( id , nested_id , ** params ) classmethod Source code in djstripe/models/account.py def delete_nested_resource ( cls , id , nested_id , ** params ): url = getattr ( cls , resource_url_method )( id , nested_id ) return getattr ( cls , resource_request_method )( \"delete\" , url , ** params ) djstripe . models . account . Account . stripe_class . external_accounts_request ( method , url , api_key = None , idempotency_key = None , stripe_version = None , stripe_account = None , ** params ) classmethod Source code in djstripe/models/account.py def nested_resource_request ( cls , method , url , api_key = None , idempotency_key = None , stripe_version = None , stripe_account = None , ** params ): requestor = api_requestor . APIRequestor ( api_key , api_version = stripe_version , account = stripe_account ) headers = util . populate_headers ( idempotency_key ) response , api_key = requestor . request ( method , url , params , headers ) return util . convert_to_stripe_object ( response , api_key , stripe_version , stripe_account ) djstripe . models . account . Account . stripe_class . external_accounts_url ( id , nested_id = None ) classmethod Source code in djstripe/models/account.py def nested_resource_url ( cls , id , nested_id = None ): url = \" %s / %s / %s \" % ( cls . class_url (), quote_plus ( id ), quote_plus ( path ), ) if nested_id is not None : url += \"/ %s \" % quote_plus ( nested_id ) return url djstripe . models . account . Account . stripe_class . instance_url ( self ) Source code in djstripe/models/account.py def instance_url ( self ): return self . _build_instance_url ( self . get ( \"id\" )) djstripe . models . account . Account . stripe_class . list_capabilities ( id , ** params ) classmethod Source code in djstripe/models/account.py def list_nested_resources ( cls , id , ** params ): url = getattr ( cls , resource_url_method )( id ) return getattr ( cls , resource_request_method )( \"get\" , url , ** params ) djstripe . models . account . Account . stripe_class . list_external_accounts ( id , ** params ) classmethod Source code in djstripe/models/account.py def list_nested_resources ( cls , id , ** params ): url = getattr ( cls , resource_url_method )( id ) return getattr ( cls , resource_request_method )( \"get\" , url , ** params ) djstripe . models . account . Account . stripe_class . list_persons ( id , ** params ) classmethod Source code in djstripe/models/account.py def list_nested_resources ( cls , id , ** params ): url = getattr ( cls , resource_url_method )( id ) return getattr ( cls , resource_request_method )( \"get\" , url , ** params ) djstripe . models . account . Account . stripe_class . login_links_request ( method , url , api_key = None , idempotency_key = None , stripe_version = None , stripe_account = None , ** params ) classmethod Source code in djstripe/models/account.py def nested_resource_request ( cls , method , url , api_key = None , idempotency_key = None , stripe_version = None , stripe_account = None , ** params ): requestor = api_requestor . APIRequestor ( api_key , api_version = stripe_version , account = stripe_account ) headers = util . populate_headers ( idempotency_key ) response , api_key = requestor . request ( method , url , params , headers ) return util . convert_to_stripe_object ( response , api_key , stripe_version , stripe_account ) djstripe . models . account . Account . stripe_class . login_links_url ( id , nested_id = None ) classmethod Source code in djstripe/models/account.py def nested_resource_url ( cls , id , nested_id = None ): url = \" %s / %s / %s \" % ( cls . class_url (), quote_plus ( id ), quote_plus ( path ), ) if nested_id is not None : url += \"/ %s \" % quote_plus ( nested_id ) return url djstripe . models . account . Account . stripe_class . modify ( id = None , ** params ) classmethod Source code in djstripe/models/account.py @classmethod def modify ( cls , id = None , ** params ): url = cls . _build_instance_url ( id ) return cls . _static_request ( \"post\" , url , ** params ) djstripe . models . account . Account . stripe_class . modify_capability ( id , nested_id , ** params ) classmethod Source code in djstripe/models/account.py def modify_nested_resource ( cls , id , nested_id , ** params ): url = getattr ( cls , resource_url_method )( id , nested_id ) return getattr ( cls , resource_request_method )( \"post\" , url , ** params ) djstripe . models . account . Account . stripe_class . modify_external_account ( id , nested_id , ** params ) classmethod Source code in djstripe/models/account.py def modify_nested_resource ( cls , id , nested_id , ** params ): url = getattr ( cls , resource_url_method )( id , nested_id ) return getattr ( cls , resource_request_method )( \"post\" , url , ** params ) djstripe . models . account . Account . stripe_class . modify_person ( id , nested_id , ** params ) classmethod Source code in djstripe/models/account.py def modify_nested_resource ( cls , id , nested_id , ** params ): url = getattr ( cls , resource_url_method )( id , nested_id ) return getattr ( cls , resource_request_method )( \"post\" , url , ** params ) djstripe . models . account . Account . stripe_class . persons ( self , ** params ) Source code in djstripe/models/account.py def persons ( self , ** params ): return self . request ( \"get\" , self . instance_url () + \"/persons\" , params ) djstripe . models . account . Account . stripe_class . persons_request ( method , url , api_key = None , idempotency_key = None , stripe_version = None , stripe_account = None , ** params ) classmethod Source code in djstripe/models/account.py def nested_resource_request ( cls , method , url , api_key = None , idempotency_key = None , stripe_version = None , stripe_account = None , ** params ): requestor = api_requestor . APIRequestor ( api_key , api_version = stripe_version , account = stripe_account ) headers = util . populate_headers ( idempotency_key ) response , api_key = requestor . request ( method , url , params , headers ) return util . convert_to_stripe_object ( response , api_key , stripe_version , stripe_account ) djstripe . models . account . Account . stripe_class . persons_url ( id , nested_id = None ) classmethod Source code in djstripe/models/account.py def nested_resource_url ( cls , id , nested_id = None ): url = \" %s / %s / %s \" % ( cls . class_url (), quote_plus ( id ), quote_plus ( path ), ) if nested_id is not None : url += \"/ %s \" % quote_plus ( nested_id ) return url djstripe . models . account . Account . stripe_class . reject ( self , idempotency_key = None , ** params ) Source code in djstripe/models/account.py def reject ( self , idempotency_key = None , ** params ): url = self . instance_url () + \"/reject\" headers = util . populate_headers ( idempotency_key ) self . refresh_from ( self . request ( \"post\" , url , params , headers )) return self djstripe . models . account . Account . stripe_class . retrieve ( id = None , api_key = None , ** params ) classmethod Source code in djstripe/models/account.py @classmethod def retrieve ( cls , id = None , api_key = None , ** params ): instance = cls ( id , api_key , ** params ) instance . refresh () return instance djstripe . models . account . Account . stripe_class . retrieve_capability ( id , nested_id , ** params ) classmethod Source code in djstripe/models/account.py def retrieve_nested_resource ( cls , id , nested_id , ** params ): url = getattr ( cls , resource_url_method )( id , nested_id ) return getattr ( cls , resource_request_method )( \"get\" , url , ** params ) djstripe . models . account . Account . stripe_class . retrieve_external_account ( id , nested_id , ** params ) classmethod Source code in djstripe/models/account.py def retrieve_nested_resource ( cls , id , nested_id , ** params ): url = getattr ( cls , resource_url_method )( id , nested_id ) return getattr ( cls , resource_request_method )( \"get\" , url , ** params ) djstripe . models . account . Account . stripe_class . retrieve_person ( id , nested_id , ** params ) classmethod Source code in djstripe/models/account.py def retrieve_nested_resource ( cls , id , nested_id , ** params ): url = getattr ( cls , resource_url_method )( id , nested_id ) return getattr ( cls , resource_request_method )( \"get\" , url , ** params ) djstripe . models . account . Account . stripe_class . serialize ( self , previous ) Source code in djstripe/models/account.py def serialize ( self , previous ): params = super ( Account , self ) . serialize ( previous ) previous = previous or self . _previous or {} for k , v in six . iteritems ( self ): if ( k == \"individual\" and isinstance ( v , stripe . api_resources . Person ) and k not in params ): params [ k ] = v . serialize ( previous . get ( k , None )) return params","title":"stripe_class"},{"location":"reference/models/#djstripe.models.account.Account.__str__","text":"Source code in djstripe/models/account.py def __str__ ( self ): settings = self . settings or {} business_profile = self . business_profile or {} return ( settings . get ( \"dashboard\" , {}) . get ( \"display_name\" ) or business_profile . get ( \"name\" ) or super () . __str__ () )","title":"__str__()"},{"location":"reference/models/#djstripe.models.account.Account.get_business_type_display","text":"Source code in djstripe/models/account.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_business_type_display()"},{"location":"reference/models/#djstripe.models.account.Account.get_default_account","text":"Source code in djstripe/models/account.py @classmethod def get_default_account ( cls ): # As of API version 2020-03-02, there is no permission that can allow # restricted keys to call GET /v1/account if djstripe_settings . STRIPE_SECRET_KEY . startswith ( \"rk_\" ): return None account_data = cls . stripe_class . retrieve ( api_key = djstripe_settings . STRIPE_SECRET_KEY ) return cls . _get_or_create_from_stripe_object ( account_data )[ 0 ]","title":"get_default_account()"},{"location":"reference/models/#djstripe.models.account.Account.get_default_api_key","text":"Source code in djstripe/models/account.py def get_default_api_key ( self ) -> str : api_key = APIKey . objects . filter ( djstripe_owner_account = self , type = APIKeyType . secret ) . first () if api_key : return api_key . secret return djstripe_settings . get_default_api_key ( self . livemode )","title":"get_default_api_key()"},{"location":"reference/models/#djstripe.models.account.Account.get_next_by_djstripe_created","text":"Source code in djstripe/models/account.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_next_by_djstripe_created()"},{"location":"reference/models/#djstripe.models.account.Account.get_next_by_djstripe_updated","text":"Source code in djstripe/models/account.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_next_by_djstripe_updated()"},{"location":"reference/models/#djstripe.models.account.Account.get_or_retrieve_for_api_key","text":"Source code in djstripe/models/account.py @classmethod def get_or_retrieve_for_api_key ( cls , api_key : str ): with transaction . atomic (): apikey_instance , _ = APIKey . objects . get_or_create_by_api_key ( api_key ) if not apikey_instance . djstripe_owner_account : apikey_instance . refresh_account () return apikey_instance . djstripe_owner_account","title":"get_or_retrieve_for_api_key()"},{"location":"reference/models/#djstripe.models.account.Account.get_previous_by_djstripe_created","text":"Source code in djstripe/models/account.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_previous_by_djstripe_created()"},{"location":"reference/models/#djstripe.models.account.Account.get_previous_by_djstripe_updated","text":"Source code in djstripe/models/account.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_previous_by_djstripe_updated()"},{"location":"reference/models/#djstripe.models.account.Account.get_type_display","text":"Source code in djstripe/models/account.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_type_display()"},{"location":"reference/models/#djstripe.models.connect-classes","text":"","title":"Classes"},{"location":"reference/models/#djstripe.models.connect.ApplicationFee","text":"When you collect a transaction fee on top of a charge made for your user (using Connect), an ApplicationFee is created in your account. Please note the model field charge exists on the Stripe Connected Account while the application_fee modelfield on Charge model exists on the Platform Account! Stripe documentation: https://stripe.com/docs/api#application_fees","title":"ApplicationFee"},{"location":"reference/models/#djstripe.models.connect.ApplicationFee.account","text":"","title":"account"},{"location":"reference/models/#djstripe.models.connect.ApplicationFee.amount","text":"","title":"amount"},{"location":"reference/models/#djstripe.models.connect.ApplicationFee.amount_refunded","text":"","title":"amount_refunded"},{"location":"reference/models/#djstripe.models.connect.ApplicationFee.balance_transaction","text":"","title":"balance_transaction"},{"location":"reference/models/#djstripe.models.connect.ApplicationFee.charge","text":"","title":"charge"},{"location":"reference/models/#djstripe.models.connect.ApplicationFee.currency","text":"","title":"currency"},{"location":"reference/models/#djstripe.models.connect.ApplicationFee.djstripe_owner_account","text":"","title":"djstripe_owner_account"},{"location":"reference/models/#djstripe.models.connect.ApplicationFee.refunded","text":"","title":"refunded"},{"location":"reference/models/#djstripe.models.connect.ApplicationFee.DoesNotExist","text":"","title":"DoesNotExist"},{"location":"reference/models/#djstripe.models.connect.ApplicationFee.MultipleObjectsReturned","text":"","title":"MultipleObjectsReturned"},{"location":"reference/models/#djstripe.models.connect.ApplicationFee.stripe_class","text":"djstripe . models . connect . ApplicationFee . stripe_class . OBJECT_NAME djstripe . models . connect . ApplicationFee . stripe_class . create_refund ( id , ** params ) classmethod Source code in djstripe/models/connect.py def create_nested_resource ( cls , id , ** params ): url = getattr ( cls , resource_url_method )( id ) return getattr ( cls , resource_request_method )( \"post\" , url , ** params ) djstripe . models . connect . ApplicationFee . stripe_class . list_refunds ( id , ** params ) classmethod Source code in djstripe/models/connect.py def list_nested_resources ( cls , id , ** params ): url = getattr ( cls , resource_url_method )( id ) return getattr ( cls , resource_request_method )( \"get\" , url , ** params ) djstripe . models . connect . ApplicationFee . stripe_class . modify_refund ( id , nested_id , ** params ) classmethod Source code in djstripe/models/connect.py def modify_nested_resource ( cls , id , nested_id , ** params ): url = getattr ( cls , resource_url_method )( id , nested_id ) return getattr ( cls , resource_request_method )( \"post\" , url , ** params ) djstripe . models . connect . ApplicationFee . stripe_class . refund ( self , idempotency_key = None , ** params ) Source code in djstripe/models/connect.py def refund ( self , idempotency_key = None , ** params ): headers = util . populate_headers ( idempotency_key ) url = self . instance_url () + \"/refund\" self . refresh_from ( self . request ( \"post\" , url , params , headers )) return self djstripe . models . connect . ApplicationFee . stripe_class . refunds_request ( method , url , api_key = None , idempotency_key = None , stripe_version = None , stripe_account = None , ** params ) classmethod Source code in djstripe/models/connect.py def nested_resource_request ( cls , method , url , api_key = None , idempotency_key = None , stripe_version = None , stripe_account = None , ** params ): requestor = api_requestor . APIRequestor ( api_key , api_version = stripe_version , account = stripe_account ) headers = util . populate_headers ( idempotency_key ) response , api_key = requestor . request ( method , url , params , headers ) return util . convert_to_stripe_object ( response , api_key , stripe_version , stripe_account ) djstripe . models . connect . ApplicationFee . stripe_class . refunds_url ( id , nested_id = None ) classmethod Source code in djstripe/models/connect.py def nested_resource_url ( cls , id , nested_id = None ): url = \" %s / %s / %s \" % ( cls . class_url (), quote_plus ( id ), quote_plus ( path ), ) if nested_id is not None : url += \"/ %s \" % quote_plus ( nested_id ) return url djstripe . models . connect . ApplicationFee . stripe_class . retrieve_refund ( id , nested_id , ** params ) classmethod Source code in djstripe/models/connect.py def retrieve_nested_resource ( cls , id , nested_id , ** params ): url = getattr ( cls , resource_url_method )( id , nested_id ) return getattr ( cls , resource_request_method )( \"get\" , url , ** params )","title":"stripe_class"},{"location":"reference/models/#djstripe.models.connect.ApplicationFee.get_next_by_djstripe_created","text":"Source code in djstripe/models/connect.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_next_by_djstripe_created()"},{"location":"reference/models/#djstripe.models.connect.ApplicationFee.get_next_by_djstripe_updated","text":"Source code in djstripe/models/connect.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_next_by_djstripe_updated()"},{"location":"reference/models/#djstripe.models.connect.ApplicationFee.get_previous_by_djstripe_created","text":"Source code in djstripe/models/connect.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_previous_by_djstripe_created()"},{"location":"reference/models/#djstripe.models.connect.ApplicationFee.get_previous_by_djstripe_updated","text":"Source code in djstripe/models/connect.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_previous_by_djstripe_updated()"},{"location":"reference/models/#djstripe.models.connect.ApplicationFeeRefund","text":"ApplicationFeeRefund objects allow you to refund an ApplicationFee that has previously been created but not yet refunded. Funds will be refunded to the Stripe account from which the fee was originally collected. Stripe documentation: https://stripe.com/docs/api#fee_refunds","title":"ApplicationFeeRefund"},{"location":"reference/models/#djstripe.models.connect.ApplicationFeeRefund.amount","text":"","title":"amount"},{"location":"reference/models/#djstripe.models.connect.ApplicationFeeRefund.balance_transaction","text":"","title":"balance_transaction"},{"location":"reference/models/#djstripe.models.connect.ApplicationFeeRefund.currency","text":"","title":"currency"},{"location":"reference/models/#djstripe.models.connect.ApplicationFeeRefund.description","text":"","title":"description"},{"location":"reference/models/#djstripe.models.connect.ApplicationFeeRefund.djstripe_owner_account","text":"","title":"djstripe_owner_account"},{"location":"reference/models/#djstripe.models.connect.ApplicationFeeRefund.fee","text":"","title":"fee"},{"location":"reference/models/#djstripe.models.connect.ApplicationFeeRefund.DoesNotExist","text":"","title":"DoesNotExist"},{"location":"reference/models/#djstripe.models.connect.ApplicationFeeRefund.MultipleObjectsReturned","text":"","title":"MultipleObjectsReturned"},{"location":"reference/models/#djstripe.models.connect.ApplicationFeeRefund.get_next_by_djstripe_created","text":"Source code in djstripe/models/connect.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_next_by_djstripe_created()"},{"location":"reference/models/#djstripe.models.connect.ApplicationFeeRefund.get_next_by_djstripe_updated","text":"Source code in djstripe/models/connect.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_next_by_djstripe_updated()"},{"location":"reference/models/#djstripe.models.connect.ApplicationFeeRefund.get_previous_by_djstripe_created","text":"Source code in djstripe/models/connect.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_previous_by_djstripe_created()"},{"location":"reference/models/#djstripe.models.connect.ApplicationFeeRefund.get_previous_by_djstripe_updated","text":"Source code in djstripe/models/connect.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_previous_by_djstripe_updated()"},{"location":"reference/models/#djstripe.models.connect.CountrySpec","text":"Stripe documentation: https://stripe.com/docs/api#country_specs","title":"CountrySpec"},{"location":"reference/models/#djstripe.models.connect.CountrySpec.default_currency","text":"","title":"default_currency"},{"location":"reference/models/#djstripe.models.connect.CountrySpec.id","text":"","title":"id"},{"location":"reference/models/#djstripe.models.connect.CountrySpec.supported_bank_account_currencies","text":"","title":"supported_bank_account_currencies"},{"location":"reference/models/#djstripe.models.connect.CountrySpec.supported_payment_currencies","text":"","title":"supported_payment_currencies"},{"location":"reference/models/#djstripe.models.connect.CountrySpec.supported_payment_methods","text":"","title":"supported_payment_methods"},{"location":"reference/models/#djstripe.models.connect.CountrySpec.supported_transfer_countries","text":"","title":"supported_transfer_countries"},{"location":"reference/models/#djstripe.models.connect.CountrySpec.verification_fields","text":"","title":"verification_fields"},{"location":"reference/models/#djstripe.models.connect.CountrySpec.DoesNotExist","text":"","title":"DoesNotExist"},{"location":"reference/models/#djstripe.models.connect.CountrySpec.MultipleObjectsReturned","text":"","title":"MultipleObjectsReturned"},{"location":"reference/models/#djstripe.models.connect.CountrySpec.stripe_class","text":"","title":"stripe_class"},{"location":"reference/models/#djstripe.models.connect.CountrySpec-methods","text":"","title":"Methods"},{"location":"reference/models/#djstripe.models.connect.CountrySpec.api_retrieve","text":"Source code in djstripe/models/connect.py def api_retrieve ( self , api_key : str = None , stripe_account = None ): if api_key is None : api_key = djstripe_settings . get_default_api_key ( livemode = None ) return self . stripe_class . retrieve ( id = self . id , api_key = api_key , stripe_account = stripe_account , )","title":"api_retrieve()"},{"location":"reference/models/#djstripe.models.connect.CountrySpec.get_next_by_djstripe_created","text":"Source code in djstripe/models/connect.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_next_by_djstripe_created()"},{"location":"reference/models/#djstripe.models.connect.CountrySpec.get_next_by_djstripe_updated","text":"Source code in djstripe/models/connect.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_next_by_djstripe_updated()"},{"location":"reference/models/#djstripe.models.connect.CountrySpec.get_previous_by_djstripe_created","text":"Source code in djstripe/models/connect.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_previous_by_djstripe_created()"},{"location":"reference/models/#djstripe.models.connect.CountrySpec.get_previous_by_djstripe_updated","text":"Source code in djstripe/models/connect.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_previous_by_djstripe_updated()"},{"location":"reference/models/#djstripe.models.connect.CountrySpec.sync_from_stripe_data","text":"Syncs this object from the stripe data provided. Foreign keys will also be retrieved and synced recursively. :param data: stripe object :type data: dict :rtype: cls Source code in djstripe/models/connect.py @classmethod def sync_from_stripe_data ( cls , data ) -> \"CountrySpec\" : \"\"\" Syncs this object from the stripe data provided. Foreign keys will also be retrieved and synced recursively. :param data: stripe object :type data: dict :rtype: cls \"\"\" data_id = data [ \"id\" ] supported_fields = ( \"default_currency\" , \"supported_bank_account_currencies\" , \"supported_payment_currencies\" , \"supported_payment_methods\" , \"supported_transfer_countries\" , \"verification_fields\" , ) instance , created = cls . objects . get_or_create ( id = data_id , defaults = { k : data [ k ] for k in supported_fields }, ) return instance","title":"sync_from_stripe_data()"},{"location":"reference/models/#djstripe.models.connect.Transfer","text":"When Stripe sends you money or you initiate a transfer to a bank account, debit card, or connected Stripe account, a transfer object will be created. Stripe documentation: https://stripe.com/docs/api?lang=python#transfers","title":"Transfer"},{"location":"reference/models/#djstripe.models.connect.Transfer.amount","text":"","title":"amount"},{"location":"reference/models/#djstripe.models.connect.Transfer.amount_reversed","text":"","title":"amount_reversed"},{"location":"reference/models/#djstripe.models.connect.Transfer.balance_transaction","text":"","title":"balance_transaction"},{"location":"reference/models/#djstripe.models.connect.Transfer.currency","text":"","title":"currency"},{"location":"reference/models/#djstripe.models.connect.Transfer.destination","text":"","title":"destination"},{"location":"reference/models/#djstripe.models.connect.Transfer.destination_payment","text":"","title":"destination_payment"},{"location":"reference/models/#djstripe.models.connect.Transfer.djstripe_owner_account","text":"","title":"djstripe_owner_account"},{"location":"reference/models/#djstripe.models.connect.Transfer.expand_fields","text":"","title":"expand_fields"},{"location":"reference/models/#djstripe.models.connect.Transfer.fee","text":"","title":"fee"},{"location":"reference/models/#djstripe.models.connect.Transfer.objects","text":"","title":"objects"},{"location":"reference/models/#djstripe.models.connect.Transfer.reversed","text":"","title":"reversed"},{"location":"reference/models/#djstripe.models.connect.Transfer.source_transaction","text":"","title":"source_transaction"},{"location":"reference/models/#djstripe.models.connect.Transfer.source_type","text":"","title":"source_type"},{"location":"reference/models/#djstripe.models.connect.Transfer.stripe_dashboard_item_name","text":"","title":"stripe_dashboard_item_name"},{"location":"reference/models/#djstripe.models.connect.Transfer.transfer_group","text":"","title":"transfer_group"},{"location":"reference/models/#djstripe.models.connect.Transfer.DoesNotExist","text":"","title":"DoesNotExist"},{"location":"reference/models/#djstripe.models.connect.Transfer.MultipleObjectsReturned","text":"","title":"MultipleObjectsReturned"},{"location":"reference/models/#djstripe.models.connect.Transfer.stripe_class","text":"djstripe . models . connect . Transfer . stripe_class . OBJECT_NAME djstripe . models . connect . Transfer . stripe_class . cancel ( self , idempotency_key = None , ** params ) Source code in djstripe/models/connect.py def cancel ( self , idempotency_key = None , ** params ): url = self . instance_url () + \"/cancel\" headers = util . populate_headers ( idempotency_key ) self . refresh_from ( self . request ( \"post\" , url , params , headers )) return self djstripe . models . connect . Transfer . stripe_class . create_reversal ( id , ** params ) classmethod Source code in djstripe/models/connect.py def create_nested_resource ( cls , id , ** params ): url = getattr ( cls , resource_url_method )( id ) return getattr ( cls , resource_request_method )( \"post\" , url , ** params ) djstripe . models . connect . Transfer . stripe_class . list_reversals ( id , ** params ) classmethod Source code in djstripe/models/connect.py def list_nested_resources ( cls , id , ** params ): url = getattr ( cls , resource_url_method )( id ) return getattr ( cls , resource_request_method )( \"get\" , url , ** params ) djstripe . models . connect . Transfer . stripe_class . modify_reversal ( id , nested_id , ** params ) classmethod Source code in djstripe/models/connect.py def modify_nested_resource ( cls , id , nested_id , ** params ): url = getattr ( cls , resource_url_method )( id , nested_id ) return getattr ( cls , resource_request_method )( \"post\" , url , ** params ) djstripe . models . connect . Transfer . stripe_class . retrieve_reversal ( id , nested_id , ** params ) classmethod Source code in djstripe/models/connect.py def retrieve_nested_resource ( cls , id , nested_id , ** params ): url = getattr ( cls , resource_url_method )( id , nested_id ) return getattr ( cls , resource_request_method )( \"get\" , url , ** params ) djstripe . models . connect . Transfer . stripe_class . reversals_request ( method , url , api_key = None , idempotency_key = None , stripe_version = None , stripe_account = None , ** params ) classmethod Source code in djstripe/models/connect.py def nested_resource_request ( cls , method , url , api_key = None , idempotency_key = None , stripe_version = None , stripe_account = None , ** params ): requestor = api_requestor . APIRequestor ( api_key , api_version = stripe_version , account = stripe_account ) headers = util . populate_headers ( idempotency_key ) response , api_key = requestor . request ( method , url , params , headers ) return util . convert_to_stripe_object ( response , api_key , stripe_version , stripe_account ) djstripe . models . connect . Transfer . stripe_class . reversals_url ( id , nested_id = None ) classmethod Source code in djstripe/models/connect.py def nested_resource_url ( cls , id , nested_id = None ): url = \" %s / %s / %s \" % ( cls . class_url (), quote_plus ( id ), quote_plus ( path ), ) if nested_id is not None : url += \"/ %s \" % quote_plus ( nested_id ) return url","title":"stripe_class"},{"location":"reference/models/#djstripe.models.connect.Transfer.__str__","text":"Source code in djstripe/models/connect.py def __str__ ( self ): if self . reversed : # Complete Reversal return f \" { self . human_readable_amount } Reversed\" elif self . amount_reversed : # Partial Reversal return f \" { self . human_readable_amount } Partially Reversed\" # No Reversal return f \" { self . human_readable_amount } \"","title":"__str__()"},{"location":"reference/models/#djstripe.models.connect.Transfer.get_next_by_djstripe_created","text":"Source code in djstripe/models/connect.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_next_by_djstripe_created()"},{"location":"reference/models/#djstripe.models.connect.Transfer.get_next_by_djstripe_updated","text":"Source code in djstripe/models/connect.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_next_by_djstripe_updated()"},{"location":"reference/models/#djstripe.models.connect.Transfer.get_previous_by_djstripe_created","text":"Source code in djstripe/models/connect.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_previous_by_djstripe_created()"},{"location":"reference/models/#djstripe.models.connect.Transfer.get_previous_by_djstripe_updated","text":"Source code in djstripe/models/connect.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_previous_by_djstripe_updated()"},{"location":"reference/models/#djstripe.models.connect.Transfer.get_source_type_display","text":"Source code in djstripe/models/connect.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_source_type_display()"},{"location":"reference/models/#djstripe.models.connect.TransferReversal","text":"Stripe documentation: https://stripe.com/docs/api#transfer_reversals","title":"TransferReversal"},{"location":"reference/models/#djstripe.models.connect.TransferReversal.amount","text":"","title":"amount"},{"location":"reference/models/#djstripe.models.connect.TransferReversal.balance_transaction","text":"","title":"balance_transaction"},{"location":"reference/models/#djstripe.models.connect.TransferReversal.currency","text":"","title":"currency"},{"location":"reference/models/#djstripe.models.connect.TransferReversal.djstripe_owner_account","text":"","title":"djstripe_owner_account"},{"location":"reference/models/#djstripe.models.connect.TransferReversal.expand_fields","text":"","title":"expand_fields"},{"location":"reference/models/#djstripe.models.connect.TransferReversal.transfer","text":"","title":"transfer"},{"location":"reference/models/#djstripe.models.connect.TransferReversal.DoesNotExist","text":"","title":"DoesNotExist"},{"location":"reference/models/#djstripe.models.connect.TransferReversal.MultipleObjectsReturned","text":"","title":"MultipleObjectsReturned"},{"location":"reference/models/#djstripe.models.connect.TransferReversal.stripe_class","text":"djstripe . models . connect . TransferReversal . stripe_class . OBJECT_NAME djstripe . models . connect . TransferReversal . stripe_class . cancel ( self , idempotency_key = None , ** params ) Source code in djstripe/models/connect.py def cancel ( self , idempotency_key = None , ** params ): url = self . instance_url () + \"/cancel\" headers = util . populate_headers ( idempotency_key ) self . refresh_from ( self . request ( \"post\" , url , params , headers )) return self djstripe . models . connect . TransferReversal . stripe_class . create_reversal ( id , ** params ) classmethod Source code in djstripe/models/connect.py def create_nested_resource ( cls , id , ** params ): url = getattr ( cls , resource_url_method )( id ) return getattr ( cls , resource_request_method )( \"post\" , url , ** params ) djstripe . models . connect . TransferReversal . stripe_class . list_reversals ( id , ** params ) classmethod Source code in djstripe/models/connect.py def list_nested_resources ( cls , id , ** params ): url = getattr ( cls , resource_url_method )( id ) return getattr ( cls , resource_request_method )( \"get\" , url , ** params ) djstripe . models . connect . TransferReversal . stripe_class . modify_reversal ( id , nested_id , ** params ) classmethod Source code in djstripe/models/connect.py def modify_nested_resource ( cls , id , nested_id , ** params ): url = getattr ( cls , resource_url_method )( id , nested_id ) return getattr ( cls , resource_request_method )( \"post\" , url , ** params ) djstripe . models . connect . TransferReversal . stripe_class . retrieve_reversal ( id , nested_id , ** params ) classmethod Source code in djstripe/models/connect.py def retrieve_nested_resource ( cls , id , nested_id , ** params ): url = getattr ( cls , resource_url_method )( id , nested_id ) return getattr ( cls , resource_request_method )( \"get\" , url , ** params ) djstripe . models . connect . TransferReversal . stripe_class . reversals_request ( method , url , api_key = None , idempotency_key = None , stripe_version = None , stripe_account = None , ** params ) classmethod Source code in djstripe/models/connect.py def nested_resource_request ( cls , method , url , api_key = None , idempotency_key = None , stripe_version = None , stripe_account = None , ** params ): requestor = api_requestor . APIRequestor ( api_key , api_version = stripe_version , account = stripe_account ) headers = util . populate_headers ( idempotency_key ) response , api_key = requestor . request ( method , url , params , headers ) return util . convert_to_stripe_object ( response , api_key , stripe_version , stripe_account ) djstripe . models . connect . TransferReversal . stripe_class . reversals_url ( id , nested_id = None ) classmethod Source code in djstripe/models/connect.py def nested_resource_url ( cls , id , nested_id = None ): url = \" %s / %s / %s \" % ( cls . class_url (), quote_plus ( id ), quote_plus ( path ), ) if nested_id is not None : url += \"/ %s \" % quote_plus ( nested_id ) return url","title":"stripe_class"},{"location":"reference/models/#djstripe.models.connect.TransferReversal-methods","text":"","title":"Methods"},{"location":"reference/models/#djstripe.models.connect.TransferReversal.__str__","text":"Source code in djstripe/models/connect.py def __str__ ( self ): return str ( self . transfer )","title":"__str__()"},{"location":"reference/models/#djstripe.models.connect.TransferReversal.api_list","text":"Call the stripe API's list operation for this model. :param api_key: The api key to use for this request. Defaults to djstripe_settings.STRIPE_SECRET_KEY. :type api_key: string See Stripe documentation for accepted kwargs for each object. :returns: an iterator over all items in the query Source code in djstripe/models/connect.py @classmethod def api_list ( cls , api_key = djstripe_settings . STRIPE_SECRET_KEY , ** kwargs ): \"\"\" Call the stripe API's list operation for this model. :param api_key: The api key to use for this request. \\ Defaults to djstripe_settings.STRIPE_SECRET_KEY. :type api_key: string See Stripe documentation for accepted kwargs for each object. :returns: an iterator over all items in the query \"\"\" return stripe . Transfer . list_reversals ( api_key = api_key , ** kwargs ) . auto_paging_iter ()","title":"api_list()"},{"location":"reference/models/#djstripe.models.connect.TransferReversal.api_retrieve","text":"Call the stripe API's retrieve operation for this model. :param api_key: The api key to use for this request. Defaults to djstripe_settings.STRIPE_SECRET_KEY. :type api_key: string :param stripe_account: The optional connected account for which this request is being made. :type stripe_account: string Source code in djstripe/models/connect.py def api_retrieve ( self , api_key = None , stripe_account = None ): \"\"\" Call the stripe API's retrieve operation for this model. :param api_key: The api key to use for this request. \\ Defaults to djstripe_settings.STRIPE_SECRET_KEY. :type api_key: string :param stripe_account: The optional connected account \\ for which this request is being made. :type stripe_account: string \"\"\" nested_id = self . id id = self . transfer . id # Prefer passed in stripe_account if set. if not stripe_account : stripe_account = self . _get_stripe_account_id ( api_key ) return stripe . Transfer . retrieve_reversal ( id = id , nested_id = nested_id , api_key = api_key or self . default_api_key , expand = self . expand_fields , stripe_account = stripe_account , )","title":"api_retrieve()"},{"location":"reference/models/#djstripe.models.connect.TransferReversal.get_next_by_djstripe_created","text":"Source code in djstripe/models/connect.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_next_by_djstripe_created()"},{"location":"reference/models/#djstripe.models.connect.TransferReversal.get_next_by_djstripe_updated","text":"Source code in djstripe/models/connect.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_next_by_djstripe_updated()"},{"location":"reference/models/#djstripe.models.connect.TransferReversal.get_previous_by_djstripe_created","text":"Source code in djstripe/models/connect.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_previous_by_djstripe_created()"},{"location":"reference/models/#djstripe.models.connect.TransferReversal.get_previous_by_djstripe_updated","text":"Source code in djstripe/models/connect.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_previous_by_djstripe_updated()"},{"location":"reference/models/#djstripe.models.connect.TransferReversal.is_valid_object","text":"Returns whether the data is a valid object for the class Source code in djstripe/models/connect.py @classmethod def is_valid_object ( cls , data ): \"\"\" Returns whether the data is a valid object for the class \"\"\" return \"object\" in data and data [ \"object\" ] == \"transfer_reversal\"","title":"is_valid_object()"},{"location":"reference/models/#fraud","text":"","title":"Fraud"},{"location":"reference/models/#orders","text":"","title":"Orders"},{"location":"reference/models/#sigma","text":"","title":"Sigma"},{"location":"reference/models/#djstripe.models.sigma-classes","text":"","title":"Classes"},{"location":"reference/models/#djstripe.models.sigma.ScheduledQueryRun","text":"Stripe documentation: https://stripe.com/docs/api#scheduled_queries","title":"ScheduledQueryRun"},{"location":"reference/models/#djstripe.models.sigma.ScheduledQueryRun.data_load_time","text":"","title":"data_load_time"},{"location":"reference/models/#djstripe.models.sigma.ScheduledQueryRun.djstripe_owner_account","text":"","title":"djstripe_owner_account"},{"location":"reference/models/#djstripe.models.sigma.ScheduledQueryRun.error","text":"","title":"error"},{"location":"reference/models/#djstripe.models.sigma.ScheduledQueryRun.file","text":"","title":"file"},{"location":"reference/models/#djstripe.models.sigma.ScheduledQueryRun.result_available_until","text":"","title":"result_available_until"},{"location":"reference/models/#djstripe.models.sigma.ScheduledQueryRun.sql","text":"","title":"sql"},{"location":"reference/models/#djstripe.models.sigma.ScheduledQueryRun.status","text":"","title":"status"},{"location":"reference/models/#djstripe.models.sigma.ScheduledQueryRun.title","text":"","title":"title"},{"location":"reference/models/#djstripe.models.sigma.ScheduledQueryRun.DoesNotExist","text":"","title":"DoesNotExist"},{"location":"reference/models/#djstripe.models.sigma.ScheduledQueryRun.MultipleObjectsReturned","text":"","title":"MultipleObjectsReturned"},{"location":"reference/models/#djstripe.models.sigma.ScheduledQueryRun.stripe_class","text":"djstripe . models . sigma . ScheduledQueryRun . stripe_class . OBJECT_NAME djstripe . models . sigma . ScheduledQueryRun . stripe_class . class_url () classmethod Source code in djstripe/models/sigma.py @classmethod def class_url ( cls ): return \"/v1/sigma/scheduled_query_runs\"","title":"stripe_class"},{"location":"reference/models/#djstripe.models.sigma.ScheduledQueryRun.__str__","text":"Source code in djstripe/models/sigma.py def __str__ ( self ): return f \" { self . title or self . id } ( { self . status } )\"","title":"__str__()"},{"location":"reference/models/#djstripe.models.sigma.ScheduledQueryRun.get_next_by_data_load_time","text":"Source code in djstripe/models/sigma.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_next_by_data_load_time()"},{"location":"reference/models/#djstripe.models.sigma.ScheduledQueryRun.get_next_by_djstripe_created","text":"Source code in djstripe/models/sigma.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_next_by_djstripe_created()"},{"location":"reference/models/#djstripe.models.sigma.ScheduledQueryRun.get_next_by_djstripe_updated","text":"Source code in djstripe/models/sigma.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_next_by_djstripe_updated()"},{"location":"reference/models/#djstripe.models.sigma.ScheduledQueryRun.get_next_by_result_available_until","text":"Source code in djstripe/models/sigma.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_next_by_result_available_until()"},{"location":"reference/models/#djstripe.models.sigma.ScheduledQueryRun.get_previous_by_data_load_time","text":"Source code in djstripe/models/sigma.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_previous_by_data_load_time()"},{"location":"reference/models/#djstripe.models.sigma.ScheduledQueryRun.get_previous_by_djstripe_created","text":"Source code in djstripe/models/sigma.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_previous_by_djstripe_created()"},{"location":"reference/models/#djstripe.models.sigma.ScheduledQueryRun.get_previous_by_djstripe_updated","text":"Source code in djstripe/models/sigma.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_previous_by_djstripe_updated()"},{"location":"reference/models/#djstripe.models.sigma.ScheduledQueryRun.get_previous_by_result_available_until","text":"Source code in djstripe/models/sigma.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_previous_by_result_available_until()"},{"location":"reference/models/#djstripe.models.sigma.ScheduledQueryRun.get_status_display","text":"Source code in djstripe/models/sigma.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_status_display()"},{"location":"reference/models/#webhooks","text":"Module for dj-stripe Webhook models","title":"Webhooks"},{"location":"reference/models/#djstripe.models.webhooks-classes","text":"","title":"Classes"},{"location":"reference/models/#djstripe.models.webhooks.WebhookEndpoint","text":"WebhookEndpoint(djstripe_created, djstripe_updated, djstripe_id, id, djstripe_owner_account, livemode, created, metadata, description, api_version, enabled_events, secret, status, url, application, djstripe_uuid)","title":"WebhookEndpoint"},{"location":"reference/models/#djstripe.models.webhooks.WebhookEndpoint.api_version","text":"","title":"api_version"},{"location":"reference/models/#djstripe.models.webhooks.WebhookEndpoint.application","text":"","title":"application"},{"location":"reference/models/#djstripe.models.webhooks.WebhookEndpoint.djstripe_owner_account","text":"","title":"djstripe_owner_account"},{"location":"reference/models/#djstripe.models.webhooks.WebhookEndpoint.djstripe_uuid","text":"","title":"djstripe_uuid"},{"location":"reference/models/#djstripe.models.webhooks.WebhookEndpoint.enabled_events","text":"","title":"enabled_events"},{"location":"reference/models/#djstripe.models.webhooks.WebhookEndpoint.secret","text":"","title":"secret"},{"location":"reference/models/#djstripe.models.webhooks.WebhookEndpoint.status","text":"","title":"status"},{"location":"reference/models/#djstripe.models.webhooks.WebhookEndpoint.url","text":"","title":"url"},{"location":"reference/models/#djstripe.models.webhooks.WebhookEndpoint.DoesNotExist","text":"","title":"DoesNotExist"},{"location":"reference/models/#djstripe.models.webhooks.WebhookEndpoint.MultipleObjectsReturned","text":"","title":"MultipleObjectsReturned"},{"location":"reference/models/#djstripe.models.webhooks.WebhookEndpoint.stripe_class","text":"","title":"stripe_class"},{"location":"reference/models/#djstripe.models.webhooks.WebhookEndpoint.__str__","text":"Source code in djstripe/models/webhooks.py def __str__ ( self ): return self . url or str ( self . djstripe_uuid )","title":"__str__()"},{"location":"reference/models/#djstripe.models.webhooks.WebhookEndpoint.get_next_by_djstripe_created","text":"Source code in djstripe/models/webhooks.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_next_by_djstripe_created()"},{"location":"reference/models/#djstripe.models.webhooks.WebhookEndpoint.get_next_by_djstripe_updated","text":"Source code in djstripe/models/webhooks.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_next_by_djstripe_updated()"},{"location":"reference/models/#djstripe.models.webhooks.WebhookEndpoint.get_previous_by_djstripe_created","text":"Source code in djstripe/models/webhooks.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_previous_by_djstripe_created()"},{"location":"reference/models/#djstripe.models.webhooks.WebhookEndpoint.get_previous_by_djstripe_updated","text":"Source code in djstripe/models/webhooks.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_previous_by_djstripe_updated()"},{"location":"reference/models/#djstripe.models.webhooks.WebhookEndpoint.get_status_display","text":"Source code in djstripe/models/webhooks.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_status_display()"},{"location":"reference/models/#djstripe.models.webhooks.WebhookEventTrigger","text":"An instance of a request that reached the server endpoint for Stripe webhooks. Webhook Events are initially UNTRUSTED , as it is possible for any web entity to post any data to our webhook url. Data posted may be valid Stripe information, garbage, or even malicious. The 'valid' flag in this model monitors this.","title":"WebhookEventTrigger"},{"location":"reference/models/#djstripe.models.webhooks.WebhookEventTrigger.body","text":"","title":"body"},{"location":"reference/models/#djstripe.models.webhooks.WebhookEventTrigger.created","text":"","title":"created"},{"location":"reference/models/#djstripe.models.webhooks.WebhookEventTrigger.djstripe_version","text":"","title":"djstripe_version"},{"location":"reference/models/#djstripe.models.webhooks.WebhookEventTrigger.event","text":"","title":"event"},{"location":"reference/models/#djstripe.models.webhooks.WebhookEventTrigger.exception","text":"","title":"exception"},{"location":"reference/models/#djstripe.models.webhooks.WebhookEventTrigger.headers","text":"","title":"headers"},{"location":"reference/models/#djstripe.models.webhooks.WebhookEventTrigger.id","text":"","title":"id"},{"location":"reference/models/#djstripe.models.webhooks.WebhookEventTrigger.is_test_event","text":"","title":"is_test_event"},{"location":"reference/models/#djstripe.models.webhooks.WebhookEventTrigger.processed","text":"","title":"processed"},{"location":"reference/models/#djstripe.models.webhooks.WebhookEventTrigger.remote_ip","text":"","title":"remote_ip"},{"location":"reference/models/#djstripe.models.webhooks.WebhookEventTrigger.stripe_trigger_account","text":"","title":"stripe_trigger_account"},{"location":"reference/models/#djstripe.models.webhooks.WebhookEventTrigger.traceback","text":"","title":"traceback"},{"location":"reference/models/#djstripe.models.webhooks.WebhookEventTrigger.updated","text":"","title":"updated"},{"location":"reference/models/#djstripe.models.webhooks.WebhookEventTrigger.valid","text":"","title":"valid"},{"location":"reference/models/#djstripe.models.webhooks.WebhookEventTrigger.DoesNotExist","text":"","title":"DoesNotExist"},{"location":"reference/models/#djstripe.models.webhooks.WebhookEventTrigger.MultipleObjectsReturned","text":"","title":"MultipleObjectsReturned"},{"location":"reference/models/#djstripe.models.webhooks.WebhookEventTrigger-methods","text":"","title":"Methods"},{"location":"reference/models/#djstripe.models.webhooks.WebhookEventTrigger.__str__","text":"Source code in djstripe/models/webhooks.py def __str__ ( self ): return f \"id= { self . id } , valid= { self . valid } , processed= { self . processed } \"","title":"__str__()"},{"location":"reference/models/#djstripe.models.webhooks.WebhookEventTrigger.from_request","text":"Create, validate and process a WebhookEventTrigger given a Django request object. The process is three-fold: 1. Create a WebhookEventTrigger object from a Django request. 2. Validate the WebhookEventTrigger as a Stripe event using the API. 3. If valid, process it into an Event object (and child resource). Source code in djstripe/models/webhooks.py @classmethod def from_request ( cls , request , stripe_account = None ): \"\"\" Create, validate and process a WebhookEventTrigger given a Django request object. The process is three-fold: 1. Create a WebhookEventTrigger object from a Django request. 2. Validate the WebhookEventTrigger as a Stripe event using the API. 3. If valid, process it into an Event object (and child resource). \"\"\" try : body = request . body . decode ( request . encoding or \"utf-8\" ) except Exception : body = \"(error decoding body)\" ip = get_remote_ip ( request ) try : data = json . loads ( body ) except ValueError : data = {} if stripe_account is None : stripe_account = StripeModel . _find_owner_account ( data = data ) obj = cls . objects . create ( headers = dict ( request . headers ), body = body , remote_ip = ip , stripe_trigger_account = stripe_account , ) try : obj . valid = obj . validate () if obj . valid : if djstripe_settings . WEBHOOK_EVENT_CALLBACK : # If WEBHOOK_EVENT_CALLBACK, pass it for processing djstripe_settings . WEBHOOK_EVENT_CALLBACK ( obj ) else : # Process the item (do not save it, it'll get saved below) obj . process ( save = False ) except Exception as e : max_length = WebhookEventTrigger . _meta . get_field ( \"exception\" ) . max_length obj . exception = str ( e )[: max_length ] obj . traceback = format_exc () # Send the exception as the webhook_processing_error signal webhook_processing_error . send ( sender = WebhookEventTrigger , exception = e , data = getattr ( e , \"http_body\" , \"\" ), ) # re-raise the exception so Django sees it raise e finally : obj . save () return obj","title":"from_request()"},{"location":"reference/models/#djstripe.models.webhooks.WebhookEventTrigger.get_next_by_created","text":"Source code in djstripe/models/webhooks.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_next_by_created()"},{"location":"reference/models/#djstripe.models.webhooks.WebhookEventTrigger.get_next_by_updated","text":"Source code in djstripe/models/webhooks.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_next_by_updated()"},{"location":"reference/models/#djstripe.models.webhooks.WebhookEventTrigger.get_previous_by_created","text":"Source code in djstripe/models/webhooks.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_previous_by_created()"},{"location":"reference/models/#djstripe.models.webhooks.WebhookEventTrigger.get_previous_by_updated","text":"Source code in djstripe/models/webhooks.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_previous_by_updated()"},{"location":"reference/models/#djstripe.models.webhooks.WebhookEventTrigger.process","text":"Source code in djstripe/models/webhooks.py def process ( self , save = True ): # Reset traceback and exception in case of reprocessing self . exception = \"\" self . traceback = \"\" self . event = Event . process ( self . json_body ) self . processed = True if save : self . save () return self . event","title":"process()"},{"location":"reference/models/#djstripe.models.webhooks.WebhookEventTrigger.validate","text":"The original contents of the Event message must be confirmed by refetching it and comparing the fetched data with the original data. This function makes an API call to Stripe to redownload the Event data and returns whether or not it matches the WebhookEventTrigger data. Source code in djstripe/models/webhooks.py def validate ( self , api_key = None ): \"\"\" The original contents of the Event message must be confirmed by refetching it and comparing the fetched data with the original data. This function makes an API call to Stripe to redownload the Event data and returns whether or not it matches the WebhookEventTrigger data. \"\"\" local_data = self . json_body if \"id\" not in local_data or \"livemode\" not in local_data : logger . error ( '\"id\" not in json body or \"livemode\" not in json body( %s )' , local_data ) return False if self . is_test_event : logger . info ( \"Test webhook received and discarded: {} \" . format ( local_data )) return False if djstripe_settings . WEBHOOK_VALIDATION is None : # validation disabled warnings . warn ( \"WEBHOOK VALIDATION is disabled.\" ) return True elif ( djstripe_settings . WEBHOOK_VALIDATION == \"verify_signature\" and djstripe_settings . WEBHOOK_SECRET ): # HTTP headers are case-insensitive, but we store them as a dict. headers = CaseInsensitiveMapping ( self . headers ) try : stripe . WebhookSignature . verify_header ( self . body , headers . get ( \"stripe-signature\" ), djstripe_settings . WEBHOOK_SECRET , djstripe_settings . WEBHOOK_TOLERANCE , ) except stripe . error . SignatureVerificationError : logger . exception ( \"Failed to verify header\" ) return False else : return True livemode = local_data [ \"livemode\" ] api_key = api_key or djstripe_settings . get_default_api_key ( livemode ) # Retrieve the event using the api_version specified in itself with stripe_temporary_api_version ( local_data [ \"api_version\" ], validate = False ): remote_data = Event . stripe_class . retrieve ( id = local_data [ \"id\" ], api_key = api_key ) return local_data [ \"data\" ] == remote_data [ \"data\" ]","title":"validate()"},{"location":"reference/models/#djstripe.models.webhooks-functions","text":"","title":"Functions"},{"location":"reference/models/#djstripe.models.webhooks.get_remote_ip","text":"Given the HTTPRequest object return the IP Address of the client :param request: client request :type request: HTTPRequest :Returns: the client ip address Source code in djstripe/models/webhooks.py def get_remote_ip ( request ): \"\"\"Given the HTTPRequest object return the IP Address of the client :param request: client request :type request: HTTPRequest :Returns: the client ip address \"\"\" # HTTP_X_FORWARDED_FOR is relevant for django running behind a proxy x_forwarded_for = request . META . get ( \"HTTP_X_FORWARDED_FOR\" ) if x_forwarded_for : ip = x_forwarded_for . split ( \",\" )[ 0 ] else : ip = request . META . get ( \"REMOTE_ADDR\" ) if not ip : warnings . warn ( \"Could not determine remote IP (missing REMOTE_ADDR). \" \"This is likely an issue with your wsgi/server setup.\" ) ip = \"0.0.0.0\" return ip","title":"get_remote_ip()"},{"location":"reference/settings/","text":"Settings STRIPE_API_VERSION (='2020-08-27') The API version used to communicate with the Stripe API is configurable, and defaults to the latest version that has been tested as working. Using a value other than the default is allowed, as a string in the format of YYYY-MM-DD. For example, you can specify \"2020-03-02\" to use that API version: STRIPE_API_VERSION = \"2020-03-02\" However you do so at your own risk, as using a value other than the default might result in incompatibilities between Stripe and this library, especially if Stripe has labelled the differences between API versions as \"Major\". Even small differences such as a new enumeration value might cause issues. For this reason it is best to assume that only the default version is supported. For more information on API versioning, see the stripe documentation . See also API Versions . DJSTRIPE_FOREIGN_KEY_TO_FIELD (Introduced in 2.4.0) DJSTRIPE_FOREIGN_KEY_TO_FIELD is a setting introduced in dj-stripe version 2.4.0. You are required to set it in 2.4.0: It does not have a default value. In 3.0.0, the default will be \"id\", and we recommend setting it to \"id\" for new installations. Older installations should set it to \"djstripe_id\". Explanation below. In dj-stripe 2.3 and before, foreign keys for Stripe models were set to point to the foreign model's djstripe_id field, a numeric integer generated by the local database. This new setting allows dj-stripe users to change it to use the \"id\" field, which is the upstream, non-numeric Stripe identifier. When using the Stripe identifier as a foreign key, synchronization between Stripe and dj-stripe can be made far more efficient and robust. Furthermore, it removes the per-installation instability of a critical value. The plan is to get rid of djstripe_id altogether for the 3.0 release (we may retain the field itself until 4.0, but it will no longer be a primary key). How to migrate older installations from \"djstripe_id\" to \"id\"? Such a migration path has not been designed at the moment. Currently if you want to switch an older installation to \"id\", the easiest way is to wipe the djstripe db and sync again from scratch. This is obviously not ideal, and we will design a proper migration path before 3.0. DJSTRIPE_IDEMPOTENCY_KEY_CALLBACK (=djstripe.settings.djstripe_settings._get_idempotency_key) A function which will return an idempotency key for a particular object_type and action pair. By default, this is set to a function which will create a djstripe.IdempotencyKey object and return its uuid . You may want to customize this if you want to give your idempotency keys a different lifecycle than they normally would get. The function takes the following signature: def get_idempotency_key ( object_type : str , action : str , livemode : bool ): return \"<idempotency key>\" The function MUST return a string suitably random for the object_type/action pair, and usable in the Stripe Idempotency-Key HTTP header. For more information, see the stripe documentation . DJSTRIPE_PRORATION_POLICY (=False) Warning This setting is deprecated and will be removed in dj-stripe 2.8. By default, plans are not prorated in dj-stripe. Concretely, this is how this translates: If a customer cancels their plan during a trial, the cancellation is effective right away. If a customer cancels their plan outside of a trial, their subscription remains active until the subscription's period end, and they do not receive a refund. If a customer switches from one plan to another, the new plan becomes effective right away, and the customer is billed for the new plan's amount. Assigning True to DJSTRIPE_PRORATION_POLICY reverses the functioning of item 2 (plan cancellation) by making a cancellation effective right away and refunding the unused balance to the customer, and affects the functioning of item 3 (plan change) by prorating the previous customer's plan towards their new plan's amount. DJSTRIPE_SUBSCRIPTION_REQUIRED_EXCEPTION_URLS (=()) Warning This functionality is deprecated. Used by djstripe.middleware.SubscriptionPaymentMiddleware Rules: \"(app_name)\" means everything from this app is exempt \"[namespace]\" means everything with this name is exempt \"namespace:name\" means this namespaced URL is exempt \"name\" means this URL is exempt The entire djstripe namespace is exempt If settings.DEBUG is True, then django-debug-toolbar is exempt Example: DJSTRIPE_SUBSCRIPTION_REQUIRED_EXCEPTION_URLS = ( \"(allauth)\" , # anything in the django-allauth URLConf \"[blogs]\" , # Anything in the blogs namespace \"products:detail\" , # A ProductDetail view you want shown to non-payers \"home\" , # Site homepage ) Note Adding app_names to applications. To make the (allauth) work, you may need to define an app_name in the include() function in the URLConf. For example: # in urls.py url ( r '^accounts/' , include ( 'allauth.urls' , app_name = \"allauth\" )), DJSTRIPE_SUBSCRIBER_CUSTOMER_KEY (=\"djstripe_subscriber\") Every Customer object created in Stripe is tagged with metadata This setting controls what the name of the key in Stripe should be. The key name must be a string no more than 40 characters long. You may set this to None or \"\" to disable that behaviour altogether. This is probably not something you want to do, though. DJSTRIPE_SUBSCRIBER_MODEL (=settings.AUTH_USER_MODEL) If the AUTH_USER_MODEL doesn't represent the object your application's subscription holder, you may define a subscriber model to use here. It should be a string in the form of 'app.model'. Note DJSTRIPE_SUBSCRIBER_MODEL must have an email field. If your existing model has no email field, add an email property that defines an email address to use. Example Model: class Organization ( models . Model ): name = CharField ( max_length = 200 , unique = True ) admin = ForeignKey ( settings . AUTH_USER_MODEL , on_delete = CASCADE ) @property def email ( self ): return self . admin . email DJSTRIPE_SUBSCRIBER_MODEL_MIGRATION_DEPENDENCY (=\"__first__\") If the model referenced in DJSTRIPE_SUBSCRIBER_MODEL is not created in the __first__ migration of an app you can specify the migration name to depend on here. For example: \"0003_here_the_subscriber_model_was_added\" DJSTRIPE_USE_NATIVE_JSONFIELD (=True) Warning This setting is deprecated and will be removed in dj-stripe 2.8. When set to False , forces dj-stripe to use the jsonfield library for JSONField . Leaving this set to True is highly recommended. However, if you have already migrated with the old fields, migrating to the native JSONField has to be done manually and is not currently natively supported by dj-stripe. The native Django JSONField uses the postgres jsonb column type, which efficiently stores JSON and can be queried far moreconveniently. Django also supports querying JSONField with the ORM. DJSTRIPE_WEBHOOK_URL (=r\"^webhook/$\") This is where you can tell Stripe to send webhook responses. You can set this to what you want to prevent unnecessary hijinks from unfriendly people. As this is embedded in the URLConf, this must be a resolvable regular expression. DJSTRIPE_WEBHOOK_SECRET (=\"\") If this is set to a non-empty value, webhook signatures will be verified. Learn more about webhook signature verification . DJSTRIPE_WEBHOOK_VALIDATION= (=\"verify_signature\") This setting controls which type of validation is done on webhooks. Value can be \"verify_signature\" for signature verification (recommended default), \"retrieve_event\" for event retrieval (makes an extra HTTP request), or None for no validation at all. DJSTRIPE_WEBHOOK_TOLERANCE (=300) Controls the milliseconds tolerance which wards against replay attacks. Leave this to its default value unless you know what you're doing. DJSTRIPE_WEBHOOK_EVENT_CALLBACK (=None) Webhook event callbacks allow an application to take control of what happens when an event from Stripe is received. It must be a callable or importable string to a callable that takes an event object. One suggestion is to put the event onto a task queue (such as celery) for asynchronous processing. Examples: # callbacks.py def webhook_event_callback ( event ): \"\"\" Dispatches the event to celery for processing. \"\"\" from . import tasks # Ansychronous hand-off to celery so that we can continue immediately tasks . process_webhook_event . s ( event . pk ) . apply_async () # tasks.py from djstripe.models import WebhookEventTrigger from stripe.error import StripeError @shared_task ( bind = True ) def process_webhook_event ( self , pk ): \"\"\" Processes events from Stripe asynchronously. \"\"\" logger . info ( f \"Processing Stripe event: { pk } \" ) try : # get the event obj = WebhookEventTrigger . objects . get ( pk = pk ) # process the event. # internally, this creates a Stripe WebhookEvent Object and invokes the respective Webhooks event = obj . process () except StripeError as exc : logger . error ( f \"Failed to process Stripe event: { pk } . Retrying in 60 seconds.\" ) raise self . retry ( exc = exc , countdown = 60 ) # retry after 60 seconds except WebhookEventTrigger . DoesNotExist as exc : # This can happen in case the celery task got executed before the actual model got saved to the DB raise self . retry ( exc = exc , countdown = 10 ) # retry after 10 seconds return event . type or \"Stripe Event Processed\" # settings.py DJSTRIPE_WEBHOOK_EVENT_CALLBACK = 'callbacks.webhook_event_callback' STRIPE_API_HOST (= unset) If set, this sets the base API host for Stripe. You may want to set this to, for example, \"http://localhost:12111\" if you are running stripe-mock . If this is set in production (DEBUG=False), a warning will be raised on manage.py check . Source Code dj-stripe settings djstripe . settings . djstripe_settings Classes djstripe.settings.DjstripeSettings Container for Dj-stripe settings :return: Initialised settings for Dj-stripe. :rtype: object Attributes djstripe . settings . DjstripeSettings . DEFAULT_STRIPE_API_VERSION djstripe . settings . DjstripeSettings . DJSTRIPE_WEBHOOK_URL property readonly djstripe . settings . DjstripeSettings . LIVE_API_KEY property readonly djstripe . settings . DjstripeSettings . PRORATION_POLICY property readonly djstripe . settings . DjstripeSettings . STRIPE_API_VERSION : str property readonly Get the desired API version to use for Stripe requests. djstripe . settings . DjstripeSettings . STRIPE_LIVE_MODE property readonly djstripe . settings . DjstripeSettings . STRIPE_PUBLIC_KEY property readonly djstripe . settings . DjstripeSettings . STRIPE_SECRET_KEY property readonly djstripe . settings . DjstripeSettings . SUBSCRIBER_CUSTOMER_KEY property readonly djstripe . settings . DjstripeSettings . SUBSCRIPTION_REDIRECT property readonly djstripe . settings . DjstripeSettings . SUBSCRIPTION_REQUIRED_EXCEPTION_URLS property readonly djstripe . settings . DjstripeSettings . TEST_API_KEY property readonly djstripe . settings . DjstripeSettings . USE_NATIVE_JSONFIELD property readonly djstripe . settings . DjstripeSettings . WEBHOOK_EVENT_CALLBACK property readonly djstripe . settings . DjstripeSettings . WEBHOOK_SECRET property readonly djstripe . settings . DjstripeSettings . WEBHOOK_TOLERANCE property readonly djstripe . settings . DjstripeSettings . WEBHOOK_VALIDATION property readonly djstripe . settings . DjstripeSettings . ZERO_DECIMAL_CURRENCIES djstripe . settings . DjstripeSettings . get_idempotency_key property readonly djstripe . settings . DjstripeSettings . subscriber_request_callback property readonly Methods djstripe . settings . DjstripeSettings . __delattr__ ( self , name ) special Source code in djstripe/settings.py def __delattr__ ( self , name ): del self . __dict__ [ name ] djstripe . settings . DjstripeSettings . __init__ ( self ) special Source code in djstripe/settings.py def __init__ ( self ): # Set STRIPE_API_HOST if you want to use a different Stripe API server # Example: https://github.com/stripe/stripe-mock if hasattr ( settings , \"STRIPE_API_HOST\" ): stripe . api_base = getattr ( settings , \"STRIPE_API_HOST\" ) djstripe . settings . DjstripeSettings . __setattr__ ( self , name , value ) special Source code in djstripe/settings.py def __setattr__ ( self , name , value ): self . __dict__ [ name ] = value djstripe . settings . DjstripeSettings . get_callback_function ( self , setting_name , default = None ) Resolve a callback function based on a setting name. If the setting value isn't set, default is returned. If the setting value is already a callable function, that value is used - If the setting value is a string, an attempt is made to import it. Anything else will result in a failed import causing ImportError to be raised. :param setting_name: The name of the setting to resolve a callback from. :type setting_name: string ( str / unicode ) :param default: The default to return if setting isn't populated. :type default: bool :returns: The resolved callback function (if any). :type: callable Source code in djstripe/settings.py def get_callback_function ( self , setting_name , default = None ): \"\"\" Resolve a callback function based on a setting name. If the setting value isn't set, default is returned. If the setting value is already a callable function, that value is used - If the setting value is a string, an attempt is made to import it. Anything else will result in a failed import causing ImportError to be raised. :param setting_name: The name of the setting to resolve a callback from. :type setting_name: string (``str``/``unicode``) :param default: The default to return if setting isn't populated. :type default: ``bool`` :returns: The resolved callback function (if any). :type: ``callable`` \"\"\" func = getattr ( settings , setting_name , None ) if not func : return default if callable ( func ): return func if isinstance ( func , str ): func = import_string ( func ) if not callable ( func ): raise ImproperlyConfigured ( \" {name} must be callable.\" . format ( name = setting_name ) ) return func djstripe . settings . DjstripeSettings . get_default_api_key ( self , livemode ) Returns the default API key for a value of livemode . Source code in djstripe/settings.py def get_default_api_key ( self , livemode ) -> str : \"\"\" Returns the default API key for a value of `livemode`. \"\"\" if livemode is None : # Livemode is unknown. Use the default secret key. return self . STRIPE_SECRET_KEY elif livemode : # Livemode is true, use the live secret key return self . LIVE_API_KEY or self . STRIPE_SECRET_KEY else : # Livemode is false, use the test secret key return self . TEST_API_KEY or self . STRIPE_SECRET_KEY djstripe . settings . DjstripeSettings . get_subscriber_model ( self ) Attempt to pull settings.DJSTRIPE_SUBSCRIBER_MODEL. Users have the option of specifying a custom subscriber model via the DJSTRIPE_SUBSCRIBER_MODEL setting. This methods falls back to AUTH_USER_MODEL if DJSTRIPE_SUBSCRIBER_MODEL is not set. Returns the subscriber model that is active in this project. Source code in djstripe/settings.py def get_subscriber_model ( self ): \"\"\" Attempt to pull settings.DJSTRIPE_SUBSCRIBER_MODEL. Users have the option of specifying a custom subscriber model via the DJSTRIPE_SUBSCRIBER_MODEL setting. This methods falls back to AUTH_USER_MODEL if DJSTRIPE_SUBSCRIBER_MODEL is not set. Returns the subscriber model that is active in this project. \"\"\" model_name = self . get_subscriber_model_string () # Attempt a Django 1.7 app lookup try : subscriber_model = django_apps . get_model ( model_name ) except ValueError : raise ImproperlyConfigured ( \"DJSTRIPE_SUBSCRIBER_MODEL must be of the form 'app_label.model_name'.\" ) except LookupError : raise ImproperlyConfigured ( \"DJSTRIPE_SUBSCRIBER_MODEL refers to model ' {model} ' \" \"that has not been installed.\" . format ( model = model_name ) ) if ( \"email\" not in [ field_ . name for field_ in subscriber_model . _meta . get_fields ()] ) and not hasattr ( subscriber_model , \"email\" ): raise ImproperlyConfigured ( \"DJSTRIPE_SUBSCRIBER_MODEL must have an email attribute.\" ) if model_name != settings . AUTH_USER_MODEL : # Custom user model detected. Make sure the callback is configured. func = self . get_callback_function ( \"DJSTRIPE_SUBSCRIBER_MODEL_REQUEST_CALLBACK\" ) if not func : raise ImproperlyConfigured ( \"DJSTRIPE_SUBSCRIBER_MODEL_REQUEST_CALLBACK must be implemented \" \"if a DJSTRIPE_SUBSCRIBER_MODEL is defined.\" ) return subscriber_model djstripe . settings . DjstripeSettings . get_subscriber_model_string ( self ) Get the configured subscriber model as a module path string. Source code in djstripe/settings.py def get_subscriber_model_string ( self ) -> str : \"\"\"Get the configured subscriber model as a module path string.\"\"\" return getattr ( settings , \"DJSTRIPE_SUBSCRIBER_MODEL\" , settings . AUTH_USER_MODEL ) # type: ignore djstripe . settings . DjstripeSettings . set_stripe_api_version ( self , version = None , validate = True ) Set the desired API version to use for Stripe requests. :param version: The version to set for the Stripe API. :type version: str :param validate: If True validate the value for the specified version). :type validate: bool Source code in djstripe/settings.py def set_stripe_api_version ( self , version = None , validate = True ): \"\"\" Set the desired API version to use for Stripe requests. :param version: The version to set for the Stripe API. :type version: ``str`` :param validate: If True validate the value for the specified version). :type validate: ``bool`` \"\"\" version = version or self . STRIPE_API_VERSION if validate : valid = validate_stripe_api_version ( version ) if not valid : raise ValueError ( \"Bad stripe API version: {} \" . format ( version )) stripe . api_version = version selection: filters: - \"!^ [^ ]\"","title":"Settings"},{"location":"reference/settings/#settings","text":"","title":"Settings"},{"location":"reference/settings/#stripe_api_version-2020-08-27","text":"The API version used to communicate with the Stripe API is configurable, and defaults to the latest version that has been tested as working. Using a value other than the default is allowed, as a string in the format of YYYY-MM-DD. For example, you can specify \"2020-03-02\" to use that API version: STRIPE_API_VERSION = \"2020-03-02\" However you do so at your own risk, as using a value other than the default might result in incompatibilities between Stripe and this library, especially if Stripe has labelled the differences between API versions as \"Major\". Even small differences such as a new enumeration value might cause issues. For this reason it is best to assume that only the default version is supported. For more information on API versioning, see the stripe documentation . See also API Versions .","title":"STRIPE_API_VERSION (='2020-08-27')"},{"location":"reference/settings/#djstripe_foreign_key_to_field","text":"(Introduced in 2.4.0) DJSTRIPE_FOREIGN_KEY_TO_FIELD is a setting introduced in dj-stripe version 2.4.0. You are required to set it in 2.4.0: It does not have a default value. In 3.0.0, the default will be \"id\", and we recommend setting it to \"id\" for new installations. Older installations should set it to \"djstripe_id\". Explanation below. In dj-stripe 2.3 and before, foreign keys for Stripe models were set to point to the foreign model's djstripe_id field, a numeric integer generated by the local database. This new setting allows dj-stripe users to change it to use the \"id\" field, which is the upstream, non-numeric Stripe identifier. When using the Stripe identifier as a foreign key, synchronization between Stripe and dj-stripe can be made far more efficient and robust. Furthermore, it removes the per-installation instability of a critical value. The plan is to get rid of djstripe_id altogether for the 3.0 release (we may retain the field itself until 4.0, but it will no longer be a primary key). How to migrate older installations from \"djstripe_id\" to \"id\"? Such a migration path has not been designed at the moment. Currently if you want to switch an older installation to \"id\", the easiest way is to wipe the djstripe db and sync again from scratch. This is obviously not ideal, and we will design a proper migration path before 3.0.","title":"DJSTRIPE_FOREIGN_KEY_TO_FIELD"},{"location":"reference/settings/#djstripe_idempotency_key_callback-djstripesettingsdjstripe_settings_get_idempotency_key","text":"A function which will return an idempotency key for a particular object_type and action pair. By default, this is set to a function which will create a djstripe.IdempotencyKey object and return its uuid . You may want to customize this if you want to give your idempotency keys a different lifecycle than they normally would get. The function takes the following signature: def get_idempotency_key ( object_type : str , action : str , livemode : bool ): return \"<idempotency key>\" The function MUST return a string suitably random for the object_type/action pair, and usable in the Stripe Idempotency-Key HTTP header. For more information, see the stripe documentation .","title":"DJSTRIPE_IDEMPOTENCY_KEY_CALLBACK (=djstripe.settings.djstripe_settings._get_idempotency_key)"},{"location":"reference/settings/#djstripe_proration_policy-false","text":"Warning This setting is deprecated and will be removed in dj-stripe 2.8. By default, plans are not prorated in dj-stripe. Concretely, this is how this translates: If a customer cancels their plan during a trial, the cancellation is effective right away. If a customer cancels their plan outside of a trial, their subscription remains active until the subscription's period end, and they do not receive a refund. If a customer switches from one plan to another, the new plan becomes effective right away, and the customer is billed for the new plan's amount. Assigning True to DJSTRIPE_PRORATION_POLICY reverses the functioning of item 2 (plan cancellation) by making a cancellation effective right away and refunding the unused balance to the customer, and affects the functioning of item 3 (plan change) by prorating the previous customer's plan towards their new plan's amount.","title":"DJSTRIPE_PRORATION_POLICY (=False)"},{"location":"reference/settings/#djstripe_subscription_required_exception_urls","text":"Warning This functionality is deprecated. Used by djstripe.middleware.SubscriptionPaymentMiddleware Rules: \"(app_name)\" means everything from this app is exempt \"[namespace]\" means everything with this name is exempt \"namespace:name\" means this namespaced URL is exempt \"name\" means this URL is exempt The entire djstripe namespace is exempt If settings.DEBUG is True, then django-debug-toolbar is exempt Example: DJSTRIPE_SUBSCRIPTION_REQUIRED_EXCEPTION_URLS = ( \"(allauth)\" , # anything in the django-allauth URLConf \"[blogs]\" , # Anything in the blogs namespace \"products:detail\" , # A ProductDetail view you want shown to non-payers \"home\" , # Site homepage ) Note Adding app_names to applications. To make the (allauth) work, you may need to define an app_name in the include() function in the URLConf. For example: # in urls.py url ( r '^accounts/' , include ( 'allauth.urls' , app_name = \"allauth\" )),","title":"DJSTRIPE_SUBSCRIPTION_REQUIRED_EXCEPTION_URLS (=())"},{"location":"reference/settings/#djstripe_subscriber_customer_key-djstripe_subscriber","text":"Every Customer object created in Stripe is tagged with metadata This setting controls what the name of the key in Stripe should be. The key name must be a string no more than 40 characters long. You may set this to None or \"\" to disable that behaviour altogether. This is probably not something you want to do, though.","title":"DJSTRIPE_SUBSCRIBER_CUSTOMER_KEY (=\"djstripe_subscriber\")"},{"location":"reference/settings/#djstripe_subscriber_model-settingsauth_user_model","text":"If the AUTH_USER_MODEL doesn't represent the object your application's subscription holder, you may define a subscriber model to use here. It should be a string in the form of 'app.model'. Note DJSTRIPE_SUBSCRIBER_MODEL must have an email field. If your existing model has no email field, add an email property that defines an email address to use. Example Model: class Organization ( models . Model ): name = CharField ( max_length = 200 , unique = True ) admin = ForeignKey ( settings . AUTH_USER_MODEL , on_delete = CASCADE ) @property def email ( self ): return self . admin . email","title":"DJSTRIPE_SUBSCRIBER_MODEL (=settings.AUTH_USER_MODEL)"},{"location":"reference/settings/#djstripe_subscriber_model_migration_dependency-__first__","text":"If the model referenced in DJSTRIPE_SUBSCRIBER_MODEL is not created in the __first__ migration of an app you can specify the migration name to depend on here. For example: \"0003_here_the_subscriber_model_was_added\"","title":"DJSTRIPE_SUBSCRIBER_MODEL_MIGRATION_DEPENDENCY (=\"__first__\")"},{"location":"reference/settings/#djstripe_use_native_jsonfield-true","text":"Warning This setting is deprecated and will be removed in dj-stripe 2.8. When set to False , forces dj-stripe to use the jsonfield library for JSONField . Leaving this set to True is highly recommended. However, if you have already migrated with the old fields, migrating to the native JSONField has to be done manually and is not currently natively supported by dj-stripe. The native Django JSONField uses the postgres jsonb column type, which efficiently stores JSON and can be queried far moreconveniently. Django also supports querying JSONField with the ORM.","title":"DJSTRIPE_USE_NATIVE_JSONFIELD (=True)"},{"location":"reference/settings/#djstripe_webhook_url-rwebhook","text":"This is where you can tell Stripe to send webhook responses. You can set this to what you want to prevent unnecessary hijinks from unfriendly people. As this is embedded in the URLConf, this must be a resolvable regular expression.","title":"DJSTRIPE_WEBHOOK_URL (=r\"^webhook/$\")"},{"location":"reference/settings/#djstripe_webhook_secret","text":"If this is set to a non-empty value, webhook signatures will be verified. Learn more about webhook signature verification .","title":"DJSTRIPE_WEBHOOK_SECRET (=\"\")"},{"location":"reference/settings/#djstripe_webhook_validation-verify_signature","text":"This setting controls which type of validation is done on webhooks. Value can be \"verify_signature\" for signature verification (recommended default), \"retrieve_event\" for event retrieval (makes an extra HTTP request), or None for no validation at all.","title":"DJSTRIPE_WEBHOOK_VALIDATION= (=\"verify_signature\")"},{"location":"reference/settings/#djstripe_webhook_tolerance-300","text":"Controls the milliseconds tolerance which wards against replay attacks. Leave this to its default value unless you know what you're doing.","title":"DJSTRIPE_WEBHOOK_TOLERANCE (=300)"},{"location":"reference/settings/#djstripe_webhook_event_callback-none","text":"Webhook event callbacks allow an application to take control of what happens when an event from Stripe is received. It must be a callable or importable string to a callable that takes an event object. One suggestion is to put the event onto a task queue (such as celery) for asynchronous processing. Examples: # callbacks.py def webhook_event_callback ( event ): \"\"\" Dispatches the event to celery for processing. \"\"\" from . import tasks # Ansychronous hand-off to celery so that we can continue immediately tasks . process_webhook_event . s ( event . pk ) . apply_async () # tasks.py from djstripe.models import WebhookEventTrigger from stripe.error import StripeError @shared_task ( bind = True ) def process_webhook_event ( self , pk ): \"\"\" Processes events from Stripe asynchronously. \"\"\" logger . info ( f \"Processing Stripe event: { pk } \" ) try : # get the event obj = WebhookEventTrigger . objects . get ( pk = pk ) # process the event. # internally, this creates a Stripe WebhookEvent Object and invokes the respective Webhooks event = obj . process () except StripeError as exc : logger . error ( f \"Failed to process Stripe event: { pk } . Retrying in 60 seconds.\" ) raise self . retry ( exc = exc , countdown = 60 ) # retry after 60 seconds except WebhookEventTrigger . DoesNotExist as exc : # This can happen in case the celery task got executed before the actual model got saved to the DB raise self . retry ( exc = exc , countdown = 10 ) # retry after 10 seconds return event . type or \"Stripe Event Processed\" # settings.py DJSTRIPE_WEBHOOK_EVENT_CALLBACK = 'callbacks.webhook_event_callback'","title":"DJSTRIPE_WEBHOOK_EVENT_CALLBACK (=None)"},{"location":"reference/settings/#stripe_api_host-unset","text":"If set, this sets the base API host for Stripe. You may want to set this to, for example, \"http://localhost:12111\" if you are running stripe-mock . If this is set in production (DEBUG=False), a warning will be raised on manage.py check .","title":"STRIPE_API_HOST (= unset)"},{"location":"reference/settings/#source-code","text":"dj-stripe settings","title":"Source Code"},{"location":"reference/settings/#djstripe.settings.djstripe_settings","text":"","title":"djstripe_settings"},{"location":"reference/settings/#djstripe.settings-classes","text":"","title":"Classes"},{"location":"reference/settings/#djstripe.settings.DjstripeSettings","text":"Container for Dj-stripe settings :return: Initialised settings for Dj-stripe. :rtype: object","title":"DjstripeSettings"},{"location":"reference/settings/#djstripe.settings.DjstripeSettings-attributes","text":"","title":"Attributes"},{"location":"reference/settings/#djstripe.settings.DjstripeSettings.DEFAULT_STRIPE_API_VERSION","text":"","title":"DEFAULT_STRIPE_API_VERSION"},{"location":"reference/settings/#djstripe.settings.DjstripeSettings.DJSTRIPE_WEBHOOK_URL","text":"","title":"DJSTRIPE_WEBHOOK_URL"},{"location":"reference/settings/#djstripe.settings.DjstripeSettings.LIVE_API_KEY","text":"","title":"LIVE_API_KEY"},{"location":"reference/settings/#djstripe.settings.DjstripeSettings.PRORATION_POLICY","text":"","title":"PRORATION_POLICY"},{"location":"reference/settings/#djstripe.settings.DjstripeSettings.STRIPE_API_VERSION","text":"Get the desired API version to use for Stripe requests.","title":"STRIPE_API_VERSION"},{"location":"reference/settings/#djstripe.settings.DjstripeSettings.STRIPE_LIVE_MODE","text":"","title":"STRIPE_LIVE_MODE"},{"location":"reference/settings/#djstripe.settings.DjstripeSettings.STRIPE_PUBLIC_KEY","text":"","title":"STRIPE_PUBLIC_KEY"},{"location":"reference/settings/#djstripe.settings.DjstripeSettings.STRIPE_SECRET_KEY","text":"","title":"STRIPE_SECRET_KEY"},{"location":"reference/settings/#djstripe.settings.DjstripeSettings.SUBSCRIBER_CUSTOMER_KEY","text":"","title":"SUBSCRIBER_CUSTOMER_KEY"},{"location":"reference/settings/#djstripe.settings.DjstripeSettings.SUBSCRIPTION_REDIRECT","text":"","title":"SUBSCRIPTION_REDIRECT"},{"location":"reference/settings/#djstripe.settings.DjstripeSettings.SUBSCRIPTION_REQUIRED_EXCEPTION_URLS","text":"","title":"SUBSCRIPTION_REQUIRED_EXCEPTION_URLS"},{"location":"reference/settings/#djstripe.settings.DjstripeSettings.TEST_API_KEY","text":"","title":"TEST_API_KEY"},{"location":"reference/settings/#djstripe.settings.DjstripeSettings.USE_NATIVE_JSONFIELD","text":"","title":"USE_NATIVE_JSONFIELD"},{"location":"reference/settings/#djstripe.settings.DjstripeSettings.WEBHOOK_EVENT_CALLBACK","text":"","title":"WEBHOOK_EVENT_CALLBACK"},{"location":"reference/settings/#djstripe.settings.DjstripeSettings.WEBHOOK_SECRET","text":"","title":"WEBHOOK_SECRET"},{"location":"reference/settings/#djstripe.settings.DjstripeSettings.WEBHOOK_TOLERANCE","text":"","title":"WEBHOOK_TOLERANCE"},{"location":"reference/settings/#djstripe.settings.DjstripeSettings.WEBHOOK_VALIDATION","text":"","title":"WEBHOOK_VALIDATION"},{"location":"reference/settings/#djstripe.settings.DjstripeSettings.ZERO_DECIMAL_CURRENCIES","text":"","title":"ZERO_DECIMAL_CURRENCIES"},{"location":"reference/settings/#djstripe.settings.DjstripeSettings.get_idempotency_key","text":"","title":"get_idempotency_key"},{"location":"reference/settings/#djstripe.settings.DjstripeSettings.subscriber_request_callback","text":"","title":"subscriber_request_callback"},{"location":"reference/settings/#djstripe.settings.DjstripeSettings-methods","text":"","title":"Methods"},{"location":"reference/settings/#djstripe.settings.DjstripeSettings.__delattr__","text":"Source code in djstripe/settings.py def __delattr__ ( self , name ): del self . __dict__ [ name ]","title":"__delattr__()"},{"location":"reference/settings/#djstripe.settings.DjstripeSettings.__init__","text":"Source code in djstripe/settings.py def __init__ ( self ): # Set STRIPE_API_HOST if you want to use a different Stripe API server # Example: https://github.com/stripe/stripe-mock if hasattr ( settings , \"STRIPE_API_HOST\" ): stripe . api_base = getattr ( settings , \"STRIPE_API_HOST\" )","title":"__init__()"},{"location":"reference/settings/#djstripe.settings.DjstripeSettings.__setattr__","text":"Source code in djstripe/settings.py def __setattr__ ( self , name , value ): self . __dict__ [ name ] = value","title":"__setattr__()"},{"location":"reference/settings/#djstripe.settings.DjstripeSettings.get_callback_function","text":"Resolve a callback function based on a setting name. If the setting value isn't set, default is returned. If the setting value is already a callable function, that value is used - If the setting value is a string, an attempt is made to import it. Anything else will result in a failed import causing ImportError to be raised. :param setting_name: The name of the setting to resolve a callback from. :type setting_name: string ( str / unicode ) :param default: The default to return if setting isn't populated. :type default: bool :returns: The resolved callback function (if any). :type: callable Source code in djstripe/settings.py def get_callback_function ( self , setting_name , default = None ): \"\"\" Resolve a callback function based on a setting name. If the setting value isn't set, default is returned. If the setting value is already a callable function, that value is used - If the setting value is a string, an attempt is made to import it. Anything else will result in a failed import causing ImportError to be raised. :param setting_name: The name of the setting to resolve a callback from. :type setting_name: string (``str``/``unicode``) :param default: The default to return if setting isn't populated. :type default: ``bool`` :returns: The resolved callback function (if any). :type: ``callable`` \"\"\" func = getattr ( settings , setting_name , None ) if not func : return default if callable ( func ): return func if isinstance ( func , str ): func = import_string ( func ) if not callable ( func ): raise ImproperlyConfigured ( \" {name} must be callable.\" . format ( name = setting_name ) ) return func","title":"get_callback_function()"},{"location":"reference/settings/#djstripe.settings.DjstripeSettings.get_default_api_key","text":"Returns the default API key for a value of livemode . Source code in djstripe/settings.py def get_default_api_key ( self , livemode ) -> str : \"\"\" Returns the default API key for a value of `livemode`. \"\"\" if livemode is None : # Livemode is unknown. Use the default secret key. return self . STRIPE_SECRET_KEY elif livemode : # Livemode is true, use the live secret key return self . LIVE_API_KEY or self . STRIPE_SECRET_KEY else : # Livemode is false, use the test secret key return self . TEST_API_KEY or self . STRIPE_SECRET_KEY","title":"get_default_api_key()"},{"location":"reference/settings/#djstripe.settings.DjstripeSettings.get_subscriber_model","text":"Attempt to pull settings.DJSTRIPE_SUBSCRIBER_MODEL. Users have the option of specifying a custom subscriber model via the DJSTRIPE_SUBSCRIBER_MODEL setting. This methods falls back to AUTH_USER_MODEL if DJSTRIPE_SUBSCRIBER_MODEL is not set. Returns the subscriber model that is active in this project. Source code in djstripe/settings.py def get_subscriber_model ( self ): \"\"\" Attempt to pull settings.DJSTRIPE_SUBSCRIBER_MODEL. Users have the option of specifying a custom subscriber model via the DJSTRIPE_SUBSCRIBER_MODEL setting. This methods falls back to AUTH_USER_MODEL if DJSTRIPE_SUBSCRIBER_MODEL is not set. Returns the subscriber model that is active in this project. \"\"\" model_name = self . get_subscriber_model_string () # Attempt a Django 1.7 app lookup try : subscriber_model = django_apps . get_model ( model_name ) except ValueError : raise ImproperlyConfigured ( \"DJSTRIPE_SUBSCRIBER_MODEL must be of the form 'app_label.model_name'.\" ) except LookupError : raise ImproperlyConfigured ( \"DJSTRIPE_SUBSCRIBER_MODEL refers to model ' {model} ' \" \"that has not been installed.\" . format ( model = model_name ) ) if ( \"email\" not in [ field_ . name for field_ in subscriber_model . _meta . get_fields ()] ) and not hasattr ( subscriber_model , \"email\" ): raise ImproperlyConfigured ( \"DJSTRIPE_SUBSCRIBER_MODEL must have an email attribute.\" ) if model_name != settings . AUTH_USER_MODEL : # Custom user model detected. Make sure the callback is configured. func = self . get_callback_function ( \"DJSTRIPE_SUBSCRIBER_MODEL_REQUEST_CALLBACK\" ) if not func : raise ImproperlyConfigured ( \"DJSTRIPE_SUBSCRIBER_MODEL_REQUEST_CALLBACK must be implemented \" \"if a DJSTRIPE_SUBSCRIBER_MODEL is defined.\" ) return subscriber_model","title":"get_subscriber_model()"},{"location":"reference/settings/#djstripe.settings.DjstripeSettings.get_subscriber_model_string","text":"Get the configured subscriber model as a module path string. Source code in djstripe/settings.py def get_subscriber_model_string ( self ) -> str : \"\"\"Get the configured subscriber model as a module path string.\"\"\" return getattr ( settings , \"DJSTRIPE_SUBSCRIBER_MODEL\" , settings . AUTH_USER_MODEL ) # type: ignore","title":"get_subscriber_model_string()"},{"location":"reference/settings/#djstripe.settings.DjstripeSettings.set_stripe_api_version","text":"Set the desired API version to use for Stripe requests. :param version: The version to set for the Stripe API. :type version: str :param validate: If True validate the value for the specified version). :type validate: bool Source code in djstripe/settings.py def set_stripe_api_version ( self , version = None , validate = True ): \"\"\" Set the desired API version to use for Stripe requests. :param version: The version to set for the Stripe API. :type version: ``str`` :param validate: If True validate the value for the specified version). :type validate: ``bool`` \"\"\" version = version or self . STRIPE_API_VERSION if validate : valid = validate_stripe_api_version ( version ) if not valid : raise ValueError ( \"Bad stripe API version: {} \" . format ( version )) stripe . api_version = version selection: filters: - \"!^ [^ ]\"","title":"set_stripe_api_version()"},{"location":"reference/utils/","text":"Utilities Utility functions related to the djstripe app. djstripe . utils . CURRENCY_SIGILS Classes djstripe.utils.QuerySetMock A mocked QuerySet class that does not handle updates. Used by UpcomingInvoice.invoiceitems. Methods djstripe . utils . QuerySetMock . delete ( self ) Delete the records in the current QuerySet. Source code in djstripe/utils.py def delete ( self ): return 0 djstripe . utils . QuerySetMock . from_iterable ( model , iterable ) classmethod Source code in djstripe/utils.py @classmethod def from_iterable ( cls , model , iterable ): instance = cls ( model ) instance . _result_cache = list ( iterable ) instance . _prefetch_done = True return instance djstripe . utils . QuerySetMock . update ( self ) Update all elements in the current QuerySet, setting all the given fields to the appropriate values. Source code in djstripe/utils.py def update ( self ): return 0 Functions djstripe . utils . clear_expired_idempotency_keys () Source code in djstripe/utils.py def clear_expired_idempotency_keys (): from .models import IdempotencyKey threshold = timezone . now () - datetime . timedelta ( hours = 24 ) IdempotencyKey . objects . filter ( created__lt = threshold ) . delete () djstripe . utils . convert_tstamp ( response ) Convert a Stripe API timestamp response (unix epoch) to a native datetime. Source code in djstripe/utils.py def convert_tstamp ( response ) -> Optional [ datetime . datetime ]: \"\"\" Convert a Stripe API timestamp response (unix epoch) to a native datetime. \"\"\" if response is None : # Allow passing None to convert_tstamp() return response # Overrides the set timezone to UTC - I think... tz = timezone . utc if settings . USE_TZ else None return datetime . datetime . fromtimestamp ( response , tz ) djstripe . utils . get_friendly_currency_amount ( amount , currency ) Source code in djstripe/utils.py def get_friendly_currency_amount ( amount , currency : str ) -> str : currency = currency . upper () sigil = CURRENCY_SIGILS . get ( currency , \"\" ) return \" {sigil}{amount:.2f} {currency} \" . format ( sigil = sigil , amount = amount , currency = currency ) djstripe . utils . get_id_from_stripe_data ( data ) Extract stripe id from stripe field data Source code in djstripe/utils.py def get_id_from_stripe_data ( data ): \"\"\" Extract stripe id from stripe field data \"\"\" if isinstance ( data , str ): # data like \"sub_6lsC8pt7IcFpjA\" return data elif data : # data like {\"id\": sub_6lsC8pt7IcFpjA\", ...} return data . get ( \"id\" ) else : return None djstripe . utils . get_supported_currency_choices ( api_key ) Pull a stripe account's supported currencies and returns a choices tuple of those supported currencies. :param api_key: The api key associated with the account from which to pull data. :type api_key: str Source code in djstripe/utils.py def get_supported_currency_choices ( api_key ): \"\"\" Pull a stripe account's supported currencies and returns a choices tuple of those supported currencies. :param api_key: The api key associated with the account from which to pull data. :type api_key: str \"\"\" import stripe stripe . api_key = api_key account = stripe . Account . retrieve () supported_payment_currencies = stripe . CountrySpec . retrieve ( account [ \"country\" ])[ \"supported_payment_currencies\" ] return [( currency , currency . upper ()) for currency in supported_payment_currencies ]","title":"Utilities"},{"location":"reference/utils/#utilities","text":"Utility functions related to the djstripe app.","title":"Utilities"},{"location":"reference/utils/#djstripe.utils.CURRENCY_SIGILS","text":"","title":"CURRENCY_SIGILS"},{"location":"reference/utils/#djstripe.utils-classes","text":"","title":"Classes"},{"location":"reference/utils/#djstripe.utils.QuerySetMock","text":"A mocked QuerySet class that does not handle updates. Used by UpcomingInvoice.invoiceitems.","title":"QuerySetMock"},{"location":"reference/utils/#djstripe.utils.QuerySetMock-methods","text":"","title":"Methods"},{"location":"reference/utils/#djstripe.utils.QuerySetMock.delete","text":"Delete the records in the current QuerySet. Source code in djstripe/utils.py def delete ( self ): return 0","title":"delete()"},{"location":"reference/utils/#djstripe.utils.QuerySetMock.from_iterable","text":"Source code in djstripe/utils.py @classmethod def from_iterable ( cls , model , iterable ): instance = cls ( model ) instance . _result_cache = list ( iterable ) instance . _prefetch_done = True return instance","title":"from_iterable()"},{"location":"reference/utils/#djstripe.utils.QuerySetMock.update","text":"Update all elements in the current QuerySet, setting all the given fields to the appropriate values. Source code in djstripe/utils.py def update ( self ): return 0","title":"update()"},{"location":"reference/utils/#djstripe.utils-functions","text":"","title":"Functions"},{"location":"reference/utils/#djstripe.utils.clear_expired_idempotency_keys","text":"Source code in djstripe/utils.py def clear_expired_idempotency_keys (): from .models import IdempotencyKey threshold = timezone . now () - datetime . timedelta ( hours = 24 ) IdempotencyKey . objects . filter ( created__lt = threshold ) . delete ()","title":"clear_expired_idempotency_keys()"},{"location":"reference/utils/#djstripe.utils.convert_tstamp","text":"Convert a Stripe API timestamp response (unix epoch) to a native datetime. Source code in djstripe/utils.py def convert_tstamp ( response ) -> Optional [ datetime . datetime ]: \"\"\" Convert a Stripe API timestamp response (unix epoch) to a native datetime. \"\"\" if response is None : # Allow passing None to convert_tstamp() return response # Overrides the set timezone to UTC - I think... tz = timezone . utc if settings . USE_TZ else None return datetime . datetime . fromtimestamp ( response , tz )","title":"convert_tstamp()"},{"location":"reference/utils/#djstripe.utils.get_friendly_currency_amount","text":"Source code in djstripe/utils.py def get_friendly_currency_amount ( amount , currency : str ) -> str : currency = currency . upper () sigil = CURRENCY_SIGILS . get ( currency , \"\" ) return \" {sigil}{amount:.2f} {currency} \" . format ( sigil = sigil , amount = amount , currency = currency )","title":"get_friendly_currency_amount()"},{"location":"reference/utils/#djstripe.utils.get_id_from_stripe_data","text":"Extract stripe id from stripe field data Source code in djstripe/utils.py def get_id_from_stripe_data ( data ): \"\"\" Extract stripe id from stripe field data \"\"\" if isinstance ( data , str ): # data like \"sub_6lsC8pt7IcFpjA\" return data elif data : # data like {\"id\": sub_6lsC8pt7IcFpjA\", ...} return data . get ( \"id\" ) else : return None","title":"get_id_from_stripe_data()"},{"location":"reference/utils/#djstripe.utils.get_supported_currency_choices","text":"Pull a stripe account's supported currencies and returns a choices tuple of those supported currencies. :param api_key: The api key associated with the account from which to pull data. :type api_key: str Source code in djstripe/utils.py def get_supported_currency_choices ( api_key ): \"\"\" Pull a stripe account's supported currencies and returns a choices tuple of those supported currencies. :param api_key: The api key associated with the account from which to pull data. :type api_key: str \"\"\" import stripe stripe . api_key = api_key account = stripe . Account . retrieve () supported_payment_currencies = stripe . CountrySpec . retrieve ( account [ \"country\" ])[ \"supported_payment_currencies\" ] return [( currency , currency . upper ()) for currency in supported_payment_currencies ]","title":"get_supported_currency_choices()"},{"location":"usage/creating_individual_charges/","text":"Creating individual charges On the subscriber's customer object, use the charge method to generate a Stripe charge. In this example, we're using the user named admin as the subscriber. from decimal import Decimal from django.contrib.auth import get_user_model from djstripe.models import Customer user = get_user_model () . objects . get ( username = \"admin\" ) customer , created = Customer . get_or_create ( subscriber = user ) customer . charge ( Decimal ( \"10.00\" ), currency = \"usd\" ) # Create charge for 10.00 USD","title":"Creating individual charges"},{"location":"usage/creating_individual_charges/#creating-individual-charges","text":"On the subscriber's customer object, use the charge method to generate a Stripe charge. In this example, we're using the user named admin as the subscriber. from decimal import Decimal from django.contrib.auth import get_user_model from djstripe.models import Customer user = get_user_model () . objects . get ( username = \"admin\" ) customer , created = Customer . get_or_create ( subscriber = user ) customer . charge ( Decimal ( \"10.00\" ), currency = \"usd\" ) # Create charge for 10.00 USD","title":"Creating individual charges"},{"location":"usage/creating_usage_record/","text":"Create a Stripe Usage Record Usage records allow you to report customer usage and metrics to Stripe for metered billing of subscription prices Usage records created using Djstripe's UsageRecord.create() method will both create and sync the created UsageRecord object with your db. Note UsageRecord objects created directly will not sync because Stripe does not expose a way to retrieve UsageRecord objects directly. They can thus only be synced at creation time. Code: from djstripe.models import UsageRecord # create and sync UsageRecord object UsageRecord . create ( id =< SUBSCRIPTION_ITEM_ID > , quantity =< SUBSCRIPTION_ITEM_QUANTITY > , timestamp = timestamp )","title":"Creating Usage Records"},{"location":"usage/creating_usage_record/#create-a-stripe-usage-record","text":"Usage records allow you to report customer usage and metrics to Stripe for metered billing of subscription prices Usage records created using Djstripe's UsageRecord.create() method will both create and sync the created UsageRecord object with your db. Note UsageRecord objects created directly will not sync because Stripe does not expose a way to retrieve UsageRecord objects directly. They can thus only be synced at creation time.","title":"Create a Stripe Usage Record"},{"location":"usage/creating_usage_record/#code","text":"from djstripe.models import UsageRecord # create and sync UsageRecord object UsageRecord . create ( id =< SUBSCRIPTION_ITEM_ID > , quantity =< SUBSCRIPTION_ITEM_QUANTITY > , timestamp = timestamp )","title":"Code:"},{"location":"usage/managing_subscriptions/","text":"Managing subscriptions and payment sources Extending subscriptions For your convenience, dj-stripe provides a Subscription.extend(*delta*) method Subscriptions can be extended by using the Subscription.extend method, which takes a positive timedelta as its only property. This method is useful if you want to offer time-cards, gift-cards, or some other external way of subscribing users or extending subscriptions, while keeping the billing handling within Stripe. Warning Subscription extensions are achieved by manipulating the trial_end of the subscription instance, which means that Stripe will change the status to trialing .","title":"Managing subscriptions and payment sources"},{"location":"usage/managing_subscriptions/#managing-subscriptions-and-payment-sources","text":"","title":"Managing subscriptions and payment sources"},{"location":"usage/managing_subscriptions/#extending-subscriptions","text":"For your convenience, dj-stripe provides a Subscription.extend(*delta*) method Subscriptions can be extended by using the Subscription.extend method, which takes a positive timedelta as its only property. This method is useful if you want to offer time-cards, gift-cards, or some other external way of subscribing users or extending subscriptions, while keeping the billing handling within Stripe. Warning Subscription extensions are achieved by manipulating the trial_end of the subscription instance, which means that Stripe will change the status to trialing .","title":"Extending subscriptions"},{"location":"usage/manually_syncing_with_stripe/","text":"Manually syncing data with Stripe If you're using dj-stripe's webhook handlers then data will be automatically synced from Stripe to the Django database, but in some circumstances you may want to manually sync Stripe API data as well. Command line You can sync your database with stripe using the manage command djstripe_sync_models , e.g. to populate an empty database from an existing Stripe account. ./manage.py djstripe_sync_models With no arguments this will sync all supported models, or a list of models to sync can be provided. ./manage.py djstripe_sync_models Invoice Subscription Note that this may be redundant since we recursively sync related objects. You can manually reprocess events using the management commands djstripe_process_events . By default this processes all events, but options can be passed to limit the events processed. Note the Stripe API documents a limitation where events are only guaranteed to be available for 30 days. # all events ./manage.py djstripe_process_events # failed events (events with pending webhooks or where all webhook delivery attempts failed) ./manage.py djstripe_process_events --failed # filter by event type (all payment_intent events in this example) ./manage.py djstripe_process_events --type payment_intent.* # specific events by ID ./manage.py djstripe_process_events --ids evt_foo evt_bar # more output for debugging processing failures ./manage.py djstripe_process_events -v 2 In Code To sync in code, for example if you write to the Stripe API and want to work with the resulting dj-stripe object without having to wait for the webhook trigger. This can be done using the classmethod sync_from_stripe_data that exists on all dj-stripe model classes. E.g. creating a product using the Stripe API, and then syncing the API return data to Django using dj-stripe:","title":"Manually syncing data with Stripe"},{"location":"usage/manually_syncing_with_stripe/#manually-syncing-data-with-stripe","text":"If you're using dj-stripe's webhook handlers then data will be automatically synced from Stripe to the Django database, but in some circumstances you may want to manually sync Stripe API data as well.","title":"Manually syncing data with Stripe"},{"location":"usage/manually_syncing_with_stripe/#command-line","text":"You can sync your database with stripe using the manage command djstripe_sync_models , e.g. to populate an empty database from an existing Stripe account. ./manage.py djstripe_sync_models With no arguments this will sync all supported models, or a list of models to sync can be provided. ./manage.py djstripe_sync_models Invoice Subscription Note that this may be redundant since we recursively sync related objects. You can manually reprocess events using the management commands djstripe_process_events . By default this processes all events, but options can be passed to limit the events processed. Note the Stripe API documents a limitation where events are only guaranteed to be available for 30 days. # all events ./manage.py djstripe_process_events # failed events (events with pending webhooks or where all webhook delivery attempts failed) ./manage.py djstripe_process_events --failed # filter by event type (all payment_intent events in this example) ./manage.py djstripe_process_events --type payment_intent.* # specific events by ID ./manage.py djstripe_process_events --ids evt_foo evt_bar # more output for debugging processing failures ./manage.py djstripe_process_events -v 2","title":"Command line"},{"location":"usage/manually_syncing_with_stripe/#in-code","text":"To sync in code, for example if you write to the Stripe API and want to work with the resulting dj-stripe object without having to wait for the webhook trigger. This can be done using the classmethod sync_from_stripe_data that exists on all dj-stripe model classes. E.g. creating a product using the Stripe API, and then syncing the API return data to Django using dj-stripe:","title":"In Code"},{"location":"usage/subscribing_customers/","text":"Subscribing a customer to one or more prices (or plans) Recommended Approach # Recommended Approach to use items dict with Prices ## This will subscribe <customer> to both <price_1> and <price_2> price_1 = Price . objects . get ( nickname = \"one_price\" ) price_2 = Price . objects . get ( nickname = \"two_price\" ) customer = Customer . objects . first () customer . subscribe ( items = [{ \"price\" : price_1 }, { \"price\" : price_2 }]) ## This will subscribe <customer> to <price_1> price_1 = Price . objects . get ( nickname = \"one_price\" ) customer = Customer . objects . first () customer . subscribe ( items = [{ \"price\" : price_1 }]) Alternate Approach 1 (with legacy Plans) ## (Alternate Approach) This will subscribe <customer> to <price_1> price_1 = Price . objects . get ( nickname = \"one_price\" ) customer = Customer . objects . first () customer . subscribe ( price = price_1 ) # If you still use legacy Plans... ## This will subscribe <customer> to both <plan_1> and <plan_2> plan_1 = Plan . objects . get ( nickname = \"one_plan\" ) plan_2 = Plan . objects . get ( nickname = \"two_plan\" ) customer = Customer . objects . first () customer . subscribe ( items = [{ \"plan\" : plan_1 }, { \"plan\" : plan_2 }]) ## This will subscribe <customer> to <plan_1> plan_1 = Plan . objects . get ( nickname = \"one_plan\" ) customer = Customer . objects . first () customer . subscribe ( items = [{ \"plan\" : plan_1 }]) Alternate Approach 2 ## (Alternate Approach) This will subscribe <customer> to <plan_1> plan_1 = Plan . objects . get ( nickname = \"one_plan\" ) customer = Customer . objects . first () customer . subscribe ( plan = plan_1 ) However in some cases subscribe() might not support all the arguments you need for your implementation. When this happens you can just call the official stripe.Customer.subscribe() . Tip Check out the following examples: form_valid view example djstripe.models.customer.add_payment_method Note that PaymentMethods can be used instead of Cards/Source by substituting # Add the payment method customer's default customer . add_payment_method ( payment_method ) instead of # Add the source as the customer's default card customer . add_card ( stripe_source ) in the above example.","title":"Subscribing a customer to a plan"},{"location":"usage/subscribing_customers/#subscribing-a-customer-to-one-or-more-prices-or-plans","text":"","title":"Subscribing a customer to one or more prices (or plans)"},{"location":"usage/subscribing_customers/#recommended-approach","text":"# Recommended Approach to use items dict with Prices ## This will subscribe <customer> to both <price_1> and <price_2> price_1 = Price . objects . get ( nickname = \"one_price\" ) price_2 = Price . objects . get ( nickname = \"two_price\" ) customer = Customer . objects . first () customer . subscribe ( items = [{ \"price\" : price_1 }, { \"price\" : price_2 }]) ## This will subscribe <customer> to <price_1> price_1 = Price . objects . get ( nickname = \"one_price\" ) customer = Customer . objects . first () customer . subscribe ( items = [{ \"price\" : price_1 }])","title":"Recommended Approach"},{"location":"usage/subscribing_customers/#alternate-approach-1-with-legacy-plans","text":"## (Alternate Approach) This will subscribe <customer> to <price_1> price_1 = Price . objects . get ( nickname = \"one_price\" ) customer = Customer . objects . first () customer . subscribe ( price = price_1 ) # If you still use legacy Plans... ## This will subscribe <customer> to both <plan_1> and <plan_2> plan_1 = Plan . objects . get ( nickname = \"one_plan\" ) plan_2 = Plan . objects . get ( nickname = \"two_plan\" ) customer = Customer . objects . first () customer . subscribe ( items = [{ \"plan\" : plan_1 }, { \"plan\" : plan_2 }]) ## This will subscribe <customer> to <plan_1> plan_1 = Plan . objects . get ( nickname = \"one_plan\" ) customer = Customer . objects . first () customer . subscribe ( items = [{ \"plan\" : plan_1 }])","title":"Alternate Approach 1 (with legacy Plans)"},{"location":"usage/subscribing_customers/#alternate-approach-2","text":"## (Alternate Approach) This will subscribe <customer> to <plan_1> plan_1 = Plan . objects . get ( nickname = \"one_plan\" ) customer = Customer . objects . first () customer . subscribe ( plan = plan_1 ) However in some cases subscribe() might not support all the arguments you need for your implementation. When this happens you can just call the official stripe.Customer.subscribe() . Tip Check out the following examples: form_valid view example djstripe.models.customer.add_payment_method Note that PaymentMethods can be used instead of Cards/Source by substituting # Add the payment method customer's default customer . add_payment_method ( payment_method ) instead of # Add the source as the customer's default card customer . add_card ( stripe_source ) in the above example.","title":"Alternate Approach 2"},{"location":"usage/using_stripe_checkout/","text":"Create a Stripe Checkout Session For your convenience, dj-stripe has provided an example implementation on how to use Checkouts Please note that in order for dj-stripe to create a link between your customers and your subscribers , you need to add the DJSTRIPE_SUBSCRIBER_CUSTOMER_KEY key to the metadata parameter of Checkout . This has also been demonstrated in the aforementioned example","title":"Using Stripe Checkout"},{"location":"usage/using_stripe_checkout/#create-a-stripe-checkout-session","text":"For your convenience, dj-stripe has provided an example implementation on how to use Checkouts Please note that in order for dj-stripe to create a link between your customers and your subscribers , you need to add the DJSTRIPE_SUBSCRIBER_CUSTOMER_KEY key to the metadata parameter of Checkout . This has also been demonstrated in the aforementioned example","title":"Create a Stripe Checkout Session"},{"location":"usage/using_with_docker/","text":"Using with Docker A Docker image allows you to run the Stripe CLI in a container. Here is a sample docker-compose.yaml file that sets up all the services to use Stripe CLI in a dockerised django container (with djstripe) version : \"3.9\" volumes : postgres-data : {} services : db : image : postgres:12 volumes : - postgres-data:/var/lib/postgresql/data environment : - POSTGRES_DB=random_number - POSTGRES_USER=root - POSTGRES_PASSWORD=random_number web : build : context : . dockerfile : <PATH_TO_DOCKERFILE> command : python manage.py runserver 0.0.0.0:8000 volumes : - .:/app ports : - \"8000:8000\" depends_on : - db environment : # Stripe specific keys - STRIPE_PUBLIC_KEY=pk_test_****** - STRIPE_SECRET_KEY=sk_test_****** - DJSTRIPE_TEST_WEBHOOK_SECRET=whsec_****** # Database Specific Settings - DJSTRIPE_TEST_DB_VENDOR=postgres - DJSTRIPE_TEST_DB_PORT=5432 - DJSTRIPE_TEST_DB_USER=root - DJSTRIPE_TEST_DB_NAME=random_number - DJSTRIPE_TEST_DB_PASS=random_number - DJSTRIPE_TEST_DB_HOST=db stripe : image : stripe/stripe-cli:v1.7.4 command : listen --forward-to http://web:8000/djstripe/webhook/ depends_on : - web environment : - STRIPE_API_KEY=sk_test_****** - STRIPE_DEVICE_NAME=djstripe_docker","title":"Using with Docker"},{"location":"usage/using_with_docker/#using-with-docker","text":"A Docker image allows you to run the Stripe CLI in a container. Here is a sample docker-compose.yaml file that sets up all the services to use Stripe CLI in a dockerised django container (with djstripe) version : \"3.9\" volumes : postgres-data : {} services : db : image : postgres:12 volumes : - postgres-data:/var/lib/postgresql/data environment : - POSTGRES_DB=random_number - POSTGRES_USER=root - POSTGRES_PASSWORD=random_number web : build : context : . dockerfile : <PATH_TO_DOCKERFILE> command : python manage.py runserver 0.0.0.0:8000 volumes : - .:/app ports : - \"8000:8000\" depends_on : - db environment : # Stripe specific keys - STRIPE_PUBLIC_KEY=pk_test_****** - STRIPE_SECRET_KEY=sk_test_****** - DJSTRIPE_TEST_WEBHOOK_SECRET=whsec_****** # Database Specific Settings - DJSTRIPE_TEST_DB_VENDOR=postgres - DJSTRIPE_TEST_DB_PORT=5432 - DJSTRIPE_TEST_DB_USER=root - DJSTRIPE_TEST_DB_NAME=random_number - DJSTRIPE_TEST_DB_PASS=random_number - DJSTRIPE_TEST_DB_HOST=db stripe : image : stripe/stripe-cli:v1.7.4 command : listen --forward-to http://web:8000/djstripe/webhook/ depends_on : - web environment : - STRIPE_API_KEY=sk_test_****** - STRIPE_DEVICE_NAME=djstripe_docker","title":"Using with Docker"},{"location":"usage/webhooks/","text":"Using Stripe Webhooks Available settings dj-stripe provides the following settings to tune how your webhooks work: DJSTRIPE_WEBHOOK_URL DJSTRIPE_WEBHOOK_SECRET DJSTRIPE_WEBHOOK_VALIDATION DJSTRIPE_WEBHOOK_TOLERANCE DJSTRIPE_WEBHOOK_EVENT_CALLBACK Using webhooks in dj-stripe dj-stripe comes with native support for webhooks as event listeners. Events allow you to do things like sending an email to a customer when his payment has failed or trial period is ending. This is how you use them: from djstripe import webhooks @webhooks . handler ( \"customer.subscription.trial_will_end\" ) def my_handler ( event , ** kwargs ): print ( \"We should probably notify the user at this point\" ) You can handle all events related to customers like this: from djstripe import webhooks @webhooks . handler ( \"customer\" ) def my_handler ( event , ** kwargs ): print ( \"We should probably notify the user at this point\" ) You can also handle different events in the same handler: from djstripe import webhooks @webhooks . handler ( \"price\" , \"product\" ) def my_handler ( event , ** kwargs ): print ( \"Triggered webhook \" + event . type ) Warning In order to get registrations picked up, you need to put them in a module that is imported like models.py or make sure you import it manually. Webhook event creation and processing is now wrapped in a transaction.atomic() block to better handle webhook errors. This will prevent any additional database modifications you may perform in your custom handler from being committed should something in the webhook processing chain fail. You can also take advantage of Django's transaction.on_commit() function to only perform an action if the transaction successfully commits (meaning the Event processing worked): from django.db import transaction from djstripe import webhooks def do_something (): pass # send a mail, invalidate a cache, fire off a Celery task, etc. @webhooks . handler ( \"price\" , \"product\" ) def my_handler ( event , ** kwargs ): transaction . on_commit ( do_something ) Official documentation Stripe docs for types of Events: https://stripe.com/docs/api/events/types Stripe docs for Webhooks: https://stripe.com/docs/webhooks Django docs for transactions: https://docs.djangoproject.com/en/dev/topics/db/transactions/#performing-actions-after-commit","title":"Using Stripe Webhooks"},{"location":"usage/webhooks/#using-stripe-webhooks","text":"","title":"Using Stripe Webhooks"},{"location":"usage/webhooks/#available-settings","text":"dj-stripe provides the following settings to tune how your webhooks work: DJSTRIPE_WEBHOOK_URL DJSTRIPE_WEBHOOK_SECRET DJSTRIPE_WEBHOOK_VALIDATION DJSTRIPE_WEBHOOK_TOLERANCE DJSTRIPE_WEBHOOK_EVENT_CALLBACK","title":"Available settings"},{"location":"usage/webhooks/#using-webhooks-in-dj-stripe","text":"dj-stripe comes with native support for webhooks as event listeners. Events allow you to do things like sending an email to a customer when his payment has failed or trial period is ending. This is how you use them: from djstripe import webhooks @webhooks . handler ( \"customer.subscription.trial_will_end\" ) def my_handler ( event , ** kwargs ): print ( \"We should probably notify the user at this point\" ) You can handle all events related to customers like this: from djstripe import webhooks @webhooks . handler ( \"customer\" ) def my_handler ( event , ** kwargs ): print ( \"We should probably notify the user at this point\" ) You can also handle different events in the same handler: from djstripe import webhooks @webhooks . handler ( \"price\" , \"product\" ) def my_handler ( event , ** kwargs ): print ( \"Triggered webhook \" + event . type ) Warning In order to get registrations picked up, you need to put them in a module that is imported like models.py or make sure you import it manually. Webhook event creation and processing is now wrapped in a transaction.atomic() block to better handle webhook errors. This will prevent any additional database modifications you may perform in your custom handler from being committed should something in the webhook processing chain fail. You can also take advantage of Django's transaction.on_commit() function to only perform an action if the transaction successfully commits (meaning the Event processing worked): from django.db import transaction from djstripe import webhooks def do_something (): pass # send a mail, invalidate a cache, fire off a Celery task, etc. @webhooks . handler ( \"price\" , \"product\" ) def my_handler ( event , ** kwargs ): transaction . on_commit ( do_something )","title":"Using webhooks in dj-stripe"},{"location":"usage/webhooks/#official-documentation","text":"Stripe docs for types of Events: https://stripe.com/docs/api/events/types Stripe docs for Webhooks: https://stripe.com/docs/webhooks Django docs for transactions: https://docs.djangoproject.com/en/dev/topics/db/transactions/#performing-actions-after-commit","title":"Official documentation"}]}